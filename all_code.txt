--- File: ./frontend/app/layout.tsx ---
import type React from "react"
import type { Metadata } from "next"
import { Geist, Geist_Mono } from "next/font/google"
import { Analytics } from "@vercel/analytics/next"
import "./globals.css"

const _geist = Geist({ subsets: ["latin"] })
const _geistMono = Geist_Mono({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Discord 自动营销管理系统",
  description: "智能 Discord 账号营销管理平台，集成微店抓取、图像识别、CNFans 链接生成",
  generator: "v0.app",
  icons: {
    icon: [
      {
        url: "/icon-light-32x32.png",
        media: "(prefers-color-scheme: light)",
      },
      {
        url: "/icon-dark-32x32.png",
        media: "(prefers-color-scheme: dark)",
      },
      {
        url: "/icon.svg",
        type: "image/svg+xml",
      },
    ],
    apple: "/apple-icon.png",
  },
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="zh-CN">
      <body className={`font-sans antialiased`}>
        {children}
        <Analytics />
      </body>
    </html>
  )
}

--- File: ./frontend/app/api/products/count/route.ts ---
import { NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/products/count`)

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Failed to fetch count' }))
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/products/count failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/route.ts ---
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: Request) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'GET',
      headers: {
        'Cookie': request.headers.get('cookie') || ''
      }
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to fetch products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error fetching products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function PUT(request: Request) {
  try {
    const contentType = request.headers.get('content-type') || ''

    let response;
    if (contentType.includes('multipart/form-data')) {
      // 处理FormData请求（包含文件上传）
      const formData = await request.formData()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Cookie': request.headers.get('cookie') || ''
        },
        body: formData
      })
    } else {
      // 处理JSON请求
      const body = await request.json()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': request.headers.get('cookie') || ''
        },
        body: JSON.stringify(body)
      })
    }

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to update product' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error updating product:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function DELETE(request: Request) {
  try {
    const url = new URL(request.url)
    const ids = url.searchParams.get('ids')

    if (!ids) {
      return new Response(JSON.stringify({ error: 'Missing ids parameter' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const response = await fetch(`${BACKEND_URL}/api/products/batch`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': request.headers.get('cookie') || ''
      },
      body: JSON.stringify({ ids: ids.split(',').map(id => parseInt(id)) })
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to delete products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error deleting products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

--- File: ./frontend/app/api/products/[id]/images/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { id, imageIndex } = resolvedParams
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id]/images/[imageIndex] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/images/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params
    const id = resolvedParams.id
    const formData = await request.formData()
    const cookieHeader = request.headers.get('cookie') || '';

    // FormData上传时，不要设置Content-Type，让浏览器自动处理multipart/form-data
    // 只传递Cookie头
    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images`, {
      method: 'POST',
      body: formData,
      headers: cookieHeader ? {
        'Cookie': cookieHeader
      } : undefined
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/config/discord-threshold/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/global-reply-delay/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/discord-channel/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to fetch discord channel config' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to update discord channel config' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/auth/logout/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端登出API
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/logout`, {
      method: 'POST',
      headers: headers
    });

    // 清除前端session cookie
    const response = NextResponse.json({ message: '已登出' });
    response.cookies.set('user_session', '', {
      maxAge: 0
    });

    return response;
  } catch (error: any) {
    console.error('Logout API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/me/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET(request: NextRequest) {
  try {
    // 获取浏览器传来的所有 Cookie
    const cookies = request.headers.get('cookie') || '';

    // 调用后端验证 Session 有效性
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/me`, {
      headers: {
        'Cookie': cookies // 关键：转发 Cookie 给后端
      }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // 如果后端验证失败 (401)，前端也要清除 user_session
      const errorData = await backendResponse.json().catch(() => ({ error: 'Not authenticated' }));
      const response = NextResponse.json(errorData, { status: backendResponse.status });

      if (backendResponse.status === 401) {
      response.cookies.set('user_session', '', { maxAge: 0 });
      }
      return response;
    }
  } catch (error: any) {
    console.error('Auth me API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/login/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // 调用后端登录API
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      const response = NextResponse.json(data);

      // --- 关键修复开始 ---
      // 1. 获取后端返回的原始 Set-Cookie 字符串
      // Flask 通常返回类似: "session=eyJ...; HttpOnly; Path=/; SameSite=Lax"
      const setCookieHeader = backendResponse.headers.get('set-cookie');

      if (setCookieHeader) {
        // 简单解析 Cookie 名称和值
        // 注意：如果后端返回多个 Cookie，这里可能需要更复杂的解析，但 Flask 默认通常只返回 session
        const firstPart = setCookieHeader.split(';')[0]; // 获取 "name=value"
        const [name, ...valueParts] = firstPart.split('=');
        const value = valueParts.join('='); // 防止值中包含 =

        if (name && value) {
          // 使用 Next.js API 设置 Cookie，避免与 header 操作冲突
          response.cookies.set({
            name: name.trim(),
            value: value.trim(),
            httpOnly: true, // 保持 HttpOnly 增强安全性
            path: '/',
            sameSite: 'lax',
            secure: process.env.NODE_ENV === 'production',
            maxAge: 60 * 60 * 24 * 7 // 设置为 7 天或与后端一致
          });
        }
      }
      // --- 关键修复结束 ---

      // 2. 设置前端专用的 user_session (用于UI展示)
      response.cookies.set('user_session', JSON.stringify({
        user: data.user,
        timestamp: Date.now()
      }), {
        httpOnly: false, // 允许前端 JS 读取
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 // 24小时
      });

      return response;
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Login API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/message-filters/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/message-filters/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/test-similarity/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/api/test_similarity`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend test_similarity error:', errorText);
      return NextResponse.json({ error: errorText }, { status: response.status });
    }

    const result = await response.json();
    return NextResponse.json(result);
  } catch (error: any) {
    console.error('POST /api/test-similarity failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const limit = url.searchParams.get('limit') || '50';

    const response = await fetch(`${BACKEND_URL}/api/search_history?limit=${limit}`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/search_history`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const historyId = resolvedParams.id;

    const response = await fetch(`${BACKEND_URL}/api/search_history/${historyId}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history/[id] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/announcements/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    // 修复：手动获取并转发 Cookie
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      headers: {
        'Cookie': cookieHeader
      }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/announcements/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/user/settings/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
        headers: {
            'Cookie': cookies
        }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // 捕获错误并返回状态码，前端收到 401 可处理跳转
      const errorData = await backendResponse.json().catch(() => ({ error: 'Failed to fetch settings' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('User settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
      method: 'PUT',
      headers: {
          'Content-Type': 'application/json',
          'Cookie': cookies
      },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/status/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET(request: Request) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/status`, {
      method: 'GET',
      headers: {
        'Cookie': cookieHeader
      }
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/control/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/control`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: Request) {
  try {
    const data = await request.json();
    const { url, weidianId } = data;
    const cookieHeader = request.headers.get('cookie') || '';

    // 支持两种输入方式：完整URL或商品ID
    if (!url && !weidianId) {
      return NextResponse.json({ error: 'URL or weidianId is required' }, { status: 400 });
    }

    // 如果提供了weidianId，构造URL
    const finalUrl = url || `https://weidian.com/item.html?itemID=${weidianId}`;

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/scrape`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify({ url: finalUrl })
    });

    // 修复：处理 409 Conflict，不要抛出通用错误，而是传递给前端处理
    if (backendResponse.status === 409) {
        const errorData = await backendResponse.json();
        return NextResponse.json(errorData, { status: 409 });
    }

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend scrape failed' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const type = url.searchParams.get('type');

    if (type === 'indexed') {
      // 获取已建立向量索引的商品URL列表
      const response = await fetch(`${BACKEND_URL}/api/get_indexed_ids`);
      if (response.ok) {
        const data = await response.json();
        return NextResponse.json(data);
      }
      return NextResponse.json({ indexedIds: [] });
    }

    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端 API 获取商品列表
    const response = await fetch(`${BACKEND_URL}/api/products`, { headers });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    } else if (response.status === 401) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    return NextResponse.json([]);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const { id } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });
    if (response.ok) {
      return NextResponse.json({ success: true });
    } else {
      const err = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(err, { status: response.status });
    }
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PUT方法用于更新商品信息
export async function PUT(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Update failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PATCH方法用于删除单个图片
export async function PATCH(request: Request) {
  try {
    const { productId, imageIndex } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${productId}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Delete image failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/image/[productId]/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ productId: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { productId, imageIndex } = resolvedParams;

    const response = await fetch(`${BACKEND_URL}/api/image/${productId}/${imageIndex}`);

    if (!response.ok) {
      return NextResponse.json({ error: 'Image not found' }, { status: response.status });
    }

    const imageBuffer = await response.arrayBuffer();
    const contentType = response.headers.get('content-type') || 'image/jpeg';

    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600',
      },
    });
  } catch (error: any) {
    console.error('GET /api/image/[productId]/[imageIndex] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch shops' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shops/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = 'http://69.30.204.184:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops/${resolvedParams.id}`, {
      method: 'DELETE',
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// 获取后端 URL
const getBackendUrl = () => {
  return process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const imageFile = formData.get('image') as File
    const threshold = parseFloat(formData.get('threshold') as string) || 0.1

    if (!imageFile) {
      return NextResponse.json({ error: 'No image provided' }, { status: 400 })
    }

    console.log('收到图片搜索请求，文件大小:', imageFile.size, 'bytes')

    // 创建新的 FormData 传递给后端
    const backendFormData = new FormData()
    const buffer = Buffer.from(await imageFile.arrayBuffer())
    const blob = new Blob([buffer], { type: imageFile.type })
    backendFormData.append('image', blob, imageFile.name || 'search.jpg')

    const backendUrl = getBackendUrl()
    console.log('调用后端搜索 API:', `${backendUrl}/search_similar`)

    // 直接调用后端的向量搜索 API (使用 Faiss)
    const response = await fetch(`${backendUrl}/search_similar`, {
      method: 'POST',
      body: backendFormData
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('后端搜索失败:', response.status, errorText)
      return NextResponse.json({
        error: `后端搜索失败: ${response.status}`,
        details: errorText
      }, { status: response.status })
    }

    const result = await response.json()
    console.log('后端搜索结果:', result)

    if (result.success && result.product) {
      // 后端返回成功，格式化响应
      return NextResponse.json({
        success: true,
        similarity: result.similarity,
        product: {
          id: result.product.id,
          title: result.product.title,
          englishTitle: result.product.englishTitle,
          weidianId: result.skuId,
          weidianUrl: result.skuId, // 直接使用 product_url
          cnfansUrl: result.skuId, // 简化处理
          ruleEnabled: result.product.ruleEnabled,
          matchKeywords: result.product.matchKeywords,
          matchType: result.product.matchType,
          images: [] // 可以从数据库加载
        },
        skuId: result.skuId,
        imageIndex: result.imageIndex,
        matchedImage: `/scraped_images/${result.skuId}/${result.imageIndex}.jpg`,
        searchTime: new Date().toISOString()
      })
    } else {
      // 未找到匹配
      return NextResponse.json({
        success: false,
        message: result.message || `未找到相似度超过 ${(threshold * 100).toFixed(0)}% 的商品`
      })
    }

  } catch (error: any) {
    console.error('搜索错误:', error)
    return NextResponse.json({
      error: error.message,
      stack: error.stack
    }, { status: 500 })
  }
}

--- File: ./frontend/app/api/system/stats/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/system/stats`)
    if (!response.ok) {
      const errorData = await response.json()
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/system/stats failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shop-info/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const shopId = searchParams.get('shopId')

    if (!shopId) {
      return NextResponse.json({ error: '缺少shopId参数' }, { status: 400 })
    }

    // 代理请求到后端，使用127.0.0.1避免代理问题
    const backendUrl = `http://69.30.204.184:5001/api/shop-info?shopId=${shopId}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      return NextResponse.json({ error: '后端请求失败' }, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)

  } catch (error) {
    console.error('Shop info API error:', error)
    return NextResponse.json({ error: '获取店铺信息失败' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/stream/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const backendUrl = `${BACKEND_URL}/api/logs/stream`

    // 创建到后端的SSE连接
    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Cookie': cookieHeader
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    // 创建可读流
    const stream = new ReadableStream({
      start(controller) {
        const reader = response.body?.getReader()
        let isControllerClosed = false

        function push() {
          if (isControllerClosed) return

          reader?.read().then(({ done, value }) => {
            if (done) {
              if (!isControllerClosed) {
                isControllerClosed = true
                try {
                  controller.close()
                } catch (closeError) {
                  // Controller already closed, ignore
                }
              }
              return
            }

            if (!isControllerClosed) {
              try {
                controller.enqueue(value)
                push() // 只有在成功enqueue后才继续
              } catch (enqueueError) {
                console.error('Stream enqueue error:', enqueueError)
                if (!isControllerClosed) {
                  isControllerClosed = true
                  try {
                    controller.close()
                  } catch (closeError) {
                    // Controller already closed, ignore
                  }
                }
              }
            }
          }).catch((error) => {
            console.error('Stream error:', error)
            if (!isControllerClosed) {
              isControllerClosed = true
              try {
                controller.close()
              } catch (closeError) {
                // Controller already closed, ignore
              }
            }
          })
        }

        push()
      }
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control',
      },
    })
  } catch (error) {
    console.error('Logs stream API error:', error)
    return NextResponse.json({ error: 'Failed to connect to log stream' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const endpoint = searchParams.get('endpoint') || 'recent'

    const backendUrl = `${BACKEND_URL}/api/logs/${endpoint}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Logs API error:', error)
    return NextResponse.json({ error: 'Failed to fetch logs' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, { headers })
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch accounts' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/rotation/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`)
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ enabled: false, rotationInterval: 10 })
    }
  } catch (error) {
    return NextResponse.json({ enabled: false, rotationInterval: 10 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update rotation config' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/user/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

// 分配Discord账号给用户
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const accountId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/accounts/${accountId}/user`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Assign account to user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/accounts/[id]/status/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}/status`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update status' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}`, {
      method: 'DELETE'
    })

    if (response.ok) {
      return NextResponse.json({ success: true })
    } else {
      return NextResponse.json({ error: 'Failed to delete account' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search_similar/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/search_similar`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend search_similar error:', errorText);
      return NextResponse.json({ error: 'Search failed' }, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/search_similar failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

// 获取用户列表（管理员权限）
export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, { headers });
    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Users API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// 创建新用户（管理员权限）
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Create user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/password/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function PUT(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const body = await request.json();

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}/password`, {

      method: 'PUT',

      headers: {

        'Content-Type': 'application/json',

        'Cookie': cookieHeader

      },

      body: JSON.stringify(body)

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    const data = await response.json();

    return NextResponse.json(data);

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/users/[id]/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

// 更新用户店铺权限
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const userId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users/${userId}/shops`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user shops API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function DELETE(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}`, {

      method: 'DELETE',

      headers: { 'Cookie': cookieHeader }

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    return NextResponse.json({ success: true });

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/bot/start/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId } = body;

    if (!userId) {
      return NextResponse.json({ error: '需要用户ID' }, { status: 400 });
    }

    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端启动机器人API
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/start`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify({ userId })
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Start bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/bot/stop/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001';

export async function POST(request: NextRequest) {
  try {
    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端停止机器人API
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/stop`, {
      method: 'POST',
      headers: headers
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Stop bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/websites/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      // 404 handling specifically
      if (response.status === 404) {
          return NextResponse.json({ websites: [] });
      }
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/[channelId]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; channelId: string }> }
) {
  try {
    const { id, channelId } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels/${channelId}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id]/channels/[channelId] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://69.30.204.184:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/page.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { DashboardView } from "@/components/dashboard-view"
import { AccountsView } from "@/components/accounts-view"
import { ScraperView } from "@/components/scraper-view"
import { ShopsView } from "@/components/shops-view"
import { ImageSearchView } from "@/components/image-search-view"
import { UsersView } from "@/components/users-view"
import { RulesView } from "@/components/rules-view"
import { LogsView } from "@/components/logs-view"
import { LoginView } from "@/components/login-view"
import { AppSidebar } from "@/components/app-sidebar"
import { SidebarProvider, SidebarInset, SidebarTrigger } from "@/components/ui/sidebar"
import { Separator } from "@/components/ui/separator"
import { Button } from "@/components/ui/button"
import { LogOut, User, Play, Square } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export default function Page() {
  const [currentView, setCurrentView] = useState("dashboard")
  const [currentUser, setCurrentUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [botStatus, setBotStatus] = useState<'stopped' | 'starting' | 'running' | 'stopping'>('stopped')

  // 使用useRef防止重复请求
  const hasFetchedUser = useRef(false)

  useEffect(() => {
    // 检查锁，防止重复请求
    if (!hasFetchedUser.current) {
      hasFetchedUser.current = true // 立即上锁
    checkLoginStatus()
    }
  }, [])

  const checkLoginStatus = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setCurrentUser(data.user)
        // 移除预加载，避免重复API调用
      }
    } catch (error) {
      // 未登录或网络错误
    } finally {
      setLoading(false)
    }
  }

  // 移除预加载逻辑，避免重复API调用
  // const preloadCommonData = async (user: User) => {
  //   console.log('预加载已禁用，避免重复API调用')
  // }

  const handleLogin = (user: User) => {
    setCurrentUser(user)
  }

  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      })
      setCurrentUser(null)
      setCurrentView("accounts")
      setBotStatus('stopped')
      toast.success("已登出")
    } catch (error) {
      toast.error("登出失败")
    }
  }

  const handleStartBot = async () => {
    if (!currentUser) {
      toast.error("请先登录")
      return
    }

    setBotStatus('starting')
    try {
      // 调用后端启动账号的API
      const response = await fetch('/api/bot/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ userId: currentUser.id })
      })

      if (response.ok) {
        setBotStatus('running')
        toast.success("Discord账号已启动")
      } else {
        const error = await response.json()
        setBotStatus('stopped')
        toast.error(error.error || "启动账号失败")
      }
    } catch (error) {
      setBotStatus('stopped')
      toast.error("网络错误，无法启动账号")
    }
  }

  const handleStopBot = async () => {
    setBotStatus('stopping')
    try {
      const response = await fetch('/api/bot/stop', {
        method: 'POST',
        credentials: 'include'
      })

      if (response.ok) {
        setBotStatus('stopped')
        toast.success("Discord账号已停止")
      } else {
        setBotStatus('running')
        toast.error("停止账号失败")
      }
    } catch (error) {
      setBotStatus('running')
      toast.error("网络错误，无法停止账号")
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    )
  }

  if (!currentUser) {
    return <LoginView onLogin={handleLogin} />
  }

  return (
    <SidebarProvider defaultOpen={true}>
      <AppSidebar
        currentView={currentView}
        setCurrentView={setCurrentView}
        currentUser={currentUser}
      />
      <SidebarInset>
        <header className="flex h-14 shrink-0 items-center gap-2 border-b px-4">
          <SidebarTrigger />
          <Separator orientation="vertical" className="h-6" />
          <h1 className="text-lg font-semibold">Discord 自动营销系统</h1>
          <div className="flex-1" />
          <div className="flex items-center gap-3">
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <User className="size-4" />
              <span>{currentUser.username}</span>
              {currentUser.role === 'admin' && (
                <span className="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">管理员</span>
              )}
            </div>

            {/* 机器人控制 */}
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <div className={`w-2 h-2 rounded-full ${
                  botStatus === 'running' ? 'bg-green-500' :
                  botStatus === 'starting' ? 'bg-yellow-500 animate-pulse' :
                  botStatus === 'stopping' ? 'bg-orange-500 animate-pulse' :
                  'bg-gray-400'
                }`} />
                <span>
                  {botStatus === 'running' ? '运行中' :
                   botStatus === 'starting' ? '启动中' :
                   botStatus === 'stopping' ? '停止中' :
                   '已停止'}
                </span>
              </div>

              {botStatus === 'running' ? (
                <Button variant="outline" size="sm" onClick={handleStopBot} disabled={botStatus !== 'running'}>
                  <Square className="size-4 mr-1" />
                  停止账号
                </Button>
              ) : (
                <Button
                  variant="default"
                  size="sm"
                  onClick={handleStartBot}
                  disabled={botStatus === 'starting'}
                  className="bg-green-600 hover:bg-green-700"
                >
                  <Play className="size-4 mr-1" />
                  启动账号
                </Button>
              )}
            </div>

            <Button variant="outline" size="sm" onClick={handleLogout}>
              <LogOut className="size-4 mr-1" />
              登出
            </Button>
          </div>
        </header>
        <main className="flex-1 overflow-auto p-6">
          {/*

            核心修改：

            不再使用条件渲染 (&&)，而是全部渲染但通过 CSS 控制显示隐藏。

            这样切换 Tab 时组件不会卸载，数据和滚动位置得以保留。

          */}
          <div style={{ display: currentView === "dashboard" ? 'block' : 'none', height: '100%' }}>
            <DashboardView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "accounts" ? 'block' : 'none', height: '100%' }}>
            <AccountsView />
          </div>

          {(currentUser.role === 'admin' || (currentUser.shops && currentUser.shops.length > 0)) && (
            <div style={{ display: currentView === "shops" ? 'block' : 'none', height: '100%' }}>
              <ShopsView currentUser={currentUser} />
            </div>
          )}

          <div style={{ display: currentView === "scraper" ? 'block' : 'none', height: '100%' }}>
            {/* ScraperView 内部建议实现轮询机制来获取最新抓取结果 */}
            <ScraperView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "image-search" ? 'block' : 'none', height: '100%' }}>
            <ImageSearchView />
          </div>

          {currentUser.role === 'admin' && (
            <>
              <div style={{ display: currentView === "users" ? 'block' : 'none', height: '100%' }}>
                <UsersView />
              </div>
              <div style={{ display: currentView === "logs" ? 'block' : 'none', height: '100%' }}>
                <LogsView />
              </div>
            </>
          )}
        </main>
      </SidebarInset>
    </SidebarProvider>
  )
}

--- File: ./frontend/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- File: ./frontend/components/theme-provider.tsx ---
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

--- File: ./frontend/components/accounts-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "sonner"
import { Plus, Settings, Save, Trash2, Globe, Link, Hash, X, Edit } from "lucide-react"

export function AccountsView() {
  const [accounts, setAccounts] = useState<any[]>([])
  const [users, setUsers] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddDialog, setShowAddDialog] = useState(false)
  const [newAccount, setNewAccount] = useState({
    token: ""
  })
  const [settings, setSettings] = useState({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
  })
  const [settingsLoading, setSettingsLoading] = useState(false)

  // 新增：当前用户信息状态
  const [currentUser, setCurrentUser] = useState<any>(null)
  const [deleteAccountConfirm, setDeleteAccountConfirm] = useState<any>(null)

  // 使用API缓存hook
  const { cachedFetch } = useApiCache()

  // 网站配置相关状态
  const [websites, setWebsites] = useState<any[]>([])
  const [showAddWebsite, setShowAddWebsite] = useState(false)
  const [editingWebsite, setEditingWebsite] = useState<any>(null)
  const [newWebsite, setNewWebsite] = useState({
    name: '',
    display_name: '',
    url_template: '',
    id_pattern: '',
    badge_color: 'blue'
  })
  const [websiteChannels, setWebsiteChannels] = useState<{[key: number]: string[]}>({})

  // 消息过滤相关状态
  const [messageFilters, setMessageFilters] = useState<any[]>([])
  const [showAddFilter, setShowAddFilter] = useState(false)
  const [editingFilter, setEditingFilter] = useState<any>(null)
  const [newFilter, setNewFilter] = useState({
    filter_type: 'contains',
    filter_value: ''
  })


  const fetchWebsites = async () => {
    try {
      const data = await cachedFetch('/api/websites', { credentials: 'include' })
      const websites = data.websites || []

      // 后端已包含channels信息，无需额外请求
        const channels: {[key: number]: string[]} = {}
      websites.forEach((website: any) => {
        channels[website.id] = website.channels || []
      })

      setWebsites(websites)
        setWebsiteChannels(channels)
    } catch (e) {
      console.error('获取网站配置失败:', e)
    }
  }

  const fetchMessageFilters = async () => {
    try {
      const res = await fetch('/api/message-filters', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setMessageFilters(data.filters || [])
      }
    } catch (e) {
      console.error('获取消息过滤规则失败:', e)
    }
  }


  useEffect(() => {
    // 先获取当前用户，再决定是否获取用户列表
    const init = async () => {
        const userRes = await fetch('/api/auth/me', { credentials: 'include' });
        if (userRes.ok) {
            const userData = await userRes.json();
            setCurrentUser(userData.user);

            // 并行获取数据
            fetchAccounts(); // 所有人都能获取账号(自己的)

            // 只有管理员才获取用户列表
            if (userData.user.role === 'admin') {
                fetchUsers();
            }
        }
    };
    init();
    fetchSettings();
    fetchWebsites();
    fetchMessageFilters();
  }, [])

  const fetchSettings = async (usePreload: boolean = true) => {
    try {
      // 首先检查是否有预加载数据
      if (usePreload) {
        const preloadData = sessionStorage.getItem('preload_settings')
        if (preloadData) {
          try {
            console.log('使用预加载设置数据')
            const data = JSON.parse(preloadData)
            setSettings({
              discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
              global_reply_min_delay: data.global_reply_min_delay || 3.0,
              global_reply_max_delay: data.global_reply_max_delay || 8.0,
            })

            // 清除预加载数据，避免重复使用
            sessionStorage.removeItem('preload_settings')

            // 在后台获取最新数据，但不显示加载状态
            setTimeout(() => fetchSettings(false), 500)
            return
          } catch (e) {
            console.error('预加载设置数据解析失败:', e)
            // 预加载数据损坏，清除并重新获取
            sessionStorage.removeItem('preload_settings')
          }
        } else {
          // 如果没有预加载数据，等待一下再试
          setTimeout(() => {
            const retryPreload = sessionStorage.getItem('preload_settings')
            if (retryPreload) {
              fetchSettings(true)
            } else {
              fetchSettings(false)
            }
          }, 200)
          return
        }
      }

      console.log('从API获取设置数据')
      const response = await fetch('/api/user/settings', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
          global_reply_min_delay: data.global_reply_min_delay || 3.0,
          global_reply_max_delay: data.global_reply_max_delay || 8.0,
        })
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
    }
  }

  const handleSaveSettings = async () => {
    setSettingsLoading(true)
    try {
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("设置已保存")
      } else {
        toast.error("保存设置失败")
      }
    } catch (error) {
      toast.error("保存设置失败")
    } finally {
      setSettingsLoading(false)
    }
  }

  const fetchAccounts = async () => {
          try {
      console.log('获取账号列表...')
      const data = await cachedFetch('/api/accounts', { credentials: 'include' })
            setAccounts(data.accounts || [])
    } catch (error) {
      console.error('获取账号列表出错:', error)
      setAccounts([])
    } finally {
      setLoading(false)
    }
  }

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users') // Next.js 会自动带上浏览器 Cookie
      if (response.ok) {
        const data = await response.json()
        setUsers(data.users || [])
      } else {
        // 不再抛出 toast 错误，而是静默失败或仅记录日志
        // 因为如果是权限不足，上面的逻辑应该已经拦截了，这里是兜底
        console.log('User fetch skipped or failed', response.status)
        setUsers([])
      }
    } catch (error) {
      setUsers([])
    }
  }

  const getUserDisplayName = (userId: number) => {
    const user = users.find(u => u.id === userId)
    return user ? user.username : `用户${userId}`
  }

  const handleAddAccount = async () => {
    if (!newAccount.token) {
      toast.error("请输入 Discord Token")
      return
    }

    try {
      const response = await fetch('/api/accounts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ token: newAccount.token })
      })

      if (response.ok) {
        toast.success("账号添加成功")
        setNewAccount({ token: "" })
        setShowAddDialog(false)
        fetchAccounts()
      } else {
        const error = await response.json()
        toast.error(error.error || "添加账号失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleDeleteAccount = (account: any) => {
    setDeleteAccountConfirm(account)
  }

  const confirmDeleteAccount = async () => {
    if (!deleteAccountConfirm) return

    try {
      const response = await fetch(`/api/accounts/${deleteAccountConfirm.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        toast.success("账号删除成功")
        fetchAccounts()
        setDeleteAccountConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "删除账号失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  // 网站配置处理函数
  const handleAddWebsite = async () => {
    try {
      const res = await fetch('/api/websites', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newWebsite)
      })
      if (res.ok) {
        toast.success('网站配置已添加')
        setShowAddWebsite(false)
        setNewWebsite({ name: '', display_name: '', url_template: '', id_pattern: '', badge_color: 'blue' })
        fetchWebsites()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateWebsite = async () => {
    if (!editingWebsite) return
    try {
      const res = await fetch(`/api/websites/${editingWebsite.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(editingWebsite)
      })
      if (res.ok) {
        toast.success('网站配置已更新')
        setEditingWebsite(null)
        fetchWebsites()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteWebsite = async (website: any) => {
    if (!confirm(`确定要删除网站配置 "${website.display_name}" 吗？`)) return
    try {
      const res = await fetch(`/api/websites/${website.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('网站配置已删除')
        fetchWebsites()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleAddChannel = async (websiteId: number, channelId: string) => {
    if (!channelId.trim()) return
    try {
      const res = await fetch(`/api/websites/${websiteId}/channels`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ channel_id: channelId.trim() })
      })
      if (res.ok) {
        toast.success('频道绑定已添加')
        fetchWebsites()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleRemoveChannel = async (websiteId: number, channelId: string) => {
    try {
      const res = await fetch(`/api/websites/${websiteId}/channels/${channelId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('频道绑定已移除')
        fetchWebsites()
      } else {
        toast.error('移除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  // 消息过滤处理函数
  const handleAddMessageFilter = async () => {
    try {
      const res = await fetch('/api/message-filters', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newFilter)
      })
      if (res.ok) {
        toast.success('过滤规则添加成功')
        setShowAddFilter(false)
        setNewFilter({ filter_type: 'contains', filter_value: '' })
        fetchMessageFilters()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateMessageFilter = async () => {
    if (!editingFilter) return
    try {
      const res = await fetch(`/api/message-filters/${editingFilter.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          filter_type: editingFilter.filter_type,
          filter_value: editingFilter.filter_value,
          is_active: editingFilter.is_active
        })
      })
      if (res.ok) {
        toast.success('过滤规则更新成功')
        setEditingFilter(null)
        fetchMessageFilters()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteMessageFilter = async (filterId: number) => {
    if (!confirm('确定要删除这个过滤规则吗？')) return
    try {
      const res = await fetch(`/api/message-filters/${filterId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('过滤规则删除成功')
        fetchMessageFilters()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }


  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-extrabold tracking-tight">账号管理</h2>
        <p className="text-sm text-muted-foreground mt-1">管理 Discord 账号</p>
      </div>

      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h3 className="text-xl font-bold">账号列表</h3>
            <p className="text-sm text-gray-600 mt-1">
              共 {accounts.length} 个账号
            </p>
          </div>
          <Dialog open={showAddDialog} onOpenChange={setShowAddDialog}>
            <DialogTrigger asChild>
              <Button>
                <Plus className="w-4 h-4 mr-2" />
                添加账号
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>添加 Discord 账号</DialogTitle>
                <DialogDescription>
                  输入 Discord Token，系统将自动验证并获取用户名
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label htmlFor="token">Discord Token</Label>
                  <Input
                    id="token"
                    type="password"
                    value={newAccount.token}
                    onChange={(e) => setNewAccount(prev => ({ ...prev, token: e.target.value }))}
                    placeholder="输入 Discord Token"
                  />
                  <p className="text-xs text-muted-foreground mt-1">
                    Token 将被安全存储，系统会自动验证有效性
                  </p>
                </div>
              </div>
              <DialogFooter>
                <Button onClick={handleAddAccount}>添加账号</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>

        <div className="space-y-2">
          {accounts.map((account) => (
            <div key={account.id} className="flex justify-between items-center p-4 border rounded">
              <div className="flex-1">
                <div className="font-semibold">{account.username}</div>
                <div className="text-sm text-gray-500">
                  {account.user_id ? `所属用户: ${getUserDisplayName(account.user_id)}` : '未分配用户'}
                </div>
                <div className="text-xs text-gray-400 font-mono">
                  {account.token && typeof account.token === 'string' ? `${account.token.substring(0, 20)}...` : 'Token 无效'}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className={`px-2 py-1 rounded text-sm ${
                  account.status === 'online' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
                }`}>
                  {account.status === 'online' ? '在线' : '离线'}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleDeleteAccount(account)}
                  className="text-red-600 hover:text-red-700 hover:bg-red-50"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            </div>
          ))}
        </div>
      </div>


      {/* 设置区域 */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h3 className="text-xl font-bold flex items-center">
              <Settings className="w-5 h-5 mr-2" />
              个人设置
            </h3>
            <p className="text-sm text-gray-600 mt-1">配置您的个性化运行参数</p>
          </div>
          <Button onClick={handleSaveSettings} disabled={settingsLoading}>
            <Save className="w-4 h-4 mr-2" />
            {settingsLoading ? "保存中..." : "保存设置"}
          </Button>
        </div>

        {/* 系统参数设置 - 合并相似度和延迟设置 */}
        <Card>
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">系统参数</CardTitle>
            <CardDescription>配置图片匹配和回复延迟参数</CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* 相似度和延迟设置 - 紧凑布局 */}
            <div className="flex flex-col sm:flex-row gap-6">
              {/* 相似度设置 */}
              <div className="flex-1 space-y-2">
                <div className="flex items-center justify-between">
                  <Label htmlFor="similarity-threshold" className="text-sm font-medium">相似度阈值</Label>
                  <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                    {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                  </span>
                </div>
                <div className="space-y-1">
                  <Input
                    id="similarity-threshold"
                    type="number"
                    step="0.1"
                    min="0.1"
                    max="1.0"
                    value={settings.discord_similarity_threshold}
                    onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                    className="h-9"
                  />
                  <p className="text-xs text-muted-foreground">
                    阈值越低匹配越宽松，建议范围 0.3-0.8
                  </p>
                </div>
              </div>

              {/* 回复延迟设置 */}
              <div className="flex-1 space-y-2">
                <Label className="text-sm font-medium">回复延迟</Label>
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="flex items-center gap-1">
                      <Input
                        id="min-delay"
                        type="number"
                        step="0.1"
                        min="0.1"
                        max="30"
                        value={settings.global_reply_min_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_min_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                      <span className="text-sm text-muted-foreground">-</span>
                      <Input
                        id="max-delay"
                        type="number"
                        step="0.5"
                        min="1"
                        max="60"
                        value={settings.global_reply_max_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_max_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                    </div>
                    <span className="text-xs text-muted-foreground">秒</span>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    每次回复随机延迟 {settings.global_reply_min_delay}-{settings.global_reply_max_delay} 秒
                  </p>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>


        {/* 编辑网站对话框 */}
        {editingWebsite && (
          <Dialog open={!!editingWebsite} onOpenChange={() => setEditingWebsite(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>编辑网站配置</DialogTitle>
                <DialogDescription>修改网站配置信息</DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>网站标识</Label>
                  <Input
                    value={editingWebsite.name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>显示名称</Label>
                  <Input
                    value={editingWebsite.display_name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>URL模板</Label>
                  <Input
                    value={editingWebsite.url_template}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>ID提取模式</Label>
                  <Input
                    value={editingWebsite.id_pattern}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>徽章颜色</Label>
                  <Select value={editingWebsite?.badge_color || 'blue'} onValueChange={value => setEditingWebsite(prev => ({ ...prev, badge_color: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="blue">蓝色</SelectItem>
                      <SelectItem value="green">绿色</SelectItem>
                      <SelectItem value="orange">橙色</SelectItem>
                      <SelectItem value="red">红色</SelectItem>
                      <SelectItem value="purple">紫色</SelectItem>
                      <SelectItem value="gray">灰色</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingWebsite(null)}>取消</Button>
                <Button onClick={handleUpdateWebsite}>保存</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}

        {/* 消息过滤设置 */}
        {currentUser?.role === 'admin' && (
          <Card className="mt-6">
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg">消息过滤</CardTitle>
                  <CardDescription>设置账号不回复的消息内容规则</CardDescription>
                </div>
                <Dialog open={showAddFilter} onOpenChange={setShowAddFilter}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      添加过滤规则
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>添加消息过滤规则</DialogTitle>
                      <DialogDescription>设置账号忽略的消息类型</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>过滤类型</Label>
                        <Select value={newFilter.filter_type} onValueChange={value => setNewFilter(prev => ({ ...prev, filter_type: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="contains">包含文本</SelectItem>
                            <SelectItem value="starts_with">开头是</SelectItem>
                            <SelectItem value="ends_with">结尾是</SelectItem>
                            <SelectItem value="regex">正则表达式</SelectItem>
                            <SelectItem value="user_id">用户ID</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      <div>
                        <Label>过滤值</Label>
                        <Input
                          value={newFilter.filter_value}
                          onChange={e => setNewFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                          placeholder={
                            newFilter.filter_type === 'user_id'
                              ? "输入用户ID，多个用逗号分隔"
                              : "输入要过滤的内容"
                          }
                        />
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddFilter(false)}>取消</Button>
                      <Button onClick={handleAddMessageFilter}>添加规则</Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                {messageFilters.map((filter: any) => (
                  <div key={filter.id} className="flex items-center justify-between p-3 border rounded">
                    <div>
                      <div className="font-medium">{filter.filter_type} "{filter.filter_value}"</div>
                      <div className="text-sm text-muted-foreground">
                        创建时间: {new Date(filter.created_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingFilter(filter)}
                      >
                        <Edit className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteMessageFilter(filter.id)}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ))}
                {messageFilters.length === 0 && (
                  <div className="text-center py-4 text-muted-foreground">
                    暂无过滤规则
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 网站配置区域 */}
        {currentUser?.role === 'admin' && (
          <Card className="mt-6">
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg flex items-center">
                    <Globe className="w-5 h-5 mr-2" />
                    网站配置
                  </CardTitle>
                  <CardDescription>管理支持的购物网站和频道绑定</CardDescription>
                </div>
                <Dialog open={showAddWebsite} onOpenChange={setShowAddWebsite}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      添加网站
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>添加网站配置</DialogTitle>
                      <DialogDescription>配置新的购物网站支持</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>网站标识</Label>
                        <Input
                          value={newWebsite.name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, name: e.target.value }))}
                          placeholder="例如: kakobuy"
                        />
                      </div>
                      <div>
                        <Label>显示名称</Label>
                        <Input
                          value={newWebsite.display_name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                          placeholder="例如: Kakobuy"
                        />
                      </div>
                      <div>
                        <Label>URL模板</Label>
                        <Input
                          value={newWebsite.url_template}
                          onChange={e => setNewWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                          placeholder="https://www.kakobuy.com/item/details?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD"
                        />
                      </div>
                      <div>
                        <Label>ID提取模式</Label>
                        <Input
                          value={newWebsite.id_pattern}
                          onChange={e => setNewWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                          placeholder="{id}"
                        />
                      </div>
                      <div>
                        <Label>徽章颜色</Label>
                        <Select value={newWebsite.badge_color} onValueChange={value => setNewWebsite(prev => ({ ...prev, badge_color: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="blue">蓝色</SelectItem>
                            <SelectItem value="green">绿色</SelectItem>
                            <SelectItem value="orange">橙色</SelectItem>
                            <SelectItem value="red">红色</SelectItem>
                            <SelectItem value="purple">紫色</SelectItem>
                            <SelectItem value="gray">灰色</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddWebsite(false)}>取消</Button>
                      <Button onClick={handleAddWebsite}>添加</Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {websites.map((website: any) => (
                  <div key={website.id} className="border rounded-lg p-4">
                    <div className="flex justify-between items-start mb-3">
                      <div className="flex items-center gap-2">
                        <span className={`inline-flex items-center rounded-md border font-medium w-fit whitespace-nowrap text-[9px] px-1 py-0 h-4 border-none shrink-0 text-white ${
                          website.badge_color === 'blue' ? 'bg-blue-600' :
                          website.badge_color === 'green' ? 'bg-green-600' :
                          website.badge_color === 'orange' ? 'bg-orange-600' :
                          website.badge_color === 'red' ? 'bg-red-600' :
                          website.badge_color === 'purple' ? 'bg-purple-600' :
                          'bg-gray-600'
                        }`}>
                          {website.display_name}
                        </span>
                        <span className="text-sm font-medium">{website.name}</span>
                      </div>
                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingWebsite(website)}
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteWebsite(website)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    </div>

                    <div className="text-xs text-muted-foreground mb-3">
                      <div>URL模板: {website.url_template}</div>
                      <div>ID模式: {website.id_pattern}</div>
                    </div>

                    {/* 频道绑定 */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Hash className="w-4 h-4" />
                        <span className="text-sm font-medium">绑定频道</span>
                        <Dialog>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Plus className="w-3 h-3 mr-1" />
                              添加频道
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>添加频道绑定</DialogTitle>
                              <DialogDescription>输入Discord频道ID</DialogDescription>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <Label>频道ID</Label>
                                <Input
                                  placeholder="例如: 1234567890123456789"
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                      handleAddChannel(website.id, (e.target as HTMLInputElement).value)
                                      ;(e.target as HTMLInputElement).value = ''
                                    }
                                  }}
                                />
                              </div>
                            </div>
                            <DialogFooter>
                              <Button variant="outline" onClick={() => {}}>取消</Button>
                              <Button onClick={() => {
                                const input = document.querySelector('input[placeholder*="频道ID"]') as HTMLInputElement
                                if (input?.value) {
                                  handleAddChannel(website.id, input.value)
                                  input.value = ''
                                }
                              }}>添加</Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </div>

                      <div className="flex flex-wrap gap-2">
                        {(websiteChannels[website.id] || []).map((channelId: string) => (
                          <div key={channelId} className="flex items-center gap-1 bg-muted rounded px-2 py-1">
                            <Hash className="w-3 h-3" />
                            <span className="text-xs font-mono">{channelId}</span>
                            <Button
                              variant="ghost"
                              size="sm"
                              className="h-4 w-4 p-0"
                              onClick={() => handleRemoveChannel(website.id, channelId)}
                            >
                              <X className="w-3 h-3" />
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 编辑消息过滤对话框 */}
        {editingFilter && (
          <Dialog open={!!editingFilter} onOpenChange={() => setEditingFilter(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>编辑过滤规则</DialogTitle>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>过滤类型</Label>
                  <Select value={editingFilter.filter_type} onValueChange={value => setEditingFilter(prev => ({ ...prev, filter_type: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="contains">包含文本</SelectItem>
                      <SelectItem value="starts_with">开头是</SelectItem>
                      <SelectItem value="ends_with">结尾是</SelectItem>
                      <SelectItem value="regex">正则表达式</SelectItem>
                      <SelectItem value="user_id">用户ID</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label>过滤值</Label>
                  <Input
                    value={editingFilter.filter_value}
                    onChange={e => setEditingFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                  />
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingFilter(null)}>取消</Button>
                <Button onClick={handleUpdateMessageFilter}>保存修改</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}


        {/* 删除账号确认对话框 */}
        <Dialog open={!!deleteAccountConfirm} onOpenChange={() => setDeleteAccountConfirm(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认删除账号</DialogTitle>
              <DialogDescription>
                确定要删除Discord账号 "{deleteAccountConfirm?.username}" 吗？此操作不可恢复。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setDeleteAccountConfirm(null)}>
                取消
              </Button>
              <Button variant="destructive" onClick={confirmDeleteAccount}>
                确认删除
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/image-search-view.tsx ---
"use client"

import type React from "react"
import { useState, useCallback, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Upload, Search, ExternalLink, Settings, X, Clock, Trash2, Copy } from "lucide-react"
import { toast } from "sonner"

export function ImageSearchView() {
  const [uploadedImage, setUploadedImage] = useState<string | null>(null)
  const [imageUrl, setImageUrl] = useState<string>("")
  const [isSearching, setIsSearching] = useState(false)
  const [searchResults, setSearchResults] = useState<any[]>([])
  const [threshold, setThreshold] = useState(30) // 0-100，默认30% (降低阈值以提高匹配成功率)
  const [maxResults, setMaxResults] = useState(5) // 返回最相似的前N个结果

  // 搜索历史相关状态
  const [searchHistory, setSearchHistory] = useState<any[]>([])
  const [currentPage, setCurrentPage] = useState(1)
  const [totalHistory, setTotalHistory] = useState(0)
  const [hasMoreHistory, setHasMoreHistory] = useState(false)
  const [showClearConfirm, setShowClearConfirm] = useState(false)

  // 加载搜索历史
  useEffect(() => {
    fetchSearchHistory()
  }, [])

  const fetchSearchHistory = async (page: number = 1) => {
    try {
      const limit = 10 // 每页显示10条记录
      const offset = (page - 1) * limit
      const response = await fetch(`/api/search_history?limit=${limit}&offset=${offset}`)
      if (response.ok) {
        const result = await response.json()
        setSearchHistory(result.history || [])
        setTotalHistory(result.total || 0)
        setHasMoreHistory(result.has_more || false)
        setCurrentPage(page)
      }
    } catch (error) {
      console.error('Failed to fetch search history:', error)
    }
  }

  // 删除单条搜索历史
  const handleDeleteHistory = async (historyId: number) => {
    try {
      const response = await fetch(`/api/search_history/${historyId}`, {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory(prev => prev.filter(h => h.id !== historyId))
        setTotalHistory(prev => prev - 1)
        toast.success('搜索记录已删除')
      } else {
        toast.error('删除失败')
      }
    } catch (error) {
      console.error('Failed to delete history:', error)
      toast.error('删除失败')
    }
  }

  // 清空所有搜索历史
  const handleClearAllHistory = () => {
    setShowClearConfirm(true)
  }

  const confirmClearAllHistory = async () => {
    setShowClearConfirm(false)
    try {
      const response = await fetch('/api/search_history', {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory([])
        setTotalHistory(0)
        toast.success('所有搜索记录已清空')
      } else {
        toast.error('清空失败')
      }
    } catch (error) {
      console.error('Failed to clear history:', error)
      toast.error('清空失败')
    }
  }

  const handleFileUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("请上传图片文件")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      setUploadedImage(event.target?.result as string)
      // 清空链接输入
      setImageUrl("")
      toast.success("图片已上传")
    }
    reader.readAsDataURL(file)
  }, [])

  const handleClearImage = () => {
    setUploadedImage(null)
  }

  const handleSearch = async () => {
    if (!uploadedImage && !imageUrl.trim()) {
      toast.error("请上传图片或输入图片链接")
      return
    }

    setIsSearching(true)

    try {
      // 创建FormData
      const formData = new FormData();

      if (uploadedImage) {
        // 将base64图片转换为blob
        try {
          const base64Data = uploadedImage.split(',')[1]; // 去掉data:image/jpeg;base64,前缀
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: 'image/jpeg' });
        formData.append('image', blob, 'search.jpg');
        console.log('使用上传的图片进行搜索');
        } catch (error) {
          console.error('图片转换失败:', error);
          toast.error('图片处理失败，请重试');
          setIsSearching(false);
          return;
        }
      } else if (imageUrl.trim()) {
        // 发送图片URL
        formData.append('image_url', imageUrl.trim());
        console.log('使用图片链接进行搜索:', imageUrl.trim());
      }

      formData.append('threshold', (threshold / 100).toString()); // 转换为0-1
      formData.append('limit', maxResults.toString()); // 返回结果数量

      // 发送到后端进行向量搜索
      const searchRes = await fetch('/api/search_similar', {
        method: 'POST',
        body: formData
      });

      if (searchRes.ok) {
        const result = await searchRes.json();
        if (result.success && result.results && result.results.length > 0) {
          // 设置搜索结果
          setSearchResults(result.results)
          // 重新加载搜索历史（新记录已保存到数据库）
          await fetchSearchHistory()
          toast.success(`找到 ${result.results.length} 个相似商品，最佳相似度 ${(result.results[0].similarity * 100).toFixed(1)}%`);
        } else {
          setSearchResults([])
          toast.info(result.message || "未找到相似商品");
        }
      } else {
        const errorText = await searchRes.text();
        console.error('Search failed:', errorText);
        toast.error("搜索失败");
      }
    } catch (error) {
      console.error('Search error:', error);
      toast.error("搜索过程中发生错误");
    } finally {
      setIsSearching(false);
    }
  }




  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">以图搜图</h2>
        <p className="text-muted-foreground">上传图片，测试向量搜索功能并获取 CNFans 链接</p>
      </div>

      <div className="grid gap-6 lg:grid-cols-1">
        <Card>
          <CardHeader>
            <CardTitle>上传图片或输入链接进行搜索</CardTitle>
            <CardDescription>支持 JPG、PNG、WebP 格式，可上传图片文件或输入图片链接进行向量搜索</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex gap-6">
              {/* 左侧：图片输入区域 */}
              <div className="flex-1 space-y-4">
                {/* 图片上传区域 */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">上传图片</label>
                  <div className="space-y-3">
                    {!uploadedImage ? (
                      <label
                        htmlFor="image-upload"
                        className={`flex flex-col items-center justify-center h-48 border-2 border-dashed rounded-lg cursor-pointer transition-colors ${
                          imageUrl.trim()
                            ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50'
                            : 'border-muted-foreground/25 hover:border-muted-foreground/50'
                        }`}
                      >
                        <Upload className="size-12 text-muted-foreground mb-2" />
                        <input
                          id="image-upload"
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={handleFileUpload}
                          disabled={!!imageUrl.trim()}
                        />
                      </label>
                    ) : (
                      <div className="relative">
                        <img
                          src={uploadedImage || "/placeholder.svg"}
                          alt="Uploaded"
                          className="w-full h-48 object-contain rounded-lg border"
                        />
                        <Button
                          variant="destructive"
                          size="icon"
                          className="absolute top-2 right-2 w-8 h-8"
                          onClick={handleClearImage}
                        >
                          <X className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>

                {/* 图片链接输入 */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">图片链接</label>
                  <input
                    type="url"
                    value={imageUrl}
                    onChange={(e) => {
                      setImageUrl(e.target.value)
                      // 当输入链接时，清空已上传的图片
                      if (e.target.value.trim()) {
                        setUploadedImage(null)
                      }
                    }}
                    placeholder="输入图片链接 (https://...)"
                    className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                      uploadedImage ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50' : 'border-gray-300'
                    }`}
                    disabled={!!uploadedImage}
                  />
                  {imageUrl && !uploadedImage && (
                    <div className="flex items-center gap-2">
                      <img
                        src={imageUrl}
                        alt="Preview"
                        className="w-16 h-16 object-cover rounded border"
                        onError={(e) => {
                          e.currentTarget.style.display = 'none';
                        }}
                      />
                      <span className="text-sm text-muted-foreground">图片预览</span>
                    </div>
                  )}
                  {uploadedImage && (
                    <p className="text-xs text-muted-foreground">已上传图片，无法输入链接</p>
                  )}
                </div>
              </div>

              {/* 右侧：搜索设置 */}
              <div className="w-80 space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">相似度阈值</label>
                    <span className="text-sm text-muted-foreground">{threshold}%</span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="1"
                    value={threshold}
                    onChange={(e) => setThreshold(Number.parseInt(e.target.value))}
                    className="w-full"
                  />
                  <p className="text-xs text-muted-foreground">只显示相似度超过此阈值的商品 (0-100%)</p>
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">返回结果数量</label>
                    <span className="text-sm text-muted-foreground">{maxResults}个</span>
                  </div>
                  <select
                    value={maxResults}
                    onChange={(e) => setMaxResults(Number.parseInt(e.target.value))}
                    className="w-full px-3 py-2 border border-input rounded-md bg-background text-sm"
                  >
                    <option value={1}>1个</option>
                    <option value={3}>3个</option>
                    <option value={5}>5个</option>
                    <option value={10}>10个</option>
                    <option value={20}>20个</option>
                  </select>
                  <p className="text-xs text-muted-foreground">返回最相似的前N个结果进行筛选</p>
                </div>

                <Button
                  className="w-full"
                  onClick={handleSearch}
                  disabled={(!uploadedImage && !imageUrl.trim()) || isSearching}
                >
                  <Search className="w-4 h-4 mr-2" />
                  {isSearching ? "搜索中..." : "开始搜索"}
                </Button>

                {isSearching && (
                  <div className="flex items-center justify-center py-4">
                    <div className="text-center space-y-2">
                      <div className="animate-spin size-6 border-4 border-primary border-t-transparent rounded-full mx-auto" />
                      <p className="text-xs text-muted-foreground">正在匹配向量...</p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* 搜索结果 */}
        {searchResults && searchResults.length > 0 && (
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-lg flex items-center gap-2">
                    <Search className="w-5 h-5" />
                    搜索结果
                  </CardTitle>
                  <CardDescription>
                    找到 {searchResults.length} 个相似商品，按相似度排序
                  </CardDescription>
                </div>
                <div className="flex items-center gap-3">
                </div>
              </div>
            </CardHeader>
            <CardContent className="pt-0">
              <div className="space-y-4">
                {searchResults.map((result, index) => (
                  <div key={index} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* 匹配图片和基本信息 */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* 匹配的商品图片 */}
                      <div className="flex-shrink-0">
                        <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                          <img
                            src={result.matchedImage}
                            alt={result.product.title}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              e.currentTarget.src = '/placeholder.jpg'
                            }}
                          />
                        </div>
                      </div>

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{result.product.title}</h4>
                          <Badge
                            className={
                              result.similarity >= 0.95
                                ? "bg-green-600 hover:bg-green-700"
                                : result.similarity >= 0.85
                                ? "bg-blue-600 hover:bg-blue-700"
                                : "bg-yellow-600 hover:bg-yellow-700"
                            }
                          >
                            {(result.similarity * 100).toFixed(1)}% 相似度
                          </Badge>
                        </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{result.product.englishTitle || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {result.product.weidianUrl?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>排名: #{result.rank}</span>
                          <span>|</span>
                          <span>搜索时间: {new Date().toLocaleString('zh-CN')}</span>
                        </div>
                      </div>
                    </div>

                    {/* 链接显示区域 */}
                    <div className="flex items-center gap-4">
                      <div className="flex flex-col gap-1 min-w-[300px]">
                        <div className="flex items-center gap-1.5">
                          <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-gray-600">
                            微店
                          </Badge>
                          <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                            <a href={result.product.weidianUrl} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">
                              {result.product.weidianUrl}
                            </a>
                            <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.weidianUrl); toast.success("Copied")}}>
                              <Copy className="h-2.5 w-2.5"/>
                            </Button>
                          </div>
                        </div>
                        {result.product.cnfansUrl && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-blue-600">
                              CNFans
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={result.product.cnfansUrl} target="_blank" className="font-mono truncate hover:underline text-blue-500">
                                {result.product.cnfansUrl}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.cnfansUrl); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                              </Button>
                            </div>
                          </div>
                        )}
                        {result.product.acbuyUrl && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-purple-600">
                              ACBuy
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={result.product.acbuyUrl} target="_blank" className="font-mono truncate hover:underline text-purple-500">
                                {result.product.acbuyUrl}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.acbuyUrl); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                              </Button>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 搜索历史 - 列表形式 */}
        <Card>
          <CardHeader className="pb-4">
            <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
              <div>
                <CardTitle className="text-lg">搜索记录</CardTitle>
                <CardDescription>历史搜索结果，按时间倒序排列</CardDescription>
              </div>
              {searchHistory.length > 0 && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleClearAllHistory}
                  className="shrink-0"
                >
                  <Trash2 className="w-4 h-4 mr-1" />
                  清空历史
                </Button>
              )}
            </div>
          </CardHeader>
          <CardContent className="pt-0">
            {searchHistory.length === 0 ? (
              <div className="text-center py-12 text-muted-foreground">
                <Search className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>暂无搜索记录</p>
                <p className="text-sm">上传图片并搜索后，结果将显示在这里</p>
              </div>
            ) : (
              <div className="space-y-3">
                {searchHistory.map((history) => (
                  <div key={history.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* 匹配图片和基本信息 */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* 匹配的商品图片 */}
                      {history.matched_product_id && (
                        <div className="flex-shrink-0">
                          <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                            <img
                              src={`/api/image/${history.matched_product_id}/${history.matched_image_index}`}
                              alt="匹配的商品图片"
                              className="w-full h-full object-cover"
                              onError={(e) => {
                                e.currentTarget.src = '/placeholder.jpg'
                              }}
                            />
                          </div>
                        </div>
                      )}

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{history.title}</h4>
                            <Badge
                              className={
                                history.similarity >= 0.95
                                  ? "bg-green-600 hover:bg-green-700"
                                  : history.similarity >= 0.85
                                  ? "bg-blue-600 hover:bg-blue-700"
                                  : "bg-yellow-600 hover:bg-yellow-700"
                              }
                            >
                              {(history.similarity * 100).toFixed(1)}% 相似度
                            </Badge>
                          </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{history.english_title || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {history.weidian_url?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>匹配图片: #{history.matched_image_index}</span>
                          <span>|</span>
                          <span>阈值: {history.threshold * 100}%</span>
                          <span>|</span>
                          <span>搜索时间: {new Date(history.search_time).toLocaleString('zh-CN')}</span>
                        </div>
                              </div>
                            </div>

                    {/* 链接显示区域 */}
                    <div className="flex items-center gap-4">
                      <div className="flex flex-col gap-1 min-w-[300px]">
                        <div className="flex items-center gap-1.5">
                          <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-gray-600">
                            微店
                          </Badge>
                          <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                            <a href={history.weidian_url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">
                              {history.weidian_url}
                            </a>
                            <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.weidian_url); toast.success("Copied")}}>
                              <Copy className="h-2.5 w-2.5"/>
                            </Button>
                          </div>
                        </div>
                        {history.cnfans_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-blue-600">
                              CNFans
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.cnfans_url} target="_blank" className="font-mono truncate hover:underline text-blue-500">
                                {history.cnfans_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.cnfans_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                        {history.acbuy_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-purple-600">
                              ACBuy
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.acbuy_url} target="_blank" className="font-mono truncate hover:underline text-purple-500">
                                {history.acbuy_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.acbuy_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                      </div>

                      {/* 删除按钮 */}
                        <Button
                        variant="outline"
                          size="icon"
                        className="h-8 w-8 hover:bg-red-50 hover:text-red-600"
                          onClick={() => handleDeleteHistory(history.id)}
                        >
                        <X className="size-3.5" />
                        </Button>
                    </div>
                  </div>
                ))}

                {/* 分页控件 */}
                {searchHistory.length > 0 && (
                  <div className="flex flex-col sm:flex-row justify-between items-center gap-4 pt-4 border-t mt-4">
                    <div className="text-sm text-muted-foreground font-medium">
                      显示第 {((currentPage - 1) * 10) + 1} - {Math.min(currentPage * 10, totalHistory)} 条，共 {totalHistory} 条记录
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage - 1)}
                        disabled={currentPage <= 1}
                        className="h-8 px-3"
                      >
                        上一页
                      </Button>
                      <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                        {currentPage}
                      </div>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage + 1)}
                        disabled={!hasMoreHistory || searchHistory.length === 0}
                        className="h-8 px-3"
                      >
                        下一页
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* 清空历史确认对话框 */}
        <Dialog open={showClearConfirm} onOpenChange={setShowClearConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认清空历史</DialogTitle>
              <DialogDescription>
                确定要清空所有搜索记录吗？此操作不可撤销。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowClearConfirm(false)}>
                取消
              </Button>
              <Button variant="destructive" onClick={confirmClearAllHistory}>
                确认清空
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/scraper-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Copy, ChevronLeft, ChevronRight, Trash2, ImageIcon, Edit, X, Download, Loader2, List, Upload, Store, CheckSquare, Square, Search, ChevronDown, ChevronUp, Pause, Play, StopCircle } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { Checkbox } from "@/components/ui/checkbox"

export function ScraperView({ currentUser }: { currentUser: any }) {
  const [batchIds, setBatchIds] = useState('')
  const [isBatchScraping, setIsBatchScraping] = useState(false)
  const [batchProgress, setBatchProgress] = useState(0)
  const [products, setProducts] = useState<any[]>([])
  const [totalProducts, setTotalProducts] = useState(0)
  const [currentPage, setCurrentPage] = useState(1)
  const [jumpPage, setJumpPage] = useState("")
  const [itemsPerPage, setItemsPerPage] = useState(50)
  const [editingProduct, setEditingProduct] = useState<any>(null)
  const [selectedProducts, setSelectedProducts] = useState<number[]>([])
  const [selectAll, setSelectAll] = useState(false)
  const [indexedIds, setIndexedIds] = useState<string[]>([])
  const [shopFilter, setShopFilter] = useState('__ALL__')
  const [keywordSearch, setKeywordSearch] = useState('')
  const [isDeleting, setIsDeleting] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [deletingProductId, setDeletingProductId] = useState<number | null>(null)
  // 图片上传 ref
  const uploadInputRef = useRef<HTMLInputElement>(null)
  const [isUploadingImg, setIsUploadingImg] = useState(false)
  const [productUrls, setProductUrls] = useState<{[key: number]: any[]}>({})
  const [expandedProducts, setExpandedProducts] = useState<Set<number>>(new Set())
  const [selectedFiles, setSelectedFiles] = useState<FileList | null>(null)
  const [batchUploading, setBatchUploading] = useState(false)

  // 使用API缓存hook
  const { cachedFetch } = useApiCache()

  // 抓取相关状态
  const [shopId, setShopId] = useState('')
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [shopScrapeProgress, setShopScrapeProgress] = useState(0)
  const [scrapeStatus, setScrapeStatus] = useState<any>(null)
  const [availableShops, setAvailableShops] = useState<any[]>([])
  const [selectedShopId, setSelectedShopId] = useState('')
  const [totalProductsCount, setTotalProductsCount] = useState(0)
  // 搜索类型状态
  const [searchType, setSearchType] = useState<'all' | 'id' | 'keyword' | 'chinese'>('all')

  // 优化：分离不同类型的加载逻辑
  useEffect(() => {
    fetchIndexedIds()
    fetchAvailableShops()
    fetchProductsCount()
  }, []) // 静态数据只加载一次

  useEffect(() => {
    fetchProducts(currentPage)
  }, [currentPage, itemsPerPage, keywordSearch, shopFilter]) // 只在相关参数改变时重新加载商品

  useEffect(() => {
    // 当搜索条件改变时，重置到第一页
    if (keywordSearch || shopFilter) {
      setCurrentPage(1)
    }
  }, [keywordSearch, shopFilter])

  // 优化轮询频率：只在有抓取任务时才频繁检查
  useEffect(() => {
    const statusInterval = setInterval(() => {
      console.log('轮询状态检查 - isShopScraping:', isShopScraping, 'isBatchScraping:', isBatchScraping)
      fetchScrapeStatus()
      // 商品数量只在有抓取任务时才检查
      if (isShopScraping || isBatchScraping) {
        fetchProductsCount()
        // 同时刷新商品列表，显示最新抓取的数据
        fetchProducts(currentPage)
      }
    }, isShopScraping || isBatchScraping ? 2000 : 10000) // 无任务时10秒检查一次

    console.log('设置新的轮询间隔:', isShopScraping || isBatchScraping ? 2000 : 10000, 'ms')

    return () => {
      console.log('清理轮询定时器')
      clearInterval(statusInterval)
    }
  }, [isShopScraping, isBatchScraping, currentPage])

  const fetchProducts = async (page: number = 1, append: boolean = false, usePreload: boolean = true) => {
    try {
      // 首先检查是否有预加载数据（只在第一次加载且未追加时）
      if (page === 1 && !append && usePreload) {
        const preloadData = sessionStorage.getItem('preload_products')
        if (preloadData) {
          try {
            console.log('使用预加载商品数据')
            const data = JSON.parse(preloadData)
            // 使用预加载数据
            const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
              ...product,
              id: product.id,
              shopName: product.shopName || product.shop_name || '未知店铺',
              title: product.title || '',
              englishTitle: product.englishTitle || product.english_title || '',
              weidianUrl: product.weidianUrl || product.product_url || '',
              cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
              acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
              weidianId: product.weidianId || '',
              ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
              customReplyText: product.customReplyText || product.custom_reply_text || '',
              customReplyImages: product.customReplyImages || product.custom_reply_images || [],
              selectedImageIndexes: product.selectedImageIndexes || [],
              customImageUrls: product.customImageUrls || product.custom_image_urls || [],
              imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload')
            }))

            setProducts(processedProducts)
            setTotalProducts(data.total || 0)

            // 清除预加载数据，避免重复使用
            sessionStorage.removeItem('preload_products')

            // 在后台获取最新数据，但不显示加载状态
            setTimeout(() => fetchProducts(1, false, false), 500)
            return
          } catch (e) {
            console.error('预加载数据解析失败:', e)
            // 预加载数据损坏，清除并重新获取
            sessionStorage.removeItem('preload_products')
          }
        } else {
          // 如果没有预加载数据，等待一下再试（给预加载一点时间）
          if (page === 1 && !append) {
            setTimeout(() => {
              const retryPreload = sessionStorage.getItem('preload_products')
              if (retryPreload) {
                fetchProducts(1, false, true)
              } else {
                fetchProducts(1, false, false)
              }
            }, 200)
            return
          }
        }
      }

      console.log('从API获取商品数据')
      const res = await fetch(`/api/products?page=${page}&limit=${itemsPerPage}`)
      const data = await res.json()

      // 调试信息
      console.log('商品列表API响应:', {
        page,
        total: data.total,
        productsCount: data.products?.length || 0,
        debug: data.debug,
        firstProduct: data.products?.[0] ? {
          id: data.products[0].id,
          shopName: data.products[0].shopName || data.products[0].shop_name,
          title: data.products[0].title
        } : null
      })

      const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
        ...product,
        id: product.id,
        shopName: product.shopName || product.shop_name || '未知店铺',
        title: product.title || '',
        englishTitle: product.englishTitle || product.english_title || '',
        weidianUrl: product.weidianUrl || product.product_url || '',
        cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
        acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
        weidianId: product.weidianId || '',
        ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
        customReplyText: product.customReplyText || product.custom_reply_text || '',
        customReplyImages: product.customReplyImages || product.custom_reply_images || [],
        selectedImageIndexes: product.selectedImageIndexes || [],
        customImageUrls: product.customImageUrls || product.custom_image_urls || [],
        imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload'),
        uploadedImages: product.uploadedImages || []
      }))

      if (append) {
        // 分页加载更多
        setProducts(prev => [...prev, ...processedProducts])
      } else {
        // 重新加载第一页
        setProducts(processedProducts)
      }

      setTotalProducts(data.total || 0)
    } catch (e) {
      toast.error("加载商品库失败")
    }
  }

  const fetchIndexedIds = async () => {
    try {
      const data = await cachedFetch('/api/scrape?type=indexed', { credentials: 'include' })
      setIndexedIds(data.indexedIds || [])
    } catch (e) {
      console.error('获取已索引ID失败:', e)
    }
  }

  const fetchAvailableShops = async () => {
    try {
      const data = await cachedFetch('/api/shops')
      setAvailableShops(data.shops || [])
    } catch (e) {
      console.error('获取店铺列表失败:', e)
    }
  }

  const fetchProductsCount = async () => {
    try {
      const data = await cachedFetch('/api/products/count')
      setTotalProductsCount(data.count || 0)
    } catch (e) {
      console.error('获取商品数量失败:', e)
    }
  }

  const fetchScrapeStatus = async () => {
    try {
      const res = await fetch('/api/scrape/shop/status')
      if (res.ok) {
        const text = await res.text()
        if (text.trim()) {
          const status = JSON.parse(text)
          setScrapeStatus(status)
          setIsShopScraping(status.is_scraping)
          setShopScrapeProgress(status.progress || 0)
          // 如果抓取完成，刷新商品列表
          if (!status.is_scraping && status.completed) {
            fetchProducts()
            fetchProductsCount()
          }
        }
      }
    } catch (e) {
      console.error('获取抓取状态失败:', e)
      // 静默失败
    }
  }

  // === 链接生成逻辑 ===

  const getProductLinks = (product: any) => {
    const links = [
        { name: 'cnfans', display_name: 'CNFans', url: product.cnfansUrl, badge_color: 'blue' },
        { name: 'weidian', display_name: '微店', url: product.weidianUrl, badge_color: 'gray' },
        { name: 'acbuy', display_name: 'AcBuy', url: product.acbuyUrl, badge_color: 'orange' }
    ].filter(link => link.url && link.url.trim() !== '');

    // 如果有从后端获取的额外链接，可以合并（这里简化处理，只用上面的）
    return links;
  }

  // ... (保留 handleBatchDelete, confirmBatchDelete, handleUploadImage, handleBatchUploadImages) ...

  const handleBatchDelete = async () => {
    console.log('批量删除按钮被点击，选中商品数量:', selectedProducts.length)
    if (selectedProducts.length === 0) {
      console.log('没有选中商品，返回')
      return
    }
    console.log('设置显示确认对话框')
    setShowDeleteConfirm(true)
  }

  const confirmBatchDelete = async () => {
    setShowDeleteConfirm(false)
    setIsDeleting(true)
    try {
      const res = await fetch(`/api/products?ids=${selectedProducts.join(',')}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success("批量删除成功")
        setProducts(products.filter(p => !selectedProducts.includes(p.id)))
        setSelectedProducts([])
      } else {
        toast.error("批量删除失败")
      }
    } catch (e) {
      toast.error("网络错误")
    } finally {
      setIsDeleting(false)
    }
  }

  const handleUploadImage = async (productId: number, file: File) => {
    if (!file) return
    setIsUploadingImg(true)
    const formData = new FormData()
    formData.append('image', file)
    try {
      const res = await fetch(`/api/products/${productId}/images`, {
        method: 'POST',
        body: formData
      })
      if (res.ok) {
        const data = await res.json()
        setProducts(products.map(p => p.id === productId ? data.product : p))
        toast.success("图片上传成功")
      } else {
        toast.error("上传失败")
      }
    } catch (e) {
      toast.error("上传出错")
    } finally {
      setIsUploadingImg(false)
    }
  }

  const handleBatchUploadImages = async (productId: number, files?: FileList | null) => {
    const filesToUpload = files || selectedFiles
    if (!filesToUpload || filesToUpload.length === 0) return
    setBatchUploading(true)
    let successCount = 0
    try {
      for (let i = 0; i < filesToUpload.length; i++) {
        const file = filesToUpload[i]
        const formData = new FormData()
        formData.append('image', file)
          const res = await fetch(`/api/products/${productId}/images`, {
            method: 'POST',
          body: formData
          })
        if (res.ok) successCount++
      }
      if (successCount > 0) {
        const productRes = await fetch(`/api/products/${productId}`) // Fix: fetch specific product if endpoint exists, else refresh all or return from API
        // Refresh products for simplicity
        fetchProducts();
      }
      toast.success(`上传完成：${successCount}张图片`)
      setSelectedFiles(null)
    } catch (e) {
      toast.error('批量上传错误')
    } finally {
      setBatchUploading(false)
    }
  }

  const handleSelectAll = () => {
    if (selectedProducts.length === currentProducts.length && currentProducts.length > 0) {
      setSelectedProducts([])
    } else {
      setSelectedProducts(currentProducts.map(p => p.id))
    }
  }

  const toggleProductExpansion = (productId: number) => {
    setExpandedProducts(prev => {
      const newSet = new Set(prev)
      if (newSet.has(productId)) newSet.delete(productId)
      else newSet.add(productId)
      return newSet
    })
  }

  const handleDeleteProduct = async (id: number) => {
    setDeletingProductId(id)
    setShowDeleteConfirm(true)
  }

  const confirmDeleteProduct = async () => {
    if (!deletingProductId) return

    setShowDeleteConfirm(false)

    // 显示删除进度提示
    toast.loading("正在删除商品...", { id: `delete-${deletingProductId}` })

    try {
      const response = await fetch(`/api/products/${deletingProductId}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        setProducts(products.filter(p => p.id !== deletingProductId))
        setTotalProducts(totalProducts - 1)
        setSelectedProducts(selectedProducts.filter(pid => pid !== deletingProductId))
        toast.success("删除成功", { id: `delete-${deletingProductId}` })
      } else {
        toast.error("删除失败", { id: `delete-${deletingProductId}` })
      }
    } catch (e) {
      toast.error("删除失败", { id: `delete-${deletingProductId}` })
    } finally {
      setDeletingProductId(null)
    }
  }

  const handleUpdateProduct = async (updatedProduct: any) => {
    try {
      let res;

      // 检查是否有上传的图片文件
      if (updatedProduct.uploadedImages && updatedProduct.uploadedImages.length > 0) {
        // 使用FormData发送文件
        const formData = new FormData();

        // 添加基本数据
        formData.append('id', updatedProduct.id.toString());
        if (updatedProduct.title) formData.append('title', updatedProduct.title);
        if (updatedProduct.englishTitle) formData.append('englishTitle', updatedProduct.englishTitle);
        if (updatedProduct.ruleEnabled !== undefined) formData.append('ruleEnabled', updatedProduct.ruleEnabled.toString());
        if (updatedProduct.customReplyText) formData.append('customReplyText', updatedProduct.customReplyText);
        if (updatedProduct.imageSource) formData.append('imageSource', updatedProduct.imageSource);

        // 添加数组数据（序列化为JSON）
        if (updatedProduct.selectedImageIndexes) {
          formData.append('selectedImageIndexes', JSON.stringify(updatedProduct.selectedImageIndexes));
        }
        if (updatedProduct.customImageUrls) {
          formData.append('customImageUrls', JSON.stringify(updatedProduct.customImageUrls));
        }

        // 添加上传的文件
        updatedProduct.uploadedImages.forEach((file: File, index: number) => {
          formData.append('uploadedImages', file);
        });

        res = await fetch('/api/products', {
          method: 'PUT',
          credentials: 'include',
          body: formData
        });
      } else {
        // 使用JSON发送普通数据
        res = await fetch('/api/products', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(updatedProduct)
        });
      }

      if (res.ok) {
        const data = await res.json()
        setProducts(products.map(p => p.id === data.product.id ? data.product : p))
        setEditingProduct(null)
        toast.success("更新成功")
      } else {
        const errorData = await res.json().catch(() => ({}));
        toast.error(errorData.error || "更新失败")
      }
    } catch (e) {
      console.error('Update error:', e);
      toast.error("更新失败")
    }
  }


  // ... (保留 handleScrapeShop, handleBatchScrape, handleJumpPage) ...

  const handleScrapeControl = async (action: 'pause' | 'resume' | 'stop') => {
    try {
      console.log(`🎮 发送抓取控制请求: action=${action}, 当前状态:`, scrapeStatus)
      const response = await fetch('/api/scrape/shop/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action
          // 不需要shopId，因为控制的是当前正在运行的任务
        })
      })

      console.log(`🎮 控制API响应状态: ${response.status}`)
      const responseText = await response.text()
      console.log(`🎮 控制API响应内容:`, responseText)

      if (response.ok) {
        const result = await response.json()
        if (action === 'pause') {
          toast.success('抓取已暂停')
        } else if (action === 'resume') {
          toast.success('抓取已继续')
        } else if (action === 'stop') {
          toast.success('抓取已停止')
        }
        // 立即刷新状态
        fetchScrapeStatus()
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || `操作失败: ${action}`)
      }
    } catch (error) {
      toast.error(`操作失败: ${action}`)
    }
  }

  const handleScrapeShop = async () => {
    if (!selectedShopId) {
      toast.error("请选择要抓取的店铺")
      return
    }

    setIsShopScraping(true)
    setShopScrapeProgress(0)

    try {
      const response = await fetch('/api/scrape/shop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shopId: selectedShopId })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success(`店铺抓取完成！共获取 ${data.totalProducts} 个商品`)
        fetchProducts()
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || "店铺抓取失败")
      }
    } catch (error) {
      toast.error("网络错误，无法抓取店铺")
    } finally {
      setIsShopScraping(false)
      setShopScrapeProgress(0)
    }
  }

  const handleBatchScrape = async () => {
    const ids = batchIds.split('\n').map(id => id.trim()).filter(id => id && id.match(/^\d+$/))
    if (ids.length === 0) {
      toast.error("请输入有效的商品ID")
      return
    }

    console.log('开始批量上传，商品数量:', ids.length)
    setIsBatchScraping(true)
    setBatchProgress(0)
    let successCount = 0
    let skipCount = 0

    try {
      for(let i = 0; i < ids.length; i++) {
        const id = ids[i]
        console.log(`上传商品 ${i+1}/${ids.length}: ${id}`)

        try {
          console.log(`发送请求到 /api/scrape，商品ID: ${id}`)
          const res = await fetch('/api/scrape', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ weidianId: id }),
            signal: AbortSignal.timeout(30000) // 30秒超时
          })

          console.log(`收到响应，状态码: ${res.status}`)

          if(res.ok) {
            successCount++
            console.log(`商品 ${id} 上传成功`)
          } else if(res.status === 409) {
            skipCount++
            console.log(`商品 ${id} 已存在，跳过`)
          } else {
            const errorText = await res.text()
            console.error(`商品 ${id} 上传失败:`, res.status, errorText)
          }
        } catch(fetchError) {
          console.error(`商品 ${id} 请求异常:`, fetchError)
          // 如果是超时或者网络错误，仍然算作处理过
          skipCount++
        }

        setBatchProgress(((i+1)/ids.length)*100)
      }

      toast.success(`完成: 成功 ${successCount}, 跳过 ${skipCount}`)
      console.log('批量上传完成')

      // 强制刷新数据
      fetchProducts()
      fetchProductsCount()

      setBatchIds('')
    } catch(e) {
      console.error('批量上传出现错误:', e)
      toast.error("批量上传失败")
    } finally {
      console.log('设置 isBatchScraping 为 false')
      setIsBatchScraping(false)
    }
  }

  const handleJumpPage = () => { /* ... */ }

  // 筛选和分页逻辑（简化版，避免一次性加载过多数据）
  const uniqueShops = Array.from(new Set(products.map(p => p?.shopName || '').filter(name => name && name.trim()))).sort()

  // 简化分页：直接使用当前页的产品数据，不再进行复杂的内存筛选
  // 这样可以显著提升加载速度，但暂时不支持跨页搜索
  const currentProducts = products.filter(p => {
    // 只有在没有搜索条件时才显示当前页数据
    if (!keywordSearch && !shopFilter) {
      return true
    }

    // 有搜索条件时，对当前加载的数据进行筛选
    let matchesSearch = true
    if (keywordSearch) {
      if (searchType === 'id') {
        matchesSearch = p.weidianId?.includes(keywordSearch)
      } else if (searchType === 'keyword') {
        matchesSearch = p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else if (searchType === 'chinese') {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.weidianId?.includes(keywordSearch)
      }
    }
    const matchesShop = !shopFilter || shopFilter === "__ALL__" || p.shopName === shopFilter
    return matchesSearch && matchesShop
  })

  // 计算总页数（基于总数）
  const totalPages = Math.ceil(totalProducts / itemsPerPage)

  return (
    <div className="space-y-8">
      {/* ... 顶部标题和管理员/普通用户上传区域 (保持不变) ... */}

      <div>
        <h2 className="text-3xl font-bold tracking-tight">微店抓取</h2>
        <p className="text-muted-foreground">商品管理与抓取</p>
      </div>

      {(currentUser?.role === 'admin' || (currentUser?.shops && currentUser.shops.length > 0)) ? (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
             {/* Shop Scrape Card */}
        <Card className="border-2 border-dashed border-purple-300/50 hover:border-purple-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-purple-100 rounded-xl"><Store className="h-6 w-6 text-purple-600"/></div>
                            <div><h4 className="text-xl font-bold">店铺商品抓取</h4><p className="text-sm text-muted-foreground">输入店铺ID</p></div>
                </div>
                        <div className="space-y-3">
                <div>
                                <Label className="text-sm">选择店铺</Label>
                                <Select value={selectedShopId} onValueChange={setSelectedShopId} disabled={isShopScraping}>
                                    <SelectTrigger className="w-full">
                                        <SelectValue placeholder="请选择要抓取的店铺" />
                                    </SelectTrigger>
                                    <SelectContent>
                                        {availableShops.map((shop) => (
                                            <SelectItem key={shop.shop_id} value={shop.shop_id}>
                                                {shop.name} (ID: {shop.shop_id})
                                            </SelectItem>
                                        ))}
                                    </SelectContent>
                                </Select>
                </div>
                            {!isShopScraping ? (
                              <Button onClick={handleScrapeShop} disabled={!selectedShopId} className="w-full">
                                抓取店铺
                              </Button>
                            ) : (
                              <div className="flex gap-2">
                                <Button
                                  variant="outline"
                                  size="sm"
                                  onClick={() => {
                                    const action = scrapeStatus?.paused ? 'resume' : 'pause'
                                    console.log(`按钮点击: 当前状态 paused=${scrapeStatus?.paused}, 发送action=${action}`)
                                    handleScrapeControl(action)
                                  }}
                                  className="flex-1"
                                >
                                  {scrapeStatus?.paused ? (
                                    <>
                                      <Play className="w-4 h-4 mr-2" />
                                      继续
                                    </>
                                  ) : (
                                    <>
                                      <Pause className="w-4 h-4 mr-2" />
                                      暂停
                                    </>
                                  )}
                                </Button>
                                <Button
                                  variant="destructive"
                                  size="sm"
                                  onClick={() => handleScrapeControl('stop')}
                                  className="flex-1"
                                >
                                  <StopCircle className="w-4 h-4 mr-2" />
                                  取消
                                </Button>
                              </div>
                            )}
              </div>
            </div>
          </CardContent>
        </Card>
             {/* Batch Scrape Card */}
        <Card className="border-2 border-dashed border-green-300/50 hover:border-green-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-green-100 rounded-xl"><List className="h-6 w-6 text-green-600"/></div>
                            <div><h4 className="text-xl font-bold">批量上传</h4><p className="text-sm text-muted-foreground">输入商品ID</p></div>
                </div>
              <div className="space-y-3">
                            <textarea placeholder="每行一个ID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-32 p-4 text-sm border-2 rounded-lg resize-none"/>
                            <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">
                                {isBatchScraping ? "上传中..." : `批量上传`}
                  </Button>
              </div>
            </div>
          </CardContent>
        </Card>
        </div>
      ) : (
          /* User View - 普通用户只能看到批量上传 */
        <div className="max-w-2xl mx-auto">
             <Card className="border-2 border-dashed border-green-300/50">
            <CardContent className="p-8">
                    <div className="space-y-4">
                  <h4 className="text-2xl font-bold mb-2">批量商品上传</h4>
                        <textarea id="batch-ids" placeholder="每行一个ID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-40 p-4 border-2 rounded-lg"/>
                        <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">批量上传</Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Progress Bar - 只显示批量抓取进度 */}
      {isBatchScraping && (
        <div className="space-y-3">
          <Progress value={batchProgress} className="h-3" />
          <p className="text-center text-sm text-muted-foreground">{batchProgress.toFixed(1)}%</p>
        </div>
      )}

      {/* Product List */}
      <div className="space-y-4">
        <Card className="shadow-sm">
            <CardHeader className="py-4 border-b">
                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div className="flex flex-col gap-1">
                        <CardTitle className="text-xl font-bold">
                          商品库{isShopScraping ? ' - 抓取中...' : ''}
                        </CardTitle>
            </div>
                    <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center w-full sm:w-auto">
                        {/* 搜索控件 */}
                        <div className="flex gap-2 flex-1 sm:flex-initial">
                <div className="relative">
                                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                                    placeholder={
                                        searchType === 'id' ? '输入商品ID...' :
                                        searchType === 'keyword' ? '输入英文关键词...' :
                                        searchType === 'chinese' ? '输入中文关键词...' :
                                        '输入商品标题、中文关键词、英文关键词或ID...'
                                    }
                    value={keywordSearch}
                                    onChange={e=>setKeywordSearch(e.target.value)}
                                    className="pl-10 h-9 w-full sm:w-[400px]"
                  />
                </div>
                            <Select value={searchType} onValueChange={(value: 'all' | 'id' | 'keyword' | 'chinese') => setSearchType(value)}>
                                <SelectTrigger className="h-9 w-28">
                                    <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="all">全部</SelectItem>
                                    <SelectItem value="id">按ID</SelectItem>
                                    <SelectItem value="keyword">英文关键词</SelectItem>
                                    <SelectItem value="chinese">中文关键词</SelectItem>
                                </SelectContent>
                            </Select>
                  <Select value={shopFilter} onValueChange={setShopFilter}>
                                <SelectTrigger className="h-9 w-32">
                                    <SelectValue placeholder="全部店铺" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__ALL__">全部店铺</SelectItem>
                                    {uniqueShops.map(s=><SelectItem key={s} value={s}>{s}</SelectItem>)}
                    </SelectContent>
                  </Select>
              <Select value={itemsPerPage.toString()} onValueChange={(v) => {
                setItemsPerPage(parseInt(v))
                setCurrentPage(1)
              }}>
                                <SelectTrigger className="h-9 w-24">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                                    <SelectItem value="20">20个/页</SelectItem>
                                    <SelectItem value="50">50个/页</SelectItem>
                                    <SelectItem value="100">100个/页</SelectItem>
                                    <SelectItem value="200">200个/页</SelectItem>
                </SelectContent>
              </Select>
            </div>
                        {/* 操作按钮 */}
                        <div className="flex items-center gap-3">
                            <Button variant={selectedProducts.length===currentProducts.length && currentProducts.length>0?"secondary":"outline"} size="sm" onClick={handleSelectAll}>
                                {selectedProducts.length===currentProducts.length && currentProducts.length>0 ? <CheckSquare className="mr-2 h-4 w-4"/> : <Square className="mr-2 h-4 w-4"/>} 全选 ({currentProducts.length})
            </Button>
                            {selectedProducts.length > 0 && (
                                <Button variant="destructive" size="sm" onClick={handleBatchDelete} disabled={isDeleting}>
                                    <Trash2 className="mr-2 h-4 w-4" /> 删除 ({selectedProducts.length})
                                </Button>
                            )}
          </div>
              </div>
            </div>
            </CardHeader>
            <CardContent className="p-0">
                {/* 列表 */}
          <div className="divide-y">
                    {currentProducts.map((product) => {
                        const links = getProductLinks(product);
                        const showAllLinks = expandedProducts.has(product.id);
                        const displayedLinks = showAllLinks ? links : links.slice(0, 3);
                        return (
              <div key={product.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                <div className="flex gap-3 items-center">
                                <Checkbox checked={selectedProducts.includes(product.id)} onCheckedChange={(checked)=>{
                                    if(checked) setSelectedProducts([...selectedProducts, product.id])
                                    else setSelectedProducts(selectedProducts.filter(id=>id!==product.id))
                                }}/>
                </div>

                            {/* 图片与基本信息 */}
                <div className="flex gap-3 items-center flex-1">
                                {/* 图片弹窗 (保持原逻辑) */}
                  <Dialog>
                    <DialogTrigger asChild>
                                        <Button variant="ghost" className="size-10 p-0 rounded bg-muted flex items-center justify-center flex-shrink-0 border shadow-sm">
                        {product.images && product.images.length > 0 ? (
                                                <img src={product.images[0]} alt="thumb" className="object-cover w-12 h-12 rounded-md" />
                                            ) : <ImageIcon className="size-4 text-muted-foreground" />}
                      </Button>
                    </DialogTrigger>
                    <DialogContent className="max-w-4xl">
                      <DialogHeader>
                        <DialogTitle className="text-xl">商品图集 - {product.weidianId}</DialogTitle>
                        <div className="flex gap-2 mt-2">
                          <input
                            type="file"
                            accept="image/*"
                            multiple
                            className="hidden"
                            id={`upload-${product.id}`}
                            onChange={(e) => {
                              const files = (e.target as HTMLInputElement).files
                              if (files && files.length > 0) {
                                handleBatchUploadImages(product.id, files)
                              }
                            }}
                          />
                          <label htmlFor={`upload-${product.id}`}>
                            <Button size="sm" disabled={isUploadingImg || batchUploading} asChild>
                              <span className="cursor-pointer">
                                <Upload className="mr-2 h-4 w-4" />
                                {isUploadingImg || batchUploading ? "上传中..." : "添加图片"}
                              </span>
                            </Button>
                          </label>
                        </div>
                      </DialogHeader>
                      <ScrollArea className="max-h-[70vh] mt-4">
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-1">
                          {product.images?.map((img: string, idx: number) => (
                            <div key={img} className="aspect-square rounded-xl border-2 bg-muted overflow-hidden group relative">
                              <img src={img} alt={`Img ${idx}`} className="object-cover w-full h-full transition-transform group-hover:scale-110" />
                              <button
                                                            onClick={async (e) => {
                                                                e.preventDefault()
                                                                e.stopPropagation()
                                                                try {
                                                                    // 从图片URL中提取image_index
                                                                    // URL格式: /api/image/{product_id}/{image_index}
                                                                    const urlParts = img.split('/')
                                                                    const imageIndex = urlParts[urlParts.length - 1] // 获取最后一个部分

                                                                    // 验证imageIndex是否为有效数字
                                                                    if (!imageIndex || isNaN(Number(imageIndex))) {
                                                                        toast.error("无法确定要删除的图片")
                                                                        return
                                                                    }

                                                                    const res = await fetch(`/api/products/${product.id}/images/${imageIndex}`, {
                                                                        method: 'DELETE'
                                  })
                                  if (res.ok) {
                                    const data = await res.json()
                                                                        // 更新产品状态，替换整个产品对象
                                                                        setProducts(prevProducts =>
                                                                            prevProducts.map(p =>
                                                                                p.id === product.id ? { ...data.product } : p
                                                                            )
                                                                        )
                                                                        toast.success("图片已删除")
                                  } else {
                                                                        const errorData = await res.json().catch(() => ({ error: 'Delete failed' }))
                                                                        toast.error(errorData.error || "删除失败")
                                                                        console.error('Delete failed:', errorData)
                                                                    }
                                                                } catch (error) {
                                                                    console.error('Delete image error:', error)
                                                                    toast.error("网络错误，删除失败")
                                  }
                                }}
                                                            className="absolute top-1 right-1 p-1 bg-red-500 rounded-full text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 shadow-lg z-10"
                              >
                                <X className="size-3" />
                              </button>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </DialogContent>
                  </Dialog>
                  <div className="space-y-0.5 min-w-0 flex-1">
                    <div className="flex items-center gap-2">
                                        <h4 className="font-bold text-base truncate">{product.title}</h4>
                                        {/* 已删除这里原本的小编辑按钮 */}
                                        {indexedIds.includes(product.weidianId) && <Badge className="bg-blue-600 text-[10px] h-4 px-2">已索引</Badge>}
                                        {product.ruleEnabled && <Badge className="bg-purple-600 text-[10px] h-4 px-2">规则启用</Badge>}
                    </div>
                    <div className="flex items-center gap-2 mt-1">
                                        <p className="text-sm font-bold text-blue-600 truncate">{product.englishTitle || "No English Title"}</p>
                    </div>
                                    <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                                        <span className="font-mono">ID: {product.weidianId}</span>
                                        <span>|</span>
                                        <span>店铺: {product.shopName}</span>
                                        <span>|</span>
                                        <span>{product.images?.length || 0}张图片</span>
                      {((product.createdAt) || (product.created_at)) && (
                                            <>
                                                <span>|</span>
                                                <span>创建: {(() => {
                          try {
                            const date = new Date(product.createdAt || product.created_at);
                            return isNaN(date.getTime()) ? '未知时间' : date.toLocaleString('zh-CN');
                          } catch {
                            return '未知时间';
                          }
                        })()}</span>
                                            </>
                      )}
                    </div>
                  </div>
                </div>
                            {/* 链接显示区域 */}
                <div className="flex items-center gap-4">
                                <div className="flex flex-col gap-1 min-w-0 flex-1 max-w-md">
                                    {displayedLinks.map((link) => (
                      <div key={link.name} className="flex items-center gap-1.5">
                                            <Badge className={`text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white ${
                          link.badge_color === 'blue' ? 'bg-blue-600' :
                          link.badge_color === 'green' ? 'bg-green-600' :
                                                link.badge_color === 'orange' ? 'bg-orange-600' : 'bg-gray-600'
                                            }`}>{link.display_name}</Badge>
                        <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                                                <a href={link.url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">{link.url}</a>
                                                <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(link.url); toast.success("Copied")}}><Copy className="h-2.5 w-2.5"/></Button>
                        </div>
                      </div>
                    ))}
                                    {links.length > 3 && (
                                        <Button variant="ghost" size="sm" className="h-5 text-xs w-full" onClick={()=>toggleProductExpansion(product.id)}>
                                            {showAllLinks ? <ChevronUp className="h-3 w-3"/> : <ChevronDown className="h-3 w-3"/>}
                                            {showAllLinks ? "收起" : `显示更多 (${links.length - 3})`}
                      </Button>
                    )}
                  </div>
                                {/* 操作按钮组 */}
                                <div className="flex items-center gap-1">
                                    {/* 编辑按钮 */}
                                    <Dialog open={editingProduct?.id === product.id} onOpenChange={(open)=>!open && setEditingProduct(null)}>
                      <DialogTrigger asChild>
                                            <Button variant="outline" size="icon" className="h-8 w-8" onClick={()=>setEditingProduct(product)}>
                                                <Edit className="size-3.5"/>
                        </Button>
                      </DialogTrigger>
                                        <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
                        <DialogHeader>
                                                <DialogTitle>编辑商品与规则 - {product.weidianId}</DialogTitle>
                          <DialogDescription>配置商品信息和自动回复规则</DialogDescription>
                        </DialogHeader>

                                            <div className="space-y-6 py-4">
                          <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                              <Label>商品名称 (中文)</Label>
                              <Input value={editingProduct?.title || ""} onChange={(e) => setEditingProduct({...editingProduct, title: e.target.value})} />
                            </div>
                            <div className="space-y-2">
                              <Label>英文关键词</Label>
                              <Input value={editingProduct?.englishTitle || ""} onChange={(e) => setEditingProduct({...editingProduct, englishTitle: e.target.value})} />
                            </div>
                          </div>
                          <div className="flex items-center justify-between p-4 border rounded-lg bg-muted/30">
                            <div className="space-y-1">
                              <Label className="text-sm font-bold">启用自动回复规则</Label>
                                                        <p className="text-xs text-muted-foreground">当检测到关键词时自动发送链接</p>
                            </div>
                                                    <Switch checked={editingProduct?.ruleEnabled || false} onCheckedChange={(c) => setEditingProduct({...editingProduct, ruleEnabled: c})} />
                          </div>

                          {/* 自定义回复设置 - 当自动回复规则关闭时显示 */}
                          {!editingProduct?.ruleEnabled && (
                            <div className="space-y-4 p-4 border rounded-lg bg-blue-50/30">
                              <div className="space-y-2">
                                <Label className="text-sm font-medium">自定义回复消息</Label>
                                <Textarea
                                  value={editingProduct?.customReplyText || ""}
                                  onChange={(e) => setEditingProduct({...editingProduct, customReplyText: e.target.value})}
                                  placeholder="输入自定义回复消息内容..."
                                  rows={3}
                                />
                                <p className="text-xs text-muted-foreground">留空则不发送文本消息</p>
                              </div>

                              <div className="space-y-2">
                                <Label className="text-sm font-medium">选择回复图片来源</Label>
                                <div className="flex flex-wrap gap-4">
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'product'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'product'})}
                                    />
                                    <span className="text-sm">选择现有图片</span>
                                  </label>
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'upload'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'upload'})}
                                    />
                                    <span className="text-sm">本地上传新图片</span>
                                  </label>
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'custom'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'custom'})}
                                    />
                                    <span className="text-sm">使用图片链接</span>
                                  </label>
                                </div>
                              </div>

                              {editingProduct?.imageSource === 'product' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">选择现有图片 (多选)</Label>
                                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3 max-h-60 overflow-y-auto">
                                    {editingProduct?.images?.map((image: any, index: number) => (
                                      <div
                                        key={index}
                                        className={`relative border-2 rounded-lg overflow-hidden cursor-pointer transition-all ${
                                          editingProduct?.selectedImageIndexes?.includes(index)
                                            ? 'border-blue-500 bg-blue-50'
                                            : 'border-gray-200 hover:border-gray-300'
                                        }`}
                                        onClick={() => {
                                          const selectedIndexes = editingProduct?.selectedImageIndexes || [];
                                          const newIndexes = selectedIndexes.includes(index)
                                            ? selectedIndexes.filter((i: number) => i !== index)
                                            : [...selectedIndexes, index];
                                          setEditingProduct({...editingProduct, selectedImageIndexes: newIndexes});
                                        }}
                                      >
                                        <img
                                          src={`/api/products/${editingProduct.id}/images/${index}`}
                                          alt={`图片 ${index + 1}`}
                                          className="w-full h-20 object-cover"
                                        />
                                        {editingProduct?.selectedImageIndexes?.includes(index) && (
                                          <div className="absolute inset-0 bg-blue-500/20 flex items-center justify-center">
                                            <div className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold">
                                              ✓
                                            </div>
                                          </div>
                                        )}
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                          图片 {index + 1}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                  {(!editingProduct?.images || editingProduct.images.length === 0) && (
                                    <div className="text-center py-8 text-muted-foreground text-sm border-2 border-dashed border-gray-200 rounded-lg">
                                      此商品暂无图片
                                    </div>
                                  )}
                                  <p className="text-xs text-muted-foreground">
                                    已选择 {editingProduct?.selectedImageIndexes?.length || 0} 张图片用于回复
                                  </p>
                                </div>
                              ) : editingProduct?.imageSource === 'upload' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">本地上传图片</Label>
                                  <div className="space-y-3">
                                    <input
                                      type="file"
                                      multiple
                                      accept="image/*"
                                      onChange={(e) => {
                                        const files = Array.from(e.target.files || []);
                                        setEditingProduct({...editingProduct, uploadedImages: files});
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    />
                                    {editingProduct?.uploadedImages && editingProduct.uploadedImages.length > 0 && (
                                      <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                                        {editingProduct.uploadedImages.map((file: File, index: number) => (
                                          <div key={index} className="relative border rounded-lg overflow-hidden">
                                            <img
                                              src={URL.createObjectURL(file)}
                                              alt={`上传图片 ${index + 1}`}
                                              className="w-full h-20 object-cover"
                                            />
                                            <button
                                              type="button"
                                              onClick={() => {
                                                const newFiles = editingProduct.uploadedImages.filter((_: File, i: number) => i !== index);
                                                setEditingProduct({...editingProduct, uploadedImages: newFiles});
                                              }}
                                              className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs"
                                            >
                                              ×
                                            </button>
                                            <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                              {file.name}
                                            </div>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                  <p className="text-xs text-muted-foreground">
                                    选择图片文件上传到商品中，支持多选
                                  </p>
                                </div>
                              ) : editingProduct?.imageSource === 'custom' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">自定义图片链接</Label>
                                  <Input
                                    value={editingProduct?.customImageUrls?.join('\n') || ""}
                                    onChange={(e) => {
                                      const urls = e.target.value.split('\n').filter(url => url.trim());
                                      setEditingProduct({...editingProduct, customImageUrls: urls});
                                    }}
                                    placeholder="每行一个图片链接&#10;https://example.com/image1.jpg&#10;https://example.com/image2.jpg"
                                    className="min-h-20"
                                  />
                                  <p className="text-xs text-muted-foreground">
                                    每行一个图片链接，最多支持10个链接
                                  </p>
                                </div>
                              ) : (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">选择商品图片 (多选)</Label>
                                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3 max-h-60 overflow-y-auto">
                                    {editingProduct?.images?.map((image: any, index: number) => (
                                      <div
                                        key={index}
                                        className={`relative border-2 rounded-lg overflow-hidden cursor-pointer transition-all ${
                                          editingProduct?.selectedImageIndexes?.includes(index)
                                            ? 'border-blue-500 bg-blue-50'
                                            : 'border-gray-200 hover:border-gray-300'
                                        }`}
                                        onClick={() => {
                                          const selectedIndexes = editingProduct?.selectedImageIndexes || [];
                                          const newIndexes = selectedIndexes.includes(index)
                                            ? selectedIndexes.filter((i: number) => i !== index)
                                            : [...selectedIndexes, index];
                                          setEditingProduct({...editingProduct, selectedImageIndexes: newIndexes});
                                        }}
                                      >
                                        <img
                                          src={`/api/products/${editingProduct.id}/images/${index}`}
                                          alt={`图片 ${index + 1}`}
                                          className="w-full h-20 object-cover"
                                        />
                                        {editingProduct?.selectedImageIndexes?.includes(index) && (
                                          <div className="absolute inset-0 bg-blue-500/20 flex items-center justify-center">
                                            <div className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold">
                                              ✓
                                            </div>
                                          </div>
                                        )}
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                          图片 {index + 1}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                  {(!editingProduct?.images || editingProduct.images.length === 0) && (
                                    <div className="text-center py-8 text-muted-foreground text-sm border-2 border-dashed border-gray-200 rounded-lg">
                                      此商品暂无图片
                                    </div>
                                  )}
                                  <p className="text-xs text-muted-foreground">
                                    已选择 {editingProduct?.selectedImageIndexes?.length || 0} 张图片
                                  </p>
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                        <DialogFooter>
                                                <Button variant="outline" onClick={()=>setEditingProduct(null)}>取消</Button>
                                                <Button onClick={()=>handleUpdateProduct(editingProduct)}>保存修改</Button>
                        </DialogFooter>
                      </DialogContent>
                    </Dialog>

                                    {/* 删除按钮 */}
                                    <Button variant="outline" size="icon" className="h-8 w-8 hover:bg-red-50 hover:text-red-600" onClick={()=>handleDeleteProduct(product.id)}>
                                        <Trash2 className="size-3.5"/>
                    </Button>
                  </div>
                </div>
              </div>
                        )
                    })}
          </div>
          
                {/* 分页组件 */}
                {currentProducts.length > 0 && (
                    <div className="flex flex-col sm:flex-row justify-between items-center gap-4 p-6 border-t bg-muted/5">
              <div className="text-sm text-muted-foreground font-medium">
                            显示第 {(currentPage-1)*itemsPerPage + 1} - {Math.min(currentPage*itemsPerPage, currentProducts.length)} 条，共 {currentProducts.length} 条记录
                            <span className="ml-2">({currentPage}/{totalPages}页)</span>
              </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.max(1, p-1))}
                                disabled={currentPage===1}
                                className="h-8 px-3"
                  >
                                <ChevronLeft className="h-4 w-4 mr-1"/> 上一页
                  </Button>
                            <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                    {currentPage} / {totalPages}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.min(totalPages, p+1))}
                                disabled={currentPage===totalPages}
                                className="h-8 px-3"
                  >
                                下一页 <ChevronRight className="h-4 w-4 ml-1"/>
                  </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

        {/* 单个商品删除确认对话框 */}
        <Dialog open={showDeleteConfirm && deletingProductId !== null} onOpenChange={(open) => {
          if (!open) {
            setShowDeleteConfirm(false)
            setDeletingProductId(null)
          }
        }}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认删除商品</DialogTitle>
              <DialogDescription>
                确定要删除商品 {deletingProductId} 吗？此操作不可恢复。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => {
                setShowDeleteConfirm(false)
                setDeletingProductId(null)
              }}>
                取消
              </Button>
              <Button
                variant="destructive"
                onClick={confirmDeleteProduct}
              >
                确认删除
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

      {/* 批量删除确认对话框 */}
        <Dialog open={showDeleteConfirm && deletingProductId === null} onOpenChange={setShowDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
              <DialogTitle>确认批量删除</DialogTitle>
            <DialogDescription>
              确定要删除选中的 {selectedProducts.length} 个商品吗？此操作不可恢复。
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteConfirm(false)}>
              取消
            </Button>
              <Button
                variant="destructive"
                onClick={confirmBatchDelete}
                disabled={isDeleting}
              >
              {isDeleting ? "删除中..." : "确认删除"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      </div>
    </div>
  )
}
--- File: ./frontend/components/logs-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Pause, Play, Trash2, RefreshCw } from "lucide-react"

type LogEntry = {
  timestamp: string
  level: string
  message: string
  module?: string
  func?: string
  type?: string // 用于心跳包
}

export function LogsView() {
  const [logs, setLogs] = useState<LogEntry[]>([])
  const [isConnected, setIsConnected] = useState(false)
  const [isPaused, setIsPaused] = useState(false)
  const scrollRef = useRef<HTMLDivElement>(null)
  const eventSourceRef = useRef<EventSource | null>(null)

  // 加载历史日志
  const loadRecentLogs = async () => {
    try {
      const response = await fetch('/api/logs?endpoint=recent')
      if (response.ok) {
        const data = await response.json()
        setLogs(data.logs || [])
      }
    } catch (error) {
      console.error('加载历史日志失败:', error)
    }
  }

  // 连接到日志流
  const connectToLogStream = () => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
    }

    const eventSource = new EventSource('/api/logs/stream')
    eventSourceRef.current = eventSource

    eventSource.onopen = () => {
      console.log('日志流连接已建立')
      setIsConnected(true)
    }

    eventSource.onmessage = (event) => {
      try {
        const logEntry: LogEntry = JSON.parse(event.data)

        // 过滤心跳包
        if (logEntry.type === 'heartbeat') {
          return
        }

        setLogs((prev) => [...prev, logEntry].slice(-200)) // 保持最近200条日志
      } catch (error) {
        console.error('解析日志数据失败:', error, event.data)
      }
    }

    eventSource.onerror = (error) => {
      console.error('日志流连接错误:', error)
      setIsConnected(false)

      // 自动重连
      setTimeout(() => {
        if (!isPaused) {
          connectToLogStream()
        }
      }, 5000)
    }
  }

  useEffect(() => {
    // 加载历史日志
    loadRecentLogs()

    // 连接到日志流
    if (!isPaused) {
      connectToLogStream()
    }

    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
      }
    }
  }, [isPaused])

  useEffect(() => {
    if (scrollRef.current && !isPaused) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" })
    }
  }, [logs, isPaused])

  const handleTogglePause = () => {
    setIsPaused(!isPaused)
    if (!isPaused) {
      // 暂停时断开连接
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
        setIsConnected(false)
      }
    } else {
      // 恢复时重新连接
      connectToLogStream()
    }
  }

  const handleClearLogs = () => {
    setLogs([])
  }

  const handleRefresh = () => {
    loadRecentLogs()
  }

  const getLevelColor = (level: string) => {
    switch (level) {
      case "INFO":
        return "bg-blue-600 hover:bg-blue-700"
      case "WARNING":
        return "bg-yellow-600 hover:bg-yellow-700"
      case "ERROR":
        return "bg-red-600 hover:bg-red-700"
      case "CRITICAL":
        return "bg-red-800 hover:bg-red-900"
      default:
        return "bg-gray-600 hover:bg-gray-700"
    }
  }

  const formatTimestamp = (timestamp: string) => {
    try {
      const date = new Date(timestamp)
      return date.toLocaleTimeString("zh-CN", { hour12: false })
    } catch {
      return timestamp
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">实时日志</h2>
          <p className="text-muted-foreground">监控系统运行状态和事件流</p>
        </div>
        <div className="flex items-center gap-2">
          <div className="flex items-center gap-1 text-sm">
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
            <span className="text-muted-foreground">
              {isConnected ? '已连接' : '未连接'}
            </span>
          </div>
          <Button variant="outline" size="sm" onClick={handleTogglePause}>
            {isPaused ? <Play className="size-4" /> : <Pause className="size-4" />}
            {isPaused ? '恢复' : '暂停'}
          </Button>
          <Button variant="outline" size="sm" onClick={handleRefresh}>
            <RefreshCw className="size-4" />
            刷新
          </Button>
          <Button variant="outline" size="sm" onClick={handleClearLogs}>
            <Trash2 className="size-4" />
            清空
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>系统日志流</CardTitle>
          <CardDescription>
            共 {logs.length} 条记录 • {isPaused ? '已暂停' : '实时监控中'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ScrollArea className="h-[600px] w-full rounded-md border bg-black/90 p-4">
            <div className="space-y-3 font-mono text-[11px] leading-relaxed">
              {logs.map((log, index) => (
                <div
                  key={`${log.timestamp}-${index}`}
                  className="flex items-start gap-3 text-green-400 hover:bg-white/5 p-2 rounded transition-colors border-b border-white/5 last:border-0"
                >
                  <span className="text-gray-500 shrink-0 font-bold">
                    {formatTimestamp(log.timestamp)}
                  </span>
                  <Badge className={`${getLevelColor(log.level)} shrink-0 text-[9px] h-4 px-1`}>
                    {log.level}
                  </Badge>
                  <span className="text-cyan-400 shrink-0 font-semibold">
                    [{log.module || 'system'}]
                  </span>
                  <span className="text-gray-200 break-words">{log.message}</span>
                </div>
              ))}
              <div ref={scrollRef} />
            </div>
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}


--- File: ./frontend/components/similarity-test-view.tsx ---
"use client"

import type React from "react"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Upload, TestTube, AlertCircle, CheckCircle } from "lucide-react"
import { toast } from "sonner"
import { Alert, AlertDescription } from "@/components/ui/alert"

export function SimilarityTestView() {
  const [image1, setImage1] = useState<string | null>(null)
  const [image2, setImage2] = useState<string | null>(null)
  const [isTesting, setIsTesting] = useState(false)
  const [result, setResult] = useState<any>(null)

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>, imageNumber: 1 | 2) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("请上传图片文件")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      if (imageNumber === 1) {
        setImage1(event.target?.result as string)
      } else {
        setImage2(event.target?.result as string)
      }
      toast.success(`图片${imageNumber}已上传`)
    }
    reader.readAsDataURL(file)
  }

  const handleTest = async () => {
    if (!image1 || !image2) {
      toast.error("请上传两张图片")
      return
    }

    setIsTesting(true)
    setResult(null)

    try {
      // 将base64图片转换为blob
      const response1 = await fetch(image1)
      const blob1 = await response1.blob()

      const response2 = await fetch(image2)
      const blob2 = await response2.blob()

      // 创建FormData
      const formData = new FormData()
      formData.append('image1', blob1, 'image1.jpg')
      formData.append('image2', blob2, 'image2.jpg')

      // 发送到API进行相似度测试
      const testRes = await fetch('/api/test-similarity', {
        method: 'POST',
        body: formData
      })

      if (testRes.ok) {
        const data = await testRes.json()
        setResult(data)
        toast.success(`相似度测试完成: ${(data.similarity * 100).toFixed(2)}%`)
      } else {
        const errorText = await testRes.text()
        console.error('Test failed:', errorText)
        toast.error("测试失败: " + errorText)
      }
    } catch (error) {
      console.error('Test error:', error)
      toast.error("测试过程中发生错误")
    } finally {
      setIsTesting(false)
    }
  }

  const clearImages = () => {
    setImage1(null)
    setImage2(null)
    setResult(null)
  }

  return (
    <div className="space-y-6">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <h2 className="text-3xl font-bold tracking-tight">相似度测试</h2>
          <p className="text-muted-foreground">测试PP-ShiTuV2模型对两张图片的相似度计算</p>
        </div>
      </div>

      <div className="grid gap-6 lg:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>图片1</CardTitle>
            <CardDescription>选择第一张图片</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image1 ? (
              <label
                htmlFor="image1-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">点击上传第一张图片</p>
                <input id="image1-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 1)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image1}
                  alt="Image 1"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage1(null)}
                >
                  ×
                </Button>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>图片2</CardTitle>
            <CardDescription>选择第二张图片</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image2 ? (
              <label
                htmlFor="image2-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">点击上传第二张图片</p>
                <input id="image2-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 2)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image2}
                  alt="Image 2"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage2(null)}
                >
                  ×
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TestTube className="size-5" />
            测试控制
          </CardTitle>
          <CardDescription>执行相似度测试</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-3">
            <Button
              onClick={handleTest}
              disabled={!image1 || !image2 || isTesting}
              className="flex-1"
            >
              <TestTube className="mr-2 size-4" />
              {isTesting ? "测试中..." : "开始相似度测试"}
            </Button>
            <Button
              variant="outline"
              onClick={clearImages}
              disabled={isTesting}
            >
              清空图片
            </Button>
          </div>

          {isTesting && (
            <div className="space-y-2">
              <Progress value={50} className="h-2" />
              <p className="text-[10px] text-blue-500 animate-pulse font-medium">正在提取特征向量并计算相似度...</p>
            </div>
          )}
        </CardContent>
      </Card>

      {result && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              {result.similarity > 0.9 ? (
                <CheckCircle className="size-5 text-green-500" />
              ) : (
                <AlertCircle className="size-5 text-orange-500" />
              )}
              测试结果
            </CardTitle>
            <CardDescription>PP-ShiTuV2模型相似度分析</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">相似度分数</span>
                  <Badge
                    className={
                      result.similarity > 0.9
                        ? "bg-green-600 hover:bg-green-700"
                        : result.similarity > 0.7
                        ? "bg-blue-600 hover:bg-blue-700"
                        : "bg-orange-600 hover:bg-orange-700"
                    }
                  >
                    {(result.similarity * 100).toFixed(2)}%
                  </Badge>
                </div>
                <Progress value={result.similarity * 100} className="h-3" />
              </div>

              <div className="space-y-2">
                <div className="text-sm">
                  <span className="font-medium">模型名称:</span> {result.model}
                </div>
                <div className="text-sm">
                  <span className="font-medium">向量维度:</span> {result.vector_dimension}
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
              <div>
                <span className="font-medium">图片1特征范数:</span> {result.features1_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">图片2特征范数:</span> {result.features2_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">点积:</span> {result.dot_product?.toFixed(4)}
              </div>
            </div>

            {result.similarity < 0.95 && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  相似度低于95%，可能的原因：
                  1. 图片内容不同
                  2. 图片在处理过程中发生变化（压缩、尺寸调整等）
                  3. 模型特征提取的局限性
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  )
}

--- File: ./frontend/components/dashboard-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
      fetchAnnouncements()
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('统计数据:', data)
        setStats(data)
      } else {
        console.error('获取统计信息失败:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('获取统计信息失败:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('获取公告失败:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('公告添加成功')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('公告更新成功')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`确定要删除公告 "${announcement.title}" 吗？`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('公告删除成功')
        fetchAnnouncements()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">仪表盘</h2>
        <p className="text-muted-foreground mt-2">系统概览和公告管理</p>
      </div>

      {/* 统计信息 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 lg:gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">店铺数量</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已收录的店铺</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">商品数量</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已抓取的商品</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">图片数量</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已索引的图片</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">用户数量</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">活跃用户</p>
          </CardContent>
        </Card>
      </div>

      {/* 公告管理 - 所有用户可见，但只有管理员可修改 */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                系统公告
              </CardTitle>
              <CardDescription>查看最新系统通知和重要更新</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm" className="shrink-0">
                    <Plus className="w-4 h-4 mr-2" />
                    添加公告
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>添加系统公告</DialogTitle>
                    <DialogDescription>创建新的系统公告</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>公告标题</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="请输入公告标题"
                      />
                    </div>
                    <div>
                      <Label>公告内容</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="请输入公告内容"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>取消</Button>
                    <Button onClick={handleAddAnnouncement}>添加公告</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                暂无公告
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4 hover:bg-muted/30 transition-colors">
                  <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                    <div className="flex-1 min-w-0">
                      <h4 className="font-semibold text-base mb-2">{announcement.title}</h4>
                      <p className="text-sm text-muted-foreground mb-3 leading-relaxed">{announcement.content}</p>
                      <div className="text-xs text-muted-foreground">
                        更新时间: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2 shrink-0">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                          className="h-8 w-8 p-0"
                          title="编辑公告"
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                          className="h-8 w-8 p-0 hover:bg-red-50 hover:text-red-600 hover:border-red-200"
                          title="删除公告"
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* 编辑公告对话框 */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>编辑公告</DialogTitle>
              <DialogDescription>修改公告内容</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>公告标题</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>公告内容</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>取消</Button>
              <Button onClick={handleUpdateAnnouncement}>保存修改</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/settings-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { toast } from "sonner"
import { Settings, Save } from "lucide-react"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

interface UserSettings {
  discord_similarity_threshold: number
  global_reply_min_delay: number
  global_reply_max_delay: number
  user_blacklist: string
  keyword_filters: string
}

export function SettingsView() {
  const [settings, setSettings] = useState<UserSettings>({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
    user_blacklist: '',
    keyword_filters: '',
  })
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  })
  const [changingPassword, setChangingPassword] = useState(false)

  useEffect(() => {
    fetchSettings()
  }, [])

  const fetchSettings = async () => {
    try {
      // 获取用户个性化设置
      const response = await fetch('/api/user/settings')
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold ?? 0.6,
          global_reply_min_delay: data.global_reply_min_delay ?? 3.0,
          global_reply_max_delay: data.global_reply_max_delay ?? 8.0,
          user_blacklist: data.user_blacklist ?? '',
          keyword_filters: data.keyword_filters ?? '',
        })
      } else {
        toast.error("获取设置失败")
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
      toast.error("获取设置失败")
    } finally {
      setLoading(false)
    }
  }

  const handleSave = async () => {
    setSaving(true)
    try {
      // 验证回复延迟设置
      if (settings.global_reply_min_delay >= settings.global_reply_max_delay) {
        toast.error("最小延迟必须小于最大延迟")
        setSaving(false)
        return
      }

      if (settings.global_reply_min_delay < 0 || settings.global_reply_max_delay < 0) {
        toast.error("延迟时间不能为负数")
        setSaving(false)
        return
      }

      // 保存用户个性化设置
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("设置已保存")
      } else {
        toast.error("保存设置失败")
      }
    } catch (error) {
      toast.error("保存设置失败")
    } finally {
      setSaving(false)
    }
  }

  const handleChangePassword = async () => {
    if (!passwordData.currentPassword || !passwordData.newPassword || !passwordData.confirmPassword) {
      toast.error("请填写所有密码字段")
      return
    }

    if (passwordData.newPassword !== passwordData.confirmPassword) {
      toast.error("新密码和确认密码不一致")
      return
    }

    if (passwordData.newPassword.length < 6) {
      toast.error("新密码长度至少6位")
      return
    }

    setChangingPassword(true)
    try {
      const response = await fetch('/api/user/change-password', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          current_password: passwordData.currentPassword,
          new_password: passwordData.newPassword
        })
      })

      if (response.ok) {
        toast.success("密码修改成功")
        setPasswordData({
          currentPassword: '',
          newPassword: '',
          confirmPassword: ''
        })
      } else {
        const error = await response.json()
        toast.error(error.error || "密码修改失败")
      }
    } catch (error) {
      toast.error("密码修改失败")
    } finally {
      setChangingPassword(false)
    }
  }

  if (loading) {
    return (
      <div className="space-y-8">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">系统设置</h2>
          <p className="text-sm text-muted-foreground mt-1">正在加载设置...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">个人设置</h2>
          <p className="text-sm text-muted-foreground mt-1">配置您的个性化运行参数</p>
        </div>
        <Button onClick={handleSave} disabled={saving}>
          <Save className="w-4 h-4 mr-2" />
          {saving ? "保存中..." : "保存设置"}
        </Button>
      </div>

      {/* 密码修改 */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">修改密码</CardTitle>
          <CardDescription>修改您的账号密码</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="current-password">当前密码</Label>
            <Input
              id="current-password"
              type="password"
              value={passwordData.currentPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, currentPassword: e.target.value }))}
              placeholder="请输入当前密码"
            />
          </div>
          <div>
            <Label htmlFor="new-password">新密码</Label>
            <Input
              id="new-password"
              type="password"
              value={passwordData.newPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
              placeholder="请输入新密码"
            />
          </div>
          <div>
            <Label htmlFor="confirm-password">确认新密码</Label>
            <Input
              id="confirm-password"
              type="password"
              value={passwordData.confirmPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
              placeholder="请再次输入新密码"
            />
          </div>
          <Button
            onClick={handleChangePassword}
            disabled={changingPassword}
            className="w-full"
          >
            {changingPassword ? "修改中..." : "修改密码"}
          </Button>
        </CardContent>
      </Card>

      {/* 系统参数设置 */}
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="text-lg">系统参数</CardTitle>
          <CardDescription>配置图片匹配和回复延迟参数</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* 相似度和延迟设置 - 紧凑布局 */}
          <div className="flex flex-col sm:flex-row gap-6">
            {/* 相似度设置 */}
            <div className="flex-1 space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="similarity-threshold" className="text-sm font-medium">相似度阈值</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="similarity-threshold"
                  type="number"
                  step="0.1"
                  min="0.1"
                  max="1.0"
                  value={settings.discord_similarity_threshold}
                  onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  阈值越低匹配越宽松，建议范围 0.3-0.8
                </p>
              </div>
            </div>

            {/* 回复延迟设置 */}
            <div className="flex-1 space-y-2">
              <Label className="text-sm font-medium">回复延迟</Label>
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <div className="flex items-center gap-1">
                    <Input
                      id="min-delay"
                      type="number"
                      step="0.1"
                      min="0.1"
                      max="30"
                      value={settings.global_reply_min_delay}
                      onChange={(e) => setSettings(prev => ({ ...prev, global_reply_min_delay: parseFloat(e.target.value) }))}
                      className="w-16 h-9 text-center"
                    />
                    <span className="text-sm text-muted-foreground">-</span>
                    <Input
                      id="max-delay"
                      type="number"
                      step="0.5"
                      min="1"
                      max="60"
                      value={settings.global_reply_max_delay}
                      onChange={(e) => setSettings(prev => ({ ...prev, global_reply_max_delay: parseFloat(e.target.value) }))}
                      className="w-16 h-9 text-center"
                    />
                  </div>
                  <span className="text-xs text-muted-foreground">秒</span>
                </div>
                <p className="text-xs text-muted-foreground">
                  每次回复随机延迟 {settings.global_reply_min_delay}-{settings.global_reply_max_delay} 秒
                </p>
              </div>
            </div>
          </div>

          {/* 用户黑名单设置 */}
          <div className="space-y-2">
            <Label htmlFor="user-blacklist" className="text-sm font-medium">用户黑名单</Label>
            <div className="space-y-1">
              <Input
                id="user-blacklist"
                type="text"
                value={settings.user_blacklist}
                onChange={(e) => setSettings(prev => ({ ...prev, user_blacklist: e.target.value }))}
                placeholder="输入不回复的用户ID，多个用逗号分隔"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                不会回复这些用户发送的消息，格式：user123,user456,user789
              </p>
            </div>
          </div>

          {/* 关键词过滤设置 */}
          <div className="space-y-2">
            <Label htmlFor="keyword-filters" className="text-sm font-medium">关键词过滤</Label>
            <div className="space-y-1">
              <Input
                id="keyword-filters"
                type="text"
                value={settings.keyword_filters}
                onChange={(e) => setSettings(prev => ({ ...prev, keyword_filters: e.target.value }))}
                placeholder="输入不回复的关键词，多个用逗号分隔"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                消息包含这些关键词时不会回复，格式：广告,刷屏,测试,垃圾
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

        {/* 系统信息 */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">系统信息</CardTitle>
            <CardDescription>当前系统状态</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-muted-foreground">状态:</span>
                <span className="text-green-600">运行正常</span>
              </div>
              <div className="flex justify-between">
                <span className="text-muted-foreground">版本:</span>
                <span>v1.0.0</span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

--- File: ./frontend/components/app-sidebar.tsx ---
"use client"

import { LayoutDashboard, Users, Search, ImageIcon, ListTree, ScrollText, Bot, Settings, TestTube, Store, Shield, Cog, BarChart3 } from "lucide-react"
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuItem,
  SidebarMenuButton,
  SidebarHeader,
  SidebarFooter,
} from "@/components/ui/sidebar"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

const baseMenuItems = [
  { id: "dashboard", icon: BarChart3, label: "仪表盘" },
  { id: "accounts", icon: Users, label: "账号与规则" },
  { id: "scraper", icon: Search, label: "微店抓取" },
  { id: "image-search", icon: ImageIcon, label: "以图搜图" },
  { id: "shops", icon: Store, label: "店铺管理" },
]

// 只有管理员才能访问的功能
const adminOnlyMenuItems = [
  { id: "users", icon: Shield, label: "用户管理" },
  { id: "logs", icon: ScrollText, label: "实时日志" },
]

export function AppSidebar({
  currentView,
  setCurrentView,
  currentUser,
}: {
  currentView: string
  setCurrentView: (view: string) => void
  currentUser: User | null
}) {
  return (
    <Sidebar>
      <SidebarHeader className="border-b p-4">
        <div className="flex items-center gap-2">
          <Bot className="size-6 text-primary" />
          <div>
            <h2 className="text-lg font-bold">Discord 营销</h2>
            <p className="text-xs text-muted-foreground">智能自动回复系统</p>
          </div>
        </div>
      </SidebarHeader>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>主要功能</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {baseMenuItems
                .filter(item => item.id !== 'shops' || currentUser?.role === 'admin' || (currentUser?.shops && currentUser.shops.length > 0))
                .map((item) => (
                <SidebarMenuItem key={item.id}>
                  <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                    <item.icon />
                    <span>{item.label}</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>


        {currentUser?.role === 'admin' && (
          <SidebarGroup>
            <SidebarGroupLabel>管理员功能</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {adminOnlyMenuItems.map((item) => (
                  <SidebarMenuItem key={item.id}>
                    <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                      <item.icon />
                      <span>{item.label}</span>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        )}
      </SidebarContent>
      <SidebarFooter className="border-t p-4">
        <p className="text-xs text-muted-foreground text-center">v1.0.0 • 技术支持</p>
        <p className="text-xs text-muted-foreground text-center mt-1">微信: OceanSeaWang</p>
        <p className="text-xs text-muted-foreground text-center mt-1">Discord: zrnown</p>
      </SidebarFooter>
    </Sidebar>
  )
}

--- File: ./frontend/components/dashboard-view-new.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
    if (currentUser?.role === 'admin') {
      fetchAnnouncements()
    }
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('统计数据:', data)
        setStats(data)
      } else {
        console.error('获取统计信息失败:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('获取统计信息失败:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements')
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('获取公告失败:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('公告添加成功')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('公告更新成功')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`确定要删除公告 "${announcement.title}" 吗？`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('公告删除成功')
        fetchAnnouncements()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">仪表盘</h2>
        <p className="text-muted-foreground mt-2">系统概览和公告管理</p>
      </div>

      {/* 统计信息 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">店铺数量</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已收录的店铺</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">商品数量</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已抓取的商品</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">图片数量</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已索引的图片</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">用户数量</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">活跃用户</p>
          </CardContent>
        </Card>
      </div>

      {/* 公告管理 - 所有用户可见，但只有管理员可修改 */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                系统公告
              </CardTitle>
              <CardDescription>查看最新系统通知</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm">
                    <Plus className="w-4 h-4 mr-2" />
                    添加公告
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>添加系统公告</DialogTitle>
                    <DialogDescription>创建新的系统公告</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>公告标题</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="请输入公告标题"
                      />
                    </div>
                    <div>
                      <Label>公告内容</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="请输入公告内容"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>取消</Button>
                    <Button onClick={handleAddAnnouncement}>添加公告</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                暂无公告
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4">
                  <div className="flex justify-between items-start mb-2">
                    <h4 className="font-semibold">{announcement.title}</h4>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground mb-2">{announcement.content}</p>
                  <div className="text-xs text-muted-foreground">
                    更新时间: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* 编辑公告对话框 */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>编辑公告</DialogTitle>
              <DialogDescription>修改公告内容</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>公告标题</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>公告内容</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>取消</Button>
              <Button onClick={handleUpdateAnnouncement}>保存修改</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/login-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Bot, LogIn, User, Shield } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export function LoginView({ onLogin }: { onLogin: (user: User) => void }) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [loading, setLoading] = useState(false)

  const handleLogin = async () => {
    if (!username || !password) {
      toast.error("请输入用户名和密码")
      return
    }

    setLoading(true)
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success("登录成功")
        onLogin(data.user)
      } else {
        const error = await response.json()
        toast.error(error.error || "登录失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    } finally {
      setLoading(false)
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleLogin()
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <Card className="w-full max-w-md shadow-2xl">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <div className="p-3 bg-primary rounded-full">
              <Bot className="h-8 w-8 text-primary-foreground" />
            </div>
          </div>
          <CardTitle className="text-2xl font-bold">Discord 营销系统</CardTitle>
          <CardDescription>智能 Discord 账号营销管理平台</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username" className="text-sm font-medium">
                用户名
              </Label>
              <div className="relative">
                <User className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="username"
                  type="text"
                  placeholder="请输入用户名"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="password" className="text-sm font-medium">
                密码
              </Label>
              <div className="relative">
                <Shield className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="password"
                  type="password"
                  placeholder="请输入密码"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
          </div>

          <Button
            onClick={handleLogin}
            disabled={loading}
            className="w-full h-11 text-base font-semibold"
          >
            {loading ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                登录中...
              </>
            ) : (
              <>
                <LogIn className="mr-2 h-5 w-5" />
                登录
              </>
            )}
          </Button>

        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/rules-view.tsx ---
"use client"

import { useState, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Trash2, Edit, Image as ImageIcon, Search, Upload, X } from "lucide-react"
import { toast } from "sonner"
import { Checkbox } from "@/components/ui/checkbox"

const mockRules: any[] = []

const availableAccounts = ["Sisyphus_Bot_01", "Marketing_Manager", "Auto_Responder_X", "Discord_Helper_04"]

export function RulesView() {
  const [rules, setRules] = useState(mockRules)
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingRule, setEditingRule] = useState<any>(null)
  const [ruleSearch, setRuleSearch] = useState("")
  const [selectedAccountMode, setSelectedAccountMode] = useState("random")
  const [selectedSpecificAccounts, setSelectedSpecificAccounts] = useState<string[]>([])
  const [matchType, setMatchType] = useState("keyword")
  
  const [replyImage, setReplyImage] = useState<string | null>(null)
  const [triggerImage, setTriggerImage] = useState<string | null>(null)
  
  const replyImageInputRef = useRef<HTMLInputElement>(null)
  const triggerImageInputRef = useRef<HTMLInputElement>(null)

  const handleDeleteRule = (id: number) => {
    setRules((prev) => prev.filter((rule) => rule.id !== id))
    toast.success("规则已删除")
  }

  const handleEditRule = (rule: any) => {
    setEditingRule(rule)
    setSelectedAccountMode(rule.accountMode)
    setMatchType(rule.matchType)
    setSelectedSpecificAccounts(rule.assignedAccounts.includes("all") ? [] : rule.assignedAccounts)
    setReplyImage(rule.replyImage || null)
    setTriggerImage(rule.triggerImage || null)
    setIsDialogOpen(true)
  }

  const filteredRules = rules.filter((r: any) =>
    r.keywords.some((k: string) => k.toLowerCase().includes(ruleSearch.toLowerCase())) ||
    r.replyText.toLowerCase().includes(ruleSearch.toLowerCase())
  )

  const toggleAccountSelection = (acc: string) => {
    setSelectedSpecificAccounts(prev => 
      prev.includes(acc) ? prev.filter(a => a !== acc) : [...prev, acc]
    )
  }

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>, type: 'reply' | 'trigger') => {
    const file = e.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        if (type === 'reply') setReplyImage(reader.result as string)
        else setTriggerImage(reader.result as string)
        toast.success("图片已就绪")
      }
      reader.readAsDataURL(file)
    }
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">规则配置</h2>
          <p className="text-sm text-muted-foreground">配置自动回复触发规则、响应内容以及发送账号模式</p>
        </div>
        <div className="flex items-center gap-4">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="搜索规则关键词..."
              className="pl-9 w-[250px] h-10"
              value={ruleSearch}
              onChange={(e) => setRuleSearch(e.target.value)}
            />
          </div>
          <Dialog open={isDialogOpen} onOpenChange={(open) => {
            setIsDialogOpen(open)
            if (!open) {
              setEditingRule(null)
              setSelectedSpecificAccounts([])
              setReplyImage(null)
              setTriggerImage(null)
              setMatchType("keyword")
            }
          }}>
            <DialogTrigger asChild>
              <Button className="h-10 px-6 font-bold">
                <Plus className="mr-2 h-5 w-5" />
                添加新规则
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle className="text-2xl">{editingRule ? "编辑规则" : "创建新规则"}</DialogTitle>
                <DialogDescription>设置触发条件、回复内容及账号分配策略</DialogDescription>
              </DialogHeader>
              <div className="space-y-6 py-6">
                <div className="grid grid-cols-2 gap-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">匹配模式</Label>
                    <Select value={matchType} onValueChange={setMatchType}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="keyword">关键词匹配 (Partial)</SelectItem>
                        <SelectItem value="exact">精确匹配 (Exact)</SelectItem>
                        <SelectItem value="regex">正则表达式 (Regex)</SelectItem>
                        <SelectItem value="image">图片识别 (识别特定照片)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">回复附件 (图片)</Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={replyImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'reply')}
                    />
                    <div className="flex items-center gap-2">
                      {replyImage ? (
                        <div className="relative size-10 border rounded overflow-hidden group">
                          <img src={replyImage} className="object-cover w-full h-full" alt="Reply" />
                          <button 
                            onClick={() => setReplyImage(null)}
                            className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity"
                          >
                            <X className="size-4 text-white" />
                          </button>
                        </div>
                      ) : (
                        <Button 
                          variant="outline" 
                          className="w-full h-10 border-dashed justify-start text-muted-foreground"
                          onClick={() => replyImageInputRef.current?.click()}
                        >
                          <Upload className="mr-2 h-4 w-4" />
                          上传回复图片
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {matchType === 'image' ? (
                  <div className="space-y-2 bg-primary/5 p-4 rounded-lg border-2 border-dashed border-primary/20">
                    <Label className="font-bold text-sm text-primary flex items-center gap-2">
                      <ImageIcon className="size-4" /> 识别目标 (触发照片)
                    </Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={triggerImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'trigger')}
                    />
                    <p className="text-[11px] text-muted-foreground mb-3">当用户在 Discord 发送与此照片高度相似的图片时，将触发回复。</p>
                    {triggerImage ? (
                      <div className="relative w-full aspect-video border rounded-xl overflow-hidden group max-h-[200px]">
                        <img src={triggerImage} className="object-contain w-full h-full bg-black/10" alt="Trigger" />
                        <button 
                          onClick={() => setTriggerImage(null)}
                          className="absolute top-2 right-2 p-1 bg-red-500 rounded-full text-white shadow-lg"
                        >
                          <X className="size-4" />
                        </button>
                      </div>
                    ) : (
                      <Button 
                        variant="secondary" 
                        className="w-full h-24 flex-col gap-2"
                        onClick={() => triggerImageInputRef.current?.click()}
                      >
                        <Upload className="size-6" />
                        <span>点击上传识别模板图</span>
                      </Button>
                    )}
                  </div>
                ) : (
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">触发条件 (关键词)</Label>
                    <Input 
                      id="keywords" 
                      defaultValue={editingRule ? editingRule.keywords.join(", ") : ""} 
                      placeholder="多个关键词用逗号分隔..." 
                      className="h-10" 
                    />
                  </div>
                )}

                <div className="space-y-2">
                  <Label className="font-bold text-sm">回复文字内容</Label>
                  <Textarea 
                    id="reply-text" 
                    defaultValue={editingRule ? editingRule.replyText : ""} 
                    placeholder="输入自动回复的文字（如果为空则只发图片）..." 
                    rows={4} 
                    className="text-base" 
                  />
                </div>

                <div className="grid grid-cols-2 gap-6 border-t pt-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">账号分配模式</Label>
                    <Select value={selectedAccountMode} onValueChange={setSelectedAccountMode}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="random">随机使用 (Random)</SelectItem>
                        <SelectItem value="rotation">顺序轮换 (Rotation)</SelectItem>
                        <SelectItem value="fixed">手动指定 (Specific)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">选择执行账号</Label>
                    <div className="border rounded-md p-3 space-y-2 bg-muted/20 max-h-[150px] overflow-y-auto">
                      {availableAccounts.map(acc => (
                        <div key={acc} className="flex items-center space-x-2">
                          <Checkbox 
                            id={`acc-${acc}`} 
                            checked={selectedSpecificAccounts.includes(acc)}
                            onCheckedChange={() => toggleAccountSelection(acc)}
                          />
                          <label htmlFor={`acc-${acc}`} className="text-xs font-medium cursor-pointer">{acc}</label>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
              <DialogFooter className="border-t pt-6">
                <Button variant="outline" onClick={() => setIsDialogOpen(false)} className="h-10">
                  取消
                </Button>
                <Button
                  className="h-10 px-8 font-bold"
                  onClick={() => {
                    setIsDialogOpen(false)
                    toast.success("规则保存成功")
                  }}
                >
                  {editingRule ? "保存修改" : "确认添加规则"}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>
      </div>

      <Card className="shadow-sm">
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold pl-6">触发规则</TableHead>
                <TableHead className="text-sm font-bold">模式</TableHead>
                <TableHead className="text-sm font-bold">账号模式</TableHead>
                <TableHead className="text-sm font-bold">回复内容</TableHead>
                <TableHead className="text-sm font-bold">延迟</TableHead>
                <TableHead className="text-sm font-bold text-right pr-6">操作</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredRules.map((rule) => (
                <TableRow key={rule.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="pl-6">
                    {rule.matchType === 'image' ? (
                      <div className="flex items-center gap-2">
                        <div className="size-8 rounded border bg-muted overflow-hidden">
                          {rule.triggerImage ? <img src={rule.triggerImage} className="object-cover w-full h-full" alt="Trigger" /> : <ImageIcon className="size-4 m-2 text-muted-foreground" />}
                        </div>
                        <Badge variant="outline" className="text-[10px] bg-blue-50 text-blue-700">图片匹配</Badge>
                      </div>
                    ) : (
                      <div className="flex flex-wrap gap-1.5">
                        {rule.keywords.map((keyword: string, i: number) => (
                          <Badge key={i} variant="secondary" className="text-[11px] font-medium h-5 bg-orange-50 text-orange-700 border-orange-200">
                            {keyword}
                          </Badge>
                        ))}
                      </div>
                    )}
                  </TableCell>
                  <TableCell>
                    <Badge variant="outline" className="text-[11px] font-medium h-5 border-primary/20 text-primary">
                      {rule.matchType === "keyword" && "关键词"}
                      {rule.matchType === "exact" && "精确匹配"}
                      {rule.matchType === "regex" && "正则"}
                      {rule.matchType === "image" && "图片识别"}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge className={`${rule.accountMode === 'rotation' ? "bg-purple-600" : "bg-blue-600"} text-[11px] h-5`}>
                      {rule.accountMode === "random" ? "随机使用" : rule.accountMode === "rotation" ? "自动轮换" : "固定账号"}
                    </Badge>
                  </TableCell>
                  <TableCell className="max-w-[200px]">
                    <div className="flex flex-col gap-1">
                      <span className="text-[11px] truncate font-medium">{rule.replyText || "(仅回复图片)"}</span>
                      {rule.replyImage && <span className="text-[9px] text-blue-500 flex items-center font-bold"><ImageIcon className="size-3 mr-1" /> [附带图片回复]</span>}
                    </div>
                  </TableCell>
                  <TableCell className="text-xs font-mono font-bold">{rule.min_delay}-{rule.max_delay}s</TableCell>
                  <TableCell className="text-right pr-6">
                    <div className="flex items-center justify-end gap-2">
                      <Button variant="ghost" size="icon" className="h-9 w-9" onClick={() => handleEditRule(rule)}>
                        <Edit className="size-4" />
                      </Button>
                      <Button variant="ghost" size="icon" className="h-9 w-9 hover:bg-red-50 hover:text-red-600" onClick={() => handleDeleteRule(rule.id)}>
                        <Trash2 className="size-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
              {filteredRules.length === 0 && (
                <TableRow>
                  <TableCell colSpan={6} className="h-24 text-center text-muted-foreground italic">未找到符合搜索条件的规则</TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/shops-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Plus, Trash2, Store, Loader2, RefreshCw, Search, CheckSquare, Square } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

export function ShopsView({ currentUser }: { currentUser: any }) {

  const [shops, setShops] = useState<any[]>([])
  const [newShopId, setNewShopId] = useState('')
  const [isAddingShop, setIsAddingShop] = useState(false)
  const [selectedShopIds, setSelectedShopIds] = useState<string[]>([])
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [searchKeyword, setSearchKeyword] = useState('')
  const [isBatchDeleting, setIsBatchDeleting] = useState(false)
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false)

  useEffect(() => {
    fetchShops()
  }, [])

  const fetchShops = async () => {
    try {
      const res = await fetch('/api/shops')
      const data = await res.json()
      let allShops = data.shops || []

      // 根据用户权限过滤店铺
      if (currentUser?.role !== 'admin' && currentUser?.shops) {
        // 普通用户只看到分配给他们的店铺
        allShops = allShops.filter((shop: any) => currentUser.shops.includes(shop.shop_id))
      }

      setShops(allShops)
    } catch (e) {
      toast.error("加载店铺列表失败")
    }
  }

  const fetchShopInfo = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shop-info?shopId=${shopId}`)
      const data = await res.json()
      return data.shopName || `店铺 ${shopId}`
    } catch (e) {
      console.error("获取店铺信息失败:", e)
      return `店铺 ${shopId}`
    }
  }

  const handleAddShop = async () => {
    if (!newShopId.trim()) {
      toast.error("请输入店铺ID")
      return
    }

    if (!/^\d+$/.test(newShopId.trim())) {
      toast.error("店铺ID必须是数字")
      return
    }

    setIsAddingShop(true)
    try {
      // 先获取店铺名称
      const shopName = await fetchShopInfo(newShopId.trim())

      const res = await fetch('/api/shops', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopId: newShopId.trim(),
          name: shopName
        })
      })

      const data = await res.json()

      if (res.ok) {
        toast.success("店铺添加成功")
        setNewShopId('')
        fetchShops()
      } else {
        toast.error(data.error || "添加店铺失败")
      }
    } catch (e) {
      toast.error("添加店铺失败")
    } finally {
      setIsAddingShop(false)
    }
  }

  const handleDeleteShop = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shops/${shopId}`, {
        method: 'DELETE'
      })

      if (res.ok) {
        toast.success("店铺删除成功")
        fetchShops()
        // 移除选中状态
        setSelectedShopIds(prev => prev.filter(id => id !== shopId))
      } else {
        toast.error("删除店铺失败")
      }
    } catch (e) {
      toast.error("删除店铺失败")
    }
  }


  const handleSelectShop = (shopId: string) => {
    setSelectedShopIds(prev =>
      prev.includes(shopId)
        ? prev.filter(id => id !== shopId)
        : [...prev, shopId]
    )
  }

  const handleSelectAllShops = () => {
    if (selectedShopIds.length === filteredShops.length) {
      setSelectedShopIds([])
    } else {
      setSelectedShopIds(filteredShops.map(shop => shop.shop_id))
    }
  }

  const handleBatchDeleteShops = () => {
    if (selectedShopIds.length === 0) return
    setShowBatchDeleteConfirm(true)
  }

  const confirmBatchDeleteShops = async () => {
    setShowBatchDeleteConfirm(false)
    setIsBatchDeleting(true)

    let successCount = 0
    let failCount = 0

    try {
      for (const shopId of selectedShopIds) {
        try {
          const res = await fetch(`/api/shops/${shopId}`, {
            method: 'DELETE'
          })

          if (res.ok) {
            successCount++
          } else {
            failCount++
          }
        } catch (e) {
          failCount++
        }
      }

      if (successCount > 0) {
        toast.success(`批量删除完成：成功 ${successCount} 个${failCount > 0 ? `，失败 ${failCount} 个` : ''}`)
        setSelectedShopIds([])
        fetchShops()
      } else {
        toast.error("批量删除失败")
      }
    } catch (e) {
      toast.error("批量删除过程中发生错误")
    } finally {
      setIsBatchDeleting(false)
    }
  }

  // 过滤店铺列表
  const filteredShops = shops.filter(shop =>
    shop.name?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    shop.shop_id?.includes(searchKeyword)
  )

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">店铺管理</h2>
        <p className="text-muted-foreground">管理微店店铺，添加新店铺并进行全量抓取</p>
        <div className="flex items-center gap-2 mt-2">
          <span className="text-sm text-muted-foreground">当前用户:</span>
          <span className="font-medium">{currentUser?.username}</span>
          <span className={`text-xs px-2 py-1 rounded ${
            currentUser?.role === 'admin'
              ? 'bg-blue-100 text-blue-700'
              : 'bg-gray-100 text-gray-700'
          }`}>
            {currentUser?.role === 'admin' ? '管理员' : '普通用户'}
          </span>
        </div>
      </div>

      {/* 添加新店铺 - 仅管理员可见 */}
      {currentUser?.role === 'admin' && (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Plus className="h-5 w-5" />
            添加新店铺
          </CardTitle>
          <CardDescription>
            输入微店店铺ID，系统会自动获取店铺名称
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex gap-3">
            <div className="flex-1">
              <Input
                placeholder="输入店铺ID (例如: 1713062461)"
                value={newShopId}
                onChange={(e) => setNewShopId(e.target.value)}
                disabled={isAddingShop}
                onKeyPress={(e) => e.key === 'Enter' && handleAddShop()}
              />
            </div>
            <Button
              onClick={handleAddShop}
              disabled={!newShopId.trim() || isAddingShop}
            >
              {isAddingShop ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  添加中...
                </>
              ) : (
                <>
                  <Plus className="mr-2 h-4 w-4" />
                  添加店铺
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
      )}


      {/* 店铺列表 */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <Store className="h-5 w-5" />
                店铺列表 ({shops.length})
              </CardTitle>
              <CardDescription>
                已添加的店铺，支持批量全量抓取和删除
              </CardDescription>
            </div>
            {selectedShopIds.length > 0 && currentUser?.role === 'admin' && (
              <Button
                variant="destructive"
                size="sm"
                onClick={handleBatchDeleteShops}
                disabled={isBatchDeleting}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                删除选中 ({selectedShopIds.length})
              </Button>
            )}
          </div>
        </CardHeader>

        {/* 搜索和操作工具栏 */}
        {shops.length > 0 && (
          <div className="px-6 pb-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="搜索店铺名称或ID..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                    disabled={isShopScraping}
                  />
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Button
                  variant={selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "secondary" : "outline"}
                  size="sm"
                  onClick={handleSelectAllShops}
                  disabled={isShopScraping || filteredShops.length === 0}
                >
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length
                    ? <CheckSquare className="mr-2 h-4 w-4" />
                    : <Square className="mr-2 h-4 w-4" />
                  }
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "取消全选" : "全选"}
                </Button>
              </div>
            </div>

            {/* 搜索结果状态 */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                搜索结果: <span className="font-medium">{filteredShops.length}</span> 个店铺
                <span className="ml-2">关键词: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}

            {/* 选中状态 */}
            {selectedShopIds.length > 0 && (
              <div className="mt-2 text-sm text-blue-700 bg-blue-50 px-3 py-2 rounded-md border border-blue-200">
                已选择 <span className="font-medium">{selectedShopIds.length}</span> 个店铺
              </div>
            )}
          </div>
        )}
        <CardContent>
          {shops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Store className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">暂无店铺</p>
              <p className="text-sm">请先添加店铺ID</p>
            </div>
          ) : filteredShops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">未找到匹配的店铺</p>
              <p className="text-sm">尝试调整搜索关键词</p>
            </div>
          ) : (
            <div className="space-y-3">
              {filteredShops.map((shop) => (
                <div
                  key={shop.shop_id}
                  className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50 transition-colors"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <input
                      type="checkbox"
                      checked={selectedShopIds.includes(shop.shop_id)}
                      onChange={() => handleSelectShop(shop.shop_id)}
                      disabled={isShopScraping}
                      className="rounded border-gray-300"
                    />
                    <div className="flex-1">
                      <div className="font-medium">{shop.name}</div>
                      <div className="text-sm text-muted-foreground">
                        ID: {shop.shop_id}{shop.product_count > 0 ? ` • 商品数: ${shop.product_count}` : ''}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        添加时间: {(() => {
                          try {
                            const date = new Date(shop.created_at);
                            return isNaN(date.getTime()) ? '未知时间' : date.toLocaleString('zh-CN');
                          } catch {
                            return '未知时间';
                          }
                        })()}
                      </div>
                    </div>
                  </div>
                  {(currentUser?.role === 'admin' || currentUser?.shops?.includes(shop.shop_id)) && (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => handleDeleteShop(shop.shop_id)}
                    disabled={isShopScraping}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                  )}
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* 批量删除确认对话框 */}
      <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>确认批量删除</DialogTitle>
            <DialogDescription>
              确定要删除选中的 {selectedShopIds.length} 个店铺吗？此操作不可恢复。
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
              取消
              </Button>
            <Button variant="destructive" onClick={confirmBatchDeleteShops} disabled={isBatchDeleting}>
              {isBatchDeleting ? "删除中..." : "确认删除"}
              </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
--- File: ./frontend/components/users-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Shield, User, Users, Edit, Trash2, Save, Search } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
  is_active: boolean
  created_at: string
}

export function UsersView() {
  const [users, setUsers] = useState<User[]>([])
  const [shops, setShops] = useState<any[]>([])
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingUser, setEditingUser] = useState<User | null>(null)
  const [newUser, setNewUser] = useState({
    username: "",
    password: "",
    role: "user",
    shops: [] as string[]
  })
  const [loading, setLoading] = useState(true)

  const [resetPasswordUser, setResetPasswordUser] = useState<User | null>(null)
  const [newPassword, setNewPassword] = useState("")
  const [deleteUserConfirm, setDeleteUserConfirm] = useState<User | null>(null)

  // Pagination State
  const [page, setPage] = useState(1)
  const itemsPerPage = 10
  const [searchKeyword, setSearchKeyword] = useState('')

  // 过滤用户列表
  const filteredUsers = users.filter(user =>
    user.username?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    user.role?.toLowerCase().includes(searchKeyword.toLowerCase())
  )

  // 计算分页数据
  const paginatedUsers = filteredUsers.slice((page-1)*itemsPerPage, page*itemsPerPage)
  const totalPages = Math.ceil(filteredUsers.length / itemsPerPage)

  useEffect(() => {
    fetchUsers()
    fetchShops()
  }, [])

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users')
      if (response.ok) {
        const data = await response.json()
        setUsers(data.users || [])
      }
    } catch (error) {
      console.error('Failed to fetch users:', error)
    } finally {
      setLoading(false)
    }
  }

  const fetchShops = async () => {
    try {
      const response = await fetch('/api/shops')
      if (response.ok) {
        const data = await response.json()
        setShops(data.shops || [])
      }
    } catch (error) {
      console.error('Failed to fetch shops:', error)
    }
  }

  const handleCreateUser = async () => {
    if (!newUser.username || !newUser.password) {
      toast.error("请输入用户名和密码")
      return
    }

    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      })

      if (response.ok) {
        const data = await response.json()
        setUsers([...users, data.user])
        toast.success("用户创建成功")
        setIsDialogOpen(false)
        setNewUser({ username: "", password: "", role: "user", shops: [] })
      } else {
        const error = await response.json()
        toast.error(error.error || "创建用户失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleDeleteUser = (user: User) => {
    setDeleteUserConfirm(user)
  }

  const confirmDeleteUser = async () => {
    if (!deleteUserConfirm) return

    try {
      const response = await fetch(`/api/users/${deleteUserConfirm.id}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        setUsers(users.filter(u => u.id !== deleteUserConfirm.id))
        toast.success("用户删除成功")
        setDeleteUserConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "删除用户失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleResetPassword = async () => {
      if (!resetPasswordUser || !newPassword) return
      try {
          const res = await fetch(`/api/users/${resetPasswordUser.id}/password`, {
              method: 'PUT',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ password: newPassword })
          })
          if (res.ok) {
              toast.success("密码修改成功")
              setResetPasswordUser(null)
              setNewPassword("")
          } else {
              toast.error("修改失败")
          }
      } catch(e) { toast.error("网络错误") }
  }

  const handleUpdateUserShops = async (userId: number, shopIds: string[]) => {
    try {
      const response = await fetch(`/api/users/${userId}/shops`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shops: shopIds })
      })

      if (response.ok) {
        setUsers(users.map(u => u.id === userId ? { ...u, shops: shopIds } : u))
        toast.success("权限更新成功")
        setEditingUser(null)
      } else {
        toast.error("权限更新失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const getShopNames = (shopIds: string[]) => {
    return shopIds.map(id => {
      const shop = shops.find(s => s.shop_id === id)
      return shop ? shop.name : id
    }).join(', ')
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">用户权限管理</h2>
          <p className="text-sm text-muted-foreground mt-1">创建用户并分配店铺管理权限</p>
        </div>
        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 size-5" />
              创建用户
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl">创建新用户</DialogTitle>
              <DialogDescription>设置用户名、密码和权限</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>用户名</Label>
                <Input
                  value={newUser.username}
                  onChange={(e) => setNewUser({...newUser, username: e.target.value})}
                  placeholder="请输入用户名"
                />
              </div>
              <div className="space-y-2">
                <Label>密码</Label>
                <Input
                  type="password"
                  value={newUser.password}
                  onChange={(e) => setNewUser({...newUser, password: e.target.value})}
                  placeholder="请输入密码"
                />
              </div>
              <div className="space-y-2">
                <Label>角色</Label>
                <Select value={newUser.role} onValueChange={(value) => setNewUser({...newUser, role: value})}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="user">普通用户</SelectItem>
                    <SelectItem value="admin">管理员</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label>管理的店铺</Label>
                <div className="max-h-32 overflow-y-auto border rounded p-2 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={shop.shop_id}
                        checked={newUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          if (checked) {
                            setNewUser({...newUser, shops: [...newUser.shops, shop.shop_id]})
                          } else {
                            setNewUser({...newUser, shops: newUser.shops.filter(id => id !== shop.shop_id)})
                          }
                        }}
                      />
                      <Label htmlFor={shop.shop_id} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>取消</Button>
              <Button onClick={handleCreateUser}>创建用户</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>

      <Card className="shadow-sm">
        <CardHeader className="py-5 border-b">
          <CardTitle className="text-2xl font-bold">用户列表</CardTitle>
          <CardDescription className="text-sm">
            共 {users.length} 个用户
          </CardDescription>
        </CardHeader>

        {/* 搜索工具栏 */}
        {users.length > 0 && (
          <div className="px-6 py-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="搜索用户名或角色..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                  />
                </div>
              </div>
            </div>

            {/* 搜索结果状态 */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                搜索结果: <span className="font-medium">{filteredUsers.length}</span> 个用户
                <span className="ml-2">关键词: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}
          </div>
        )}
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold text-foreground pl-6">用户名</TableHead>
                <TableHead className="text-sm font-bold text-foreground">角色</TableHead>
                <TableHead className="text-sm font-bold text-foreground">管理店铺</TableHead>
                <TableHead className="text-sm font-bold text-foreground">状态</TableHead>
                <TableHead className="text-sm font-bold text-foreground text-right pr-6">操作</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {paginatedUsers.map((user) => (
                <TableRow key={user.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="font-medium py-3 pl-6">
                    <div className="flex items-center gap-2">
                      {user.role === 'admin' ? (
                        <Shield className="size-4 text-blue-600" />
                      ) : (
                        <User className="size-4 text-gray-600" />
                      )}
                      <span className="text-base font-semibold">{user.username}</span>
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.role === 'admin' ? (
                      <Badge className="bg-blue-600">管理员</Badge>
                    ) : (
                      <Badge variant="secondary">普通用户</Badge>
                    )}
                  </TableCell>
                  <TableCell className="py-3">
                    <div className="text-sm max-w-xs truncate" title={getShopNames(user.shops)}>
                      {user.shops.length > 0 ? getShopNames(user.shops) : "无"}
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.is_active ? (
                      <Badge className="bg-green-600">活跃</Badge>
                    ) : (
                      <Badge variant="secondary">禁用</Badge>
                    )}
                  </TableCell>
                  <TableCell className="text-right pr-6 py-3">
                    <div className="flex items-center justify-end gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setResetPasswordUser(user)}
                      >
                        修改密码
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingUser(user)}
                      >
                        <Edit className="size-4 mr-1" />
                        权限
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteUser(user)}
                        className="text-red-600 hover:text-red-700 hover:bg-red-50"
                      >
                        <Trash2 className="size-4 mr-1" />
                        删除
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* 编辑用户权限对话框 */}
      {editingUser && (
        <Dialog open={!!editingUser} onOpenChange={() => setEditingUser(null)}>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle>编辑用户权限 - {editingUser.username}</DialogTitle>
              <DialogDescription>修改用户管理的店铺权限</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>管理的店铺</Label>
                <div className="max-h-48 overflow-y-auto border rounded p-3 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={`edit-${shop.shop_id}`}
                        checked={editingUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          const newShops = checked
                            ? [...editingUser.shops, shop.shop_id]
                            : editingUser.shops.filter(id => id !== shop.shop_id)
                          setEditingUser({...editingUser, shops: newShops})
                        }}
                      />
                      <Label htmlFor={`edit-${shop.shop_id}`} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
                {shops.length === 0 && (
                  <p className="text-sm text-muted-foreground">暂无店铺，请先添加店铺</p>
                )}
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingUser(null)}>取消</Button>
              <Button onClick={() => handleUpdateUserShops(editingUser.id, editingUser.shops)}>
                <Save className="size-4 mr-1" />
                保存权限
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}

      {/* 分页控件 */}
      {totalPages > 1 && (
        <div className="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6 px-6 py-4 border-t bg-muted/5">
          <div className="text-sm text-muted-foreground font-medium">
            显示第 {(page-1)*itemsPerPage + 1} - {Math.min(page*itemsPerPage, filteredUsers.length)} 条，共 {filteredUsers.length} 条记录
          </div>
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                disabled={page===1}
                onClick={()=>setPage(p=>p-1)}
                className="h-8 px-3"
              >
                上一页
              </Button>
              <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                {page} / {totalPages}
              </div>
              <Button
                variant="outline"
                size="sm"
                disabled={page===totalPages}
                onClick={()=>setPage(p=>p+1)}
                className="h-8 px-3"
              >
                下一页
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Reset Password Dialog */}
      <Dialog open={!!resetPasswordUser} onOpenChange={()=>setResetPasswordUser(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>重置密码 - {resetPasswordUser?.username}</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <Label>新密码</Label>
            <Input type="password" value={newPassword} onChange={e=>setNewPassword(e.target.value)} />
          </div>
          <DialogFooter>
            <Button onClick={handleResetPassword}>确认修改</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* 删除用户确认对话框 */}
      <Dialog open={!!deleteUserConfirm} onOpenChange={() => setDeleteUserConfirm(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>确认删除用户</DialogTitle>
            <DialogDescription>
              确定要删除用户 "{deleteUserConfirm?.username}" 吗？此操作不可恢复！
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteUserConfirm(null)}>
              取消
            </Button>
            <Button variant="destructive" onClick={confirmDeleteUser}>
              确认删除
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}

--- File: ./frontend/hooks/use-api-cache.ts ---
import { useState, useCallback } from 'react'

interface CacheEntry {
  data: any
  timestamp: number
}

export function useApiCache(cacheDuration: number = 30000) {
  const [cache, setCache] = useState<{[key: string]: CacheEntry}>({})

  const cachedFetch = useCallback(async (url: string, options?: RequestInit): Promise<any> => {
    const cacheKey = `${options?.method || 'GET'}:${url}`
    const now = Date.now()

    // 检查缓存
    const cached = cache[cacheKey]
    if (cached && (now - cached.timestamp) < cacheDuration) {
      console.log(`使用缓存数据: ${cacheKey}`)
      return cached.data
    }

    // 发起新请求
    console.log(`发起API请求: ${cacheKey}`)
    const response = await fetch(url, options)
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`)
    }
    const data = await response.json()

    // 更新缓存
    setCache(prev => ({
      ...prev,
      [cacheKey]: { data, timestamp: now }
    }))

    return data
  }, [cache, cacheDuration])

  const clearCache = useCallback(() => {
    setCache({})
  }, [])

  const invalidateCache = useCallback((url: string, method: string = 'GET') => {
    const cacheKey = `${method}:${url}`
    setCache(prev => {
      const newCache = { ...prev }
      delete newCache[cacheKey]
      return newCache
    })
  }, [])

  return { cachedFetch, clearCache, invalidateCache }
}

--- File: ./frontend/hooks/use-mobile.ts ---
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener('change', onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener('change', onChange)
  }, [])

  return !!isMobile
}

--- File: ./frontend/hooks/use-toast.ts ---
'use client'

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '@/components/ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }

--- File: ./frontend/lib/utils.ts ---
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- File: ./backend/config.py ---
import os

class Config:
    # Discord 配置
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = float(os.getenv('DISCORD_SIMILARITY_THRESHOLD', '0.6'))

    # 全局回复延迟配置
    GLOBAL_REPLY_MIN_DELAY = float(os.getenv('GLOBAL_REPLY_MIN_DELAY', '3.0'))
    GLOBAL_REPLY_MAX_DELAY = float(os.getenv('GLOBAL_REPLY_MAX_DELAY', '8.0'))

    # 频道配置
    CNFANS_CHANNEL_ID = int(os.getenv('CNFANS_CHANNEL_ID', 0)) if os.getenv('CNFANS_CHANNEL_ID') else 0
    ACBUY_CHANNEL_ID = int(os.getenv('ACBUY_CHANNEL_ID', 0)) if os.getenv('ACBUY_CHANNEL_ID') else 0

    # 关键词转发配置
    FORWARD_KEYWORDS = os.getenv('FORWARD_KEYWORDS', '商品,货源,进货,批发,代理').split(',')  # 触发转发的关键词
    FORWARD_TARGET_CHANNEL_ID = int(os.getenv('FORWARD_TARGET_CHANNEL_ID', 0)) if os.getenv('FORWARD_TARGET_CHANNEL_ID') else 0  # 转发目标频道ID

    # API服务地址（本地服务）
    NEXTJS_API_URL = 'http://localhost:5001/api'
    PADDLE_SERVICE_URL = 'http://localhost:5001'

    # 机器人配置
    COMMAND_PREFIX = '!'

    # DINOv2 & FAISS 配置
    DINO_MODEL_NAME = os.getenv('DINO_MODEL_NAME', 'facebook/dinov2-small')
    VECTOR_DIMENSION = 384 if 'small' in DINO_MODEL_NAME else 768
    SIMILARITY_THRESHOLD = 0.6

    # 图像处理配置
    YOLO_MODEL_PATH = os.getenv('YOLO_MODEL_PATH', 'yolov8s-world.pt')  # 升级到YOLO-World
    USE_YOLO_CROP = os.getenv('USE_YOLO_CROP', 'True').lower() == 'true'  # 启用YOLO-World裁剪

    # 多线程配置
    DOWNLOAD_THREADS = int(os.getenv('DOWNLOAD_THREADS', '4'))  # 图片下载线程数
    FEATURE_EXTRACT_THREADS = int(os.getenv('FEATURE_EXTRACT_THREADS', '4'))  # 特征提取线程数


    # FAISS 配置
    FAISS_INDEX_FILE = os.path.join(os.path.dirname(__file__), 'data', 'faiss_index.bin')
    FAISS_ID_MAP_FILE = os.path.join(os.path.dirname(__file__), 'data', 'faiss_id_map.pkl')
    FAISS_HNSW_M = int(os.getenv('FAISS_HNSW_M', '64'))
    FAISS_EF_CONSTRUCTION = int(os.getenv('FAISS_EF_CONSTRUCTION', '80'))
    FAISS_EF_SEARCH = int(os.getenv('FAISS_EF_SEARCH', '64'))

    # 图片保存目录
    IMAGE_SAVE_DIR = os.path.join(os.path.dirname(__file__), 'data')

    # 服务配置
    HOST = '0.0.0.0'
    PORT = int(os.getenv('PORT', 5001))
    DEBUG = os.getenv('DEBUG', 'True').lower() == 'true'

    # 设备配置
    DEVICE = os.getenv('DEVICE', 'cpu')

config = Config()

--- File: ./backend/database.py ---
import sqlite3
import numpy as np
import os
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager
try:
    from config import config
except ImportError:
    from .config import config

logger = logging.getLogger(__name__)

class Database:
    def __init__(self):
        # SQLite 数据库路径 (用于存储商品元数据和Discord账号信息)
        self.db_path = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

        # 确保数据目录存在
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # 初始化 SQLite 数据库
        self.init_sqlite_database()

    def init_sqlite_database(self):
        """初始化 SQLite 数据库 (用于元数据存储)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # 创建商品表（移除商品级别延迟，使用全局延迟）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_url TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    english_title TEXT,
                    cnfans_url TEXT,
                    acbuy_url TEXT,
                    shop_name TEXT,
                    ruleEnabled BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建索引以优化查询性能
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_shop_name ON products(shop_name)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_rule_enabled ON products(ruleEnabled)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_image_index ON product_images(image_index)')
            except sqlite3.OperationalError:
                pass

            # 创建店铺表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS shops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    shop_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    product_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 为现有表添加新字段（如果不存在）
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN ruleEnabled BOOLEAN DEFAULT 1')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN min_delay INTEGER DEFAULT 3')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN max_delay INTEGER DEFAULT 8')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            # 新增英文标题与 cnfans 链接字段（兼容已有数据库）
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN english_title TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN cnfans_url TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN acbuy_url TEXT')
            except sqlite3.OperationalError:
                pass

            # 添加自定义回复字段
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_text TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_images TEXT')  # JSON格式存储图片索引数组
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_image_urls TEXT')  # JSON格式存储自定义图片URL数组
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN image_source TEXT DEFAULT \'product\'')  # 图片来源：'product'(商品图片), 'upload'(本地上传), 'custom'(URL)
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN shop_name TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN cnfans_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN acbuy_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            # 创建图片表 (milvus_id 替代 faiss_id)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS product_images (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    image_index INTEGER NOT NULL,
                    features TEXT,  -- 存储序列化的特征向量
                    milvus_id INTEGER UNIQUE,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE,
                    UNIQUE(product_id, image_index)
                )
            ''')

            # 创建用户表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT DEFAULT 'user',  -- admin, user
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建用户-店铺权限表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_shop_permissions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    shop_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id, shop_id)
                )
            ''')

            # 创建 Discord 账号表（关联到用户）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS discord_accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    token TEXT UNIQUE NOT NULL,
                    user_id INTEGER,
                    status TEXT DEFAULT 'offline',
                    last_active TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL
                )
            ''')

            # 插入默认管理员用户
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO users (id, username, password_hash, role, is_active)
                    VALUES (1, 'admin', 'hashed_admin123', 'admin', 1)
                ''')  # 密码: admin123
            except sqlite3.Error as e:
                logger.warning(f"创建默认管理员失败: {e}")

            # 创建账号轮换配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS account_rotation_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    enabled BOOLEAN DEFAULT 0,
                    rotation_interval INTEGER DEFAULT 10,
                    current_account_id INTEGER,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认轮换配置
            cursor.execute('''
                INSERT OR IGNORE INTO account_rotation_config (id, enabled, rotation_interval)
                VALUES (1, 0, 10)
            ''')

            # 创建搜索历史表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS search_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    query_image_path TEXT NOT NULL,
                    matched_product_id INTEGER,
                    matched_image_index INTEGER,
                    similarity REAL NOT NULL,
                    threshold REAL NOT NULL,
                    search_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (matched_product_id) REFERENCES products (id) ON DELETE SET NULL
                )
            ''')

            # 创建全局延迟配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS global_reply_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    min_delay REAL DEFAULT 3.0,
                    max_delay REAL DEFAULT 8.0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建系统配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    discord_channel_id TEXT DEFAULT '',
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    cnfans_channel_id TEXT DEFAULT '',
                    acbuy_channel_id TEXT DEFAULT '',
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认系统配置
            cursor.execute('''
                INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                VALUES (1, '', 4, 4, 0.6, '', '')
            ''')

            # 创建网站配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_configs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    display_name TEXT NOT NULL,
                    url_template TEXT NOT NULL,
                    id_pattern TEXT NOT NULL,
                    badge_color TEXT DEFAULT 'blue',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建网站频道绑定表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_channel_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    channel_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(website_id, channel_id)
                )
            ''')

            # 创建系统公告表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_announcements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建消息过滤规则表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS message_filters (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filter_type TEXT NOT NULL, -- 'contains', 'starts_with', 'ends_with', 'regex'
                    filter_value TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建自定义回复内容表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS custom_replies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reply_type TEXT NOT NULL, -- 'text', 'image', 'text_and_link', 'custom_only'
                    content TEXT, -- 文字内容或图片URL
                    image_url TEXT, -- 如果是图片回复
                    is_active BOOLEAN DEFAULT 1,
                    priority INTEGER DEFAULT 0, -- 优先级，数字越大优先级越高
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认网站配置
            cursor.execute('''
                INSERT OR IGNORE INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                VALUES
                    ('cnfans', 'CNFans', 'https://cnfans.com/product?id={id}&platform=WEIDIAN', '{id}', 'blue'),
                    ('acbuy', 'AcBuy', 'https://www.acbuy.com/product?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD', '{id}', 'orange'),
                    ('weidian', '微店', 'https://weidian.com/item.html?itemID={id}', '{id}', 'gray')
            ''')

            # 创建用户设置表（每个用户的个性化设置）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    global_reply_min_delay REAL DEFAULT 3.0,
                    global_reply_max_delay REAL DEFAULT 8.0,
                    user_blacklist TEXT DEFAULT '',  -- 用户黑名单，逗号分隔
                    keyword_filters TEXT DEFAULT '',  -- 关键词过滤，逗号分隔
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id)
                )
            ''')

            # 创建抓取状态表（持久化存储抓取状态）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scrape_status (
                    id INTEGER PRIMARY KEY CHECK (id = 1),  -- 只允许一条记录
                    is_scraping BOOLEAN DEFAULT 0,
                    paused BOOLEAN DEFAULT 0,
                    stop_signal BOOLEAN DEFAULT 0,
                    current_shop_id TEXT,
                    total INTEGER DEFAULT 0,
                    processed INTEGER DEFAULT 0,
                    success INTEGER DEFAULT 0,
                    progress REAL DEFAULT 0,
                    message TEXT DEFAULT '等待开始...',
                    completed BOOLEAN DEFAULT 0,
                    thread_id TEXT,  -- 记录当前线程ID
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认状态记录
            cursor.execute('''
                INSERT OR IGNORE INTO scrape_status (id, is_scraping, paused, stop_signal, message)
                VALUES (1, 0, 0, 0, '等待开始...')
            ''')

            # 插入默认全局延迟配置
            cursor.execute('''
                INSERT OR IGNORE INTO global_reply_config (id, min_delay, max_delay)
                VALUES (1, 3.0, 8.0)
            ''')

            # 为现有商品设置默认店铺名称
            try:
                cursor.execute('UPDATE products SET shop_name = ? WHERE shop_name IS NULL OR shop_name = ?', ('未知店铺', ''))
                logger.info("已为缺少店铺名称的商品设置默认值")
            except Exception as e:
                logger.warning(f"设置默认店铺名称失败: {e}")

            conn.commit()


    @contextmanager
    def get_connection(self):
        """获取 SQLite 数据库连接的上下文管理器"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # 启用行工厂
            yield conn
        except Exception as e:
            logger.error("数据库连接失败: %s", str(e))
            raise
        finally:
            if conn:
                conn.close()

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> List[Dict]:
        """执行查询并返回结果"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            if fetch:
                results = [dict(row) for row in cursor.fetchall()]
                conn.commit()
                return results
            conn.commit()
            return []

    def insert_product(self, product_data: Dict) -> int:
        """插入商品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO products
                (product_url, title, description, english_title, cnfans_url, acbuy_url, shop_name, ruleEnabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                product_data['product_url'],
                product_data.get('title', ''),
                product_data.get('description', ''),
                product_data.get('english_title', ''),
                product_data.get('cnfans_url', ''),
                product_data.get('acbuy_url', ''),
                product_data.get('shop_name', ''),
                product_data.get('ruleEnabled', True)
            ))
            product_id = cursor.lastrowid
            conn.commit()
            return product_id

    def insert_image_record(self, product_id: int, image_path: str, image_index: int, features: np.ndarray = None) -> int:
        """插入图像记录到数据库，返回记录ID供FAISS使用"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 将特征向量序列化为字符串存储
                features_str = None
                if features is not None:
                    import json
                    features_str = json.dumps(features.tolist())

                cursor.execute('''
                    INSERT INTO product_images
                    (product_id, image_path, image_index, features)
                    VALUES (?, ?, ?, ?)
                ''', (product_id, image_path, image_index, features_str))
                conn.commit()
                record_id = cursor.lastrowid
                logger.info(f"图像记录插入成功: product_id={product_id}, image_index={image_index}, record_id={record_id}")
                return record_id

        except Exception as e:
            logger.error(f"插入图像记录失败: {e}")
            raise e

    def search_similar_images(self, query_vector: np.ndarray, limit: int = 1,
                             threshold: float = 0.6, user_shops: Optional[List[str]] = None) -> List[Dict]:
        """使用FAISS搜索相似图像"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()

            print(f"DEBUG DB: Starting FAISS search, threshold: {threshold}, limit: {limit}")
            print(f"DEBUG DB: Query vector length: {len(query_vector) if hasattr(query_vector, '__len__') else 'unknown'}")

            # 执行FAISS搜索 - 请求更多结果以应对被删除的向量
            faiss_results = engine.search(query_vector, top_k=min(limit * 3, 50))  # 请求更多候选结果
            print(f"DEBUG DB: FAISS search returned {len(faiss_results)} results")

            matched_results = []

            for result in faiss_results:
                score = result['score']
                db_id = result['db_id']

                print(f"DEBUG DB: Processing result - db_id: {db_id}, score: {score}, threshold: {threshold}")

                # 通过image_db_id获取产品信息
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    print(f"DEBUG DB: Found image info for db_id {db_id}: product_id={image_info['product_id']}")
                    product_info = self._get_product_info_by_id(image_info['product_id'])

                    if product_info:
                        # 如果指定了用户店铺权限，进行过滤
                        if user_shops and product_info.get('shop_name') not in user_shops:
                            print(f"DEBUG DB: Skipping product from shop {product_info.get('shop_name')} - not in user shops {user_shops}")
                            continue

                        print(f"DEBUG DB: Found product info for product_id {image_info['product_id']}: ruleEnabled={product_info.get('ruleEnabled', True)}")
                        result_dict = {
                            **product_info,
                            'similarity': score,
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added result with similarity {score}")

                        # 如果找到了足够的结果，就停止
                        if len(matched_results) >= limit:
                            break
                    else:
                        print(f"DEBUG DB: Product info not found for product_id {image_info['product_id']}")
                else:
                    print(f"DEBUG DB: Image info not found for db_id {db_id}")

            # 如果没有找到任何结果，返回最佳匹配（即使低于阈值）
            if not matched_results and faiss_results:
                print(f"DEBUG DB: No results above threshold {threshold}, returning best match")
                best_result = faiss_results[0]
                db_id = best_result['db_id']
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    product_info = self._get_product_info_by_id(image_info['product_id'])
                    if product_info:
                        result_dict = {
                            **product_info,
                            'similarity': best_result['score'],
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added best match with similarity {best_result['score']}")

            return matched_results

        except Exception as e:
            logger.error(f"FAISS搜索失败: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _get_product_url_by_id(self, product_id: int) -> Optional[str]:
        """根据产品ID获取产品URL"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT product_url FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return row['product_url'] if row else None

    def get_image_info_by_id(self, image_id: int) -> Optional[Dict]:
        """根据图像记录ID获取图像信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM product_images WHERE id = ?", (image_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def _get_product_info_by_id(self, product_id: int) -> Optional[Dict]:
        """根据产品ID获取完整的产品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_indexed_product_ids(self) -> List[str]:
        """获取已建立索引的商品URL列表"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT p.product_url
                FROM products p
                JOIN product_images pi ON p.id = pi.product_id
            ''')
            return [row['product_url'] for row in cursor.fetchall()]

    def get_product_images(self, product_id: int) -> List[Dict]:
        """获取商品的所有图片及其特征向量"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, image_path, image_index, features
                    FROM product_images
                    WHERE product_id = ?
                    ORDER BY image_index
                ''', (product_id,))

                images = []
                for row in cursor.fetchall():
                    image_data = dict(row)
                    # 反序列化特征向量
                    if image_data.get('features'):
                        import json
                        try:
                            features_list = json.loads(image_data['features'])
                            image_data['features'] = np.array(features_list, dtype='float32')
                        except Exception as e:
                            logger.warning(f"反序列化特征向量失败: {e}")
                            image_data['features'] = None
                    else:
                        image_data['features'] = None
                    images.append(image_data)

                return images

        except Exception as e:
            logger.error(f"获取商品图片失败: {e}")
            return []

    def delete_product_images(self, product_id: int) -> bool:
        """删除商品的所有图像和物理文件"""
        try:
            # 获取该商品的所有图像记录ID和文件路径
            image_records = []
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ?", (product_id,))
                image_records = [{'id': row['id'], 'path': row['image_path']} for row in cursor.fetchall()]

            if image_records:
                # 从FAISS中删除向量
                try:
                    from vector_engine import get_vector_engine
                except ImportError:
                    from .vector_engine import get_vector_engine
                engine = get_vector_engine()
                for record in image_records:
                    engine.remove_vector_by_db_id(record['id'])

            # 删除物理文件
            for record in image_records:
                if record['path'] and os.path.exists(record['path']):
                    try:
                        os.remove(record['path'])
                        logger.info(f"已删除商品图片文件: {record['path']}")
                    except Exception as e:
                        logger.warning(f"删除商品图片文件失败: {e}")

            # 从 SQLite 删除
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ?", (product_id,))
                cursor.execute("DELETE FROM products WHERE id = ?", (product_id,))
                conn.commit()

            # 保存FAISS索引
            if image_records:
                engine.save()

            return True
        except Exception as e:
            logger.error(f"删除商品图像失败: {e}")
            return False

    def delete_image_vector(self, product_id: int, image_index: int) -> bool:
        """删除特定的图像向量和物理文件"""
        try:
            # 获取该图像的记录ID和文件路径
            image_path = None
            image_id = None
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))
                row = cursor.fetchone()
                if row:
                    image_id = row['id']
                    image_path = row['image_path']

            if not image_id:
                logger.warning(f"图片不存在: product_id={product_id}, image_index={image_index}")
                return False

            # 从FAISS中删除向量并重建索引
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            success = engine.remove_vector_by_db_id(image_id)
            if not success:
                logger.error(f"FAISS删除向量失败: db_id={image_id}")
                return False

            # 删除物理文件
            if image_path and os.path.exists(image_path):
                try:
                    os.remove(image_path)
                    logger.info(f"已删除图片文件: {image_path}")
                except Exception as e:
                    logger.warning(f"删除图片文件失败: {e}")

            # 从 SQLite 删除记录
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))

                # --- 删除重新排序的代码 ---
                # 重新排序会导致前端 React key 冲突和浏览器缓存问题
                # 让图片索引保持固定，删除中间图片后索引不变
                # cursor.execute("SELECT id, image_index FROM product_images WHERE product_id = ? ORDER BY image_index",
                #              (product_id,))
                # remaining_images = cursor.fetchall()
                #
                # # 更新索引，从0开始重新编号
                # for new_index, (img_id, old_index) in enumerate(remaining_images):
                #     if new_index != old_index:
                #         cursor.execute("UPDATE product_images SET image_index = ? WHERE id = ?",
                #                      (new_index, img_id))

                conn.commit()

            logger.info(f"图片删除成功: product_id={product_id}, image_index={image_index}")
            return True
        except Exception as e:
            logger.error(f"删除图像向量失败: {e}")
            return False

    def get_product_by_url(self, product_url: str) -> Optional[Dict]:
        """根据商品URL获取商品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def cleanup_unused_images(self, days_old: int = 30) -> int:
        """
        清理未使用的图片文件
        删除那些在数据库中不存在记录的图片文件，或者删除超过指定天数的旧图片

        Args:
            days_old: 删除多少天前的图片（默认30天）

        Returns:
            删除的文件数量
        """
        try:
            import os
            import time

            # 获取所有数据库中存在的图片路径
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT image_path FROM product_images")
                db_image_paths = set(row['image_path'] for row in cursor.fetchall())

            # 获取data/images目录下的所有文件
            images_dir = os.path.join('data', 'images')
            if not os.path.exists(images_dir):
                return 0

            deleted_count = 0
            cutoff_time = time.time() - (days_old * 24 * 60 * 60)

            for filename in os.listdir(images_dir):
                filepath = os.path.join(images_dir, filename)

                # 只处理jpg文件
                if not filename.endswith('.jpg'):
                    continue

                # 检查是否在数据库中存在
                if filepath not in db_image_paths:
                    try:
                        os.remove(filepath)
                        logger.info(f"清理未使用的图片文件: {filepath}")
                        deleted_count += 1
                    except Exception as e:
                        logger.warning(f"删除文件失败 {filepath}: {e}")
                # 或者检查是否太旧（即使在数据库中）
                elif os.path.getmtime(filepath) < cutoff_time:
                    # 这里可以选择是否删除旧文件
                    # 暂时保留，避免误删
                    pass

            if deleted_count > 0:
                logger.info(f"图片清理完成，共删除 {deleted_count} 个未使用的文件")

            return deleted_count

        except Exception as e:
            logger.error(f"图片清理失败: {e}")
            return 0

    def get_product_id_by_url(self, product_url: str) -> Optional[int]:
        """根据商品URL获取商品内部ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return row['id'] if row else None

    def get_total_indexed_images(self) -> int:
        """获取已索引的总图片数量"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            return engine.count()
        except Exception as e:
            logger.error(f"获取索引图片数量失败: {e}")
            return 0

    def get_indexed_product_urls(self) -> List[str]:
        """获取已建立索引的商品URL列表"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT DISTINCT p.product_url
                    FROM products p
                    JOIN product_images pi ON p.id = pi.product_id
                ''')
                return [row['product_url'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取已索引商品URL失败: {e}")
            return []

    def add_search_history(self, query_image_path: str, matched_product_id: int,
                          matched_image_index: int, similarity: float, threshold: float) -> bool:
        """添加搜索历史记录"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO search_history
                    (query_image_path, matched_product_id, matched_image_index, similarity, threshold)
                    VALUES (?, ?, ?, ?, ?)
                ''', (query_image_path, matched_product_id, matched_image_index, similarity, threshold))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加搜索历史失败: {e}")
            return False

    def get_search_history(self, limit: int = 50, offset: int = 0) -> Dict:
        """获取搜索历史记录（支持分页）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 获取总数
                cursor.execute('SELECT COUNT(*) FROM search_history')
                total = cursor.fetchone()[0]

                # 获取分页数据
                cursor.execute('''
                    SELECT
                        sh.id,
                        sh.query_image_path,
                        sh.matched_product_id,
                        sh.matched_image_index,
                        sh.similarity,
                        sh.threshold,
                        sh.search_time,
                        p.title,
                        p.english_title,
                        p.product_url as weidian_url,
                        p.cnfans_url,
                        p.acbuy_url,
                        p.ruleEnabled,
                        pi.image_path as matched_image_path
                    FROM search_history sh
                    LEFT JOIN products p ON sh.matched_product_id = p.id
                    LEFT JOIN product_images pi ON sh.matched_product_id = pi.product_id AND sh.matched_image_index = pi.image_index
                    ORDER BY sh.search_time DESC
                    LIMIT ? OFFSET ?
                ''', (limit, offset))
                rows = cursor.fetchall()
                history = []
                for row in rows:
                    history.append({
                        'id': row['id'],
                        'query_image_path': row['query_image_path'],
                        'matched_product_id': row['matched_product_id'],
                        'matched_image_index': row['matched_image_index'],
                        'similarity': row['similarity'],
                        'threshold': row['threshold'],
                        'search_time': row['search_time'],
                        'title': row['title'],
                        'english_title': row['english_title'],
                        'weidian_url': row['weidian_url'],
                        'cnfans_url': row['cnfans_url'],
                        'acbuy_url': row['acbuy_url'],
                        'ruleEnabled': row['ruleEnabled'],
                        'matched_image_path': row['matched_image_path']
                    })

                return {
                    'history': history,
                    'total': total,
                    'limit': limit,
                    'offset': offset,
                    'has_more': offset + limit < total
                }
        except Exception as e:
            logger.error(f"获取搜索历史失败: {e}")
            return []

    def delete_search_history(self, history_id: int) -> bool:
        """删除搜索历史记录"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history WHERE id = ?', (history_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除搜索历史失败: {e}")
            return False

    def clear_search_history(self) -> bool:
        """清空所有搜索历史"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history')
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"清空搜索历史失败: {e}")
            return False

    # ===== 用户权限管理方法 =====

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """用户认证"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, role, is_active, created_at
                    FROM users
                    WHERE username = ? AND is_active = 1
                ''', (username,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    stored_hash = user_dict.get('password_hash')

                    # 验证密码
                    authenticated = False

                    if stored_hash:
                        # 首先尝试Werkzeug哈希验证（新用户）
                        from werkzeug.security import check_password_hash
                        if check_password_hash(stored_hash, password):
                            authenticated = True
                        # 如果失败，尝试旧的哈希方式（兼容旧用户）
                        elif stored_hash == f"hashed_{password}":
                            authenticated = True

                    if authenticated:
                        # 获取用户管理的店铺
                        user_dict['shops'] = self.get_user_shops(user_dict['id'])
                        return user_dict
                return None
        except Exception as e:
            logger.error(f"用户认证失败: {e}")
            return None

    def create_user(self, username: str, password: str, role: str = 'user') -> bool:
        """创建新用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 简单的密码哈希（生产环境应该使用bcrypt）
                import hashlib
                password_hash = f"hashed_{password}"  # 简化版，实际应该用bcrypt

                cursor.execute('''
                    INSERT INTO users (username, password_hash, role, is_active)
                    VALUES (?, ?, ?, 1)
                ''', (username, password_hash, role))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            logger.warning(f"用户名已存在: {username}")
            return False
        except Exception as e:
            logger.error(f"创建用户失败: {e}")
            return False

    def get_all_users(self) -> List[Dict]:
        """获取所有用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    ORDER BY created_at DESC
                ''')
                users = []
                for row in cursor.fetchall():
                    user = dict(row)
                    user['shops'] = self.get_user_shops(user['id'])
                    users.append(user)
                return users
        except Exception as e:
            logger.error(f"获取用户列表失败: {e}")
            return []

    def get_user_shops(self, user_id: int) -> List[str]:
        """获取用户管理的店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT shop_id FROM user_shop_permissions
                    WHERE user_id = ?
                ''', (user_id,))
                return [row['shop_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取用户店铺权限失败: {e}")
            return []

    def update_user_shops(self, user_id: int, shop_ids: List[str]) -> bool:
        """更新用户的店铺权限"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 先删除旧的权限
                cursor.execute('DELETE FROM user_shop_permissions WHERE user_id = ?', (user_id,))

                # 添加新的权限
                for shop_id in shop_ids:
                    cursor.execute('''
                        INSERT INTO user_shop_permissions (user_id, shop_id)
                        VALUES (?, ?)
                    ''', (user_id, shop_id))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户店铺权限失败: {e}")
            return False

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """根据ID获取用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    WHERE id = ?
                ''', (user_id,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    user_dict['shops'] = self.get_user_shops(user_id)
                    return user_dict
                return None
        except Exception as e:
            logger.error(f"获取用户信息失败: {e}")
            return None

    def update_discord_account_user(self, account_id: int, user_id: Optional[int]) -> bool:
        """更新Discord账号关联的用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET user_id = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新Discord账号用户关联失败: {e}")
            return False

    def get_discord_accounts_by_user(self, user_id: Optional[int]) -> List[Dict]:
        """获取用户关联的Discord账号"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id is None:
                    # 管理员查询所有账号
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                    FROM discord_accounts
                    ORDER BY created_at DESC
                    ''')
                else:
                    # 普通用户查询自己的账号
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                        FROM discord_accounts
                        WHERE user_id = ?
                        ORDER BY created_at DESC
                    ''', (user_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取用户Discord账号失败: {e}")
            return []

    def update_product_title(self, product_id: int, title: str) -> bool:
        """更新商品标题"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE products
                    SET title = ?, updated_at = datetime('now')
                    WHERE id = ?
                ''', (title, product_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新商品标题失败: {e}")
            return False

    def update_product(self, product_id: int, updates: Dict) -> bool:
        """更新商品信息（通用方法）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 构建动态更新语句
                set_parts = []
                params = []
                allowed_fields = [
                    'title', 'english_title', 'ruleEnabled',
                    'custom_reply_text', 'custom_reply_images', 'custom_image_urls'
                ]

                for field in allowed_fields:
                    if field in updates:
                        set_parts.append(f'{field} = ?')
                        if (field == 'custom_reply_images' or field == 'custom_image_urls') and isinstance(updates[field], list):
                            # 将图片索引或URL数组转换为JSON字符串
                            params.append(json.dumps(updates[field]))
                        else:
                            params.append(updates[field])

                if not set_parts:
                    return False

                set_parts.append('updated_at = datetime(\'now\')')

                query = f'''
                    UPDATE products
                    SET {', '.join(set_parts)}
                    WHERE id = ?
                '''
                params.append(product_id)

                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新商品失败: {e}")
            return False

    def get_product_by_id(self, product_id: int) -> Optional[Dict]:
        """根据ID获取商品"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM products WHERE id = ?', (product_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            logger.error(f"获取商品失败: {e}")
            return None

    def delete_user(self, user_id: int) -> bool:
        """删除用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 首先删除用户的所有相关数据
                # 删除用户的Discord账号
                cursor.execute('DELETE FROM discord_accounts WHERE user_id = ?', (user_id,))
                # 删除用户的设置
                cursor.execute('DELETE FROM user_settings WHERE user_id = ?', (user_id,))
                # 删除用户
                cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除用户失败: {e}")
            return False

    def update_account_status(self, account_id: int, status: str) -> bool:
        """更新Discord账号状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET status = ?, last_active = datetime('now')
                    WHERE id = ?
                ''', (status, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新账号状态失败: {e}")
            return False

    def get_website_configs(self) -> List[Dict]:
        """获取所有网站配置及其频道绑定（优化版本，避免N+1查询）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 使用LEFT JOIN一次性获取所有网站和其频道绑定
                cursor.execute('''
                    SELECT
                        wc.id, wc.name, wc.display_name, wc.url_template,
                        wc.id_pattern, wc.badge_color, wc.created_at,
                        GROUP_CONCAT(wcb.channel_id) as channels
                    FROM website_configs wc
                    LEFT JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                    GROUP BY wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color, wc.created_at
                    ORDER BY wc.created_at
                ''')

                configs = []
                for row in cursor.fetchall():
                    config = dict(row)
                    # 将channels字符串解析为数组
                    if config.get('channels'):
                        config['channels'] = config['channels'].split(',') if config['channels'] else []
                    else:
                        config['channels'] = []
                    configs.append(config)

                return configs
        except Exception as e:
            logger.error(f"获取网站配置失败: {e}")
            return []

    def add_website_config(self, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str = 'blue') -> bool:
        """添加网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                    VALUES (?, ?, ?, ?, ?)
                ''', (name, display_name, url_template, id_pattern, badge_color))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加网站配置失败: {e}")
            return False

    def update_website_config(self, config_id: int, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str) -> bool:
        """更新网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET name = ?, display_name = ?, url_template = ?, id_pattern = ?, badge_color = ?
                    WHERE id = ?
                ''', (name, display_name, url_template, id_pattern, badge_color, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新网站配置失败: {e}")
            return False

    def delete_website_config(self, config_id: int) -> bool:
        """删除网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM website_configs WHERE id = ?', (config_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除网站配置失败: {e}")
            return False

    def get_website_channel_bindings(self, website_id: int) -> List[str]:
        """获取网站绑定的频道列表"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT channel_id FROM website_channel_bindings
                    WHERE website_id = ?
                    ORDER BY created_at
                ''', (website_id,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取网站频道绑定失败: {e}")
            return []

    def add_website_channel_binding(self, website_id: int, channel_id: str) -> bool:
        """添加网站频道绑定"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO website_channel_bindings (website_id, channel_id)
                    VALUES (?, ?)
                ''', (website_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"添加网站频道绑定失败: {e}")
            return False

    def remove_website_channel_binding(self, website_id: int, channel_id: str) -> bool:
        """移除网站频道绑定"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ? AND channel_id = ?
                ''', (website_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"移除网站频道绑定失败: {e}")
            return False

    def generate_website_urls(self, weidian_id: str) -> List[Dict]:
        """根据微店ID生成所有网站的URL"""
        try:
            website_configs = self.get_website_configs()
            urls = []

            for config in website_configs:
                try:
                    # 替换URL模板中的{id}占位符
                    url = config['url_template'].replace('{id}', weidian_id)
                    urls.append({
                        'name': config['name'],
                        'display_name': config['display_name'],
                        'url': url,
                        'badge_color': config['badge_color'],
                        'channels': self.get_website_channel_bindings(config['id'])
                    })
                except Exception as e:
                    logger.warning(f"生成网站URL失败 {config['name']}: {e}")

            return urls
        except Exception as e:
            logger.error(f"生成网站URL失败: {e}")
            return []

    def get_system_stats(self) -> Dict:
        """获取系统统计信息"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 获取店铺数量（从shops表统计）
                cursor.execute("SELECT COUNT(*) FROM shops")
                shop_count = cursor.fetchone()[0] or 0

                # 获取商品数量
                cursor.execute("SELECT COUNT(*) FROM products")
                product_count = cursor.fetchone()[0] or 0

                # 获取图片数量
                cursor.execute("SELECT COUNT(*) FROM product_images")
                image_count = cursor.fetchone()[0] or 0

                # 获取用户数量
                cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
                user_count = cursor.fetchone()[0] or 0

                return {
                    'shop_count': shop_count,
                    'product_count': product_count,
                    'image_count': image_count,
                    'user_count': user_count
                }
        except Exception as e:
            logger.error(f"获取系统统计信息失败: {e}")
            return {'shop_count': 0, 'product_count': 0, 'image_count': 0, 'user_count': 0}

    def get_active_announcements(self) -> List[Dict]:
        """获取活跃的系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, title, content, created_at, updated_at
                    FROM system_announcements
                    WHERE is_active = 1
                    ORDER BY updated_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取系统公告失败: {e}")
            return []

    def create_announcement(self, title: str, content: str) -> bool:
        """创建系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO system_announcements (title, content)
                    VALUES (?, ?)
                ''', (title, content))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"创建系统公告失败: {e}")
            return False

    def update_announcement(self, announcement_id: int, title: str, content: str, is_active: bool) -> bool:
        """更新系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE system_announcements
                    SET title = ?, content = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (title, content, is_active, announcement_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新系统公告失败: {e}")
            return False

    def delete_announcement(self, announcement_id: int) -> bool:
        """删除系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM system_announcements WHERE id = ?', (announcement_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除系统公告失败: {e}")
            return False

    def get_message_filters(self) -> List[Dict]:
        """获取消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, filter_type, filter_value, is_active, created_at
                    FROM message_filters
                    WHERE is_active = 1
                    ORDER BY created_at
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取消息过滤规则失败: {e}")
            return []

    def add_message_filter(self, filter_type: str, filter_value: str) -> bool:
        """添加消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO message_filters (filter_type, filter_value)
                    VALUES (?, ?)
                ''', (filter_type, filter_value))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加消息过滤规则失败: {e}")
            return False

    def update_message_filter(self, filter_id: int, filter_type: str, filter_value: str, is_active: bool) -> bool:
        """更新消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE message_filters
                    SET filter_type = ?, filter_value = ?, is_active = ?
                    WHERE id = ?
                ''', (filter_type, filter_value, is_active, filter_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新消息过滤规则失败: {e}")
            return False

    def delete_message_filter(self, filter_id: int) -> bool:
        """删除消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM message_filters WHERE id = ?', (filter_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除消息过滤规则失败: {e}")
            return False

    def get_custom_replies(self) -> List[Dict]:
        """获取自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, reply_type, content, image_url, is_active, priority, created_at
                    FROM custom_replies
                    WHERE is_active = 1
                    ORDER BY priority DESC, created_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取自定义回复内容失败: {e}")
            return []

    def add_custom_reply(self, reply_type: str, content: str = None, image_url: str = None, priority: int = 0) -> bool:
        """添加自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO custom_replies (reply_type, content, image_url, priority)
                    VALUES (?, ?, ?, ?)
                ''', (reply_type, content, image_url, priority))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加自定义回复内容失败: {e}")
            return False

    def update_custom_reply(self, reply_id: int, reply_type: str, content: str = None, image_url: str = None, priority: int = 0, is_active: bool = True) -> bool:
        """更新自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE custom_replies
                    SET reply_type = ?, content = ?, image_url = ?, priority = ?, is_active = ?
                    WHERE id = ?
                ''', (reply_type, content, image_url, priority, is_active, reply_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新自定义回复内容失败: {e}")
            return False

    def delete_custom_reply(self, reply_id: int) -> bool:
        """删除自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM custom_replies WHERE id = ?', (reply_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除自定义回复内容失败: {e}")
            return False

    def get_products_by_user_shops(self, user_shops: List[str], limit: int = None, offset: int = 0) -> Dict:
        """根据用户店铺权限获取商品"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor = conn.cursor()

                if user_shops is None:
                    # 管理员可以看到所有商品（不限制店铺）- 优化查询性能
                    if limit is None or limit <= 0:
                        # 一次性获取所有商品和对应的图片索引
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index ORDER BY pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                        '''
                        cursor.execute(query)
                        rows = cursor.fetchall()

                        # 获取总数
                        cursor.execute('SELECT COUNT(*) FROM products')
                        total = cursor.fetchone()[0]
                    else:
                        # 分页查询 - 使用子查询优化性能
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index ORDER BY pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                            LIMIT ? OFFSET ?
                        '''
                        cursor.execute(query, [limit, offset])
                    rows = cursor.fetchall()

                    # 获取总数
                    cursor.execute('SELECT COUNT(*) FROM products')
                    total = cursor.fetchone()[0]

                    products = []
                    for row in rows:
                        prod = dict(row)
                        # 处理图片路径 - 直接使用预查询的image_indices
                        if prod.get('image_indices'):
                            image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                            prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                        else:
                            prod['images'] = []

                        # 格式化字段名以兼容前端
                        prod['weidianUrl'] = prod.get('product_url')
                        prod['englishTitle'] = prod.get('english_title') or ''
                        prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                        prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                        prod['createdAt'] = prod.get('created_at')
                        prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                        prod['shopName'] = prod.get('shop_name') or '未知店铺'

                        # 提取微店ID
                        try:
                            import re
                            m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                            prod['weidianId'] = m.group(1) if m else ''
                        except:
                            prod['weidianId'] = ''

                        products.append(prod)

                    return {'products': products, 'total': total}

                elif not user_shops:
                    # 如果用户没有店铺权限，返回空结果
                    return {'products': [], 'total': 0}

                # 确保user_shops是list类型
                if not isinstance(user_shops, list):
                    user_shops = []

                # 根据shop_id找到对应的shop_name
                shop_names = []
                for shop_id in user_shops:
                    cursor.execute("SELECT name FROM shops WHERE shop_id = ?", (shop_id,))
                    shop_row = cursor.fetchone()
                    if shop_row:
                        shop_names.append(shop_row[0])

                if not shop_names:
                    # 如果没有找到对应的店铺名称，返回空结果
                    return {'products': [], 'total': 0}

                # 构建IN查询 - 优化性能
                placeholders = ','.join('?' * len(shop_names))
                if limit is None or limit <= 0:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index ORDER BY pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                    '''
                    cursor.execute(query, shop_names)
                    rows = cursor.fetchall()

                    # 获取总数
                    count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                    cursor.execute(count_query, shop_names)
                    total = cursor.fetchone()[0]
                else:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index ORDER BY pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                        LIMIT ? OFFSET ?
                    '''
                    cursor.execute(query, shop_names + [limit, offset])
                rows = cursor.fetchall()

                # 获取总数
                count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                cursor.execute(count_query, shop_names)
                total = cursor.fetchone()[0]

                products = []
                for row in rows:
                    prod = dict(row)
                    # 处理图片路径 - 直接使用预查询的image_indices
                    if prod.get('image_indices'):
                        image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                        prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                    else:
                        prod['images'] = []

                    # 格式化字段名以兼容前端
                    prod['weidianUrl'] = prod.get('product_url')
                    prod['englishTitle'] = prod.get('english_title') or ''
                    prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                    prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                    prod['createdAt'] = prod.get('created_at')
                    prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                    prod['shopName'] = prod.get('shop_name') or '未知店铺'
                    prod['customReplyText'] = prod.get('custom_reply_text') or ''
                    # 解析自定义回复图片索引
                    try:
                        custom_reply_images = prod.get('custom_reply_images')
                        if custom_reply_images:
                            prod['selectedImageIndexes'] = json.loads(custom_reply_images)
                        else:
                            prod['selectedImageIndexes'] = []
                    except:
                        prod['selectedImageIndexes'] = []

                    # 提取微店ID
                    try:
                        import re
                        m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                        prod['weidianId'] = m.group(1) if m else ''
                    except:
                        prod['weidianId'] = ''

                    products.append(prod)

                return {'products': products, 'total': total}

        except Exception as e:
            print(f"DEBUG: Exception in get_products_by_user_shops: {type(e).__name__}: {e}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            logger.error("获取用户商品失败: %s", str(e))
            return {'products': [], 'total': 0}

    def get_global_reply_config(self) -> Dict[str, float]:
        """获取全局回复延迟配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT min_delay, max_delay FROM global_reply_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {'min_delay': row[0], 'max_delay': row[1]}
                return {'min_delay': 3.0, 'max_delay': 8.0}  # 默认值
        except Exception as e:
            logger.error(f"获取全局回复配置失败: {e}")
            return {'min_delay': 3.0, 'max_delay': 8.0}

    def update_global_reply_config(self, min_delay: float, max_delay: float) -> bool:
        """更新全局回复延迟配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE global_reply_config
                    SET min_delay = ?, max_delay = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''', (min_delay, max_delay))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新全局回复配置失败: {e}")
            return False

    def get_system_config(self) -> Dict[str, any]:
        """获取系统配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id FROM system_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_channel_id': row[0] or '',
                        'discord_similarity_threshold': row[1] or 0.6,
                        'cnfans_channel_id': row[2] or '',
                        'acbuy_channel_id': row[3] or ''
                    }
                # 如果没有配置记录，创建默认配置
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')
                conn.commit()
                return {
                    'discord_channel_id': '',
                    'discord_similarity_threshold': 0.6
                }
        except Exception as e:
            logger.error(f"获取系统配置失败: {e}")
            return {
                'discord_channel_id': '',
                'discord_similarity_threshold': 0.6
            }

    def get_user_settings(self, user_id: int) -> Dict[str, any]:
        """获取用户个性化设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT discord_similarity_threshold, global_reply_min_delay, global_reply_max_delay,
                           user_blacklist, keyword_filters
                    FROM user_settings WHERE user_id = ?
                ''', (user_id,))
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_similarity_threshold': row[0] or 0.6,
                        'global_reply_min_delay': row[1] or 3.0,
                        'global_reply_max_delay': row[2] or 8.0,
                        'user_blacklist': row[3] or '',
                        'keyword_filters': row[4] or '',
                    }
                # 如果用户没有设置，返回默认值
                return {
                    'discord_similarity_threshold': 0.6,
                    'global_reply_min_delay': 3.0,
                    'global_reply_max_delay': 8.0,
                    'user_blacklist': '',
                    'keyword_filters': '',
                }
        except Exception as e:
            logger.error(f"获取用户设置失败: {e}")
            return {
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'global_reply_min_delay': 3.0,
                'global_reply_max_delay': 8.0,
                'user_blacklist': '',
                'keyword_filters': '',
            }

    def update_user_settings(self, user_id: int, discord_similarity_threshold: float = None,
                           global_reply_min_delay: float = None, global_reply_max_delay: float = None,
                           user_blacklist: str = None, keyword_filters: str = None) -> bool:
        """更新用户个性化设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 检查用户是否已有设置
                cursor.execute('SELECT id FROM user_settings WHERE user_id = ?', (user_id,))
                existing = cursor.fetchone()

                if existing:
                    # 更新现有设置
                    update_fields = []
                    params = []


                    if discord_similarity_threshold is not None:
                        update_fields.append('discord_similarity_threshold = ?')
                        params.append(discord_similarity_threshold)

                    if global_reply_min_delay is not None:
                        update_fields.append('global_reply_min_delay = ?')
                        params.append(global_reply_min_delay)

                    if global_reply_max_delay is not None:
                        update_fields.append('global_reply_max_delay = ?')
                        params.append(global_reply_max_delay)

                    if user_blacklist is not None:
                        update_fields.append('user_blacklist = ?')
                        params.append(user_blacklist)

                    if keyword_filters is not None:
                        update_fields.append('keyword_filters = ?')
                        params.append(keyword_filters)

                    if update_fields:
                        update_fields.append('updated_at = CURRENT_TIMESTAMP')
                        sql = f'UPDATE user_settings SET {", ".join(update_fields)} WHERE user_id = ?'
                        params.append(user_id)
                        cursor.execute(sql, params)
                else:
                    # 插入新设置
                    cursor.execute('''
                        INSERT INTO user_settings
                        (user_id, discord_similarity_threshold, global_reply_min_delay, global_reply_max_delay,
                         user_blacklist, keyword_filters)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (
                        user_id,
                        discord_similarity_threshold or 0.6,
                        global_reply_min_delay or 3.0,
                        global_reply_max_delay or 8.0,
                        user_blacklist or '',
                        keyword_filters or ''
                    ))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户设置失败: {e}")
            return False

    def update_system_config(self, discord_channel_id: str = None, discord_similarity_threshold: float = None,
                           cnfans_channel_id: str = None, acbuy_channel_id: str = None) -> bool:
        """更新系统配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 首先确保配置记录存在
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')

                # 构建更新语句
                update_fields = []
                params = []

                if discord_channel_id is not None:
                    update_fields.append('discord_channel_id = ?')
                    params.append(discord_channel_id)

                if discord_similarity_threshold is not None:
                    update_fields.append('discord_similarity_threshold = ?')
                    params.append(discord_similarity_threshold)

                if cnfans_channel_id is not None:
                    update_fields.append('cnfans_channel_id = ?')
                    params.append(cnfans_channel_id)

                if acbuy_channel_id is not None:
                    update_fields.append('acbuy_channel_id = ?')
                    params.append(acbuy_channel_id)

                if update_fields:
                    update_fields.append('updated_at = CURRENT_TIMESTAMP')
                    sql = f'UPDATE system_config SET {", ".join(update_fields)} WHERE id = 1'
                    cursor.execute(sql, params)
                    conn.commit()
                    return True
                return False
        except Exception as e:
            logger.error(f"更新系统配置失败: {e}")
            return False

    # ===== 店铺管理方法 =====

    def add_shop(self, shop_id: str, name: str) -> bool:
        """添加新店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 检查店铺是否已存在
                cursor.execute('SELECT id FROM shops WHERE shop_id = ?', (shop_id,))
                if cursor.fetchone():
                    logger.warning(f"店铺 {shop_id} 已存在")
                    return False

                cursor.execute('''
                    INSERT INTO shops (shop_id, name, product_count)
                    VALUES (?, ?, 0)
                ''', (shop_id, name))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加店铺失败: {e}")
            return False

    def get_all_shops(self) -> List[Dict]:
        """获取所有店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops ORDER BY created_at DESC')
                rows = cursor.fetchall()

                shops = []
                for row in rows:
                    shops.append({
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    })
                return shops
        except Exception as e:
            logger.error(f"获取店铺列表失败: {e}")
            return []

    def get_shop_by_id(self, shop_id: str) -> Optional[Dict]:
        """根据shop_id获取店铺信息"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops WHERE shop_id = ?', (shop_id,))
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    }
                return None
        except Exception as e:
            logger.error(f"获取店铺信息失败: {e}")
            return None

    def update_shop_product_count(self, shop_id: str, product_count: int) -> bool:
        """更新店铺的商品数量"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE shops
                    SET product_count = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE shop_id = ?
                ''', (product_count, shop_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新店铺商品数量失败: {e}")
            return False

    def delete_shop(self, shop_id: str) -> bool:
        """删除店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM shops WHERE shop_id = ?', (shop_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除店铺失败: {e}")
            return False

    # ========== 抓取状态管理方法 ==========

    def get_scrape_status(self) -> Dict:
        """获取抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM scrape_status WHERE id = 1')
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'is_scraping': bool(row[1]),
                        'paused': bool(row[2]),
                        'stop_signal': bool(row[3]),
                        'current_shop_id': row[4],
                        'total': row[5] or 0,
                        'processed': row[6] or 0,
                        'success': row[7] or 0,
                        'progress': row[8] or 0.0,
                        'message': row[9] or '等待开始...',
                        'completed': bool(row[10]),
                        'thread_id': row[11],
                        'updated_at': row[12]
                    }
                else:
                    # 如果没有记录，创建默认记录
                    return self.reset_scrape_status()

        except Exception as e:
            logger.error(f"获取抓取状态失败: {e}")
            return {
                'is_scraping': False,
                'paused': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': '获取状态失败',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

    def update_scrape_status(self, **kwargs) -> bool:
        """更新抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 构建更新语句
                fields = []
                values = []
                for key, value in kwargs.items():
                    if key in ['is_scraping', 'paused', 'stop_signal', 'completed']:
                        fields.append(f'{key} = ?')
                        values.append(1 if value else 0)
                    elif key in ['total', 'processed', 'success']:
                        fields.append(f'{key} = ?')
                        values.append(int(value) if value is not None else 0)
                    elif key == 'progress':
                        fields.append(f'{key} = ?')
                        values.append(float(value) if value is not None else 0.0)
                    elif key in ['current_shop_id', 'message', 'thread_id']:
                        fields.append(f'{key} = ?')
                        values.append(str(value) if value is not None else None)

                if fields:
                    fields.append('updated_at = CURRENT_TIMESTAMP')
                    query = f'UPDATE scrape_status SET {", ".join(fields)} WHERE id = 1'
                    cursor.execute(query, values)
                    conn.commit()
                    return cursor.rowcount > 0

                return False

        except Exception as e:
            logger.error(f"更新抓取状态失败: {e}")
            return False

    def reset_scrape_status(self) -> Dict:
        """重置抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scrape_status SET
                        is_scraping = 0,
                        paused = 0,
                        stop_signal = 0,
                        current_shop_id = NULL,
                        total = 0,
                        processed = 0,
                        success = 0,
                        progress = 0,
                        message = '等待开始...',
                        completed = 0,
                        thread_id = NULL,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''')
                conn.commit()

                return {
                    'is_scraping': False,
                    'paused': False,
                    'stop_signal': False,
                    'current_shop_id': None,
                    'total': 0,
                    'processed': 0,
                    'success': 0,
                    'progress': 0.0,
                    'message': '等待开始...',
                    'completed': False,
                    'thread_id': None,
                    'updated_at': None
                }

        except Exception as e:
            logger.error(f"重置抓取状态失败: {e}")
            return {
                'is_scraping': False,
                'paused': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': '重置失败',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

# 全局数据库实例
db = Database()

--- File: ./backend/weidian_scraper.py ---
import requests
import re
import json
import time
import logging
from urllib.parse import urlparse, parse_qs, quote
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class WeidianScraper:
    """微店商品信息爬虫 - 使用官方API"""

    def __init__(self):
        self.session = requests.Session()
        # 修复：更新 Headers，完全匹配你的 CURL 请求
        self.session.headers.update({
            'accept': 'application/json, */*',  # 注意：curl中是 application/json, / 但实际应该是 /*
            'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'origin': 'https://weidian.com',
            'priority': 'u=1, i',
            'referer': 'https://weidian.com/',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-site',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
        })

        # 修复：更新 Cookies
        self.session.cookies.update({
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '6',
            '__spider__sessionid': 'e0e858ac8efb20a2'
        })

    def extract_item_id(self, url: str) -> Optional[str]:
        """从微店URL中提取商品ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # 尝试从路径中提取
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # 尝试其他格式
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"提取商品ID失败: {e}")
            return None

    def extract_item_id(self, url: str) -> Optional[str]:
        """从微店URL中提取商品ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # 尝试从路径中提取
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # 尝试其他格式
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"提取商品ID失败: {e}")
            return None

    def scrape_product_info(self, url: str) -> Optional[Dict]:
        """
        抓取微店商品信息 - 使用官方API
        返回包含标题、描述、图片等信息的字典
        """
        try:
            item_id = self.extract_item_id(url)
            if not item_id:
                logger.error(f"无法从URL提取商品ID: {url}")
                return None

            logger.info(f"开始抓取商品: {item_id}")

            # 获取店铺信息
            shop_name = self._get_shop_name(url)
            if shop_name == "未知店铺":
                logger.info("店铺名称获取失败，尝试从页面HTML提取")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # 尝试从JavaScript数据中提取店铺名称
                        shop_name_pattern = r'"shopName"[^:]*:[^"]*"([^"]+)"'
                        match = re.search(shop_name_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            shop_name = match.group(1).strip()
                            logger.info(f"✅ 从JavaScript数据获取到店铺名称: {shop_name}")
                except Exception as e:
                    logger.warning(f"从页面提取店铺名称失败: {e}")

            # 使用官方API获取商品信息
            product_info = self._scrape_by_api(item_id, url, shop_name)
            if product_info:
                logger.info(f"✅ 商品信息抓取成功: {product_info.get('title', 'Unknown')}")
                return product_info

            # 如果API失败，返回None
            logger.error("API抓取失败，没有备用方法")
            return None

        except Exception as e:
            logger.error(f"商品信息抓取失败: {e}")
            return None

    def _scrape_by_api(self, item_id: str, url: str, shop_name: str = '') -> Optional[Dict]:
        """使用微店官方API抓取商品信息"""
        try:
            # 获取商品标题和SKU信息
            title_info = self._get_item_title_and_sku(item_id)
            title = title_info.get('title', '') if title_info else ''

            # 如果API获取失败，尝试从页面HTML中提取商品标题
            if not title:
                logger.info("API获取标题失败，尝试从页面HTML提取")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # 从页面HTML中提取商品标题
                        title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                        match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            title = match.group(1).strip()
                            logger.info(f"✅ 从页面HTML获取到商品标题: {title}")
                        else:
                            title = f'微店商品 {item_id}'
                except Exception as e:
                    logger.warning(f"从页面HTML提取标题失败: {e}")
                    title = f'微店商品 {item_id}'
            else:
                title = title

            # 获取商品图片信息（即使标题获取失败也要尝试获取图片）
            image_info = self._get_item_images(item_id)
            images = image_info if image_info else []

            # 如果既没有标题也没有图片，返回None
            if not title and not images:
                logger.error("无法获取商品标题和图片信息")
                return None

            # 构建商品信息
            product_info = {
                'id': item_id,
                'weidian_url': url,
                'cnfans_url': f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN",
                'acbuy_url': f"https://www.acbuy.com/product?url=https%253A%252F%252Fweidian.com%252Fitem.html%253FitemID%253D{item_id}%2526spider_token%253D43fe&id={item_id}&source=WD",
                'images': images,
                'title': title,
                'english_title': self._generate_english_title(title),
                'description': f"微店商品ID: {item_id}",
                'shop_name': shop_name
            }

            return product_info

        except Exception as e:
            logger.error(f"API抓取失败: {e}")
            return None

    def _get_item_title_and_sku(self, item_id: str) -> Optional[Dict]:
        """获取商品标题和SKU信息"""
        try:
            # 构造API URL - 使用更新的格式
            param = json.dumps({"itemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getItemSkuInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.info(f"调用SKU API: {api_url}")  # 修改日志级别为 INFO 以便调试

            # 使用与前端 fetch 完全一致的 headers
            headers = {
                "accept": "application/json, */*",
                "accept-language": "en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"macOS"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "referrer": "https://weidian.com/",
                "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
            }

            # 不带 cookies 发送请求 (有时候 cookies 会导致校验失败)
            response = requests.get(api_url, headers=headers, timeout=15)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"标题API返回状态: {data.get('status', {}).get('code')}")

            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                title = result.get('itemTitle', '')
                if title:
                    return {'title': title, 'sku_info': result}

            # 如果API获取失败，尝试从页面HTML中提取商品标题
            logger.info("API获取标题失败，尝试从页面HTML提取")
            try:
                page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                    'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                    'cache-control': 'max-age=0',
                    'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                    'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '"macOS"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'same-origin',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                }, cookies={
                    'wdtoken': '8ea9315c',
                    '__spider__visitorid': '0dcf6a5b878847ec',
                    'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                    'v-components/cpn-coupon-dialog@nologinshop': '10',
                    '__spider__sessionid': 'e55c6458ac1fdba4'
                })

                if page_response.status_code == 200:
                    # 从页面HTML中提取商品标题
                    title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                    match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                    if match:
                        title = match.group(1).strip()
                        logger.info(f"✅ 从页面HTML获取到商品标题: {title}")
                        return {'title': title, 'sku_info': {}}
            except Exception as e:
                logger.warning(f"从页面HTML提取标题失败: {e}")

            return None

        except Exception as e:
            logger.error(f"获取商品标题失败: {e}")
            return None

    def _get_item_images(self, item_id: str) -> List[str]:
        """获取商品图片信息 - 同时调用两个API并去重"""
        try:
            all_images = []

            # 1. 获取商品详情图片 (原有API)
            detail_images = self._get_detail_images(item_id)
            all_images.extend(detail_images)

            # 2. 获取SKU属性图片 (新API)
            sku_images = self._get_sku_images(item_id)
            all_images.extend(sku_images)

            # 3. 简单URL去重
            unique_images = []
            seen_urls = set()
            for img_url in all_images:
                if img_url and img_url not in seen_urls:
                    unique_images.append(img_url)
                    seen_urls.add(img_url)

            logger.info(f"✅ 商品 {item_id} 图片获取完成: 共 {len(unique_images)} 张 (详情:{len(detail_images)}, SKU:{len(sku_images)})")
            if len(unique_images) > 0:
                logger.info(f"📸 图片URL样例: {unique_images[:3]}")
            return unique_images

        except Exception as e:
            logger.error(f"获取商品图片失败: {e}")
            return []

    def _get_detail_images(self, item_id: str) -> List[str]:
        """获取商品详情图片 (原有API)"""
        try:
            # 构造API URL
            param = json.dumps({"vItemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getDetailDesc/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.debug(f"调用详情图片API: {api_url}")

            # 使用更稳定的请求头，模拟浏览器行为
            import requests
            headers = {
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'origin': 'https://weidian.com',
                'priority': 'u=1, i',
                'referer': 'https://weidian.com/',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-site',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            # 设置cookies
            cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }

            response = requests.get(api_url, timeout=15, proxies={'http': None, 'https': None}, headers=headers, cookies=cookies)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"详情图片API返回状态: {data.get('status', {}).get('code')}")

            images = []
            if data.get('status', {}).get('code') == 0:
                item_detail = data.get('result', {}).get('item_detail', {})
                desc_content = item_detail.get('desc_content', [])

                for item in desc_content:
                    if item.get('type') == 2 and item.get('url'):
                        images.append(item['url'])

            return images

        except Exception as e:
            logger.error(f"获取详情图片失败: {e}")
            return []

    def _get_sku_images(self, item_id: str) -> List[str]:
        """获取SKU属性图片 (新API)"""
        try:
            logger.info(f"开始获取SKU图片，商品ID: {item_id}")
            # 复用 _get_item_title_and_sku 的逻辑
            title_info = self._get_item_title_and_sku(item_id)
            if not title_info or 'sku_info' not in title_info:
                logger.warning(f"无法获取SKU信息，跳过图片提取: {item_id}")
                return []

            result = title_info['sku_info']
            attr_list = result.get('attrList', [])
            logger.info(f"找到 {len(attr_list)} 个属性组")

            images = []
            for i, attr in enumerate(attr_list):
                attr_values = attr.get('attrValues', [])
                logger.info(f"属性组 {i+1} 有 {len(attr_values)} 个属性值")
                for j, attr_value in enumerate(attr_values):
                    # === 修复：从 attrValues 中提取 img ===
                    img_url = attr_value.get('img')
                    if img_url:
                        logger.debug(f"找到SKU图片: {img_url}")
                        # 确保URL格式正确
                        if img_url.startswith('//'):
                            img_url = 'https:' + img_url
                        if img_url not in images:
                            images.append(img_url)

            logger.info(f"从SKU属性中成功提取 {len(images)} 张图片")
            return images
        except Exception as e:
            logger.error(f"获取SKU图片失败: {e}")
            return []


    def _generate_english_title(self, chinese_title: str) -> str:
        """根据中文标题生成英文标题 - 使用免费翻译API"""
        if not chinese_title or len(chinese_title.strip()) == 0:
            return ""
        # 优先使用 Google 免费接口，失败再回退到百度，再回退到简单映射
        try:
            return self._translate_with_google(chinese_title)
        except Exception as e:
            logger.debug(f"Google 翻译失败: {e}")
        try:
            res = self._translate_with_baidu(chinese_title)
            if res:
                return res
        except Exception as e:
            logger.debug(f"百度翻译失败: {e}")
        # 最后备用：简单映射
        return self._simple_chinese_to_english(chinese_title)

    def _translate_with_baidu(self, text: str) -> str:
        """使用百度翻译API"""
        try:
            # 百度翻译免费API
            url = "https://fanyi.baidu.com/transapi"

            params = {
                'from': 'zh',
                'to': 'en',
                'query': text[:200]  # 限制长度
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            data = response.json()
            # 尝试多种可能的返回结构，避免直接抛出异常
            translated = ""
            if isinstance(data, dict):
                try:
                    translated = data.get('data', {}).get('result', [{}])[0].get('dst', '') or ''
                except Exception:
                    translated = ''
                if not translated:
                    if 'trans_result' in data:
                        try:
                            translated = data.get('trans_result', [{}])[0].get('dst', '') or ''
                        except Exception:
                            translated = ''
            if translated:
                return translated.strip()
            logger.debug("百度翻译返回空结果")
            return ""
        except Exception as e:
            logger.warning(f"百度翻译API调用异常: {e}")
            return ""

    def _translate_with_google(self, text: str) -> str:
        """使用Google Translate API的免费版本"""
        try:
            # 使用Google Translate的免费API
            url = "https://translate.googleapis.com/translate_a/single"

            params = {
                'client': 'gtx',
                'sl': 'zh-CN',
                'tl': 'en',
                'dt': 't',
                'q': text[:500]  # 限制长度
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # Google返回的是JSON数组
            data = response.json()
            if data and len(data) > 0 and len(data[0]) > 0:
                translated = data[0][0][0]
                if translated:
                    return translated.strip()

            raise Exception("Google翻译返回空结果")

        except Exception as e:
            logger.error(f"Google翻译API调用失败: {e}")
            raise e

    def _simple_chinese_to_english(self, text: str) -> str:
        """简单的中英映射 - 最后的备用方案"""
        # 简单的商品关键词映射
        mappings = {
            '鞋': 'shoes',
            '运动鞋': 'sports shoes',
            '袜子': 'socks',
            '鞋子': 'shoes',
            '衣服': 'clothes',
            '上衣': 'top',
            '裤子': 'pants',
            '包': 'bag',
            '包包': 'bag',
            '手机': 'phone',
            '电脑': 'computer',
            '耳机': 'headphones',
            '手表': 'watch',
            '眼镜': 'glasses',
            '帽子': 'hat',
            '书': 'book',
            '玩具': 'toy',
            '游戏': 'game'
        }

        result = text
        for cn, en in mappings.items():
            result = result.replace(cn, en)

        # 如果有明显的变化，返回翻译结果，否则返回空
        if result != text:
            return result.strip()
        else:
            return ""


    def download_images(self, image_urls: List[str], save_dir: str, item_id: str) -> List[str]:
        """多线程下载商品图片到本地"""
        import os
        import concurrent.futures
        import threading

        saved_paths = []
        os.makedirs(save_dir, exist_ok=True)

        # 移除图片数量限制，抓取所有可用的图片
        # SKU图片通常排在详情图之后，现在可以获取所有图片
        logger.info(f"准备下载 {len(image_urls)} 张图片（无数量限制）")

        def download_single_image(args):
            """下载单张图片的函数"""
            i, img_url = args
            try:
                # 为每个线程创建独立的session
                thread_session = requests.Session()
                thread_session.headers.update(self.session.headers)
                thread_session.cookies.update(self.session.cookies)

                response = thread_session.get(img_url, timeout=10, proxies={'http': None, 'https': None})
                response.raise_for_status()

                # 保存图片
                img_path = os.path.join(save_dir, f"{item_id}_{i}.jpg")
                with open(img_path, 'wb') as f:
                    f.write(response.content)

                logger.info(f"图片下载成功: {img_path}")
                return img_path

            except Exception as e:
                logger.warning(f"图片下载失败 {img_url}: {e}")
                return None

        # 使用线程池并发下载图片
        try:
            from config import config
        except ImportError:
            from .config import config
        max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))  # 使用配置的下载线程数

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 提交所有下载任务
            future_to_image = {
                executor.submit(download_single_image, (i, img_url)): (i, img_url)
                for i, img_url in enumerate(image_urls)
            }

            # 收集结果
            for future in concurrent.futures.as_completed(future_to_image):
                result = future.result()
                if result:
                    saved_paths.append(result)

        # 按索引排序结果
        saved_paths.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

        return saved_paths

    def _get_shop_name(self, url: str) -> str:
        """从商品页面获取店铺名称"""
        try:
            logger.debug(f"开始获取店铺名称: {url}")

            # 请求商品页面
            response = self.session.get(url, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # 解码HTML实体（&#34; -> " 等）
            html_content = response.text
            html_content = html_content.replace('&#34;', '"').replace('&#39;', "'").replace('&quot;', '"')

            # 首先尝试最精确的匹配：em标签中的shop-name-str类（根据用户提供的HTML结构）
            shop_name_pattern1 = r'<em[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</em>'
            match = re.search(shop_name_pattern1, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (em shop-name-str): {shop_name}")
                return shop_name

            # 然后尝试更宽泛的匹配，查找包含shop-name-str类的任何元素
            shop_name_pattern2 = r'<[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</[^>]*>'
            match = re.search(shop_name_pattern2, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (通用shop-name-str): {shop_name}")
                return shop_name

            # 尝试匹配class="shop-name-str"的元素（不限定标签类型）
            shop_name_pattern3 = r'class="shop-name-str"[^>]*>([^<]+)</'
            match = re.search(shop_name_pattern3, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (shop-name-str): {shop_name}")
                return shop_name

            # 尝试从JavaScript数据中提取店铺名称（多种格式）
            # 格式1: "shopName":"Aiseo"
            shop_name_pattern4 = r'"shopName"\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern4, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript): {shop_name}")
                return shop_name

            # 格式2: \"shopName\":\"Aiseo\" (在HTML中被转义)
            shop_name_pattern5 = r'\\"shopName\\"\s*:\s*\\"([^\\"]+)\\"'
            match = re.search(shop_name_pattern5, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript转义): {shop_name}")
                return shop_name

            # 格式3: shopName:"Aiseo" (无引号)
            shop_name_pattern6 = r'shopName\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern6, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript无引号): {shop_name}")
                return shop_name

            logger.warning("未找到店铺名称，使用默认名称")
            return "未知店铺"

        except Exception as e:
            logger.error(f"获取店铺名称失败: {e}")
            return "未知店铺"

    def close(self):
        """关闭资源 - 占位方法"""
        pass

# 全局爬虫实例
_scraper = None

def get_weidian_scraper() -> WeidianScraper:
    """获取微店爬虫实例"""
    global _scraper
    if _scraper is None:
        _scraper = WeidianScraper()
    return _scraper

--- File: ./backend/bot_config.py ---
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = float(os.getenv('DISCORD_SIMILARITY_THRESHOLD', '0.6'))  # Discord机器人相似度阈值

    # 全局回复延迟配置
    GLOBAL_REPLY_MIN_DELAY = int(os.getenv('GLOBAL_REPLY_MIN_DELAY', '3'))  # 全局最小延迟秒数
    GLOBAL_REPLY_MAX_DELAY = int(os.getenv('GLOBAL_REPLY_MAX_DELAY', '8'))  # 全局最大延迟秒数

    # 关键词转发配置
    FORWARD_KEYWORDS = os.getenv('FORWARD_KEYWORDS', '商品,货源,进货,批发,代理').split(',')  # 触发转发的关键词
    FORWARD_TARGET_CHANNEL_ID = int(os.getenv('FORWARD_TARGET_CHANNEL_ID', 0)) if os.getenv('FORWARD_TARGET_CHANNEL_ID') else 0  # 转发目标频道ID

    # API服务地址（本地服务）
    NEXTJS_API_URL = 'http://localhost:5001/api'
    PADDLE_SERVICE_URL = 'http://localhost:5001'

    # 机器人配置
    COMMAND_PREFIX = '!'

config = Config()

--- File: ./backend/bot.py ---
import discord
import aiohttp
import logging
import time
import asyncio
import random
import os
import json
import io
from datetime import datetime
try:
    from config import config
except ImportError:
    from .config import config

# 全局变量用于多账号机器人管理
bot_clients = []
bot_tasks = []

def get_response_url_for_channel(product, channel_id):
    """根据频道ID决定发送哪个链接"""
    channel_id_str = str(channel_id)

    # 如果是CNFans频道，优先发送CNFans链接
    if config.CNFANS_CHANNEL_ID and channel_id_str == config.CNFANS_CHANNEL_ID:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        elif product.get('acbuyUrl'):
            return product['acbuyUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

    # 如果是AcBuy频道，优先发送AcBuy链接
    elif config.ACBUY_CHANNEL_ID and channel_id_str == config.ACBUY_CHANNEL_ID:
        if product.get('acbuyUrl'):
            return product['acbuyUrl']
        elif product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

    # 其他频道默认发送CNFans链接，如果没有则发送微店链接
    else:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

class HTTPLogHandler(logging.Handler):
    """通过HTTP发送日志到Flask应用"""
    def __init__(self):
        super().__init__()
        self.pending_logs = []
        self.is_sending = False

    def emit(self, record):
        try:
            # 只发送我们关心的日志级别
            if record.levelno >= logging.INFO:
                log_data = {
                    'timestamp': datetime.now().isoformat(),
                    'level': record.levelname,
                    'message': self.format(record),
                    'module': record.module,
                    'func': record.funcName
                }

                # 添加到待发送队列
                self.pending_logs.append(log_data)

                # 如果没有正在发送，启动发送任务
                if not self.is_sending:
                    # 在机器人的事件循环中创建任务
                    try:
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            loop.create_task(self.send_pending_logs())
                        else:
                            # 如果循环没有运行，直接发送（同步方式）
                            self.send_sync(log_data)
                    except RuntimeError:
                        # 没有事件循环，直接同步发送
                        self.send_sync(log_data)

        except Exception as e:
            print(f"HTTP日志处理器错误: {e}")

    def send_sync(self, log_data):
        """同步发送日志（作为fallback）"""
        try:
            import requests
            response = requests.post('http://localhost:5001/api/logs/add',
                                   json=log_data, timeout=2)
            if response.status_code != 200:
                print(f"同步发送日志失败: {response.status_code}")
        except Exception as e:
            print(f"同步发送日志异常: {e}")

    async def send_pending_logs(self):
        """异步发送待处理的日志"""
        if self.is_sending:
            return

        self.is_sending = True

        try:
            while self.pending_logs:
                log_data = self.pending_logs.pop(0)

                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.post('http://localhost:5001/api/logs/add',
                                              json=log_data, timeout=aiohttp.ClientTimeout(total=2)) as resp:
                            if resp.status != 200:
                                print(f"发送日志失败: {resp.status}")
                except Exception as e:
                    print(f"发送日志异常: {e}")
                    # 重新放回队列
                    self.pending_logs.insert(0, log_data)
                    break

                # 小延迟避免发送太快
                await asyncio.sleep(0.1)

        finally:
            self.is_sending = False

# 配置日志
logging.basicConfig(level=logging.INFO)

# 添加HTTP日志处理器
http_handler = HTTPLogHandler()
http_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(http_handler)

logger = logging.getLogger(__name__)

# 确保discord库也使用我们的日志配置
logging.getLogger('discord').setLevel(logging.INFO)

class DiscordBotClient(discord.Client):
    def __init__(self, account_id=None, user_id=None, user_shops=None):
        # discord.py-self 可能不需要 intents，或者使用不同的语法
        try:
            # 尝试使用标准的 intents
            intents = discord.Intents.default()
            intents.message_content = True
            intents.messages = True
            intents.guilds = True
            super().__init__(intents=intents)
        except AttributeError:
            # 如果 Intents 不存在，直接初始化（discord.py-self 可能不需要）
            super().__init__()
        self.current_token = None
        self.running = False
        self.account_id = account_id
        self.user_id = user_id  # 用户ID，用于获取个性化设置
        self.user_shops = user_shops  # 用户管理的店铺列表

    def _should_filter_message(self, message):
        """检查消息是否应该被过滤"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 1. 检查全局消息过滤规则
            filters = db.get_message_filters()
            message_content = message.content.lower()

            for filter_rule in filters:
                filter_value = filter_rule['filter_value'].lower()
                filter_type = filter_rule['filter_type']

                if filter_type == 'contains':
                    if filter_value in message_content:
                        logger.info(f'消息被过滤: 包含 "{filter_value}"')
                        return True
                elif filter_type == 'starts_with':
                    if message_content.startswith(filter_value):
                        logger.info(f'消息被过滤: 以 "{filter_value}" 开头')
                        return True
                elif filter_type == 'ends_with':
                    if message_content.endswith(filter_value):
                        logger.info(f'消息被过滤: 以 "{filter_value}" 结尾')
                        return True
                elif filter_type == 'regex':
                    import re
                    try:
                        if re.search(filter_value, message_content, re.IGNORECASE):
                            logger.info(f'消息被过滤: 匹配正则 "{filter_value}"')
                            return True
                    except re.error:
                        logger.warning(f'无效的正则表达式: {filter_value}')
                elif filter_type == 'user_id':
                    # 检查用户ID过滤
                    filter_user_ids = [uid.strip() for uid in filter_value.split(',') if uid.strip()]
                    sender_id = str(message.author.id)
                    sender_name = str(message.author.name).lower()

                    for blocked_id in filter_user_ids:
                        blocked_id = blocked_id.strip()
                        if blocked_id == sender_id or blocked_id.lower() in sender_name:
                            logger.info(f'消息被过滤: 用户 {message.author.name} (ID: {sender_id}) 在过滤列表中')
                            return True

            # 2. 检查用户个性化设置的过滤规则
            if self.user_id:
                user_settings = db.get_user_settings(self.user_id)
                if user_settings:
                    # 检查用户黑名单
                    user_blacklist = user_settings.get('user_blacklist', '')
                    if user_blacklist:
                        blacklist_users = [u.strip().lower() for u in user_blacklist.split(',') if u.strip()]
                        sender_name = str(message.author.name).lower()
                        sender_id = str(message.author.id).lower()

                        for blocked_user in blacklist_users:
                            blocked_user = blocked_user.lower()
                            if blocked_user in sender_name or blocked_user == sender_id:
                                logger.info(f'消息被过滤: 用户 {message.author.name} 在黑名单中')
                                return True

                    # 检查关键词过滤
                    keyword_filters = user_settings.get('keyword_filters', '')
                    if keyword_filters:
                        filter_keywords = [k.strip().lower() for k in keyword_filters.split(',') if k.strip()]

                        for keyword in filter_keywords:
                            if keyword in message_content:
                                logger.info(f'消息被过滤: 包含关键词 "{keyword}"')
                                return True

        except Exception as e:
            logger.error(f'检查消息过滤失败: {e}')

        return False

    def _get_custom_reply(self):
        """获取自定义回复内容"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            replies = db.get_custom_replies()

            if replies:
                # 返回优先级最高的活跃回复
                return replies[0]
        except Exception as e:
            logger.error(f'获取自定义回复失败: {e}')

        return None

    async def on_ready(self):
        logger.info(f'Discord机器人已登录: {self.user} (ID: {self.user.id})')
        logger.info(f'机器人已就绪，开始监听消息')
        logger.info(f'监听频道: {config.DISCORD_CHANNEL_ID or "所有频道"}')
        self.running = True

        # 更新数据库中的账号状态为在线
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            if hasattr(self, 'account_id'):
                db.update_account_status(self.account_id, 'online')
                logger.info(f'账号 {self.account_id} 状态已更新为在线')
        except Exception as e:
            logger.error(f'更新账号状态失败: {e}')

    async def on_message(self, message):
        if not self.running:
            return

        # 忽略自己的消息
        if message.author == self.user:
            return

        # 忽略机器人和webhook的消息
        if message.author.bot or message.webhook_id:
            return

        # 如果配置了频道ID，只处理特定频道的消息；否则处理所有频道
        if config.DISCORD_CHANNEL_ID and str(message.channel.id) != str(config.DISCORD_CHANNEL_ID):
            return

        # 检查消息过滤规则
        if self._should_filter_message(message):
            return

        logger.info(f'收到消息: {message.author.name} 在 #{message.channel.name}: "{message.content[:100]}{"..." if len(message.content) > 100 else ""}"')

        # 处理关键词消息转发
        await self.handle_keyword_forward(message)

        # 处理关键词搜索（文字消息）
        await self.handle_keyword_search(message)

        # 检查消息是否包含图片（只处理图片，不处理文字）
        if message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and attachment.content_type.startswith('image/'):
                    await self.handle_image(message, attachment)
                    # 如果消息包含图片，不再处理文字内容，避免重复回复

    async def handle_image(self, message, attachment):
        try:
            # 下载图片，设置较短的超时时间和重试机制
            timeout = aiohttp.ClientTimeout(total=10, connect=5)  # 10秒总超时，5秒连接超时
            image_data = None

            # 重试最多3次
            for attempt in range(3):
                try:
                    logger.info(f"下载Discord图片 (尝试 {attempt + 1}/3): {attachment.filename}")
                    async with aiohttp.ClientSession(timeout=timeout) as session:
                        async with session.get(attachment.url) as resp:
                            if resp.status == 200:
                                image_data = await resp.read()
                                logger.info(f"图片下载成功，大小: {len(image_data)} bytes")
                                break
                            else:
                                logger.warning(f"图片下载失败，状态码: {resp.status}")
                except aiohttp.ClientError as e:
                    logger.warning(f"图片下载失败 (尝试 {attempt + 1}/3): {e}")
                    if attempt < 2:  # 不是最后一次尝试
                        await asyncio.sleep(1)  # 等待1秒后重试
                except Exception as e:
                    logger.error(f"图片下载未知错误 (尝试 {attempt + 1}/3): {e}")
                    break

            if image_data is None:
                logger.error("图片下载失败，已达到最大重试次数")
                return  # 静默失败，不发送错误消息

            # 调用 DINOv2 服务识别图片，根据用户权限过滤结果
            result = await self.recognize_image(image_data, self.user_shops)

            logger.info(f'图片识别结果: success={result.get("success") if result else False}, results_count={len(result.get("results", [])) if result else 0}')

            if result and result.get('success') and result.get('results'):
                # 获取最佳匹配结果
                best_match = result['results'][0]
                similarity = best_match.get('similarity', 0)

                # 获取用户个性化相似度阈值，如果没有则使用全局默认值
                user_threshold = config.DISCORD_SIMILARITY_THRESHOLD  # 默认值
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        user_settings = db.get_user_settings(self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            user_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'获取用户相似度设置失败: {e}')

                logger.info(f'最佳匹配相似度: {similarity:.4f}, 用户阈值: {user_threshold:.4f}')

                # 检查相似度是否超过用户设置的阈值，或者是否为高质量匹配（相似度>0.8）
                if similarity >= user_threshold or similarity > 0.8:
                    product = best_match.get('product', {})
                    logger.info(f'✅ 匹配成功! 相似度: {similarity:.2f} | 商品: {product.get("id")} | 频道: {message.channel.name}')

                    # 模拟打字状态并延迟回复
                    async with message.channel.typing():
                        # === 修复延迟逻辑 ===
                        # 直接读取配置，不设硬性下限，允许 0.1s
                        min_d = max(0.1, float(config.GLOBAL_REPLY_MIN_DELAY))
                        max_d = max(min_d, float(config.GLOBAL_REPLY_MAX_DELAY))

                        delay = random.uniform(min_d, max_d)
                        await asyncio.sleep(delay)

                    # 检查商品是否启用了自动回复规则
                    product_rule_enabled = product.get('ruleEnabled', True)

                    if product_rule_enabled:
                        # 使用全局自定义回复
                    custom_reply = self._get_custom_reply()

                    if custom_reply:
                        reply_type = custom_reply.get('reply_type')

                        if reply_type == 'custom_only':
                            # 只发送自定义内容，不发送链接
                            if custom_reply.get('content'):
                                await message.reply(custom_reply['content'])
                            if custom_reply.get('image_url'):
                                # 这里可以实现发送图片的逻辑
                                pass

                        elif reply_type == 'text_and_link':
                            # 发送文字 + 链接
                            response = get_response_url_for_channel(product, message.channel.id)
                            full_reply = f"{custom_reply.get('content', '')}\n{response}".strip()
                            await message.reply(full_reply)

                        elif reply_type == 'text':
                            # 只发送文字
                            if custom_reply.get('content'):
                                await message.reply(custom_reply['content'])

                        elif reply_type == 'image':
                            # 发送图片（如果设置了的话）
                            if custom_reply.get('image_url'):
                                # 这里可以实现发送图片的逻辑
                                pass
                    else:
                        # 默认行为：发送链接
                        response = get_response_url_for_channel(product, message.channel.id)
                        await message.reply(response)
                    else:
                        # 商品级自定义回复
                        custom_text = product.get('custom_reply_text', '').strip()
                        custom_image_indexes = product.get('selectedImageIndexes', [])
                        custom_image_urls = product.get('customImageUrls', [])

                        # 发送自定义文本消息
                        if custom_text:
                            await message.reply(custom_text)

                        # 发送图片（按优先级：本地上传 > 自定义链接 > 商品图片）
                        images_sent = False

                        # 优先检查图片来源类型
                        image_source = product.get('image_source', 'product')

                        if image_source == 'upload':
                            # 发送本地上传的图片
                            try:
                                from database import db
                                # 获取该商品的所有图片（包括上传的）
                                product_images = db.get_product_images(product['id'])
                                if product_images:
                                    for img_data in product_images[:10]:  # 最多发送10张图片
                                        try:
                                            image_path = img_data.get('image_path')
                                            # 如果是相对路径，构建完整路径
                                            if image_path and not os.path.isabs(image_path):
                                                image_path = os.path.join(os.path.dirname(__file__), image_path)
                                            if image_path and os.path.exists(image_path):
                                                await message.reply(file=discord.File(image_path, os.path.basename(image_path)))
                                                images_sent = True
                                        except Exception as e:
                                            logger.error(f'发送本地上传图片失败: {e}')
                            except Exception as e:
                                logger.error(f'处理本地上传图片回复失败: {e}')

                        elif image_source == 'custom' and custom_image_urls and len(custom_image_urls) > 0:
                            # 发送自定义图片链接
                            try:
                                import aiohttp
                                for url in custom_image_urls[:10]:  # 最多发送10张图片
                                    try:
                                        async with aiohttp.ClientSession() as session:
                                            async with session.get(url.strip()) as resp:
                                                if resp.status == 200:
                                                    image_data = await resp.read()
                                                    # 从URL提取文件名
                                                    filename = url.split('/')[-1].split('?')[0] or f"image_{custom_image_urls.index(url)}.jpg"
                                                    if not filename.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
                                                        filename += '.jpg'
                                                    await message.reply(file=discord.File(io.BytesIO(image_data), filename))
                                                    images_sent = True
                                    except Exception as e:
                                        logger.error(f'发送自定义图片失败 {url}: {e}')
                            except Exception as e:
                                logger.error(f'处理自定义图片回复失败: {e}')

                        elif custom_image_indexes and len(custom_image_indexes) > 0:
                            # 发送选中的商品图片
                            try:
                                import aiofiles
                                import os
                                from database import db

                                for image_index in custom_image_indexes:
                                    try:
                                        # 获取图片路径
                                        image_path = db.get_product_image_path(product['id'], image_index)
                                        if image_path and os.path.exists(image_path):
                                            # 发送图片文件
                                            await message.reply(file=discord.File(image_path, f"image_{image_index}.jpg"))
                                            images_sent = True
                                    except Exception as e:
                                        logger.error(f'发送商品图片失败: {e}')
                            except Exception as e:
                                logger.error(f'处理商品图片回复失败: {e}')

                        # 如果既没有文本也没有图片，则发送默认链接
                        if not custom_text and not images_sent:
                            response = get_response_url_for_channel(product, message.channel.id)
                            await message.reply(response)

                    logger.info(f'图片识别成功，相似度: {similarity:.4f}')
                else:
                    # 相似度低于阈值，不回复任何消息
                    logger.info(f'图片识别相似度 {similarity:.4f} 低于用户阈值 {user_threshold:.4f}，不回复')

        except Exception as e:
            logger.error(f'Error handling image: {e}')
            # 不发送错误消息到Discord，只记录日志

    async def handle_keyword_forward(self, message):
        """处理关键词消息转发"""
        try:
            # 检查消息内容是否包含关键词
            message_content = message.content.lower() if message.content else ""
            has_keyword = any(keyword.strip().lower() in message_content for keyword in config.FORWARD_KEYWORDS)

            if has_keyword and config.FORWARD_TARGET_CHANNEL_ID:
                # 获取目标频道
                target_channel = self.get_channel(config.FORWARD_TARGET_CHANNEL_ID)
                if target_channel:
                    # 构建转发消息
                    forward_embed = discord.Embed(
                        title="📢 商品相关消息转发",
                        description=f"**原始消息:** {message.content[:500]}{'...' if len(message.content) > 500 else ''}",
                        color=0x00ff00,
                        timestamp=message.created_at
                    )

                    forward_embed.add_field(
                        name="发送者",
                        value=f"{message.author.name}#{message.author.discriminator}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="来源频道",
                        value=f"#{message.channel.name}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="服务器",
                        value=message.guild.name if message.guild else "DM",
                        inline=True
                    )

                    # 如果有附件，添加到embed中
                    if message.attachments:
                        attachment_urls = [att.url for att in message.attachments]
                        forward_embed.add_field(
                            name="附件",
                            value="\n".join(attachment_urls),
                            inline=False
                        )

                    forward_embed.set_footer(text=f"消息ID: {message.id}")

                    await target_channel.send(embed=forward_embed)
                    logger.info(f"转发了包含关键词的消息: {message.content[:100]}...")
                else:
                    logger.warning(f"找不到目标频道: {config.FORWARD_TARGET_CHANNEL_ID}")

        except Exception as e:
            logger.error(f'Error handling keyword forward: {e}')

    async def handle_keyword_search(self, message):
        """处理关键词商品搜索"""
        try:
            # 只处理纯文字消息（不包含图片的）
            if not message.content or message.attachments:
                return

            search_query = message.content.strip()
            if not search_query:
                return

            # 调用搜索API
            result = await self.search_products_by_keyword(search_query)

            products = []
            if result and result.get('success') and result.get('products'):
                products = result['products'][:5]  # 最多显示5个结果

            # 只在找到商品时回复和记录日志
            if products:
                logger.info(f'关键词搜索成功: "{search_query}" -> 找到 {len(products)} 个商品')
                # 根据频道决定发送哪个链接
                product = products[0]
                response = get_response_url_for_channel(product, message.channel.id)

                logger.info(f'关键词搜索完成，找到 {len(products)} 个商品')

                # 模拟打字状态并延迟回复
                async with message.channel.typing():
                    # 检查是否设置了全局延迟（只要有一个值不为默认值3.0，就认为已设置）
                    if abs(config.GLOBAL_REPLY_MIN_DELAY - 3.0) > 0.01 or abs(config.GLOBAL_REPLY_MAX_DELAY - 8.0) > 0.01:
                        delay = random.uniform(config.GLOBAL_REPLY_MIN_DELAY, config.GLOBAL_REPLY_MAX_DELAY)
                        logger.info(f"模拟打字并延迟回复 {delay:.2f} 秒...")
                        await asyncio.sleep(delay)
                    else:
                        # 如果没有设置延迟，至少模拟1-3秒的打字时间
                        delay = random.uniform(1.0, 3.0)
                        logger.info(f"模拟打字 {delay:.2f} 秒...")
                        await asyncio.sleep(delay)

                await message.reply(response)
            else:
                # 没有找到商品，不回复任何消息
                logger.info(f'关键词搜索无结果: {search_query}')

        except Exception as e:
            logger.error(f'Error handling keyword search: {e}')
            # 不发送错误消息到Discord，只记录日志

    async def search_products_by_keyword(self, keyword):
        """根据关键词搜索商品"""
        try:
            # 设置超时时间
            timeout = aiohttp.ClientTimeout(total=10)  # 10秒超时
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # 构建搜索请求
                search_data = {
                    'query': keyword,
                    'limit': 10  # 搜索更多结果，但只显示前5个
                }

                # 调用后端搜索API
                async with session.post('http://localhost:5001/api/search_similar_text',
                                      json=search_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'Keyword search API error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error searching products by keyword: {e}')
            return None

    async def recognize_image(self, image_data, user_shops=None):
        try:
            # 设置较短的超时时间，避免阻塞Discord网关
            timeout = aiohttp.ClientTimeout(total=15)  # 15秒超时
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # 准备图片数据
                form_data = aiohttp.FormData()
                form_data.add_field('image', image_data, filename='image.jpg', content_type='image/jpeg')
                # 使用配置的阈值
                # 使用用户个性化阈值，如果没有则使用全局默认值
                api_threshold = config.DISCORD_SIMILARITY_THRESHOLD
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        user_settings = db.get_user_settings(self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            api_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'获取用户相似度设置失败: {e}')

                form_data.add_field('threshold', str(api_threshold))
                form_data.add_field('limit', '1')  # Discord只返回最相似的一个结果

                # 如果指定了用户店铺权限，添加到请求中
                if user_shops:
                    form_data.add_field('user_shops', json.dumps(user_shops))

                # 调用 DINOv2 + FAISS 服务（本地）
                async with session.post('http://localhost:5001/search_similar', data=form_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'PP-ShiTuV2 service error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error recognizing image: {e}')
            return None

async def get_all_accounts_from_backend():
    """从后端 API 获取所有可用的 Discord 账号"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get('http://localhost:5001/api/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    if accounts:
                        logger.info(f'Got {len(accounts)} accounts from backend')
                        return accounts
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def get_all_accounts_from_backend():
    """从后端 API 获取所有可用的 Discord 账号"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get('http://localhost:5001/api/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    # 只返回状态为online的账号
                    return [account for account in accounts if account.get('status') == 'online']
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def bot_loop(client):
    """主循环，定期检查并重连"""
    while True:
        try:
            token = await get_token_from_backend()
            if token:
                if not client.is_ready():
                    logger.info('Starting Discord bot with token from database...')
                    await client.start(token, reconnect=True)
                elif client.current_token != token:
                    logger.info('Token changed, reconnecting...')
                    await client.close()
                    await asyncio.sleep(2)
                    client.current_token = token
                    await client.start(token, reconnect=True)
            else:
                logger.warning('No active token found in database, waiting...')
                if client.is_ready():
                    await client.close()
                client.current_token = None

        except Exception as e:
            logger.error(f'Bot loop error: {e}')
            if client.is_ready():
                await client.close()

        # 等待 30 秒后再次检查
        await asyncio.sleep(30)

async def start_multi_bot_loop():
    """启动多账号机器人循环，定期检查账号状态"""
    global bot_clients, bot_tasks

    while True:
        try:
            # 获取当前所有账号
            accounts = await get_all_accounts_from_backend()
            current_account_ids = {account['id'] for account in accounts}

            # 停止已删除账号的机器人
            to_remove = []
            for i, client in enumerate(bot_clients):
                if client.account_id not in current_account_ids:
                    logger.info(f'停止已删除账号的机器人: {client.account_id}')
                    try:
                        if not client.is_closed():
                            await client.close()
                    except Exception as e:
                        logger.error(f'停止机器人时出错: {e}')

                    # 取消对应的任务
                    if i < len(bot_tasks) and bot_tasks[i] and not bot_tasks[i].done():
                        bot_tasks[i].cancel()

                    to_remove.append(i)

            # 从列表中移除已停止的机器人
            for i in reversed(to_remove):
                bot_clients.pop(i)
                if i < len(bot_tasks):
                    bot_tasks.pop(i)

            # 为新账号启动机器人
            existing_account_ids = {client.account_id for client in bot_clients}
            for account in accounts:
                account_id = account['id']
                if account_id not in existing_account_ids:
                    token = account['token']
                    username = account.get('username', f'account_{account_id}')

                    logger.info(f'启动新账号机器人: {username}')

                    # 创建机器人实例
                    client = DiscordBotClient(account_id=account_id)

                    # 启动机器人
                    try:
                        task = asyncio.create_task(client.start(token, reconnect=True))
                        bot_clients.append(client)
                        bot_tasks.append(task)
                        logger.info(f'机器人启动成功: {username}')
                    except Exception as e:
                        logger.error(f'启动机器人失败 {username}: {e}')

            # 等待一段时间后再次检查
            await asyncio.sleep(30)

        except Exception as e:
            logger.error(f'多账号机器人循环错误: {e}')
            await asyncio.sleep(30)

async def main():
    client = DiscordBotClient()

    # 启动主循环
    await bot_loop(client)

if __name__ == '__main__':
    asyncio.run(main())

--- File: ./backend/feature_extractor.py ---
import os
import torch
import numpy as np
import threading
from typing import List, Optional, Union, Dict
import logging
from pathlib import Path
from PIL import Image
from transformers import AutoImageProcessor, AutoModel
from ultralytics import YOLO
try:
    from .config import config
except ImportError:
    from config import config
from functools import lru_cache
import hashlib

logger = logging.getLogger(__name__)

# 使用类级单例模式
class FeatureExtractorSingleton:
    """特征提取器单例管理器"""
    _instance = None
    _lock = threading.Lock()

    @classmethod
    def get_instance(cls):
        with cls._lock:
            if cls._instance is None:
                logger.info("🚀 创建特征提取器单例实例...")
                cls._instance = DINOv2FeatureExtractor()
                logger.info("✅ 特征提取器单例实例创建完成")
        return cls._instance

def get_feature_extractor():
    """获取特征提取器单例实例"""
    return FeatureExtractorSingleton.get_instance()

class DINOv2FeatureExtractor:
    """
    "猎鹰"架构特征提取器
    DINOv2 (大脑) + YOLO-World (眼睛)
    专为鞋类识别优化，自动裁剪鞋子主体后提取高精度特征
    """

    def __init__(self):
        self.device = torch.device(config.DEVICE)
        logger.info(f"正在初始化猎鹰AI引擎，使用设备: {self.device}")

        # 加载YOLOv8-Nano (眼睛 - 主体检测)
        self._load_yolo_detector()

        # 加载DINOv2 (大脑 - 特征提取)
        self._load_dino_model()

        # 初始化缓存用于检测结果
        self._detection_cache = {}

    def _get_image_hash(self, image_path: str) -> str:
        """计算图片文件的哈希值用于缓存"""
        try:
            with open(image_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception:
            # 如果读取失败，使用文件路径+修改时间作为备用
            import os
            stat = os.stat(image_path)
            return hashlib.md5(f"{image_path}:{stat.st_mtime}".encode()).hexdigest()

    def _load_yolo_detector(self):
        """强制加载YOLO-World模型用于商品识别"""
        try:
            logger.info("🔥 强制加载YOLO-World模型...")

            # 强制使用YOLO-World，不允许降级
            self.detector = YOLO('yolov8s-world.pt')

            # [核心配置] 定义全自动识别的范围
            # 优化后的商品类别，覆盖微店/代购场景95%的商品
            # YOLO-World 会自动忽略人脸、手、家具、背景
            self.target_classes = [
                # 鞋类 (高优先级)
                "shoe", "sneaker", "boot", "sandal", "slipper", "heel",
                # 服装 (高优先级)
                "shirt", "t-shirt", "jacket", "coat", "pants", "jeans",
                "dress", "skirt", "shorts", "hoodie", "sweater", "suit",
                # 包袋配饰 (中优先级)
                "bag", "handbag", "backpack", "wallet", "belt", "hat", "cap",
                "watch", "jewelry", "necklace", "ring", "glasses",
                # 电子产品 (中优先级)
                "phone", "laptop", "headphone", "camera", "watch",
                # 家居用品 (低优先级)
                "toy", "box", "bottle", "cup", "lamp"
            ]

            # 将这些类别注入模型
            self.detector.set_classes(self.target_classes)

            logger.info("🎉 YOLO-World模型加载成功！")
            logger.info(f"🎯 支持自动识别 {len(self.target_classes)} 种商品类别")
            logger.info(f"📋 YOLO-World目标类别: {', '.join(self.target_classes[:10])}...")
            logger.info("⚡ YOLO-World优化说明: 使用多维度评分(面积×置信度×位置×类别权重)，显著提升裁剪准确率")

            # 验证CLIP库是否正确安装
            try:
                import clip
                logger.info(f"✅ CLIP库版本验证: {getattr(clip, '__version__', '未知')}")
                if hasattr(clip, 'load'):
                    logger.info("✅ CLIP.load方法可用")
                else:
                    logger.warning("⚠️ CLIP.load方法不可用，可能影响YOLO-World性能")
            except ImportError as e:
                logger.warning(f"⚠️ 无法导入CLIP库: {e}")

        except Exception as e:
            logger.error(f"💥 YOLO-World模型加载失败: {e}")

            # 检查是否是CLIP相关的问题，如果是则尝试备用方案
            if "clip" in str(e).lower():
                logger.warning("🔍 检测到CLIP库问题，尝试备用加载方式...")

                try:
                    # 尝试不依赖CLIP的加载方式
                    import ultralytics
                    logger.info(f"Ultralytics版本: {ultralytics.__version__}")

                    # 直接创建YOLO-World实例，不设置类别
                    self.detector = YOLO('yolov8s-world.pt')
                    self.target_classes = None  # 不设置自定义类别

                    logger.warning("⚠️ YOLO-World以基础模式加载 (无自定义类别)")
                    logger.warning("📊 影响: 将使用YOLO-World的内置80类进行检测")
                    logger.info("✅ YOLO-World基础模式加载成功")

                except Exception as backup_error:
                    logger.error(f"💥 备用加载方式也失败: {backup_error}")
                    logger.error("🔥 用户要求强制使用YOLO-World，但所有加载方式都失败！")
                    logger.error("💡 最终解决方案:")
                    logger.error("   1. pip uninstall clip torch torchvision ultralytics")
                    logger.error("   2. pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu")
                    logger.error("   3. pip install ultralytics")
                    logger.error("   4. pip install git+https://github.com/openai/CLIP.git")
                    raise RuntimeError("YOLO-World加载失败，所有备用方案均无效") from e
            else:
                # 不是CLIP问题，直接报错
                logger.error("🔥 YOLO-World加载失败，错误不相关CLIP库")
                logger.error("💡 建议检查网络连接和ultralytics版本")
                raise RuntimeError("YOLO-World加载失败") from e

    def _load_dino_model(self):
        """加载DINOv2模型用于特征提取"""
        try:
            model_name = config.DINO_MODEL_NAME
            logger.info(f"加载DINOv2特征模型: {model_name}...")

            self.processor = AutoImageProcessor.from_pretrained(model_name)
            self.model = AutoModel.from_pretrained(model_name)

            # 安全地将模型移动到设备，避免meta tensor错误
            try:
                if hasattr(self.model, 'to'):
                    self.model = self.model.to(self.device)
                else:
                    logger.warning("模型没有to()方法，使用原模型")
            except Exception as device_error:
                logger.warning(f"模型移动到设备失败: {device_error}，尝试其他方法...")
                try:
                    # 尝试使用to_empty方法
                    if hasattr(self.model, 'to_empty'):
                        self.model = self.model.to_empty(device=self.device)
                    else:
                        logger.error("模型不支持to_empty方法，使用CPU")
                        self.device = torch.device('cpu')
                        self.model = self.model.to(self.device)
                except Exception as fallback_error:
                    logger.error(f"所有设备移动方法都失败: {fallback_error}")
                    raise

            self.model.eval()
            logger.info("✅ DINOv2模型加载成功")
        except Exception as e:
            logger.error(f"❌ DINOv2模型加载失败: {e}")
            raise RuntimeError("DINOv2模型加载失败") from e

    def _crop_main_object(self, image_path: str) -> Image.Image:
        """全自动裁剪商品主体

        全自动裁剪逻辑：
        1. 在预设的商品类别中检测所有物体
        2. 自动过滤掉背景、人、手
        3. 在剩下的商品中，选出最显著的一个（最大+最中心）
        """
        try:
            if not config.USE_YOLO_CROP:
                return Image.open(image_path).convert("RGB")

            # 检查缓存
            image_hash = self._get_image_hash(image_path)
            if image_hash in self._detection_cache:
                logger.debug("使用缓存的检测结果")
                cached_result = self._detection_cache[image_hash]
                if cached_result is None:
                    # 缓存中表示未检测到商品
                    return Image.open(image_path).convert("RGB")
                # 返回缓存的裁剪结果
                return cached_result

            # conf=0.1: 降低门槛，宁可多检不要漏检，反正我们有逻辑过滤
            results = self.detector(image_path, conf=0.1, verbose=False)

            if not results or len(results[0].boxes) == 0:
                logger.info("未检测到通用商品，降级使用原图")
                # 缓存未检测到商品的结果
                self._detection_cache[image_hash] = None
                return Image.open(image_path).convert("RGB")

            boxes = results[0].boxes
            img = Image.open(image_path).convert("RGB")
            img_w, img_h = img.size
            center_x, center_y = img_w / 2, img_h / 2

            # --- 智能评分逻辑 ---
            # 在所有检测到的"商品"中，选出主角

            best_box = None
            max_score = -1

            for box in boxes:
                # 1. 获取坐标
                coords = box.xyxy[0].cpu().numpy()  # [x1, y1, x2, y2]
                x1, y1, x2, y2 = coords

                # 2. 计算面积
                width = x2 - x1
                height = y2 - y1
                area = width * height

                # 3. 计算离图片中心的距离
                box_center_x = x1 + width / 2
                box_center_y = y1 + height / 2
                dist_to_center = ((box_center_x - center_x)**2 + (box_center_y - center_y)**2) ** 0.5

                # 4. 综合评分公式：
                # 面积越大越好 (权重 0.7)
                # 越靠中心越好 (权重 0.3)
                # 这个公式能保证：即使角落里有个大包，也会优先选中间的小鞋子
                norm_area = area / (img_w * img_h)
                norm_dist = 1 - (dist_to_center / ((img_w**2 + img_h**2)**0.5))

                score = (norm_area * 0.7) + (norm_dist * 0.3) + (float(box.conf) * 0.1)

                if score > max_score:
                    max_score = score
                    best_box = coords

            if best_box is None:
                logger.info("未找到合适的商品框，使用原图")
                # 缓存失败结果
                self._detection_cache[image_hash] = None
                return img

            # 执行裁剪
            x1, y1, x2, y2 = best_box

            # 扩充 5% - 10% 的边缘，保留一点点上下文
            pad_x = (x2 - x1) * 0.05
            pad_y = (y2 - y1) * 0.05

            crop_box = (
                max(0, x1 - pad_x),
                max(0, y1 - pad_y),
                min(img_w, x2 + pad_x),
                min(img_h, y2 + pad_y)
            )

            cropped_img = img.crop(crop_box)
            logger.info(f"成功裁剪商品区域: {crop_box}")

            # 缓存成功结果
            self._detection_cache[image_hash] = cropped_img.copy()

            return cropped_img

        except Exception as e:
            logger.warning(f"自动裁剪出错: {e}, 使用原图")
            # 缓存失败结果
            try:
                image_hash = self._get_image_hash(image_path)
                self._detection_cache[image_hash] = None
            except:
                pass
            return Image.open(image_path).convert("RGB")
        """使用YOLO-World精准裁剪鞋类主体"""
        try:
            if not config.USE_YOLO_CROP:
                return Image.open(image_path).convert("RGB")

            # 检查缓存
            image_hash = self._get_image_hash(image_path)
            if image_hash in self._detection_cache:
                logger.debug("使用缓存的检测结果")
                cached_result = self._detection_cache[image_hash]
                if cached_result is None:
                    # 缓存中表示未检测到鞋子
                    return Image.open(image_path).convert("RGB")
                # 返回缓存的裁剪结果
                return cached_result

            # 优化检测参数，提高准确率
            # 使用更低的置信度但更高的质量阈值
            results = self.detector(image_path, conf=0.05, iou=0.5, verbose=False)

            if not results or len(results[0].boxes) == 0:
                logger.info("未检测到通用商品，降级使用原图")
                # 缓存未检测到商品的结果
                self._detection_cache[image_hash] = None
                return Image.open(image_path).convert("RGB")

            boxes = results[0].boxes
            img = Image.open(image_path).convert("RGB")
            img_w, img_h = img.size
            center_x, center_y = img_w / 2, img_h / 2

            # --- 优化候选逻辑 (YOLO-World增强版) ---
            # 多维度评分：面积、置信度、位置、长宽比

            candidates = []
            for box in boxes:
                coords = box.xyxy[0].cpu().numpy()
                conf = float(box.conf)
                cls = int(box.cls)

                w = coords[2] - coords[0]
                h = coords[3] - coords[1]
                area = w * h

                # 过滤太小或太大bbox
                if area < img_w * img_h * 0.01:  # 至少占图片面积1%
                    continue
                if area > img_w * img_h * 0.9:   # 最多占图片面积90%
                    continue

                # 计算长宽比 (过滤极端比例)
                aspect_ratio = max(w/h, h/w)
                if aspect_ratio > 5:  # 太细长
                    continue

                # 计算中心距离权重 (越靠近中心越好)
                box_cx = coords[0] + w/2
                box_cy = coords[1] + h/2
                dist_from_center = ((box_cx - center_x)**2 + (box_cy - center_y)**2) ** 0.5
                max_dist = ((img_w/2)**2 + (img_h/2)**2) ** 0.5
                center_weight = 1 - (dist_from_center / max_dist)

                # 计算类别权重 (鞋类和服装更高权重)
                class_name = self.target_classes[cls] if cls < len(self.target_classes) else "unknown"
                class_weight = 1.5 if any(keyword in class_name.lower() for keyword in ['shoe', 'shirt', 'pants', 'dress']) else 1.0

                # 综合评分
                score = area * conf * center_weight * class_weight

                candidates.append({
                    'coords': coords,
                    'score': score,
                    'conf': conf,
                    'area': area,
                    'class': class_name
                })

            # 选择最佳候选
            if not candidates:
                logger.info("未找到合适的商品框，使用原图")
                return img

            best_candidate = max(candidates, key=lambda x: x['score'])
            best_box = best_candidate['coords']

            logger.info(f"选择最佳检测框: {best_candidate['class']}, 置信度: {best_candidate['conf']:.3f}, 得分: {best_candidate['score']:.1f}")

            if best_box is None:
                logger.info("未找到合适的鞋子框，使用原图")
                return img

            # 裁剪选中的鞋子
            x1, y1, x2, y2 = best_box

            # 扩充5%的边缘，防止切掉边缘特征
            pad_x = (x2 - x1) * 0.05
            pad_y = (y2 - y1) * 0.05

            crop_box = (
                max(0, x1 - pad_x),
                max(0, y1 - pad_y),
                min(img_w, x2 + pad_x),
                min(img_h, y2 + pad_y)
            )

            cropped_img = img.crop(crop_box)
            logger.info(f"成功裁剪鞋子区域: {crop_box}")

            # 缓存结果
            self._detection_cache[image_hash] = cropped_img.copy()

            return cropped_img

        except Exception as e:
            logger.warning(f"鞋子裁剪异常: {e}")
            # 缓存失败结果
            self._detection_cache[image_hash] = None
            return Image.open(image_path).convert("RGB")

    def extract_feature(self, image_path: Union[str, Path]) -> Optional[np.ndarray]:
        """提取单张图片的特征向量 (384维或768维)"""
        try:
            image_path = str(image_path)

            if not os.path.exists(image_path):
                logger.error(f"文件不存在: {image_path}")
                return None

            # 1. YOLO裁剪主体
            img = self._crop_main_object(image_path)

            # 2. 预处理（DINOv2会自动处理）
            inputs = self.processor(images=img, return_tensors="pt").to(self.device)

            # 3. 特征提取
            with torch.no_grad():
                outputs = self.model(**inputs)

            # 4. 获取CLS token特征 (DINOv2的最佳实践)
            # outputs.last_hidden_state.shape: [1, num_patches+1, dim]
            # 第0个是CLS token，代表整张图的语义
            embedding = outputs.last_hidden_state[0, 0, :].cpu().numpy()

            # 5. L2归一化 (对余弦相似度至关重要)
            norm = np.linalg.norm(embedding)
            if norm > 0:
                embedding = embedding / norm

            # 6. 确保数据类型为float32 (FAISS要求)
            return embedding.astype('float32')

        except Exception as e:
            logger.error(f"DINOv2特征提取失败 {image_path}: {e}")
            import traceback
            traceback.print_exc()
            return None

    def extract_features_batch(self, image_paths: List[Union[str, Path]]) -> List[Optional[np.ndarray]]:
        """批量提取特征向量"""
        results = []
        for image_path in image_paths:
            feature = self.extract_feature(image_path)
            results.append(feature)
        return results

    def get_status(self) -> Dict:
        """获取AI模型状态和性能信息"""
        status = {
            'device': str(self.device),
            'yolo_available': self.detector is not None,
            'yolo_type': 'None'
        }

        if self.detector is not None:
            if self.target_classes and len(self.target_classes) > 20:
                status['yolo_type'] = 'YOLO-World'
                status['target_classes_count'] = len(self.target_classes)
                status['target_classes'] = self.target_classes[:10]  # 只显示前10个
            else:
                status['yolo_type'] = 'YOLOv8-Nano'
                status['target_classes_count'] = len(self.target_classes) if self.target_classes else 0

        status['detection_cache_size'] = len(self._detection_cache)
        status['confidence_threshold'] = 0.05
        status['iou_threshold'] = 0.5

        # 性能提示
        tips = []
        if self.detector is None:
            tips.append("YOLO裁剪已禁用，建议修复YOLO加载问题以提升准确性")
        elif status['yolo_type'] == 'YOLOv8-Nano':
            tips.append("当前使用YOLOv8-Nano，建议升级依赖以启用YOLO-World获得更好效果")

        if status['detection_cache_size'] > 1000:
            tips.append("检测缓存较大，考虑定期清理缓存")

        status['performance_tips'] = tips if tips else ["AI模型运行正常"]

        return status

# 向后兼容的别名
class FeatureExtractor(DINOv2FeatureExtractor):
    """向后兼容的别名"""
    pass

# 单例模式获取实例
_feature_extractor = None

def get_feature_extractor() -> DINOv2FeatureExtractor:
    global _feature_extractor
    if _feature_extractor is None:
        _feature_extractor = DINOv2FeatureExtractor()
    return _feature_extractor

--- File: ./backend/vector_engine.py ---
import faiss
import numpy as np
import os
import pickle
import logging
from typing import List, Dict, Tuple
try:
    from .config import config
except ImportError:
    from config import config

logger = logging.getLogger(__name__)

class VectorEngine:
    """
    FAISS HNSW向量搜索引擎
    纯文件系统存储，无需Docker
    支持百万级向量毫秒级查询
    """

    def __init__(self, index_file=None, id_map_file=None):
        self.index_file = index_file or config.FAISS_INDEX_FILE
        self.id_map_file = id_map_file or config.FAISS_ID_MAP_FILE

        self.dimension = config.VECTOR_DIMENSION
        self.index = None

        # FAISS只能存整数ID，我们需要一个映射：FAISS内部ID -> 数据库(product_images表的ID)
        # 这个列表的索引是FAISS ID，值是数据库ID
        self.id_map = []

        self._load_or_create_index()

    def _load_or_create_index(self):
        """加载或创建FAISS HNSW索引"""
        if os.path.exists(self.index_file) and os.path.exists(self.id_map_file):
            logger.info("正在加载FAISS索引...")
            try:
                self.index = faiss.read_index(self.index_file)
                with open(self.id_map_file, 'rb') as f:
                    self.id_map = pickle.load(f)
                logger.info(f"✅ FAISS索引加载完成，当前包含 {self.index.ntotal} 个向量")
            except Exception as e:
                logger.error(f"加载索引失败，将创建新索引: {e}")
                self._create_new_index()
        else:
            logger.info("创建新的FAISS HNSW索引...")
            self._create_new_index()

    def _create_new_index(self):
        """创建新的FAISS HNSW索引，优化参数设置"""
        logger.info("创建新的FAISS HNSW索引...")

        # HNSW64: 图结构，查询极快，准确率高
        # InnerProduct (IP) 在归一化向量上等同于余弦相似度
        self.index = faiss.IndexHNSWFlat(
            self.dimension,
            config.FAISS_HNSW_M,
            faiss.METRIC_INNER_PRODUCT
        )

        # 设置构建参数 (兼容不同版本的FAISS)
        ef_construction_set = False
        ef_search_set = False

        try:
            # 尝试设置HNSW参数 (新版本FAISS >= 1.7.0)
            if hasattr(self.index, 'efConstruction'):
                self.index.efConstruction = config.FAISS_EF_CONSTRUCTION  # 构建时的深度，越高越准但构建越慢
                ef_construction_set = True
                logger.info(f"设置efConstruction = {config.FAISS_EF_CONSTRUCTION}")

            if hasattr(self.index, 'efSearch'):
                self.index.efSearch = config.FAISS_EF_SEARCH  # 搜索时的深度，越高越准但搜索越慢
                ef_search_set = True
                logger.info(f"设置efSearch = {config.FAISS_EF_SEARCH}")

        except AttributeError:
            logger.warning("FAISS版本不支持efConstruction/efSearch参数，将使用默认值")

        # 如果无法设置参数，提供性能优化建议
        if not ef_construction_set or not ef_search_set:
            logger.info("💡 FAISS性能优化建议:")
            logger.info(f"   - 当前FAISS版本: {faiss.__version__}")
            logger.info("   - 建议升级到FAISS >= 1.7.0以获得最佳性能")
            logger.info("   - 或者使用: pip install faiss-cpu --upgrade")

        # 设置其他兼容性参数
        try:
            # 设置HNSW的M参数 (如果支持)
            if hasattr(self.index, 'hnsw'):
                logger.info(f"HNSW M参数 = {config.FAISS_HNSW_M}")
        except:
            pass

        self.id_map = []

        # 确保目录存在
        os.makedirs(os.path.dirname(self.index_file), exist_ok=True)

        logger.info("✅ FAISS HNSW索引创建完成")

    def save(self):
        """保存索引到磁盘 (百万级数据保存大约需要几秒)"""
        try:
            faiss.write_index(self.index, self.index_file)
            with open(self.id_map_file, 'wb') as f:
                pickle.dump(self.id_map, f)
            logger.info("FAISS索引已保存到磁盘")
        except Exception as e:
            logger.error(f"保存索引失败: {e}")

    def add_vector(self, db_id: int, vector: np.ndarray) -> bool:
        """添加向量到FAISS索引"""
        try:
            # 确保向量是正确的形状和类型
            if isinstance(vector, list):
                vector = np.array(vector, dtype='float32')
            elif vector.dtype != np.float32:
                vector = vector.astype('float32')

            vector = vector.reshape(1, -1)  # 确保是[1, dim]形状

            # 添加到FAISS
            self.index.add(vector)

            # 记录ID映射：FAISS内部ID -> 数据库ID
            faiss_id = self.index.ntotal - 1  # 新添加的向量ID
            if len(self.id_map) <= faiss_id:
                self.id_map.extend([None] * (faiss_id - len(self.id_map) + 1))
            self.id_map[faiss_id] = db_id

            return True

        except Exception as e:
            logger.error(f"添加向量失败: {e}")
            return False

    def search(self, query_vector: np.ndarray, top_k: int = 1) -> List[Dict]:
        """搜索最相似的向量"""
        if self.index.ntotal == 0:
            return []

        try:
            # 确保查询向量格式正确
            if isinstance(query_vector, list):
                query_vector = np.array(query_vector, dtype='float32')
            elif query_vector.dtype != np.float32:
                query_vector = query_vector.astype('float32')

            query_vector = query_vector.reshape(1, -1)

            # 执行搜索
            # distances: 相似度分数 (因为是内积且归一化了，范围-1到1)
            # indices: FAISS内部的ID
            distances, indices = self.index.search(query_vector, top_k)

            results = []
            for i in range(min(top_k, len(indices[0]))):
                faiss_id = indices[0][i]
                score = distances[0][i]

                if faiss_id != -1 and faiss_id < len(self.id_map) and self.id_map[faiss_id] is not None:
                    db_id = self.id_map[faiss_id]
                    results.append({
                        'db_id': db_id,  # 数据库中的ID
                        'score': float(score)  # 相似度分数
                    })

            return results

        except Exception as e:
            logger.error(f"搜索失败: {e}")
            return []

    def remove_vector_by_db_id(self, db_id: int) -> bool:
        """
        从FAISS索引中删除向量。由于FAISS不支持直接删除单个向量，
        我们标记删除并定期重建索引（性能优化版本）。
        """
        try:
            # 标记要删除的向量
            vector_removed = False
            for i, mapped_id in enumerate(self.id_map):
                if mapped_id == db_id:
                    self.id_map[i] = None
                    vector_removed = True
                    logger.info(f"标记向量删除: db_id={db_id}, faiss_id={i}")
                    break

            # 性能优化：不立即重建索引，只保存状态
            # 只有当删除的向量比例超过阈值时才重建
            if vector_removed:
                deleted_count = sum(1 for id_val in self.id_map if id_val is None)
                total_count = len(self.id_map)
                deletion_ratio = deleted_count / total_count if total_count > 0 else 0

                # 如果删除比例超过30%，则重建索引清理碎片
                if deletion_ratio > 0.3:
                    logger.info(f"删除比例({deletion_ratio:.1%})过高，重建索引清理碎片")
                    self._rebuild_index_after_removal()
                else:
                    # 只保存索引状态，不重建
                    self.save()

            return True
        except Exception as e:
            logger.error(f"删除向量失败: {e}")
            return False

    def _rebuild_index_after_removal(self):
        """删除向量后重建索引"""
        try:
            # 获取所有未删除的向量数据
            try:
                from database import db
            except ImportError:
                from .database import db
            valid_vectors = []

            with db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE id IS NOT NULL")
                for row in cursor.fetchall():
                    img_id = row['id']
                    # 检查这个向量是否在我们的id_map中且未被标记删除
                    if img_id in self.id_map and self.id_map[self.id_map.index(img_id)] is not None:
                        # 重新提取特征（或者从缓存中获取）
                        # 这里为了简单，我们假设特征需要重新提取
                        # 在生产环境中，应该缓存特征或定期重建
                        try:
                            # 这里需要导入特征提取器
                            try:
                                from feature_extractor import get_feature_extractor
                            except ImportError:
                                from .feature_extractor import get_feature_extractor
                            extractor = get_feature_extractor()
                            features = extractor.extract_feature(row['image_path'])
                            if features is not None:
                                valid_vectors.append((img_id, features))
                        except Exception as e:
                            logger.warning(f"重新提取特征失败 {row['image_path']}: {e}")

            # 重建索引
            self._create_new_index()
            for img_id, features in valid_vectors:
                self.add_vector(img_id, features)

            self.save()
            logger.info(f"索引重建完成，包含 {len(valid_vectors)} 个向量")

        except Exception as e:
            logger.error(f"重建索引失败: {e}")

    def rebuild_index(self, vectors_data: List[Tuple[int, np.ndarray]]) -> bool:
        """
        重建整个索引 (用于清理已删除的向量或批量更新)

        vectors_data: [(db_id, vector), ...]
        """
        try:
            logger.info("开始重建FAISS索引...")

            # 删除旧的索引文件
            try:
                if os.path.exists(self.index_file):
                    os.remove(self.index_file)
                if os.path.exists(self.id_map_file):
                    os.remove(self.id_map_file)
            except Exception as e:
                logger.warning(f"删除旧索引文件失败: {e}")

            # 创建新索引
            self._create_new_index()

            # 重新添加所有向量
            for db_id, vector in vectors_data:
                self.add_vector(db_id, vector)

            # 立即保存新索引
            self.save()

            logger.info(f"索引重建完成，包含 {self.index.ntotal} 个向量")
            return True

        except Exception as e:
            logger.error(f"重建索引失败: {e}")
            # 尝试重新加载旧索引
            try:
                self._load_or_create_index()
            except:
                pass
            return False

    def count(self) -> int:
        """返回当前索引中的向量数量"""
        return self.index.ntotal

    def get_stats(self) -> Dict:
        """获取索引统计信息"""
        ef_construction = getattr(self.index, 'efConstruction', '不支持')
        ef_search = getattr(self.index, 'efSearch', '不支持')

        return {
            'total_vectors': self.index.ntotal,
            'dimension': self.dimension,
            'index_type': 'HNSW',
            'metric_type': 'InnerProduct (Cosine)',
            'ef_construction': ef_construction,
            'ef_search': ef_search,
            'memory_usage_mb': self._estimate_memory_usage(),
            'faiss_version': faiss.__version__,
            'performance_tips': self._get_performance_tips()
        }

    def _get_performance_tips(self) -> List[str]:
        """获取性能优化建议"""
        tips = []

        # 检查FAISS版本
        try:
            version_parts = faiss.__version__.split('.')
            major = int(version_parts[0])
            minor = int(version_parts[1])

            if major < 1 or (major == 1 and minor < 7):
                tips.append("建议升级FAISS到1.7.0+版本以获得efConstruction/efSearch参数支持")
        except:
            tips.append("无法检测FAISS版本，建议升级到最新版本")

        # 检查ef参数
        if not hasattr(self.index, 'efConstruction'):
            tips.append("当前FAISS版本不支持efConstruction参数，搜索性能可能受限")

        if not hasattr(self.index, 'efSearch'):
            tips.append("当前FAISS版本不支持efSearch参数，建议手动设置搜索参数")

        # 检查向量数量
        if self.index.ntotal < 1000:
            tips.append("向量数量较少，考虑增加更多商品数据以提高搜索准确性")

        # 检查内存使用
        memory_mb = self._estimate_memory_usage()
        if memory_mb > 1000:  # 超过1GB
            tips.append(f"内存使用量较大 ({memory_mb:.1f}MB)，建议监控内存使用情况")

        return tips if tips else ["系统运行正常，无性能优化建议"]

    def _estimate_memory_usage(self) -> float:
        """估算内存使用量 (MB)"""
        # HNSW索引内存估算：向量数据 + 图结构
        vector_memory = self.index.ntotal * self.dimension * 4  # float32 = 4 bytes
        graph_memory = self.index.ntotal * config.FAISS_HNSW_M * 4  # 邻居指针
        total_bytes = vector_memory + graph_memory
        return total_bytes / (1024 * 1024)

# 全局单例
_engine = None

def get_vector_engine() -> VectorEngine:
    global _engine
    if _engine is None:
        _engine = VectorEngine()
    return _engine

--- File: ./backend/scripts/clear_database.py ---
#!/usr/bin/env python3
"""
数据库清理脚本
清空所有数据库数据、图片文件和向量索引

使用方法:
cd backend
python3 clear_database.py

或者直接运行:
python3 clear_database.py --confirm
"""

import os
import sys
import sqlite3
import shutil
from pathlib import Path

def clear_all_data(confirm=False):
    """清空所有数据"""
    if not confirm:
        print("⚠️ 警告: 此操作将清空所有数据！")
        print("包括: 用户账户、商品数据、图片文件、向量索引等")
        print("")
        response = input("确认要清空所有数据吗？输入 'YES' 确认: ")
        if response != 'YES':
            print("操作已取消")
            return

    # 数据目录
    DATA_DIR = Path('data')

    # 所有数据库文件
    DB_FILES = [
        'data/app.db',
        'data/metadata.db',
        'data/milvus.db',
        'data/discord_bot.db'  # 万一存在
    ]

    print('🗑️ 开始全面清空所有数据库和相关数据...')

    # 1. 清空所有SQLite数据库
    for db_path in DB_FILES:
        if os.path.exists(db_path):
            print(f'📄 清空SQLite数据库: {db_path}')
            try:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()

                # 获取所有表名
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = cursor.fetchall()

                # 清空所有表
                for table in tables:
                    table_name = table[0]
                    if table_name != 'sqlite_sequence':  # 跳过SQLite内部表
                        print(f'  删除表 {table_name} 的所有数据')
                        cursor.execute(f'DELETE FROM {table_name}')

                        # 重置自增ID
                        cursor.execute(f'DELETE FROM sqlite_sequence WHERE name="{table_name}"')

                conn.commit()
                conn.close()
                print(f'✅ {db_path} 已清空')

            except Exception as e:
                print(f'❌ 清空 {db_path} 失败: {e}')
        else:
            print(f'⚠️ 数据库文件不存在: {db_path}')

    # 2. 删除图片文件
    IMAGES_DIR = DATA_DIR / 'scraped_images'
    if IMAGES_DIR.exists():
        print(f'🖼️ 删除图片目录: {IMAGES_DIR}')
        try:
            shutil.rmtree(IMAGES_DIR)
            print('✅ 图片目录已删除')
        except Exception as e:
            print(f'❌ 删除图片目录失败: {e}')
    else:
        print('⚠️ 图片目录不存在')

    # 3. 删除向量数据目录
    VECTOR_DIR = DATA_DIR / 'vectors'
    if VECTOR_DIR.exists():
        print(f'🔍 删除向量数据目录: {VECTOR_DIR}')
        try:
            shutil.rmtree(VECTOR_DIR)
            print('✅ 向量数据目录已删除')
        except Exception as e:
            print(f'❌ 删除向量数据目录失败: {e}')
    else:
        print('⚠️ 向量数据目录不存在')

    # 4. 删除向量索引文件
    vector_extensions = ['*.faiss', '*.index', '*.pkl', '*.npy', '*.bin']
    vector_files = []
    for ext in vector_extensions:
        vector_files.extend(list(DATA_DIR.glob(ext)))

    if vector_files:
        print('🔍 删除向量索引文件:')
        for vf in vector_files:
            try:
                vf.unlink()
                print(f'  ✅ 删除: {vf}')
            except Exception as e:
                print(f'  ❌ 删除失败 {vf}: {e}')

    # 5. 删除临时文件
    temp_files = list(DATA_DIR.glob('temp_*')) + list(DATA_DIR.glob('*.tmp'))
    if temp_files:
        print('🗂️ 删除临时文件:')
        for tf in temp_files:
            try:
                tf.unlink()
                print(f'  ✅ 删除: {tf}')
            except Exception as e:
                print(f'  ❌ 删除失败 {tf}: {e}')

    print('\n🎉 全面数据库清理完成！')
    print('\n📋 清理内容总结:')
    print('  - 所有SQLite数据库 (app.db, metadata.db, milvus.db) 已清空')
    print('  - 自增ID计数器已重置')
    print('  - 图片文件目录已删除')
    print('  - 向量数据目录已删除')
    print('  - 向量索引文件 (*.faiss, *.index, *.pkl, *.npy, *.bin) 已删除')
    print('  - 临时文件已删除')
    print('\n⚠️ 注意: 所有用户账户、商品数据、系统配置、向量索引都已被清空')
    print('   这是一个不可逆的操作，如需恢复请从备份恢复')

if __name__ == '__main__':
    confirm = '--confirm' in sys.argv
    clear_all_data(confirm)

--- File: ./backend/scripts/create_admin.py ---
#!/usr/bin/env python3
"""
创建管理员账号脚本

使用方法:
cd backend
python3 create_admin.py

或者指定用户名和密码:
python3 create_admin.py --username admin --password admin123
"""

import sys
import getpass
import argparse
try:
    from database import Database
except ImportError:
    from ..database import Database
from werkzeug.security import generate_password_hash

def create_admin_user(username=None, password=None):
    """创建管理员用户"""
    db = Database()

    # 如果没有提供参数，交互式输入
    if not username:
        username = input("请输入管理员用户名: ").strip()
        if not username:
            print("❌ 用户名不能为空")
            return

    if not password:
        password = getpass.getpass("请输入管理员密码: ").strip()
        if not password:
            print("❌ 密码不能为空")
            return

        # 确认密码
        confirm_password = getpass.getpass("请再次输入密码确认: ").strip()
        if password != confirm_password:
            print("❌ 两次输入的密码不一致")
            return

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 检查用户名是否已存在
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = cursor.fetchone()

            if existing_user:
                print(f"❌ 用户名 '{username}' 已存在")
                return

            # 创建管理员用户
            hashed_password = generate_password_hash(password)
            cursor.execute("""
                INSERT INTO users (username, password_hash, role, created_at, updated_at)
                VALUES (?, ?, 'admin', datetime('now'), datetime('now'))
            """, (username, hashed_password))

            user_id = cursor.lastrowid
            conn.commit()

            print("✅ 管理员账号创建成功！")
            print(f"   用户名: {username}")
            print(f"   角色: 管理员")
            print(f"   用户ID: {user_id}")
            print("\n🔐 请妥善保管账号信息")

    except Exception as e:
        print(f"❌ 创建管理员账号失败: {e}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='创建管理员账号')
    parser.add_argument('--username', help='管理员用户名')
    parser.add_argument('--password', help='管理员密码')

    args = parser.parse_args()

    if args.username and args.password:
        create_admin_user(args.username, args.password)
    else:
        create_admin_user()

--- File: ./backend/app.py ---
from flask import Flask, request, jsonify, Response, session
import numpy as np
import os
import logging
import sys
from datetime import datetime
try:
    from feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
except ImportError:
    from .feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
try:
    from database import db
    from config import config
except ImportError:
    from .database import db
    from .config import config
import requests
import json
from flask_cors import CORS
import queue
import threading
import time
from urllib.parse import quote
import hashlib

# 在应用启动时从数据库加载系统配置
def load_system_config():
    """从数据库加载系统配置到内存"""
    # 在函数内部定义logger，因为此时全局logger可能还没有初始化
    import logging
    func_logger = logging.getLogger(__name__)

    try:
        sys_config = db.get_system_config()
        config.DISCORD_SIMILARITY_THRESHOLD = sys_config['discord_similarity_threshold']
        config.DISCORD_CHANNEL_ID = sys_config['discord_channel_id']
        config.CNFANS_CHANNEL_ID = sys_config['cnfans_channel_id']
        config.ACBUY_CHANNEL_ID = sys_config['acbuy_channel_id']

        # 加载全局回复延迟配置
        reply_config = db.get_global_reply_config()
        config.GLOBAL_REPLY_MIN_DELAY = reply_config['min_delay']
        config.GLOBAL_REPLY_MAX_DELAY = reply_config['max_delay']

        # 设置环境变量（供机器人使用）
        discord_channel_id = sys_config['discord_channel_id']
        if discord_channel_id:
            os.environ['DISCORD_CHANNEL_ID'] = discord_channel_id

        func_logger.info("系统配置已从数据库加载")
        func_logger.info(f"下载线程: {config.DOWNLOAD_THREADS}")
        func_logger.info(f"特征提取线程: {config.FEATURE_EXTRACT_THREADS}")
        func_logger.info(f"Discord相似度阈值: {config.DISCORD_SIMILARITY_THRESHOLD} ({config.DISCORD_SIMILARITY_THRESHOLD*100:.0f}%)")
        func_logger.info(f"全局回复延迟设置为: {config.GLOBAL_REPLY_MIN_DELAY}-{config.GLOBAL_REPLY_MAX_DELAY}秒")
        func_logger.info(f"Discord频道ID: {discord_channel_id or '未设置(监听所有频道)'}")
    except Exception as e:
        func_logger.warning(f"加载系统配置失败，使用默认值: {e}")

# 加载系统配置
load_system_config()

# === 重构：店铺抓取状态控制 ===
# 移除全局状态变量，改为数据库持久化存储
# scrape_status现在通过db.get_scrape_status()和db.update_scrape_status()管理

# 线程管理：跟踪当前运行的抓取线程
current_scrape_thread = None
scrape_thread_lock = threading.Lock()

# 全局关闭事件，用于优雅关闭
shutdown_event = None

# 配置日志
logging.basicConfig(level=logging.INFO)

# 创建日志队列用于实时流式传输
log_queue = queue.Queue()
log_clients = []

# 存储所有日志的列表，用于API查询
all_logs = []

class QueueHandler(logging.Handler):
    """自定义日志处理器，将日志发送到队列"""
    def emit(self, record):
        try:
            # 过滤掉HTTP请求日志和不重要的系统日志
            if self._should_filter_log(record):
                return

            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'level': record.levelname,
                'message': self.format(record),
                'module': record.module,
                'func': record.funcName
            }

            # 添加到日志列表（限制大小）
            all_logs.append(log_entry)
            if len(all_logs) > 200:  # 最多保存200条日志
                all_logs.pop(0)

            log_queue.put(log_entry)

            # 通知所有连接的客户端
            for client_queue in log_clients[:]:  # 复制列表以避免修改时的问题
                try:
                    client_queue.put(log_entry)
                except:
                    # 如果客户端队列已满或断开，移除它
                    if client_queue in log_clients:
                        log_clients.remove(client_queue)
        except Exception as e:
            print(f"日志队列错误: {e}")

    def _should_filter_log(self, record):
        """判断是否应该过滤掉这条日志"""
        # 过滤Werkzeug的HTTP请求日志
        if record.module == '_internal':
            return True

        # 过滤包含HTTP请求模式的日志
        message = self.format(record)
        if any(pattern in message for pattern in [
            '"GET ', '"POST ', '"PUT ', '"DELETE ',
            'HTTP/1.1"', 'HTTP/1.0"',
            'werkzeug',
            '127.0.0.1 - -',  # 过滤访问日志
        ]):
            return True

        # 过滤一些不重要的系统日志
        if record.module in ['urllib3', 'requests', 'aiohttp']:
            return True

        # 2. 关键修复：允许 weidian_scraper 和 app 的 INFO 日志通过
        # 只要是这些模块，即使是 INFO 级别也允许通过
        whitelist_modules = [
            '__main__', 'app', 'database', 'bot',
            'weidian_scraper', 'feature_extractor',
            'vector_engine', 'migrate_data'
        ]

        if record.module in whitelist_modules:
            return False

        # 对于其他未知模块，只显示WARNING级别以上
        if record.levelno < logging.WARNING:
            return True

        return False

# 创建队列处理器并添加到根日志器
queue_handler = QueueHandler()
queue_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(queue_handler)

# 确保控制台输出不受QueueHandler过滤影响
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
logging.getLogger().addHandler(console_handler)

# 设置其他日志器的级别
logging.getLogger('werkzeug').setLevel(logging.INFO)  # 显示HTTP请求日志
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('requests').setLevel(logging.WARNING)
logging.getLogger('aiohttp').setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

# 机器人相关变量
bot_clients = []
bot_tasks = []
bot_running = False  # 标记机器人是否正在运行

# 全局特征提取器实例（在应用启动时创建）
feature_extractor_instance = None

def initialize_feature_extractor():
    """在应用启动时初始化特征提取器，确保单例模式"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        print("🚀 初始化全局特征提取器实例...")
        try:
            from feature_extractor import DINOv2FeatureExtractor
            feature_extractor_instance = DINOv2FeatureExtractor()
            print("✅ 全局特征提取器实例初始化完成")
        except Exception as e:
            print(f"❌ 特征提取器初始化失败: {e}")
            feature_extractor_instance = None
    return feature_extractor_instance

def get_global_feature_extractor():
    """获取全局特征提取器实例"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        return initialize_feature_extractor()
    return feature_extractor_instance

# 在应用启动时初始化
initialize_feature_extractor()

app = Flask(__name__)
# 生产环境使用强随机密钥
app.secret_key = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')

# CORS 配置，必须允许 Credentials
CORS(app, origins=[
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://69.30.204.184:3000"
], supports_credentials=True)

# Cookie 配置优化 (解决本地调试 Cookie 无法写入的问题)
app.config.update(
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax', # 在同一域名不同端口下 Lax 通常更好
    SESSION_COOKIE_SECURE=False,   # 本地调试必须为 False，否则 http 下不发送 cookie
)

def extract_features(image_path):
    """使用深度学习模型提取图像特征"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            logger.error("特征提取器未初始化")
            return None
        features = extractor.extract_feature(image_path)
        # 如果特征提取失败，返回 None（上层将处理并返回错误）
        if features is None:
            logger.warning(f"特征提取失败: {image_path}")
            return None

        return features

    except Exception as e:
        logger.error(f"特征提取异常: {e}")
        return None

@app.route('/search_similar', methods=['POST'])
def search_similar():
    """搜索相似图像 - 使用 FAISS HNSW"""
    try:
        image_url = request.form.get('image_url')
        threshold = float(request.form.get('threshold', 0.6))  # DINOv2需要更高的阈值
        limit = int(request.form.get('limit', 5))  # 返回结果数量，默认5个

        # 获取用户店铺权限过滤（用于Discord机器人）
        user_shops = None
        user_shops_json = request.form.get('user_shops')
        if user_shops_json:
            try:
                user_shops = json.loads(user_shops_json)
            except:
                user_shops = None

        # 调试信息
        print(f"DEBUG: Received threshold: {threshold}")
        print(f"DEBUG: User shops filter: {user_shops}")
        print(f"DEBUG: Form data: {list(request.form.keys())}")
        print(f"DEBUG: Files: {list(request.files.keys()) if request.files else 'No files'}")
        print(f"DEBUG: Content-Type: {request.content_type}")
        print(f"DEBUG: Method: {request.method}")
        print(f"DEBUG: image_url parameter: '{image_url}'")

        # 处理图片来源
        import uuid
        if image_url:
            print(f"DEBUG: Processing image URL: {image_url}")
            # 验证URL格式
            if not image_url.startswith(('http://', 'https://')):
                return jsonify({'error': 'Invalid URL format, must start with http:// or https://'}), 400

            # 从URL下载图片
            import requests
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                response = requests.get(image_url, timeout=15, headers=headers, stream=True)
                print(f"DEBUG: URL response status: {response.status_code}")
                print(f"DEBUG: Content-Type: {response.headers.get('content-type', 'unknown')}")

                if response.status_code != 200:
                    return jsonify({'error': f'Failed to download image from URL, status: {response.status_code}'}), 400

                # 检查内容类型
                content_type = response.headers.get('content-type', '').lower()
                if not any(img_type in content_type for img_type in ['image/', 'application/octet-stream']):
                    print(f"DEBUG: Warning - Content-Type '{content_type}' may not be an image")

                temp_filename = f"{uuid.uuid4()}.jpg"
                image_path = f"/tmp/{temp_filename}"

                with open(image_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)

                # 检查文件大小
                import os
                file_size = os.path.getsize(image_path)
                print(f"DEBUG: Image downloaded to: {image_path}, size: {file_size} bytes")

                if file_size == 0:
                    os.remove(image_path)
                    return jsonify({'error': 'Downloaded file is empty'}), 400

                if file_size > 10 * 1024 * 1024:  # 10MB limit
                    os.remove(image_path)
                    return jsonify({'error': 'Image file too large (max 10MB)'}), 400

            except requests.exceptions.RequestException as e:
                print(f"DEBUG: Network error downloading image: {str(e)}")
                return jsonify({'error': f'Network error downloading image: {str(e)}'}), 400
            except Exception as e:
                print(f"DEBUG: Failed to download image: {str(e)}")
                return jsonify({'error': f'Failed to download image: {str(e)}'}), 400
        else:
            print("DEBUG: No image_url provided, checking for uploaded file")
            # 从上传的文件获取图片
            if 'image' not in request.files:
                print("DEBUG: No 'image' file found in request.files")
                return jsonify({'error': 'No image provided'}), 400

            image_file = request.files['image']
            print(f"DEBUG: Found uploaded file: {image_file.filename if image_file else 'None'}")
        temp_filename = f"{uuid.uuid4()}.jpg"
        image_path = f"/tmp/{temp_filename}"
        image_file.save(image_path)

        try:
            # 提取特征 (使用 DINOv2 + YOLOv8)
            query_features = extract_features(image_path)

            if query_features is None:
                return jsonify({'error': 'Feature extraction failed'}), 500

            # 使用 FAISS HNSW 向量搜索
            print(f"DEBUG: Searching with threshold: {threshold}, vector length: {len(query_features)}")
            # 用较低的阈值搜索找到候选结果，然后从中筛选满足用户阈值的结果
            low_threshold_results = db.search_similar_images(query_features, limit=10, threshold=0.1)
            print(f"DEBUG: Low threshold (0.1) search results: {len(low_threshold_results) if low_threshold_results else 0}")

            # 从低阈值结果中筛选出满足用户阈值的结果
            results = []
            if low_threshold_results:
                for result in low_threshold_results:
                    similarity = result.get('similarity', 0)
                    # 应用用户相似度阈值和店铺过滤
                    if similarity >= threshold:
                        # 检查店铺权限
                        if user_shops and result.get('shop_name') not in user_shops:
                            print(f"DEBUG: Skipping result from shop {result.get('shop_name')} - not in user shops {user_shops}")
                            continue
                        results.append(result)
                        if len(results) >= limit:
                            break

            print(f"DEBUG: Filtered results count (threshold {threshold}): {len(results)}")
            if results:
                print(f"DEBUG: Best match similarity: {results[0]['similarity']}")
            elif low_threshold_results:
                print(f"DEBUG: Best low-threshold match similarity: {low_threshold_results[0]['similarity']}")
            print(f"DEBUG: Total indexed images: {db.get_total_indexed_images()}")

            # 如果没有找到满足阈值的结果，但有高质量的低阈值匹配（相似度>0.8），也可以考虑使用
            if not results and low_threshold_results and len(low_threshold_results) > 0:
                best_low_match = low_threshold_results[0]
                if best_low_match.get('similarity', 0) > 0.8:  # 高质量匹配
                    print(f"DEBUG: Using high-quality low-threshold result (similarity: {best_low_match['similarity']:.4f})")
                    results = [best_low_match]

            response_data = {
                'success': True,
                'results': [],
                'totalResults': 0,
                'message': f'未找到相似度超过{threshold*100:.0f}%的商品',
                'searchTime': datetime.now().isoformat(),
                'debugInfo': {
                    'totalIndexedImages': db.get_total_indexed_images(),
                    'threshold': threshold,
                    'searchedVectors': len(results) if results else 0
                }
            }

            if results:
                # 处理多个搜索结果
                processed_results = []
                for i, result in enumerate(results):
                    # 获取完整产品信息
                    product_info = db._get_product_info_by_id(result['id'])

                    # 获取实际的图片URL列表
                    actual_images = []
                    if product_info:
                        with db.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (result['id'],))
                            actual_images = [f"/api/image/{result['id']}/{row[0]}" for row in cursor.fetchall()]

                    result_data = {
                        'rank': i + 1,
                        'similarity': float(result['similarity']),
                        'imageIndex': result['image_index'],
                        'matchedImage': f"/api/image/{result['id']}/{result['image_index']}",
                        'product': {
                            'id': result['id'],
                            'title': product_info['title'] if product_info else result.get('title', ''),
                            'englishTitle': product_info.get('english_title', ''),
                            'weidianUrl': product_info['product_url'] if product_info else result.get('product_url', ''),
                            'cnfansUrl': product_info.get('cnfans_url', ''),
                            'acbuyUrl': product_info.get('acbuy_url', ''),
                            'ruleEnabled': product_info.get('ruleEnabled', True) if product_info else True,
                            'images': actual_images if actual_images else [f"/api/image/{result['id']}/{result['image_index']}"]  # 使用实际图片列表
                        }
                    }
                    processed_results.append(result_data)

                # 保存最佳匹配的搜索历史
                if processed_results:
                    best_match = processed_results[0]
                    db.add_search_history(
                        query_image_path=image_path,
                        matched_product_id=best_match['product']['id'],
                        matched_image_index=best_match['imageIndex'],
                        similarity=best_match['similarity'],
                        threshold=threshold
                    )

                response_data = {
                    'success': True,
                    'results': processed_results,
                    'totalResults': len(processed_results),
                    'searchTime': datetime.now().isoformat(),
                    'debugInfo': {
                        'totalIndexedImages': db.get_total_indexed_images(),
                        'threshold': threshold,
                        'limit': limit,
                        'searchedVectors': len(results) if results else 0
                    }
                }

            return jsonify(response_data)

        finally:
            # 清理临时文件
            if os.path.exists(image_path):
                os.unlink(image_path)

    except Exception as e:
        logger.error(f"搜索失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/scrape', methods=['POST'])
def scrape_product():
    """抓取商品并建立索引"""
    try:
        logger.info("收到商品抓取请求")
        data = request.get_json()
        if data is None:
            logger.error("请求体为空")
            return jsonify({'error': 'Invalid request body'}), 400

        logger.info(f"请求数据: {data}")

        # 支持两种输入方式：完整URL或商品ID
        url = data.get('url')
        weidian_id = data.get('weidianId')

        if not url and not weidian_id:
            logger.error("缺少URL或weidianId")
            return jsonify({'error': 'URL or weidianId is required'}), 400

        # 如果提供了weidianId，构造URL
        if weidian_id and not url:
            url = f"https://weidian.com/item.html?itemID={weidian_id}"
            logger.info(f"构造URL: {url}")

        # 验证URL格式
        if 'weidian.com' not in url:
            logger.error(f"不支持的URL格式: {url}")
            return jsonify({'error': '只支持微店商品链接'}), 400

        logger.info(f"开始抓取商品: {url}")

        # 检查商品是否已存在
        existing = db.get_product_by_url(url)
        if existing:
            return jsonify({'error': '商品已存在', 'existing': True}), 409

        # 使用真正的爬虫
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        # 抓取商品信息
        product_info = scraper.scrape_product_info(url)

        if not product_info:
            return jsonify({'error': '商品信息抓取失败，请检查URL是否正确'}), 500

        # 生成acbuy链接
        acbuy_url = ''
        if product_info['weidian_url']:
            # 从weidian_url中提取itemID
            import re
            item_id_match = re.search(r'itemID=(\d+)', product_info['weidian_url'])
            if item_id_match:
                item_id = item_id_match.group(1)
                # 构建acbuy链接
                encoded_url = product_info['weidian_url'].replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
                acbuy_url = f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'

        # 保存到数据库（使用全局延迟配置）
        product_id = db.insert_product({
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'description': product_info['description'],
            'english_title': product_info.get('english_title') or '',
            'cnfans_url': product_info.get('cnfans_url') or '',
            'acbuy_url': acbuy_url,
            'shop_name': product_info.get('shop_name', ''),  # 从product_info获取店铺名称
            'ruleEnabled': True  # 默认启用自动回复规则
        })

        # 下载图片并建立向量索引
        if product_info['images']:
            logger.info(f"下载 {len(product_info['images'])} 张图片并建立索引")

            # 创建图片保存目录
            import os
            images_dir = os.path.join(os.path.dirname(__file__), 'data', 'scraped_images', product_info['id'])
            os.makedirs(images_dir, exist_ok=True)

            # 下载图片
            saved_image_paths = scraper.download_images(
                product_info['images'],
                images_dir,
                product_info['id']
            )
            # 为每张图片建立向量索引
            # 注意：YOLO裁剪已集成在DINOv2特征提取过程中，无需额外步骤
            # 使用全局特征提取器
            extractor = get_global_feature_extractor()
            if extractor is None:
                logger.error("特征提取器未初始化")
                return

            # 串行建立向量索引 (SQLite不支持多线程写入)
            # 但先使用多线程进行特征提取，然后串行插入数据库
            import concurrent.futures
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()

            def extract_features_only(img_path):
                """只提取特征，不插入数据库"""
                try:
                    features = extractor.extract_feature(img_path)
                    return features
                except Exception as e:
                    logger.error(f"特征提取失败 {img_path}: {e}")
                    return None

            # 第一步：多线程特征提取
            logger.info("开始多线程特征提取...")
            features_list = []
            max_workers = min(config.FEATURE_EXTRACT_THREADS, len(saved_image_paths))

            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # 提交特征提取任务
                future_to_image = {
                    executor.submit(extract_features_only, img_path): (i, img_path)
                    for i, img_path in enumerate(saved_image_paths)
                }

                # 收集特征提取结果
                for future in concurrent.futures.as_completed(future_to_image):
                    i, img_path = future_to_image[future]
                    try:
                        features = future.result()
                        features_list.append((i, img_path, features))
                    except Exception as e:
                        logger.error(f"特征提取异常 {img_path}: {e}")
                        features_list.append((i, img_path, None))

            # 按索引排序结果
            features_list.sort(key=lambda x: x[0])

            # 第二步：串行插入数据库和FAISS索引
            logger.info("开始串行数据库插入和索引建立...")
            indexed_images = []

            for i, img_path, features in features_list:
                try:
                    if features is None:
                        logger.error(f"跳过图片 {i}: 特征提取失败")
                        continue

                    # 插入数据库记录
                    image_db_id = db.insert_image_record(product_id, img_path, i)
                    if not image_db_id:
                        logger.error(f"图片 {i} 元数据插入失败")
                        continue

                    # 插入FAISS向量索引
                    success = engine.add_vector(image_db_id, features)
                    if success:
                        indexed_images.append(f"{i}.jpg")
                        logger.info(f"图片 {i} 索引建立成功")
                    else:
                        logger.error(f"图片 {i} 索引建立失败")

                except Exception as e:
                    logger.error(f"处理图片 {i} 时出错: {e}")
                    continue

            # 检查是否有图片处理失败
            if len(indexed_images) != len(saved_image_paths):
                failed_count = len(saved_image_paths) - len(indexed_images)
                logger.warning(f"有 {failed_count} 张图片处理失败，但继续执行")

            # 如果一张图片都没成功，认为是错误
            if not indexed_images:
                logger.error("所有图片处理都失败了")
                try:
                    db.delete_product_images(product_id)
                except Exception as del_e:
                    logger.error(f"回滚删除失败: {del_e}")
                return jsonify({'error': 'All image processing failed'}), 500

            # 实时保存FAISS索引
            engine.save()

            logger.info(f"共建立 {len(indexed_images)} 张图片的索引")
        else:
            logger.warning("未找到商品图片")

        # 返回完整的商品信息
        result = {
            'id': product_id,
            'weidianId': product_info['id'],  # 添加微店商品ID
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'englishTitle': product_info['english_title'],
            'weidianUrl': product_info['weidian_url'],
            'cnfansUrl': product_info['cnfans_url'],
            'description': product_info['description'],
            'ruleEnabled': True,  # 默认启用规则
            'createdAt': datetime.now().isoformat(),
            'images': product_info['images']  # 返回图片URL列表
        }

        logger.info(f"商品抓取完成: {product_info['title']}")
        return jsonify(result)

    except Exception as e:
        logger.error(f"抓取失败: {e}")
        return jsonify({'error': str(e)}), 500

# Discord 账号管理 API
# ===== 用户认证和权限管理API =====

def get_current_user():
    """获取当前登录用户"""
    user_id = session.get('user_id')
    if user_id:
        return db.get_user_by_id(user_id)
    return None

def require_admin():
    """检查是否为管理员"""
    user = get_current_user()
    return user and user.get('role') == 'admin'

def can_manage_shops():
    """检查用户是否有管理店铺的权限（管理员或有分配的店铺）"""
    user = get_current_user()
    if not user:
        return False
    # 管理员可以管理所有店铺
    if user.get('role') == 'admin':
        return True
    # 普通用户如果有分配的店铺，也可以管理
    user_shops = user.get('shops', [])
    return len(user_shops) > 0

def require_login():
    """检查是否已登录"""
    # 开发模式下跳过认证
    if config.DEBUG:
        # 开发模式下自动设置为admin用户
        if 'user_id' not in session:
            session['user_id'] = 1  # 默认admin用户ID
        return True
    return get_current_user() is not None

@app.route('/api/auth/login', methods=['POST'])
def login():
    """用户登录"""
    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': '用户名和密码不能为空'}), 400

        username = data['username']
        password = data['password']

        user = db.authenticate_user(username, password)
        if user:
            session['user_id'] = user['id']
            # 不返回密码哈希
            user_info = {k: v for k, v in user.items() if k != 'password_hash'}
            return jsonify({'user': user_info, 'message': '登录成功'})
        else:
            return jsonify({'error': '用户名或密码错误'}), 401
    except Exception as e:
        logger.error(f"登录失败: {e}")
        return jsonify({'error': '登录失败'}), 500

@app.route('/api/auth/logout', methods=['POST'])
def logout():
    """用户登出"""
    session.pop('user_id', None)
    return jsonify({'message': '已登出'})

@app.route('/api/auth/me', methods=['GET'])
def get_current_user_info():
    """获取当前用户信息"""
    user = get_current_user()
    if user:
        # 不返回密码哈希
        user_info = {k: v for k, v in user.items() if k != 'password_hash'}
        return jsonify({'user': user_info})
    return jsonify({'error': '未登录'}), 401

@app.route('/api/users', methods=['GET'])
def get_users():
    """获取所有用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        users = db.get_all_users()
        # 不返回密码哈希
        for user in users:
            user.pop('password_hash', None)
        return jsonify({'users': users})
    except Exception as e:
        logger.error(f"获取用户列表失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users', methods=['POST'])
def create_user():
    """创建新用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': '用户名和密码不能为空'}), 400

        username = data['username']
        password = data['password']
        role = data.get('role', 'user')
        shop_ids = data.get('shops', [])

        # 创建用户
        password_hash = f"hashed_{password}"
        if db.create_user(username, password_hash, role):
            # 获取新创建的用户ID
            user = db.authenticate_user(username, password_hash)
            if user:
                # 设置店铺权限
                if shop_ids:
                    db.update_user_shops(user['id'], shop_ids)

                user_info = {k: v for k, v in user.items() if k != 'password_hash'}
                return jsonify({'user': user_info, 'message': '用户创建成功'})
            else:
                return jsonify({'error': '用户创建失败'}), 500
        else:
            return jsonify({'error': '用户名已存在或创建失败'}), 400
    except Exception as e:
        logger.error(f"创建用户失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """删除用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        current_user = get_current_user()
        if current_user['id'] == user_id:
            return jsonify({'error': '不能删除自己的账号'}), 400

        # 检查用户是否存在
        user = db.get_user_by_id(user_id)
        if not user:
            return jsonify({'error': '用户不存在'}), 404

        # 删除用户
        if db.delete_user(user_id):
            logger.info(f"管理员 {current_user['username']} 删除了用户 {user['username']}")
            return jsonify({'message': '用户删除成功'})
        else:
            return jsonify({'error': '用户删除失败'}), 500
    except Exception as e:
        logger.error(f"删除用户失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：管理员修改用户密码 ===
@app.route('/api/users/<int:user_id>/password', methods=['PUT'])
def reset_user_password(user_id):
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        new_password = data.get('password')
        if not new_password:
            return jsonify({'error': '密码不能为空'}), 400

        # 简单哈希 (生产环境请用 bcrypt)
        password_hash = f"hashed_{new_password}"

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (password_hash, user_id))
            conn.commit()

        return jsonify({'success': True, 'message': '密码已重置'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# === 新增：网站配置管理API ===
@app.route('/api/websites', methods=['GET'])
def get_website_configs():
    """获取所有网站配置及其频道绑定（优化版本，避免N+1查询）"""
    try:
        configs = db.get_website_configs()
        return jsonify({'websites': configs})
    except Exception as e:
        logger.error(f"获取网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites', methods=['POST'])
def add_website_config():
    """添加网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': '所有字段都是必填的'}), 400

        if db.add_website_config(name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': '网站配置已添加'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['PUT'])
def update_website_config(config_id):
    """更新网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': '所有字段都是必填的'}), 400

        if db.update_website_config(config_id, name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': '网站配置已更新'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['DELETE'])
def delete_website_config(config_id):
    """删除网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_website_config(config_id):
            return jsonify({'success': True, 'message': '网站配置已删除'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['GET'])
def get_website_channels(config_id):
    """获取网站绑定的频道"""
    try:
        channels = db.get_website_channel_bindings(config_id)
        return jsonify({'channels': channels})
    except Exception as e:
        logger.error(f"获取网站频道失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['POST'])
def add_website_channel(config_id):
    """添加网站频道绑定"""
    try:
        data = request.get_json()
        channel_id = data.get('channel_id')

        if not channel_id:
            return jsonify({'error': '频道ID不能为空'}), 400

        if db.add_website_channel_binding(config_id, channel_id):
            return jsonify({'success': True, 'message': '频道绑定已添加'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加网站频道绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels/<channel_id>', methods=['DELETE'])
def remove_website_channel(config_id, channel_id):
    """移除网站频道绑定"""
    try:
        if db.remove_website_channel_binding(config_id, channel_id):
            return jsonify({'success': True, 'message': '频道绑定已移除'})
        else:
            return jsonify({'error': '移除失败'}), 500
    except Exception as e:
        logger.error(f"移除网站频道绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>/urls', methods=['GET'])
def get_product_urls(product_id):
    """获取商品的所有网站URL"""
    try:
        # 获取商品信息
        product = db._get_product_info_by_id(product_id)
        if not product:
            return jsonify({'error': '商品不存在'}), 404

        # 从商品URL中提取微店ID
        weidian_url = product.get('product_url', '')
        weidian_id = None

        if 'itemID=' in weidian_url:
            # 提取itemID参数
            import re
            match = re.search(r'itemID=([^&]+)', weidian_url)
            if match:
                weidian_id = match.group(1)

        if not weidian_id:
            return jsonify({'urls': []})

        # 生成所有网站的URL
        urls = db.generate_website_urls(weidian_id)
        return jsonify({'urls': urls})
    except Exception as e:
        logger.error(f"获取商品URL失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：系统统计信息API ===
@app.route('/api/system/stats', methods=['GET'])
def get_system_stats():
    """获取系统统计信息"""
    try:
        stats = db.get_system_stats()
        return jsonify(stats)
    except Exception as e:
        logger.error(f"获取系统统计信息失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：公告管理API ===
@app.route('/api/announcements', methods=['GET'])
def get_announcements():
    """获取所有公告"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        announcements = db.get_active_announcements()
        return jsonify({'announcements': announcements})
    except Exception as e:
        logger.error(f"获取公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements', methods=['POST'])
def create_announcement():
    """创建公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')

        if not title or not content:
            return jsonify({'error': '标题和内容都是必填的'}), 400

        if db.create_announcement(title, content):
            return jsonify({'success': True, 'message': '公告创建成功'})
        else:
            return jsonify({'error': '创建失败'}), 500
    except Exception as e:
        logger.error(f"创建公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['PUT'])
def update_announcement(announcement_id):
    """更新公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')
        is_active = data.get('is_active', True)

        if not title or not content:
            return jsonify({'error': '标题和内容都是必填的'}), 400

        if db.update_announcement(announcement_id, title, content, is_active):
            return jsonify({'success': True, 'message': '公告更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['DELETE'])
def delete_announcement(announcement_id):
    """删除公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_announcement(announcement_id):
            return jsonify({'success': True, 'message': '公告删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除公告失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：消息过滤规则API ===
@app.route('/api/message-filters', methods=['GET'])
def get_message_filters():
    """获取消息过滤规则"""
    try:
        filters = db.get_message_filters()
        return jsonify({'filters': filters})
    except Exception as e:
        logger.error(f"获取消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters', methods=['POST'])
def add_message_filter():
    """添加消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')

        if not filter_type or not filter_value:
            return jsonify({'error': '过滤类型和值都是必填的'}), 400

        if db.add_message_filter(filter_type, filter_value):
            return jsonify({'success': True, 'message': '过滤规则添加成功'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['PUT'])
def update_message_filter(filter_id):
    """更新消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')
        is_active = data.get('is_active', True)

        if not filter_type or not filter_value:
            return jsonify({'error': '过滤类型和值都是必填的'}), 400

        if db.update_message_filter(filter_id, filter_type, filter_value, is_active):
            return jsonify({'success': True, 'message': '过滤规则更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['DELETE'])
def delete_message_filter(filter_id):
    """删除消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_message_filter(filter_id):
            return jsonify({'success': True, 'message': '过滤规则删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：自定义回复内容API ===
@app.route('/api/custom-replies', methods=['GET'])
def get_custom_replies():
    """获取自定义回复内容"""
    try:
        replies = db.get_custom_replies()
        return jsonify({'replies': replies})
    except Exception as e:
        logger.error(f"获取自定义回复内容失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies', methods=['POST'])
def add_custom_reply():
    """添加自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)

        if not reply_type:
            return jsonify({'error': '回复类型是必填的'}), 400

        if db.add_custom_reply(reply_type, content, image_url, priority):
            return jsonify({'success': True, 'message': '自定义回复添加成功'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['PUT'])
def update_custom_reply(reply_id):
    """更新自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)
        is_active = data.get('is_active', True)

        if not reply_type:
            return jsonify({'error': '回复类型是必填的'}), 400

        if db.update_custom_reply(reply_id, reply_type, content, image_url, priority, is_active):
            return jsonify({'success': True, 'message': '自定义回复更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['DELETE'])
def delete_custom_reply(reply_id):
    """删除自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_custom_reply(reply_id):
            return jsonify({'success': True, 'message': '自定义回复删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>/shops', methods=['PUT'])
def update_user_shops(user_id):
    """更新用户店铺权限（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        shop_ids = data.get('shops', [])

        if db.update_user_shops(user_id, shop_ids):
            return jsonify({'message': '权限更新成功'})
        else:
            return jsonify({'error': '权限更新失败'}), 500
    except Exception as e:
        logger.error(f"更新用户权限失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """获取所有 Discord 账号"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()
    try:
        # 根据用户权限过滤账号
        if current_user['role'] == 'admin':
            # 管理员可以看到所有账号
            accounts = db.get_discord_accounts_by_user(None)
        else:
            # 普通用户只能看到自己关联的账号
            accounts = db.get_discord_accounts_by_user(current_user['id'])

        return jsonify({'accounts': accounts})
    except Exception as e:
        logger.error(f"获取账号列表失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['GET'])
def list_products():
    """列出用户有权限的商品及其图片"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()
    try:
        # 获取分页参数
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 50))  # 默认每页50条
        offset = (page - 1) * limit

        # 根据用户权限获取商品（支持分页）
        if current_user['role'] == 'admin':
            # 管理员可以看到所有商品
            logger.info(f"管理员用户 {current_user['username']} 获取商品列表 (页{page}, 每页{limit}条)")
            result = db.get_products_by_user_shops(None, limit=limit, offset=offset)
        else:
            # 普通用户只能看到自己管理的店铺的商品
            user_shops = current_user.get('shops', [])
            logger.info(f"普通用户 {current_user['username']} 获取店铺商品 (页{page}, 每页{limit}条)，分配的店铺: {user_shops}")
            result = db.get_products_by_user_shops(user_shops, limit=limit, offset=offset)

            # 调试：检查数据库中的商品和店铺匹配情况
            if user_shops:
                with db.get_connection() as conn:
                    cursor = conn.cursor()
                    placeholders = ','.join('?' * len(user_shops))
                    cursor.execute(f"SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})", user_shops)
                    matching_products = cursor.fetchone()[0]
                    logger.info(f"数据库中匹配的商品数量: {matching_products}")

                    # 列出所有店铺名称
                    cursor.execute("SELECT DISTINCT shop_name FROM products")
                    all_shop_names = [row[0] for row in cursor.fetchall()]
                    logger.info(f"数据库中的所有店铺名称: {all_shop_names}")

        logger.info(f"返回商品数量: {len(result['products'])}")

        # 添加调试信息到响应中
        response_data = {
            'products': result['products'],
            'total': result['total'],
            'debug': {
                'user_role': current_user['role'],
                'user_shops': current_user.get('shops', []),
                'is_admin': current_user['role'] == 'admin'
            }
        }

        # 添加缓存头以优化性能（5分钟缓存）
        response = jsonify(response_data)
        response.headers['Cache-Control'] = 'private, max-age=300'
        return response
    except Exception as e:
        logger.error(f"列出商品失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['PUT'])
def update_product():
    """更新商品信息"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()

    # 检查是否是multipart/form-data（包含文件上传）
    if request.content_type and 'multipart/form-data' in request.content_type:
        # 处理文件上传
        product_id = request.form.get('id')
        if not product_id:
            return jsonify({'error': '商品ID不能为空'}), 400

        try:
            # 检查权限
            if current_user['role'] == 'admin':
                pass
            else:
                user_shops = current_user.get('shops', [])
                product = db.get_product_by_id(int(product_id))
                if not product or product.get('shop_name') not in user_shops:
                    return jsonify({'error': '无权限更新此商品'}), 403

            # 处理上传的图片文件
            uploaded_files = []
            if 'uploadedImages' in request.files:
                files = request.files.getlist('uploadedImages')
                for file in files:
                    if file and file.filename:
                        # 保存文件到商品图片目录
                        import uuid
                        import os
                        filename = f"{uuid.uuid4()}_{file.filename}"
                        image_path = os.path.join('data', 'images', str(product_id), filename)

                        # 确保目录存在
                        os.makedirs(os.path.dirname(image_path), exist_ok=True)

                        # 保存文件
                        file.save(image_path)

                        # 添加到数据库
                        db.add_product_image(int(product_id), filename)
                        uploaded_files.append(filename)

            # 构建更新数据
            updates = {}
            for key in ['title', 'englishTitle', 'ruleEnabled', 'customReplyText', 'imageSource']:
                value = request.form.get(key)
                if value is not None:
                    if key == 'englishTitle':
                        updates['english_title'] = value
                    elif key == 'ruleEnabled':
                        updates['ruleEnabled'] = value.lower() == 'true'
                    elif key == 'customReplyText':
                        updates['custom_reply_text'] = value
                    elif key == 'imageSource':
                        updates['image_source'] = value
                    else:
                        updates[key] = value

            # 处理数组数据
            if 'selectedImageIndexes' in request.form:
                import json
                try:
                    updates['custom_reply_images'] = json.loads(request.form.get('selectedImageIndexes'))
                except:
                    pass

            if 'customImageUrls' in request.form:
                try:
                    updates['custom_image_urls'] = json.loads(request.form.get('customImageUrls'))
                except:
                    pass

            # 执行更新
            if updates:
                success = db.update_product(int(product_id), updates)
                if success:
                    updated_product = db.get_product_by_id(int(product_id))
                    return jsonify({'message': '商品更新成功', 'product': updated_product})
                else:
                    return jsonify({'error': '更新失败'}), 500
            else:
                return jsonify({'error': '没有要更新的字段'}), 400

        except Exception as e:
            logger.error(f"更新商品失败: {e}")
            return jsonify({'error': '更新失败'}), 500
    else:
        # 处理JSON数据（原有逻辑）
        data = request.get_json()

    if not data or not data.get('id'):
        return jsonify({'error': '商品ID不能为空'}), 400

    product_id = data['id']

    try:
            # 检查权限
        if current_user['role'] == 'admin':
            pass
        else:
            user_shops = current_user.get('shops', [])
            product = db.get_product_by_id(product_id)
            if not product or product.get('shop_name') not in user_shops:
                return jsonify({'error': '无权限更新此商品'}), 403

            # 构建更新数据
            updates = {}
            if 'title' in data:
                updates['title'] = data['title']
            if 'englishTitle' in data:
                updates['english_title'] = data['englishTitle']
            if 'ruleEnabled' in data:
                updates['ruleEnabled'] = data['ruleEnabled']
            if 'customReplyText' in data:
                updates['custom_reply_text'] = data['customReplyText']
            if 'selectedImageIndexes' in data:
                updates['custom_reply_images'] = data['selectedImageIndexes']
            if 'customImageUrls' in data:
                updates['custom_image_urls'] = data['customImageUrls']
            if 'imageSource' in data:
                updates['image_source'] = data['imageSource']

            # 执行更新
            if updates:
                success = db.update_product(product_id, updates)
                if success:
                    updated_product = db.get_product_by_id(product_id)
                    return jsonify({'message': '商品更新成功', 'product': updated_product})
                else:
                    return jsonify({'error': '更新失败'}), 500
            else:
                return jsonify({'error': '没有要更新的字段'}), 400

    except Exception as e:
        logger.error(f"更新商品失败: {e}")
        return jsonify({'error': '更新失败'}), 500


@app.route('/api/backfill_products', methods=['POST'])
def backfill_products():
    """为已存在但缺少英名或 cnfans 链接的商品回填数据"""
    try:
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        updated = []
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, product_url, english_title, cnfans_url FROM products")
            rows = cursor.fetchall()

            for row in rows:
                pid = row['id']
                url = row['product_url']
                need_english = not row['english_title']
                need_cnfans = not row['cnfans_url']
                if not (need_english or need_cnfans):
                    continue

                product_info = scraper.scrape_product_info(url)
                if not product_info:
                    logger.warning(f"回填失败，无法抓取: {url}")
                    continue

                english = product_info.get('english_title') or ''
                cnfans = product_info.get('cnfans_url') or ''

                cursor.execute("""
                    UPDATE products
                    SET english_title = ?, cnfans_url = ?
                    WHERE id = ?
                """, (english, cnfans, pid))
                conn.commit()
                updated.append(pid)

        return jsonify({'updated': updated, 'count': len(updated)})
    except Exception as e:
        logger.error(f"回填失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/rebuild_index', methods=['POST'])
def rebuild_index():
    """重建FAISS索引，清理被删除的向量"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        from feature_extractor import get_feature_extractor

        logger.info("开始重建FAISS索引...")

        # 获取所有有效的图片记录（确保图片文件存在）
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT pi.id, pi.product_id, pi.image_path, pi.image_index
                FROM product_images pi
                JOIN products p ON pi.product_id = p.id
                ORDER BY pi.id
            """)
            all_records = cursor.fetchall()

        # 过滤出文件存在的记录
        image_records = []
        for record in all_records:
            if os.path.exists(record['image_path']):
                image_records.append(record)
            else:
                logger.warning(f"图片文件不存在，跳过: {record['image_path']}")

        if not image_records:
            return jsonify({'error': '没有找到图片记录'}), 400

        logger.info(f"找到 {len(image_records)} 张图片记录")

        # 重新提取特征并重建索引
        extractor = get_feature_extractor()
        engine = get_vector_engine()

        # 创建新索引
        vectors_data = []
        for record in image_records:
            try:
                image_path = record['image_path']
                if not os.path.exists(image_path):
                    logger.warning(f"图片文件不存在: {image_path}")
                    continue

                # 提取特征
                features = extractor.extract_feature(image_path)
                if features is not None:
                    vectors_data.append((record['id'], features))
                    logger.info(f"重新提取特征: {record['id']}")
                else:
                    logger.warning(f"特征提取失败: {image_path}")

            except Exception as e:
                logger.error(f"处理图片 {record['id']} 失败: {e}")
                continue

        # 重建索引
        success = engine.rebuild_index(vectors_data)
        if success:
            logger.info(f"索引重建完成，包含 {len(vectors_data)} 个向量")
            return jsonify({
                'success': True,
                'message': f'索引重建完成，包含 {len(vectors_data)} 个有效向量',
                'total_vectors': len(vectors_data)
            })
        else:
            return jsonify({'error': '索引重建失败'}), 500

    except Exception as e:
        logger.error(f"重建索引失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/rebuild_vectors', methods=['POST'])
def rebuild_vectors():
    """为已有商品（或缺失向量的图片）重建特征并插入 FAISS"""
    try:
        extractor = get_feature_extractor()
        rebuilt = []
        failed = []

        with db.get_connection() as conn:
            cursor = conn.cursor()
            # 查找所有 product_images 中 milvus_id 为空或 NULL 的记录
            cursor.execute("SELECT id, product_id, image_path, image_index FROM product_images WHERE milvus_id IS NULL OR milvus_id = ''")
            rows = cursor.fetchall()

        for row in rows:
            pid = row['product_id']
            img_path = row['image_path']
            idx = row['image_index']
            try:
                features = extractor.extract_feature(img_path)
                if features is None:
                    logger.error(f"重建特征失败: {img_path}")
                    failed.append({'product_id': pid, 'image_index': idx})
                    continue

                success = db.insert_image_vector(product_id=pid, image_path=img_path, image_index=idx, vector=features)
                if success:
                    rebuilt.append({'product_id': pid, 'image_index': idx})
                else:
                    failed.append({'product_id': pid, 'image_index': idx})
            except Exception as e:
                logger.error(f"重建向量出错: {e}")
                failed.append({'product_id': pid, 'image_index': idx})

        return jsonify({'rebuilt': rebuilt, 'failed': failed, 'count': len(rebuilt)})
    except Exception as e:
        logger.error(f"重建向量失败: {e}")
        return jsonify({'error': str(e)}), 500



@app.route('/api/image/<int:product_id>/<int:image_index>', methods=['GET'])
def serve_product_image(product_id: int, image_index: int):
    """返回指定商品指定序号的图片文件（用于前端缩略图/查看）"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_path FROM product_images WHERE product_id = ? AND image_index = ?", (product_id, image_index))
            row = cursor.fetchone()
            if not row:
                return jsonify({'error': 'Image not found'}), 404
            image_path = row[0]

        # 安全检查并返回文件
        from flask import send_file
        if not os.path.exists(image_path):
            return jsonify({'error': 'Image file missing'}), 404
        return send_file(image_path, mimetype='image/jpeg')
    except Exception as e:
        logger.error(f"serve_product_image 失败: {e}")
        return jsonify({'error': str(e)}), 500

def verify_discord_token(token):
    """验证Discord token并获取用户信息"""
    try:
        headers = {
            'Authorization': f'Bot {token}' if token.startswith('Bot ') else token,
            'User-Agent': 'DiscordBot/1.0'
        }

        # 首先尝试作为Bot token验证
        response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 401:
            # 如果Bot token失败，尝试作为User token
            if not token.startswith('Bot '):
                headers['Authorization'] = f'Bot {token}'
                response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 200:
            user_data = response.json()
            return {
                'valid': True,
                'username': f"{user_data.get('username', 'Unknown')}#{user_data.get('discriminator', '0000')}",
                'user_id': user_data.get('id'),
                'avatar': user_data.get('avatar'),
                'bot': user_data.get('bot', False)
            }
        else:
            return {
                'valid': False,
                'error': f'HTTP {response.status_code}: {response.text}'
            }
    except requests.exceptions.RequestException as e:
        return {
            'valid': False,
            'error': f'网络错误: {str(e)}'
        }
    except Exception as e:
        return {
            'valid': False,
            'error': f'验证失败: {str(e)}'
        }

@app.route('/api/accounts', methods=['POST'])
def add_account():
    """添加新的 Discord 账号"""
    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': '需要登录'}), 401

        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        token = data.get('token')
        username = data.get('username', '')

        if not token:
            return jsonify({'error': 'Token is required'}), 400

        # 验证token并获取真实用户名
        logger.info("正在验证Discord token...")
        token_info = verify_discord_token(token)

        if not token_info['valid']:
            return jsonify({'error': f'Token验证失败: {token_info["error"]} 请检查token是否正确'}), 400

        # 如果没有提供用户名，使用从token获取的用户名
        if not username:
            username = token_info['username']
            logger.info(f"自动获取用户名: {username}")

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO discord_accounts (username, token, status, user_id)
                VALUES (?, ?, 'offline', ?)
            """, (username, token, current_user['id']))
            account_id = cursor.lastrowid

            cursor.execute("SELECT id, username, token, status, last_active, user_id FROM discord_accounts WHERE id = ?", (account_id,))
            account = cursor.fetchone()
            conn.commit()

        logger.info(f"账号添加成功: {username} (用户ID: {current_user['id']})")
        return jsonify({
            'id': account[0],
            'username': account[1],
            'token': account[2],
            'status': account[3],
            'lastActive': account[4],
            'user_id': account[5],
            'verified': True
        })
    except Exception as e:
        logger.error(f"添加账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/user', methods=['PUT'])
def assign_account_to_user(account_id):
    """将Discord账号分配给用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        user_id = data.get('user_id')

        if db.update_discord_account_user(account_id, user_id):
            return jsonify({'message': '账号分配成功'})
        else:
            return jsonify({'error': '账号分配失败'}), 500
    except Exception as e:
        logger.error(f"分配账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>', methods=['DELETE'])
def delete_account(account_id):
    """删除 Discord 账号"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM discord_accounts WHERE id = ?", (account_id,))
            conn.commit()

        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"删除账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/status', methods=['PUT'])
def update_account_status(account_id):
    """更新账号状态"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        status = data.get('status')

        if status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status'}), 400

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE discord_accounts
                SET status = ?, updated_at = datetime('now')
                WHERE id = ?
            """, (status, account_id))
            conn.commit()

        return jsonify({'success': True, 'status': status})
    except Exception as e:
        logger.error(f"更新账号状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/current', methods=['GET'])
def get_current_account():
    """获取当前可用的 Discord 账号 (状态为online的第一个)"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, username, token, status, last_active
                FROM discord_accounts
                WHERE status = 'online'
                ORDER BY last_active DESC NULLS LAST, created_at ASC
                LIMIT 1
            """)
            account = cursor.fetchone()

            if account:
                return jsonify({
                    'id': account[0],
                    'username': account[1],
                    'token': account[2],
                    'status': account[3],
                    'lastActive': account[4]
                })
            else:
                return jsonify({'error': 'No active account found'}), 404
    except Exception as e:
        logger.error(f"获取当前账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/verify-all', methods=['POST'])
def verify_all_accounts():
    """重新验证所有账号"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            # 获取所有账号
            cursor.execute("SELECT id, username, token FROM discord_accounts")
            accounts = cursor.fetchall()

            verified_count = 0
            invalid_count = 0
            results = []

            for account in accounts:
                account_id, username, token = account
                logger.info(f"正在验证账号: {username}")

                token_info = verify_discord_token(token)

                if token_info['valid']:
                    # 更新用户名（如果有变化）
                    new_username = token_info['username']
                    if new_username != username:
                        cursor.execute("""
                            UPDATE discord_accounts
                            SET username = ?
                            WHERE id = ?
                        """, (new_username, account_id))
                        logger.info(f"用户名已更新: {username} -> {new_username}")

                    verified_count += 1
                    results.append({
                        'id': account_id,
                        'username': new_username,
                        'valid': True
                    })
                else:
                    invalid_count += 1
                    results.append({
                        'id': account_id,
                        'username': username,
                        'valid': False,
                        'error': token_info['error']
                    })

            conn.commit()

        return jsonify({
            'success': True,
            'total': len(accounts),
            'verified': verified_count,
            'invalid': invalid_count,
            'results': results
        })
    except Exception as e:
        logger.error(f"批量验证账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/bulk-status', methods=['POST'])
def bulk_update_status():
    """批量开启或停止所有账号"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        new_status = data.get('status')
        if new_status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status. Must be "online" or "offline"'}), 400

        with db.get_connection() as conn:
            cursor = conn.cursor()

            if new_status == 'online':
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'online', last_active = ?
                """, (datetime.now(),))
            else:
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'offline'
                """)

            updated_count = cursor.rowcount
            conn.commit()

        logger.info(f"批量更新账号状态: {updated_count} 个账号设置为 {new_status}")

        return jsonify({
            'success': True,
            'updated_count': updated_count,
            'new_status': new_status
        })
    except Exception as e:
        logger.error(f"批量更新账号状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/rotation', methods=['GET'])
def get_rotation_config():
    """获取账号轮换配置"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT enabled, rotation_interval, current_account_id
                FROM account_rotation_config
                LIMIT 1
            """)
            row = cursor.fetchone()

        if row:
            return jsonify({
                'enabled': row[0],
                'rotationInterval': row[1],
                'currentAccountId': row[2]
            })
        return jsonify({'enabled': False, 'rotationInterval': 10})
    except Exception as e:
        logger.error(f"获取轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/user/settings', methods=['GET'])
def get_user_settings():
    """获取当前用户的个性化设置"""
    user = get_current_user()
    if not user:
        return jsonify({'error': '需要登录'}), 401

    try:
        settings = db.get_user_settings(user['id'])
        return jsonify(settings)
    except Exception as e:
        logger.error(f"获取用户设置失败: {e}")
        return jsonify({'error': '获取设置失败'}), 500

@app.route('/api/user/settings', methods=['PUT'])
def update_user_settings():
    """更新当前用户的个性化设置"""
    user = get_current_user()
    if not user:
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        success = db.update_user_settings(
            user_id=user['id'],
            download_threads=data.get('download_threads'),
            feature_extract_threads=data.get('feature_extract_threads'),
            discord_similarity_threshold=data.get('discord_similarity_threshold'),
            global_reply_min_delay=data.get('global_reply_min_delay'),
            global_reply_max_delay=data.get('global_reply_max_delay'),
            user_blacklist=data.get('user_blacklist'),
            keyword_filters=data.get('keyword_filters')
        )

        if success:
            return jsonify({'message': '设置更新成功'})
        else:
            return jsonify({'error': '设置更新失败'}), 500
    except Exception as e:
        logger.error(f"更新用户设置失败: {e}")
        return jsonify({'error': '更新设置失败'}), 500

@app.route('/api/accounts/rotation', methods=['POST'])
def update_rotation_config():
    """更新账号轮换配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        enabled = data.get('enabled', False)
        rotation_interval = data.get('rotationInterval', 10)

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE account_rotation_config
                SET enabled = ?, rotation_interval = ?, updated_at = datetime('now')
                WHERE id = 1
            """, (enabled, rotation_interval))
            conn.commit()

        return jsonify({'success': True, 'enabled': enabled, 'rotationInterval': rotation_interval})
    except Exception as e:
        logger.error(f"更新轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/get_indexed_ids', methods=['GET'])
def get_indexed_ids():
    """获取已建立索引的商品URL列表"""
    try:
        indexed_urls = db.get_indexed_product_urls()
        return jsonify({'indexedIds': indexed_urls})
    except Exception as e:
        logger.error(f"获取已索引ID失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：批量删除 API ===
@app.route('/api/products/batch', methods=['DELETE'])
def batch_delete_products():
    """批量删除商品"""
    try:
        data = request.get_json()
        ids = data.get('ids', [])
        if not ids:
            return jsonify({'error': 'No IDs provided'}), 400

        count = 0
        for pid in ids:
            if db.delete_product_images(pid):
                count += 1

        return jsonify({'success': True, 'count': count})
    except Exception as e:
        logger.error(f"批量删除失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>', methods=['DELETE'])
def delete_product(product_id):
    """删除商品及其所有相关数据"""
    try:
        # 删除商品及其向量数据
        if db.delete_product_images(product_id):
            return jsonify({'success': True, 'message': f'商品 {product_id} 已删除'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除商品失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：商品图片上传 API ===
@app.route('/api/products/<int:product_id>/images', methods=['POST'])
def upload_product_image(product_id):
    """上传新图片到商品（多线程处理）"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        if 'image' not in request.files:
            return jsonify({'error': 'No image file'}), 400

        file = request.files['image']
        if not file.filename:
            return jsonify({'error': 'Empty filename'}), 400

        # 获取当前最大的 image_index 和检查图片数量限制
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT MAX(image_index) FROM product_images WHERE product_id = ?", (product_id,))
            row = cursor.fetchone()
            next_index = (row[0] + 1) if row and row[0] is not None else 0

            # 检查图片数量限制（每个商品最多20张图片）
            cursor.execute("SELECT COUNT(*) FROM product_images WHERE product_id = ?", (product_id,))
            count_row = cursor.fetchone()
            if count_row and count_row[0] >= 20:
                return jsonify({'error': '每个商品最多只能上传20张图片'}), 400

        # 保存文件
        filename = f"{product_id}_{next_index}_{int(time.time())}.jpg"
        save_path = os.path.join('data', 'images', filename)
        os.makedirs(os.path.dirname(save_path), exist_ok=True)
        file.save(save_path)

        # 多线程处理：特征提取和索引
        import concurrent.futures
        import threading

        result = {'success': False, 'error': None}

        def process_image_async():
            """异步处理图片特征提取和索引"""
            try:
                # 提取特征
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("特征提取器未初始化")
                    return None
                features = extractor.extract_feature(save_path)

                if features is None:
                    os.remove(save_path)
                    result['error'] = '特征提取失败，图片无效'
                    return

                # 存入数据库
                img_db_id = db.insert_image_record(product_id, save_path, next_index)

                # 存入 FAISS
                try:
                    from vector_engine import get_vector_engine
                except ImportError:
                    from .vector_engine import get_vector_engine
                engine = get_vector_engine()
                engine.add_vector(img_db_id, features)
                engine.save()

                result['success'] = True
                result['img_db_id'] = img_db_id
                logger.info(f"图片上传成功: product_id={product_id}, image_index={next_index}, db_id={img_db_id}")

            except Exception as e:
                logger.error(f"图片处理失败: {e}")
                result['error'] = str(e)
                # 清理失败的文件
                try:
                    os.remove(save_path)
                except:
                    pass

        # 启动后台线程处理图片
        processing_thread = threading.Thread(target=process_image_async, daemon=True)
        processing_thread.start()

        # 等待最多5秒让处理完成
        processing_thread.join(timeout=5.0)

        if not result['success']:
            error_msg = result.get('error', '图片处理失败')
            return jsonify({'error': error_msg}), 500

        # 返回更新后的商品信息
        product = db._get_product_info_by_id(product_id)
        # 获取所有图片
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            images = [f"/api/image/{product_id}/{row[0]}" for row in cursor.fetchall()]

        product['images'] = images
        # 格式化以匹配前端
        product['weidianId'] = product.get('product_url', '').split('itemID=')[1] if 'itemID=' in product.get('product_url', '') else ''
        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['ruleEnabled'] = product.get('ruleEnabled')
        product['matchType'] = 'fuzzy' # Default

        return jsonify({'success': True, 'product': product})
    except Exception as e:
        logger.error(f"上传图片失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：删除图片后返回最新 Product 对象 ===
@app.route('/api/products/<int:product_id>/images/<int:image_index>', methods=['DELETE'])
def delete_product_image(product_id, image_index):
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        logger.info(f"开始删除图片: product_id={product_id}, image_index={image_index}")


        # 验证参数
        try:
            product_id = int(product_id)
            image_index = int(image_index)
        except ValueError:
            return jsonify({'error': '参数格式错误'}), 400

        # 调用数据库删除逻辑
        success = db.delete_image_vector(product_id, image_index)

        if not success:
            logger.warning(f"删除图片失败: product_id={product_id}, image_index={image_index}")
            return jsonify({'error': '删除失败，图片可能不存在'}), 404

        # 获取最新商品信息
        product = db._get_product_info_by_id(product_id)

        if not product:
            logger.error(f"删除后商品不存在: product_id={product_id}")
            return jsonify({'error': '商品不存在'}), 404

        # 获取剩余所有图片
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            image_indices = [row[0] for row in cursor.fetchall()]
            images = [f"/api/image/{product_id}/{idx}" for idx in image_indices]

        product['images'] = images

        # 格式化商品信息
        try:
            if 'itemID=' in product.get('product_url', ''):
                product['weidianId'] = product.get('product_url', '').split('itemID=')[1]
            else:
                product['weidianId'] = ''
        except:
            product['weidianId'] = ''

        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['acbuyUrl'] = product.get('acbuy_url')
        product['ruleEnabled'] = product.get('ruleEnabled')

        logger.info(f"删除图片成功: product_id={product_id}, image_index={image_index}, 剩余图片数量={len(images)}")

        return jsonify({'success': True, 'product': product})

    except Exception as e:
        logger.error(f"删除图片失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/cleanup/images', methods=['POST'])
def cleanup_images():
    """清理未使用的图片文件"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': '只有管理员可以执行清理操作'}), 403

        # 获取清理参数
        data = request.get_json() or {}
        days_old = data.get('days_old', 30)

        # 执行清理
        deleted_count = db.cleanup_unused_images(days_old)

        return jsonify({
            'success': True,
            'message': f'清理完成，共删除 {deleted_count} 个未使用的图片文件',
            'deleted_count': deleted_count
        })

    except Exception as e:
        logger.error(f"图片清理失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/ai-status', methods=['GET'])
def get_ai_status():
    """获取AI系统完整状态和诊断信息"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            return {'error': '特征提取器未初始化'}
        ai_status = extractor.get_status()

        # 获取FAISS状态
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        faiss_engine = get_vector_engine()
        faiss_status = faiss_engine.get_stats()

        # 综合状态
        overall_status = {
            'ai_model_status': ai_status,
            'vector_engine_status': faiss_status,
            'system_health': '良好' if ai_status['yolo_available'] and faiss_status['total_vectors'] >= 0 else '需要优化',
            'recommendations': []
        }

        # 生成建议
        recommendations = []
        recommendations.extend(ai_status.get('performance_tips', []))
        recommendations.extend(faiss_status.get('performance_tips', []))

        # 额外的系统级建议
        if not ai_status['yolo_available']:
            recommendations.append("YOLO裁剪功能已禁用，图像识别准确率会降低")
        if faiss_status['total_vectors'] == 0:
            recommendations.append("向量数据库为空，建议添加商品数据")
        if faiss_status['ef_construction'] == '不支持' or faiss_status['ef_search'] == '不支持':
            recommendations.append("FAISS版本较旧，建议升级以获得最佳搜索性能")

        overall_status['recommendations'] = recommendations[:5]  # 最多显示5条建议

        return jsonify(overall_status)
    except Exception as e:
        logger.error(f"获取AI状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/rebuild-index', methods=['POST'])
def rebuild_faiss_index():
    """重建FAISS索引，清理已删除的向量"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': '只有管理员可以重建索引'}), 403

        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()

        # 获取所有有效的图片数据
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, image_path FROM product_images WHERE id IS NOT NULL")
            all_images = cursor.fetchall()

        # 重新提取所有特征
        valid_vectors = []
        for row in all_images:
            try:
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("特征提取器未初始化")
                    continue
                features = extractor.extract_feature(row['image_path'])
                if features is not None:
                    valid_vectors.append((row['id'], features))
            except Exception as e:
                logger.warning(f"重新提取特征失败 {row['image_path']}: {e}")

        # 重建索引
        engine.rebuild_index(valid_vectors)

        return jsonify({
            'success': True,
            'message': f'索引重建完成，包含 {len(valid_vectors)} 个向量',
            'total_vectors': len(valid_vectors)
        })

    except Exception as e:
        logger.error(f"重建索引失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['GET'])
def get_discord_threshold():
    """获取Discord相似度阈值"""
    try:
        sys_config = db.get_system_config()
        threshold = sys_config['discord_similarity_threshold']
        return jsonify({
            'threshold': threshold,
            'threshold_percentage': threshold * 100
        })
    except Exception as e:
        logger.error(f"获取Discord阈值失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['POST'])
def update_discord_threshold():
    """更新Discord相似度阈值"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        threshold = float(data.get('threshold', 0.4))

        # 验证范围
        if not (0.0 <= threshold <= 1.0):
            return jsonify({'error': '阈值必须在0.0-1.0之间'}), 400

        # 保存到数据库
        if db.update_system_config(discord_similarity_threshold=threshold):
            # 同时更新内存中的配置
            config.DISCORD_SIMILARITY_THRESHOLD = threshold
            logger.info(f"Discord相似度阈值设置为: {threshold} ({threshold*100:.0f}%)")

            return jsonify({
            'success': True,
            'threshold': threshold,
            'threshold_percentage': threshold * 100,
            'message': 'Discord阈值设置已更新，请重启Discord机器人服务以生效'
        })

    except Exception as e:
        logger.error(f"更新Discord阈值失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/global-reply-delay', methods=['GET'])
def get_global_reply_delay():
    """获取全局回复延迟配置"""
    try:
        delay_config = db.get_global_reply_config()
        return jsonify({
            'min_delay': delay_config['min_delay'],
            'max_delay': delay_config['max_delay'],
            'description': f'{delay_config["min_delay"]}-{delay_config["max_delay"]}秒随机延迟'
        })
    except Exception as e:
        logger.error(f"获取全局回复延迟失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/debug/faiss_status', methods=['GET'])
def get_faiss_status():
    """获取FAISS向量数据库状态"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()
        stats = engine.get_stats()

        # 尝试搜索一个测试向量
        test_vector = np.zeros(config.VECTOR_DIMENSION, dtype='float32')
        test_results = engine.search(test_vector, top_k=1)

        return jsonify({
            'index_exists': True,
            'entity_count': stats['total_vectors'],
            'test_search_works': len(test_results) > 0,
            'vector_dimension': config.VECTOR_DIMENSION,
            'index_type': stats['index_type'],
            'metric_type': stats['metric_type'],
            'memory_usage_mb': stats['memory_usage_mb'],
            'ef_construction': stats['ef_construction'],
            'ef_search': stats['ef_search']
        })
    except Exception as e:
        logger.error(f"获取FAISS状态失败: {e}")
        return jsonify({
            'error': str(e),
            'index_exists': False,
            'entity_count': 0
        }), 500


@app.route('/api/config/global-reply-delay', methods=['POST'])
def update_global_reply_delay():
    """更新全局回复延迟配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        min_delay = float(data.get('min_delay', 3))
        max_delay = float(data.get('max_delay', 8))

        # 验证范围
        if min_delay < 0 or max_delay < 0:
            return jsonify({'error': '延迟时间不能为负数'}), 400
        if min_delay > max_delay:
            return jsonify({'error': '最小延迟不能大于最大延迟'}), 400
        if max_delay > 300:
            return jsonify({'error': '最大延迟不能超过300秒'}), 400

        # 保存到数据库
        if db.update_global_reply_config(min_delay, max_delay):
            # 同时更新内存中的配置
            config.GLOBAL_REPLY_MIN_DELAY = min_delay
            config.GLOBAL_REPLY_MAX_DELAY = max_delay

            logger.info(f"全局回复延迟设置为: {min_delay}-{max_delay}秒")

            return jsonify({
                'success': True,
                'min_delay': min_delay,
                'max_delay': max_delay,
                'description': f'{min_delay}-{max_delay}秒随机延迟',
                'message': '全局回复延迟设置已更新，所有自动回复将使用此设置'
            })
        else:
            return jsonify({'error': '保存失败'}), 500

    except Exception as e:
        logger.error(f"更新全局回复延迟失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['GET'])
def get_discord_channel():
    """获取Discord频道配置"""
    try:
        sys_config = db.get_system_config()
        return jsonify({
            'channel_id': sys_config['discord_channel_id'],
            'cnfans_channel_id': sys_config['cnfans_channel_id'],
            'acbuy_channel_id': sys_config['acbuy_channel_id']
        })
    except Exception as e:
        logger.error(f"获取Discord频道配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['POST'])
def update_discord_channel():
    """更新Discord频道配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        channel_id = data.get('channel_id', '').strip()
        cnfans_channel_id = data.get('cnfans_channel_id', '').strip()
        acbuy_channel_id = data.get('acbuy_channel_id', '').strip()

        # 验证频道ID格式（应该是数字）
        for cid_name, cid_value in [('channel_id', channel_id), ('cnfans_channel_id', cnfans_channel_id), ('acbuy_channel_id', acbuy_channel_id)]:
            if cid_value and not cid_value.isdigit():
                return jsonify({'error': f'{cid_name} 必须是数字'}), 400

        # 保存到数据库
        if db.update_system_config(
            discord_channel_id=channel_id,
            cnfans_channel_id=cnfans_channel_id,
            acbuy_channel_id=acbuy_channel_id
        ):
            # 同时更新环境变量和bot_config
            if channel_id:
                os.environ['DISCORD_CHANNEL_ID'] = channel_id
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = int(channel_id)
                logger.info(f"Discord频道ID设置为: {channel_id}")
            else:
                os.environ.pop('DISCORD_CHANNEL_ID', None)
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = 0
                logger.info("Discord频道ID已清除")

            return jsonify({
                'success': True,
                'channel_id': channel_id,
                'message': f'Discord频道ID已设置为: {channel_id or "无(监听所有频道)"}'
            })
        else:
            return jsonify({'error': '保存失败'}), 500
    except Exception as e:
        logger.error(f"更新Discord频道配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['GET'])
def get_search_history():
    """获取搜索历史记录（支持分页）"""
    try:
        limit = min(int(request.args.get('limit', 20)), 100)  # 最多100条
        offset = max(int(request.args.get('offset', 0)), 0)
        page = max(int(request.args.get('page', 1)), 1)

        # 如果提供了page参数，计算offset
        if 'page' in request.args and 'offset' not in request.args:
            offset = (page - 1) * limit

        result = db.get_search_history(limit, offset)
        return jsonify(result)
    except Exception as e:
        logger.error(f"获取搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_similar_text', methods=['POST'])
def search_similar_text():
    """根据文字关键词搜索相似商品"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        query = data.get('query', '').strip()
        limit = min(int(data.get('limit', 5)), 20)  # 最多20个结果

        if not query:
            return jsonify({'error': 'Query is required'}), 400

        logger.info(f'文字搜索请求: "{query}", 限制: {limit}')

        # 在数据库中搜索包含关键词的商品
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 使用LIKE查询在标题和英文标题中搜索
            cursor.execute("""
                SELECT id, product_url, title, english_title, description,
                       ruleEnabled, min_delay, max_delay, created_at,
                       cnfans_url
                FROM products
                WHERE (title LIKE ? OR english_title LIKE ? OR description LIKE ?)
                  AND ruleEnabled = 1
                ORDER BY created_at DESC
                LIMIT ?
            """, (f'%{query}%', f'%{query}%', f'%{query}%', limit))

            rows = cursor.fetchall()

            products = []
            for row in rows:
                prod = dict(row)
                # 获取图片
                cursor.execute("SELECT image_path FROM product_images WHERE product_id = ? ORDER BY image_index LIMIT 1", (prod['id'],))
                img_row = cursor.fetchone()
                if img_row:
                    prod['image'] = f"/api/image/{prod['id']}/0"
                else:
                    prod['image'] = None

                # 格式化字段
                prod['weidianUrl'] = prod.get('product_url')
                prod['englishTitle'] = prod.get('english_title') or ''
                prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                # 从URL中提取weidian ID
                try:
                    import re
                    m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                    prod['weidianId'] = m.group(1) if m else ''
                except:
                    prod['weidianId'] = ''

                products.append(prod)

        logger.info(f'文字搜索完成，找到 {len(products)} 个商品')

        return jsonify({
            'success': True,
            'query': query,
            'products': products,
            'total': len(products)
        })

    except Exception as e:
        logger.error(f"文字搜索失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history/<int:history_id>', methods=['DELETE'])
def delete_search_history(history_id):
    """删除搜索历史记录"""
    try:
        if db.delete_search_history(history_id):
            return jsonify({'success': True})
        else:
            return jsonify({'error': '记录不存在'}), 404
    except Exception as e:
        logger.error(f"删除搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['DELETE'])
def clear_search_history():
    """清空所有搜索历史"""
    try:
        if db.clear_search_history():
            return jsonify({'success': True})
        else:
            return jsonify({'error': '清空失败'}), 500
    except Exception as e:
        logger.error(f"清空搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/stream')
def log_stream():
    """Server-Sent Events 日志流"""
    import json

    def generate():
        # 为这个客户端创建队列
        client_queue = queue.Queue(maxsize=100)  # 限制队列大小
        log_clients.append(client_queue)

        try:
            # 发送最近的日志历史
            for log_entry in all_logs[-20:]:  # 发送最近20条历史日志
                yield f"data: {json.dumps(log_entry)}\n\n"

            # 持续监听新日志
            while True:
                try:
                    # 等待新日志，超时时间设为30秒
                    log_entry = client_queue.get(timeout=30)
                    yield f"data: {json.dumps(log_entry)}\n\n"
                except queue.Empty:
                    # 发送心跳包保持连接
                    yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': datetime.now().isoformat()})}\n\n"

        except GeneratorExit:
            # 客户端断开连接
            pass
        finally:
            # 清理客户端队列
            if client_queue in log_clients:
                log_clients.remove(client_queue)

    return Response(generate(), mimetype='text/event-stream',
                   headers={'Cache-Control': 'no-cache',
                           'Access-Control-Allow-Origin': '*',
                           'Access-Control-Allow-Headers': 'Cache-Control'})

@app.route('/api/logs/recent')
def get_recent_logs():
    """获取最近的日志记录"""
    try:
        # 从日志列表中返回最近50条日志
        return jsonify({
            'logs': all_logs[-50:],
            'total': len(all_logs)
        })
    except Exception as e:
        logger.error(f"获取最近日志失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/add', methods=['POST'])
def add_external_log():
    """接收外部进程发送的日志"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid log data'}), 400

        # 创建日志条目
        log_entry = {
            'timestamp': data.get('timestamp', datetime.now().isoformat()),
            'level': data.get('level', 'INFO'),
            'message': data.get('message', ''),
            'module': data.get('module', 'external'),
            'func': data.get('func', '')
        }

        # 添加到日志列表
        all_logs.append(log_entry)
        if len(all_logs) > 200:
            all_logs.pop(0)

        # 添加到队列
        log_queue.put(log_entry)

        return jsonify({'success': True})
    except Exception as e:
        print(f"添加外部日志失败: {e}")
        return jsonify({'error': str(e)}), 500

def start_discord_bot(user_id=None):
    """启动Discord机器人 - 支持多账号"""
    global bot_clients, bot_tasks, bot_running

    if bot_running:
        logger.warning("机器人已经在运行中")
        return

    try:
        import asyncio
        from bot import DiscordBotClient

        logger.info(f"正在启动Discord机器人... (用户ID: {user_id})")

        # 获取账号 - 如果指定了用户ID，只获取该用户的账号
        if user_id:
            accounts = db.get_discord_accounts_by_user(user_id)
        else:
            # 获取所有账号
            accounts = db.get_discord_accounts_by_user(None)

        if not accounts:
            logger.warning("没有找到可用的Discord账号")
            return

        logger.info(f"找到 {len(accounts)} 个Discord账号，开始启动...")

        # 在新的事件循环中运行机器人
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        # 为每个账号创建机器人实例
        for account in accounts:
            account_id = account['id']
            token = account['token']
            username = account.get('username', f'account_{account_id}')
            user_id = account.get('user_id')

            # 获取用户管理的店铺
            user_shops = None
            if user_id:
                user = db.get_user_by_id(user_id)
                if user:
                    user_shops = user.get('shops', [])

            logger.info(f"正在启动机器人账号: {username} (用户ID: {user_id}, 管理店铺: {user_shops})")

            # 创建机器人实例
            client = DiscordBotClient(account_id=account_id, user_id=user_id, user_shops=user_shops)

            # 启动机器人
            try:
                task = loop.create_task(client.start(token, reconnect=True))
                bot_clients.append(client)
                bot_tasks.append(task)
                logger.info(f"Discord机器人启动成功: {username}")
            except Exception as e:
                logger.error(f"启动机器人失败 {username}: {e}")

        # 在后台线程中运行事件循环
        import threading
        bot_thread = threading.Thread(target=loop.run_forever, daemon=True)
        bot_thread.start()

        if bot_clients:
            bot_running = True
            logger.info(f"共启动了 {len(bot_clients)} 个Discord机器人")
        else:
            logger.warning("没有成功启动任何机器人")

    except ImportError as e:
        logger.warning(f"Discord机器人模块不可用: {e}")
        logger.info("Flask应用将继续运行，但机器人功能不可用")
    except Exception as e:
        logger.error(f"Discord机器人启动失败: {e}")
        logger.info("Flask应用将继续运行，但机器人功能不可用")

def stop_discord_bot():
    """停止Discord机器人"""
    global bot_clients, bot_tasks, bot_running

    if not bot_running:
        logger.info("机器人未在运行")
        return

    if bot_clients:
        logger.info(f"正在停止 {len(bot_clients)} 个Discord机器人...")
        try:
            import asyncio
            # 创建任务来停止所有机器人
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            for i, client in enumerate(bot_clients):
                try:
                    if client and not client.is_closed():
                        # 更新账号状态为offline
                        if hasattr(client, 'account_id') and client.account_id:
                            db.update_account_status(client.account_id, 'offline')
                            logger.info(f"账号 {client.account_id} 状态已更新为离线")
                        loop.run_until_complete(client.close())
                        logger.info(f"Discord机器人 {i+1} 已停止")
                except Exception as e:
                    logger.error(f"停止机器人 {i+1} 时出错: {e}")

            logger.info("所有Discord机器人已停止")
        except Exception as e:
            logger.error(f"停止机器人时出错: {e}")

    # 取消所有任务
    for task in bot_tasks:
        if task and not task.done():
            task.cancel()

    # 清空机器人列表
    bot_clients.clear()
    bot_tasks.clear()
    bot_running = False

# ===== 机器人控制API =====

@app.route('/api/bot/start', methods=['POST'])
def start_bot():
    """启动Discord机器人"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        user_id = data.get('userId')

        if not user_id:
            return jsonify({'error': '需要用户ID'}), 400

        # 检查用户是否有权限的账号
        user_accounts = db.get_discord_accounts_by_user(user_id)

        if not user_accounts:
            return jsonify({'error': '用户没有Discord账号，请先添加账号'}), 400

        # 启动机器人（启动所有账号，不管是否在线）
        start_discord_bot(user_id)

        logger.info(f"用户 {user_id} 启动机器人成功，共有 {len(user_accounts)} 个账号")
        return jsonify({
            'message': '账号启动成功',
            'totalAccounts': len(user_accounts)
        })

    except Exception as e:
        logger.error(f"启动机器人失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/bot/stop', methods=['POST'])
def stop_bot():
    """停止Discord机器人"""
    try:
        stop_discord_bot()
        logger.info("机器人停止成功")
        return jsonify({'message': '机器人停止成功'})

    except Exception as e:
        logger.error(f"停止机器人失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/shop-info', methods=['GET'])
def get_shop_info():
    """获取店铺信息"""
    try:
        shop_id = request.args.get('shopId')
        if not shop_id:
            return jsonify({'error': '缺少shopId参数'}), 400

        shop_id = shop_id.strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        logger.info(f'获取店铺信息: {shop_id}')

        # 调用微店API获取店铺信息
        try:
            param = json.dumps({"shop_id": shop_id, "page_id": 0})
            encoded_param = quote(param)

            api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

            response = requests.get(api_url, headers={
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'Origin': 'https://weidian.com',
                'Referer': 'https://weidian.com/',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-site',
            }, cookies={
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }, timeout=10)

            if response.status_code == 200:
                data = response.json()
                if data.get('status', {}).get('code') == 0:
                    shop_name = data.get('result', {}).get('shareTitle', f'店铺 {shop_id}')
                    return jsonify({'shopName': shop_name})
                else:
                    logger.warning(f'API返回错误状态: {data}')
            else:
                logger.warning(f'API请求失败: {response.status_code}')

        except Exception as e:
            logger.error(f'获取店铺信息失败: {e}')

        # 如果API失败，返回默认名称
        return jsonify({'shopName': f'店铺 {shop_id}'})

    except Exception as e:
        logger.error(f'获取店铺信息出错: {e}')
        return jsonify({'error': '获取店铺信息失败'}), 500

# ===== 店铺管理API =====

@app.route('/api/shops', methods=['GET'])
def get_shops():
    """获取所有店铺列表"""
    try:
        shops = db.get_all_shops()
        return jsonify({'shops': shops})
    except Exception as e:
        logger.error(f'获取店铺列表失败: {e}')
        return jsonify({'error': '获取店铺列表失败'}), 500

@app.route('/api/shops', methods=['POST'])
def add_shop():
    """添加新店铺"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId') or not data.get('name'):
            return jsonify({'error': '缺少shopId或name参数'}), 400

        shop_id = data['shopId'].strip()
        name = data['name'].strip()

        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        # 获取真实的店铺名称
        shop_info = get_shop_info_from_api(shop_id)
        if shop_info and shop_info.get('shopName'):
            name = shop_info['shopName']

        if db.add_shop(shop_id, name):
            return jsonify({'success': True, 'message': '店铺添加成功'})
        else:
            return jsonify({'error': '店铺已存在或添加失败'}), 400
    except Exception as e:
        logger.error(f'添加店铺失败: {e}')
        return jsonify({'error': '添加店铺失败'}), 500

@app.route('/api/shops/<shop_id>', methods=['DELETE'])
def delete_shop(shop_id):
    """删除店铺"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        # 获取店铺信息，检查用户是否有权限删除
        shop_info = db.get_shop_by_id(shop_id)
        if not shop_info:
            return jsonify({'error': '店铺不存在'}), 404

        current_user = get_current_user()
        # 管理员可以删除任何店铺，普通用户只能删除分配给他们的店铺
        if current_user['role'] != 'admin' and shop_info['shop_id'] not in current_user.get('shops', []):
            return jsonify({'error': '无权限删除此店铺'}), 403

        if db.delete_shop(shop_id):
            return jsonify({'success': True, 'message': '店铺删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f'删除店铺失败: {e}')
        return jsonify({'error': '删除店铺失败'}), 500

def get_shop_info_from_api(shop_id):
    """从API获取店铺信息"""
    try:
        import json
        from urllib.parse import quote
        import time

        param = json.dumps({"shop_id": shop_id, "page_id": 0})
        encoded_param = quote(param)

        api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

        response = requests.get(api_url, headers={
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'Origin': 'https://weidian.com',
            'Referer': 'https://weidian.com/',
            'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'Sec-Ch-Ua-Mobile': '?0',
            'Sec-Ch-Ua-Platform': '"macOS"',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site',
        }, cookies={
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '2',
            '__spider__sessionid': 'c7da7d6e06b1f1ac'
        }, timeout=10, proxies={'http': None, 'https': None})

        if response.status_code == 200:
            data = response.json()
            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                shop_name = result.get('shareTitle', '')
                if shop_name:
                    return {'shopName': shop_name}

    except Exception as e:
        logger.warning(f'获取店铺信息失败: {e}')

    return None

@app.route('/api/scrape/shop', methods=['POST'])
def scrape_shop():
    """抓取整个店铺的所有商品"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId'):
            return jsonify({'error': '缺少shopId参数'}), 400

        shop_id = data['shopId'].strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        # 检查是否已有抓取任务在运行
        global scrape_status
        if scrape_status.get('is_scraping', False):
            return jsonify({'error': '已有抓取任务在运行中，请等待完成后再试'}), 409

        logger.info(f'开始抓取店铺: {shop_id}')

        # 在后台线程中运行抓取任务，避免阻塞其他操作
        import threading

        def run_scrape_task():
            """后台抓取任务"""
            try:
                scrape_shop_products(shop_id)
            except Exception as e:
                logger.error(f'抓取任务异常: {e}')
            finally:
                # 确保状态正确重置
                global scrape_status
                scrape_status.update({
                    'is_scraping': False,
                    'message': f'抓取异常结束: {str(e)}' if 'e' in locals() else '抓取已完成'
                })

        # 创建守护线程，确保不会阻塞应用退出
        scrape_thread = threading.Thread(target=run_scrape_task, daemon=True, name=f'scrape-{shop_id}')
        scrape_thread.start()

        logger.info(f'已启动后台抓取线程处理店铺 {shop_id}')

        return jsonify({
            'success': True,
            'message': '抓取任务已启动，请查看进度'
        })

    except Exception as e:
        logger.error(f'店铺抓取失败: {e}')
        return jsonify({'error': str(e)        }), 500

@app.route('/api/scrape/shop/reset', methods=['POST'])
def reset_scrape_status():
    """重置抓取状态（紧急修复）"""
    try:
        global current_scrape_thread, scrape_thread_lock

        # 重置数据库状态
        reset_status = db.reset_scrape_status()

        # 终止当前线程
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                logger.info("🔄 终止旧的抓取线程...")
                # 注意：Python线程不能强制终止，这里只是设置信号
            current_scrape_thread = None

        logger.info("✅ 抓取状态已重置")
        return jsonify({'message': '抓取状态已重置', 'status': reset_status})
    except Exception as e:
        logger.error(f'重置抓取状态失败: {e}')
        return jsonify({'error': '重置失败'}), 500

@app.route('/api/scrape/shop/control', methods=['POST'])
def control_shop_scrape():
    """控制抓取任务: start, pause, resume, stop"""
    action = request.json.get('action')
    shop_id = request.json.get('shopId')  # 可选参数

    global current_scrape_thread, scrape_thread_lock

    # 获取当前状态
    current_status = db.get_scrape_status()
    logger.info(f"收到抓取控制请求: action={action}, shop_id={shop_id}, 当前状态: is_scraping={current_status.get('is_scraping')}, paused={current_status.get('paused')}, stop_signal={current_status.get('stop_signal')}")

    if action == 'stop':
        # 设置停止信号
        success = db.update_scrape_status(stop_signal=True, message='正在停止...')
        if success:
            logger.info("✅ 设置停止信号为True")

            # 尝试终止线程
            with scrape_thread_lock:
                if current_scrape_thread and current_scrape_thread.is_alive():
                    logger.info("🔄 尝试终止抓取线程...")
                    # 注意：Python线程不能强制终止，这里只是设置信号让线程自行退出

            updated_status = db.get_scrape_status()
            return jsonify(updated_status)
        else:
            return jsonify({'error': '设置停止信号失败'}), 500

    if action == 'pause':
        success = db.update_scrape_status(paused=True, message='已暂停')
        if success:
            logger.info("✅ 设置暂停状态为True")
            updated_status = db.get_scrape_status()
            return jsonify(updated_status)
        else:
            return jsonify({'error': '设置暂停状态失败'}), 500

    if action == 'resume':
        success = db.update_scrape_status(paused=False, message='继续抓取...')
        if success:
            logger.info("✅ 设置暂停状态为False")
            updated_status = db.get_scrape_status()
            return jsonify(updated_status)
        else:
            return jsonify({'error': '设置继续状态失败'}), 500

    if action == 'start':
        if current_status.get('is_scraping', False):
            return jsonify({'error': '已有任务在运行'}), 400

        # 检查是否有线程在运行
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                return jsonify({'error': '已有线程在运行'}), 400

        # 重置状态
        reset_success = db.update_scrape_status(
            is_scraping=True,
            paused=False,
            stop_signal=False,
            current_shop_id=shop_id,
            total=0,
            processed=0,
            success=0,
            progress=0,
            message='初始化抓取...',
            completed=False,
            thread_id=None
        )

        if not reset_success:
            return jsonify({'error': '重置状态失败'}), 500

        # 异步启动
        with scrape_thread_lock:
            current_scrape_thread = threading.Thread(
                target=run_shop_scrape_task,
                args=(shop_id,),
                daemon=True,
                name=f'scrape-{shop_id}'
            )
            current_scrape_thread.start()

            # 更新线程ID到数据库
            db.update_scrape_status(thread_id=current_scrape_thread.ident)

        updated_status = db.get_scrape_status()
        return jsonify(updated_status)

    return jsonify({'error': 'Invalid action'}), 400

@app.route('/api/scrape/shop/status', methods=['GET'])
def get_scrape_status():
    """获取抓取状态"""
    try:
        status = db.get_scrape_status()

        # 确保返回必要的字段（兼容前端期望的字段名）
        result = {
            'is_scraping': status.get('is_scraping', False),
            'paused': status.get('paused', False),
            'progress': status.get('progress', 0),
            'total': status.get('total', 0),
            'current': status.get('processed', 0),  # 前端期望current字段
            'processed': status.get('processed', 0),
            'success': status.get('success', 0),
            'message': status.get('message', ''),
            'completed': status.get('completed', False),
            'current_shop_id': status.get('current_shop_id'),
            'thread_id': status.get('thread_id')
        }

        # 调试日志
        logger.debug(f"DEBUG: Scrape status - is_scraping: {result.get('is_scraping')}, paused: {result.get('paused')}, message: {result.get('message')}")

        return jsonify(result)
    except Exception as e:
        logger.error(f'获取抓取状态失败: {e}')
        return jsonify({
            'is_scraping': False,
            'paused': False,
            'progress': 0,
            'total': 0,
            'current': 0,
            'processed': 0,
            'success': 0,
            'message': '获取状态失败',
            'completed': False,
            'current_shop_id': None,
            'thread_id': None
        })

@app.route('/api/products/count', methods=['GET'])
def get_products_count():
    """获取商品总数"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM products")
            count = cursor.fetchone()[0]
            return jsonify({'count': count})
    except Exception as e:
        logger.error(f"获取商品数量失败: {e}")
        return jsonify({'count': 0}), 500

@app.route('/api/debug/user_permissions', methods=['GET'])
def debug_user_permissions():
    """调试用户权限和商品分配（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 获取所有用户
            cursor.execute('SELECT id, username, role FROM users')
            users = []
            for row in cursor.fetchall():
                user_dict = dict(row)
                user_dict['shops'] = db.get_user_shops(user_dict['id'])
                users.append(user_dict)

            # 获取所有店铺
            cursor.execute('SELECT id, name FROM shops')
            shops = [dict(row) for row in cursor.fetchall()]

            # 获取商品统计
            cursor.execute('SELECT shop_name, COUNT(*) as count FROM products GROUP BY shop_name')
            product_stats = [dict(row) for row in cursor.fetchall()]

            # 获取用户店铺权限统计
            cursor.execute('SELECT user_id, COUNT(*) as shop_count FROM user_shop_permissions GROUP BY user_id')
            permission_stats = []
            for row in cursor.fetchall():
                user_id, shop_count = row
                user = next((u for u in users if u['id'] == user_id), None)
                if user:
                    permission_stats.append({
                        'username': user['username'],
                        'shop_count': shop_count,
                        'shops': user['shops']
                    })

            return jsonify({
                'users': users,
                'shops': shops,
                'product_stats': product_stats,
                'permission_stats': permission_stats
            })
    except Exception as e:
        logger.error(f"调试用户权限失败: {e}")
        return jsonify({'error': str(e)}), 500

def run_shop_scrape_task(shop_id):
    """后台任务包装器 - 调用真正的抓取逻辑"""
    global scrape_status
    try:
        logger.info(f"🧵 后台抓取线程启动: {shop_id}")
        scrape_shop_products(shop_id)
    except Exception as e:
        logger.error(f"❌ 后台抓取线程崩溃: {e}")
        scrape_status['message'] = f"系统错误: {str(e)}"
    finally:
        scrape_status['is_scraping'] = False
        scrape_status['completed'] = True
        if not scrape_status['stop_signal']:
            scrape_status['message'] = '任务结束'
        logger.info("🧵 后台抓取线程结束")

def scrape_shop_products(shop_id):
    """抓取店铺所有商品的实现 (支持暂停/停止)"""
    import requests
    import time
    from weidian_scraper import get_weidian_scraper

    scraper = get_weidian_scraper()  # 实例化爬虫
    total_products = 0
    offset = 0
    limit = 20
    page_count = 0

    # 初始化状态到数据库
    db.update_scrape_status(
        is_scraping=True,
        paused=False,
        stop_signal=False,
        progress=0,
        total=0,
        processed=0,
        success=0,
        message='正在初始化...'
    )

    # 获取店铺名称
    shop_info = get_shop_info_from_api(shop_id)
    shop_name = shop_info.get('shopName', f'店铺 {shop_id}') if shop_info else f'店铺 {shop_id}'

    scrape_status['message'] = f'正在抓取店铺: {shop_name}'
    logger.info(f"开始抓取循环，店铺: {shop_name}")

    while True:
        # === 1. 检查停止信号 ===
        if scrape_status['stop_signal']:
            logger.info(f"🔴 检测到停止信号，退出抓取循环。当前状态: {scrape_status}")
            scrape_status['message'] = '抓取已手动停止'
            break

        # === 2. 检查暂停状态 ===
        if scrape_status['paused']:
            logger.info(f"⏸️ 检测到暂停状态，等待恢复... 状态: {scrape_status}")
            scrape_status['message'] = '已暂停，等待恢复...'
            while scrape_status['paused']:
                if scrape_status['stop_signal']:
                    logger.info("暂停期间收到停止信号，退出")
                    break
                time.sleep(1)
            logger.info(f"▶️ 暂停结束，继续抓取。状态: {scrape_status}")
            scrape_status['message'] = '继续抓取...'

        try:
            # 构建API URL
            url = f"https://thor.weidian.com/decorate/shopDetail.tab.getItemList/1.0"
            param_encoded = quote(f'{{"shopId":"{shop_id}","tabId":0,"sortOrder":"desc","offset":{offset},"limit":{limit},"from":"h5","showItemTag":true}}')
            full_url = f"{url}?param={param_encoded}&wdtoken=8ea9315c&_={int(time.time()*1000)}"

            # 复用scraper的session，确保headers和cookies一致
            response = scraper.session.get(full_url, timeout=10)

            if response.status_code != 200:
                logger.warning(f'API请求失败: {response.status_code}')
                break

            data = response.json()

            if data.get('status', {}).get('code') != 0:
                logger.warning('API响应状态码不为0')
                break

            result = data.get('result', {})
            if not result.get('hasData', False):
                logger.info('没有更多数据，抓取完成')
                break

            items = result.get('itemList', [])
            if not items:
                logger.info('商品列表为空，抓取完成')
                break

            # 逐个处理商品，支持更细粒度的暂停/停止控制
            page_processed = 0
            page_success = 0

            for item in items:
                # === 检查点 3: 每处理一个商品前检查暂停/停止 ===
                if scrape_status['stop_signal']:
                    logger.info("处理商品期间收到停止信号，退出")
                    break

                while scrape_status['paused']:
                    if scrape_status['stop_signal']:
                        logger.info("暂停期间收到停止信号，退出")
                        break
                    time.sleep(1)

                item_id = item.get('itemId', '')
                if item_id:
                    try:
                        # 处理单个商品
                        product_info = {
                            'item_id': item_id,
                            'item_url': item.get('itemUrl', ''),
                            'shop_name': shop_name
                        }

                        success = process_and_save_single_product_sync(product_info)
                        page_processed += 1
                        total_products += 1

                        if success:
                            page_success += 1
                            scrape_status['success'] += 1

                        scrape_status.update({
                            'current': total_products,
                            'processed': total_products,
                            'message': f'正在抓取... (成功: {scrape_status["success"]}/{total_products})'
                        })

                    except Exception as e:
                        logger.error(f'处理商品 {item_id} 失败: {e}')
                        page_processed += 1
                        total_products += 1

            if page_processed > 0:
                logger.info(f'第 {page_count + 1} 页处理完成，处理 {page_processed} 个商品，成功 {page_success} 个')
                page_count += 1

            # 增加offset继续抓取
            offset += limit

            # 避免请求过于频繁
            time.sleep(0.5)

        except Exception as e:
            logger.error(f'抓取过程中出错: {e}')
            break

    scrape_status.update({
        'is_scraping': False,
        'completed': True,
        'progress': 100,
        'message': f'抓取结束，共处理 {total_products} 个商品'
    })
    logger.info(f"店铺 {shop_id} 抓取任务结束")

    return {
        "total_products": total_products,
        "pages_processed": page_count
    }

def process_and_save_single_product_sync(product_info):
    """同步处理单个商品（为了能够响应暂停/停止，不建议在店铺抓取时再开多线程池）"""
    try:
        # 1. 抓取详情
        from app import process_single_product  # 引用 app.py 中的逻辑
        product_data = process_single_product(product_info)

        if not product_data:
            return False

        # 2. 查重
        if db.get_product_by_url(product_data['product_url']):
            return True  # 已存在算处理成功

        # 3. 入库
        product_id = db.insert_product(product_data)

        # 4. 图片处理
        if product_data.get('images'):
            from app import save_product_images
            save_product_images(product_id, product_data['images'])

        return True
    except Exception as e:
        logger.error(f"处理商品出错 {product_info.get('item_id')}: {e}")
        return False

def scrape_product_info(product_url):
    """根据商品URL获取商品详细信息"""
    try:
        from weidian_scraper import get_weidian_scraper

        scraper = get_weidian_scraper()
        product_info = scraper.scrape_product_info(product_url)

        if product_info:
            # 重新格式化返回数据
            return {
                'title': product_info.get('title', ''),
                'description': product_info.get('description', ''),
                # 修复：移除 [:5] 限制，返回所有抓取到的图片
                'images': product_info.get('images', []),
                'shop_name': product_info.get('shop_name', '')
            }

        return None

    except Exception as e:
        logger.error(f'获取商品详细信息失败: {e}')
        return None

def generate_acbuy_url(weidian_url):
    """生成AcBuy链接"""
    if not weidian_url:
        return ''

    try:
        import re
        item_id_match = re.search(r'itemID=(\d+)', weidian_url)
        if item_id_match:
            item_id = item_id_match.group(1)
            # 构建acbuy链接
            encoded_url = weidian_url.replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
            return f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'
    except Exception as e:
        logger.error(f'生成AcBuy链接失败: {e}')

    return ''

def generate_cnfans_url(item_id):
    """生成CNFans链接"""
    if not item_id:
        return ''
    return f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN"

def generate_english_title(chinese_title):
    """将中文标题翻译为英文标题"""
    if not chinese_title:
        return ''

    try:
        import re
        import requests

        # 首先尝试提取已有的英文部分
        english_parts = re.findall(r'[a-zA-Z\s]+', chinese_title)
        if english_parts and len(' '.join(english_parts).strip()) > 5:
            # 如果英文部分足够长，直接返回
            return ' '.join(english_parts).strip()

        # 品牌名称映射（扩展版）
        brand_mappings = {
            'Nike': 'Nike', '阿迪': 'Adidas', 'Adidas': 'Adidas', '李宁': 'LiNing',
            '安踏': 'Anta', '匹克': 'Peak', '乔丹': 'Jordan', 'New Balance': 'New Balance',
            'Converse': 'Converse', 'Vans': 'Vans', 'Supreme': 'Supreme', 'BAPE': 'BAPE',
            'Palace': 'Palace', 'Stone Island': 'Stone Island', 'Off-White': 'Off-White',
            'Balenciaga': 'Balenciaga', 'Gucci': 'Gucci', 'Louis Vuitton': 'Louis Vuitton',
            'Chanel': 'Chanel', 'Dior': 'Dior', 'Yeezy': 'Yeezy', 'Puma': 'Puma',
            'Reebok': 'Reebok', 'Under Armour': 'Under Armour', 'Fila': 'Fila',
            'The North Face': 'The North Face', 'Columbia': 'Columbia', 'Patagonia': 'Patagonia',
            'Arc\'teryx': 'Arc\'teryx', 'Canada Goose': 'Canada Goose', 'Moncler': 'Moncler',
            'Burberry': 'Burberry', 'Prada': 'Prada', 'Versace': 'Versace', 'Fendi': 'Fendi',
            'Hermes': 'Hermes', 'Rolex': 'Rolex', 'Cartier': 'Cartier', 'Omega': 'Omega',
            'IWC': 'IWC', 'Jaeger-LeCoultre': 'Jaeger-LeCoultre', 'Patek Philippe': 'Patek Philippe'
        }

        # 应用品牌映射
        title = chinese_title
        for zh, en in brand_mappings.items():
            title = title.replace(zh, en)

        # 检查是否还有中文字符
        has_chinese = any('\u4e00' <= char <= '\u9fff' for char in title)

        if has_chinese:
            # 使用百度翻译API或其他免费翻译服务
            try:
                # 这里使用一个简单的翻译API示例
                # 实际部署时需要替换为稳定的翻译服务
                api_url = "https://api.mymemory.translated.net/get"
                params = {
                    'q': chinese_title,
                    'langpair': 'zh-CN|en-US',
                    'de': 'your-email@example.com'  # MyMemory要求提供邮箱
                }

                response = requests.get(api_url, params=params, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code == 200:
                    data = response.json()
                    translated = data.get('responseData', {}).get('translatedText', '')
                    if translated and translated != chinese_title:
                        # 清理翻译结果
                        translated = re.sub(r'[^\w\s\-]', '', translated)
                        return translated.strip()

            except Exception as e:
                logger.warning(f'在线翻译失败: {e}')

            # 如果翻译失败，返回提取的英文部分或原标题
            english_parts = re.findall(r'[a-zA-Z\s\-]+', title)
            if english_parts:
                result = ' '.join(english_parts).strip()
                if len(result) > 3:
                    return result

        # 如果没有中文或翻译失败，返回处理后的标题
        return re.sub(r'[^\w\s\-]', '', title).strip()

    except Exception as e:
        logger.error(f'生成英文标题失败: {e}')
        return chinese_title

def process_single_product(product_info):
    """处理单个商品的详情抓取"""
    try:
        item_id = product_info['item_id']
        item_url = product_info['item_url']
        shop_name = product_info['shop_name']

        # 获取商品详细信息
        product_details = scrape_product_info(item_url)

        if product_details:
            # 生成英文标题
            english_title = generate_english_title(product_details.get('title', ''))

            return {
                'product_url': item_url,
                'title': product_details.get('title', ''),
                'description': product_details.get('description', ''),
                'english_title': english_title,
                'cnfans_url': generate_cnfans_url(item_id),
                'acbuy_url': generate_acbuy_url(item_url),
                'shop_name': shop_name,
                'images': product_details.get('images', []),
                'ruleEnabled': True
            }
        return None

    except Exception as e:
        logger.error(f'处理商品失败: {e}')
        return None

def process_products_multithreaded(products_list):
    """多线程处理商品详情抓取"""
    import concurrent.futures

    processed_products = []

    # 获取配置的线程数
    max_workers = config.DOWNLOAD_THREADS if hasattr(config, 'DOWNLOAD_THREADS') else 4

    logger.info(f'开始多线程处理 {len(products_list)} 个商品，使用 {max_workers} 个线程')

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        # 提交所有任务
        future_to_product = {
            executor.submit(process_single_product, product): product
            for product in products_list
        }

        # 收集结果
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                if result:
                    processed_products.append(result)
            except Exception as e:
                logger.error(f'商品处理任务失败: {e}')

    logger.info(f'多线程处理完成，共处理 {len(processed_products)} 个商品')
    return processed_products

def process_page_multithreaded(products_list, page_num):
    """
    多线程处理整个页面：获取详情 + 插入数据库 + 下载图片
    每个线程负责一个商品的完整处理流程
    """
    import concurrent.futures

    processed_count = 0

    # 获取配置的线程数
    max_workers = config.DOWNLOAD_THREADS if hasattr(config, 'DOWNLOAD_THREADS') else 4

    logger.info(f'第 {page_num} 页开始多线程处理 {len(products_list)} 个商品')

    def process_and_save_product(product):
        """处理单个商品的完整流程：获取详情 -> 插入数据库 -> 下载图片"""
        try:
            # 1. 获取商品详情
            product_data = process_single_product(product)
            if not product_data:
                logger.warning(f'商品详情获取失败: {product}')
                return 0

            # 2. 检查商品是否已存在
            existing = db.get_product_by_url(product_data['product_url'])
            if existing:
                logger.info(f'商品已存在，跳过: {product_data["title"]} (URL: {product_data["product_url"]})')
                return 0

            # 3. 插入商品到数据库
            product_id = db.insert_product(product_data)
            logger.info(f'✅ 成功插入新商品: {product_data["title"]} (ID: {product_id})')

            # 4. 下载并保存图片
            if product_data.get('images'):
                save_product_images(product_id, product_data['images'])
                logger.info(f'📸 商品图片下载完成: {product_data["title"]} ({len(product_data["images"])}张)')

            return 1  # 成功处理一个商品

        except Exception as e:
            logger.error(f'处理商品失败: {e}')
            return 0

    # 降低并发数避免内存爆炸，YOLO模型现在是单例模式
    max_workers_page = min(2, len(products_list))  # 最多2个并发
    logger.info(f"页面处理使用 {max_workers_page} 个线程")

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers_page) as executor:
        # 提交所有任务，每个商品一个任务
        future_to_product = {
            executor.submit(process_and_save_product, product): product
            for product in products_list
        }

        # 收集结果
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                processed_count += result
            except Exception as e:
                logger.error(f'页面处理任务失败: {e}')

    logger.info(f'第 {page_num} 页处理完成，成功新增 {processed_count} 个商品')
    return processed_count

def save_product_images(product_id, image_urls):
    """保存商品图片并提取特征向量（优化版本 - 减少并发避免内存爆炸）"""
    try:
        # 使用线程池而不是进程池，避免YOLO模型重复加载
        # 降低并发数，从4个减少到2个，避免内存爆炸
        import concurrent.futures

        max_workers = min(2, len(image_urls))  # 最多2个并发线程
        logger.info(f"开始处理 {len(image_urls)} 张图片，使用 {max_workers} 个线程")

        def process_single_image(args):
            """处理单张图片：下载 -> 保存 -> 提取特征 -> 索引"""
            index, image_url = args
            try:
                # 下载图片（使用更短的超时时间）
                response = requests.get(image_url, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code != 200:
                    return None

                # 生成唯一文件名，避免并发冲突
                timestamp = int(time.time() * 1000000)  # 微秒级时间戳
                image_filename = f"{product_id}_{index}_{timestamp}.jpg"
                image_path = os.path.join('data', 'images', image_filename)

                # 确保目录存在
                os.makedirs(os.path.dirname(image_path), exist_ok=True)

                # 直接写入文件，避免内存占用过多
                with open(image_path, 'wb') as f:
                    f.write(response.content)

                # 验证图片完整性
                if os.path.getsize(image_path) == 0:
                    os.remove(image_path)
                    return None

                # 提取特征（这里会调用YOLO裁剪和DINOv2特征提取）
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("特征提取器未初始化")
                    return None
                features = extractor.extract_feature(image_path)

                if features is None:
                    # 特征提取失败，删除文件
                    os.remove(image_path)
                    return None

                # 返回处理结果，让主进程统一处理数据库操作
                return {
                    'image_path': image_path,
                    'features': features,
                    'index': index
                }

            except Exception as e:
                logger.error(f'处理图片失败 {image_url}: {e}')
                return None

        # 获取该商品已有的图片向量，用于去重
        existing_features = []
        try:
            existing_images = db.get_product_images(product_id)
            for img_record in existing_images:
                if img_record.get('features'):
                    existing_features.append(img_record['features'])
            logger.info(f'商品 {product_id} 已存在 {len(existing_features)} 张图片的向量数据')
        except Exception as e:
            logger.warning(f'获取商品现有向量失败: {e}')

        # 使用线程池处理图片下载和特征提取（单例YOLO避免重复加载）
        # 降低并发数避免内存爆炸
        max_workers = min(2, len(image_urls))  # 最多2个并发线程

        logger.info(f'商品 {product_id} 开始多线程处理 {len(image_urls)} 张图片，使用 {max_workers} 个线程')

        def process_single_image_with_deduplication(args):
            """处理单张图片：下载 -> 保存 -> 提取特征 -> 向量去重"""
            index, image_url = args
            try:
                # 下载图片（使用更短的超时时间）
                response = requests.get(image_url, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code != 200:
                    return None

                # 生成唯一文件名，避免并发冲突
                timestamp = int(time.time() * 1000000)  # 微秒级时间戳
                image_filename = f"{product_id}_{index}_{timestamp}.jpg"
                image_path = os.path.join('data', 'images', image_filename)

                # 确保目录存在
                os.makedirs(os.path.dirname(image_path), exist_ok=True)

                # 直接写入文件，避免内存占用过多
                with open(image_path, 'wb') as f:
                    f.write(response.content)

                # 验证图片完整性
                if os.path.getsize(image_path) == 0:
                    os.remove(image_path)
                    return None

                # 提取特征（这里会调用YOLO裁剪和DINOv2特征提取）
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("特征提取器未初始化")
                    return None
                features = extractor.extract_feature(image_path)

                if features is None:
                    # 特征提取失败，删除文件
                    os.remove(image_path)
                    return None

                # 向量去重：检查与该商品现有图片的相似度
                if existing_features:
                    import numpy as np
                    for existing_feature in existing_features:
                        # 计算余弦相似度
                        similarity = np.dot(features, existing_feature) / (np.linalg.norm(features) * np.linalg.norm(existing_feature))
                        if similarity > 0.95:  # 相似度阈值95%
                            logger.info(f'检测到重复图片 (相似度: {similarity:.3f})，跳过: {os.path.basename(image_path)}')
                            os.remove(image_path)
                            return None

                # 返回处理结果，让主进程统一处理数据库操作
                return {
                    'image_path': image_path,
                    'features': features,
                    'index': index
                }

            except Exception as e:
                logger.error(f'处理图片失败 {image_url}: {e}')
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 提交任务 - 移除图片数量限制
            image_tasks = [(index, url) for index, url in enumerate(image_urls) if url]
            futures = [executor.submit(process_single_image_with_deduplication, task) for task in image_tasks]

            # 收集结果，支持优雅关闭
            processed_results = []
        try:
            for future in concurrent.futures.as_completed(futures, timeout=30):  # 30秒超时
                # 检查是否收到关闭信号
                if shutdown_event and shutdown_event.is_set():
                    logger.info("检测到关闭信号，停止图片处理...")
                    executor.shutdown(wait=False)
                    break

                result = future.result()
                if result is not None:
                    processed_results.append(result)
        except concurrent.futures.TimeoutError:
            logger.warning("图片处理超时，强制关闭线程池")
            executor.shutdown(wait=False)
        except Exception as e:
            logger.error(f"图片处理过程中出错: {e}")
            executor.shutdown(wait=False)

        # 在主进程中统一处理数据库操作，避免进程间数据库连接问题
        processed_images = 0
        for result in processed_results:
            try:
                # 插入图片记录到数据库（包含特征向量）
                img_db_id = db.insert_image_record(product_id, result['image_path'], result['index'], result['features'])

                # 添加到FAISS索引
                try:
                    from vector_engine import get_vector_engine
                except ImportError:
                    from .vector_engine import get_vector_engine
                engine = get_vector_engine()
                engine.add_vector(img_db_id, result['features'])

                processed_images += 1
                logger.debug(f'图片入库完成: {os.path.basename(result["image_path"])} (ID: {img_db_id})')

            except Exception as e:
                logger.error(f'图片入库失败 {result["image_path"]}: {e}')
                # 清理失败的文件
                try:
                    os.remove(result['image_path'])
                except:
                    pass

        # 保存FAISS索引（批量保存更高效）
        if processed_images > 0:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            engine.save()

        logger.info(f'商品 {product_id} 图片处理完成，共处理 {processed_images}/{len(image_urls)} 张图片')

    except Exception as e:
        logger.error(f'保存商品图片失败: {e}')

def save_product_images_multithreaded(product_id, image_urls):
    """多线程版本的图片保存函数（向后兼容）"""
    save_product_images(product_id, image_urls)

if __name__ == '__main__':
    import atexit
    import threading
    import signal
    import time

    # 全局变量用于控制优雅关闭
    shutdown_event = threading.Event()

    def signal_handler(signum, frame):
        """处理中断信号，优雅关闭"""
        print(f"\n🛑 Received signal {signum}, initiating graceful shutdown...")
        shutdown_event.set()

        # 设置抓取状态为停止
        global scrape_status
        if scrape_status.get('is_scraping', False):
            scrape_status.update({
                'stop_signal': True,
                'message': '系统正在关闭，已停止抓取任务'
            })
            print("⏹️  已停止所有抓取任务")

        # 立即停止Discord机器人
        stop_discord_bot()

        # 强制等待一小段时间让线程完成，然后强制退出
        time.sleep(0.5)
        print("💥 Force exiting...")
        import os
        os._exit(0)

    # 注册信号处理器
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # 注册退出时停止机器人的函数
    atexit.register(stop_discord_bot)

    # 本地开发模式 - 总是启用热重载
    print("🚀 Starting Flask API in development mode...")
    print("🤖 Discord bot will NOT auto-start. Use web interface to start manually...")
    print("🔄 Hot reload enabled - modify files and refresh browser")

    try:
        # 使用多线程模式，更好地处理中断信号
        app.run(host='0.0.0.0', port=5001, debug=config.DEBUG, use_reloader=False, threaded=True)
    except KeyboardInterrupt:
        print("\n🛑 Received KeyboardInterrupt, shutting down...")
        signal_handler(signal.SIGINT, None)
    except Exception as e:
        print(f"\n💥 Unexpected error: {e}")
        signal_handler(signal.SIGINT, None)
    finally:
        print("👋 Flask API shutdown complete")

