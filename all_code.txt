--- File: ./frontend/app/layout.tsx ---
import type React from "react"
import type { Metadata } from "next"
import { Geist, Geist_Mono } from "next/font/google"
import { Analytics } from "@vercel/analytics/next"
import "./globals.css"

const _geist = Geist({ subsets: ["latin"] })
const _geistMono = Geist_Mono({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Discord 自动营销管理系统",
  description: "智能 Discord 账号营销管理平台，集成微店抓取、图像识别、CNFans 链接生成",
  generator: "v0.app",
  icons: {
    icon: [
      {
        url: "/icon-light-32x32.png",
        media: "(prefers-color-scheme: light)",
      },
      {
        url: "/icon-dark-32x32.png",
        media: "(prefers-color-scheme: dark)",
      },
      {
        url: "/icon.svg",
        type: "image/svg+xml",
      },
    ],
    apple: "/apple-icon.png",
  },
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="zh-CN">
      <body className={`font-sans antialiased`}>
        {children}
        <Analytics />
      </body>
    </html>
  )
}

--- File: ./frontend/app/api/products/count/route.ts ---
import { NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/products/count`)

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Failed to fetch count' }))
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/products/count failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/route.ts ---
// 强制使用内网回环地址，速度最快且最稳定
const BACKEND_URL = 'http://127.0.0.1:5001'

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const query = url.searchParams.toString()
    const backendUrl = query
      ? `${BACKEND_URL}/api/products?${query}`
      : `${BACKEND_URL}/api/products`
    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Cookie': request.headers.get('cookie') || ''
      }
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to fetch products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error fetching products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function PUT(request: Request) {
  try {
    const contentType = request.headers.get('content-type') || ''

    let response;
    if (contentType.includes('multipart/form-data')) {
      // 处理FormData请求（包含文件上传）
      const formData = await request.formData()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Cookie': request.headers.get('cookie') || ''
        },
        body: formData
      })
    } else {
      // 处理JSON请求
      const body = await request.json()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': request.headers.get('cookie') || ''
        },
        body: JSON.stringify(body)
      })
    }

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to update product' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error updating product:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function DELETE(request: Request) {
  try {
    const url = new URL(request.url)
    const ids = url.searchParams.get('ids')

    if (!ids) {
      return new Response(JSON.stringify({ error: 'Missing ids parameter' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const response = await fetch(`${BACKEND_URL}/api/products/batch`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': request.headers.get('cookie') || ''
      },
      body: JSON.stringify({ ids: ids.split(',').map(id => parseInt(id)) })
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to delete products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error deleting products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

--- File: ./frontend/app/api/products/[id]/images/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { id, imageIndex } = resolvedParams
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id]/images/[imageIndex] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/images/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params
    const id = resolvedParams.id
    const formData = await request.formData()
    const cookieHeader = request.headers.get('cookie') || '';

    // FormData上传时，不要设置Content-Type，让浏览器自动处理multipart/form-data
    // 只传递Cookie头
    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images`, {
      method: 'POST',
      body: formData,
      headers: cookieHeader ? {
        'Cookie': cookieHeader
      } : undefined
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'GET',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    // 将ID添加到请求体中，因为后端期望ID在body中而不是URL中
    const bodyWithId = { ...body, id: parseInt(id) }

    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(bodyWithId)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/config/discord-threshold/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/global-reply-delay/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/discord-channel/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to fetch discord channel config' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to update discord channel config' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/auth/logout/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// 强制使用内网回环地址，速度最快且最稳定
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function POST(request: NextRequest) {
  try {
    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端登出API
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/logout`, {
      method: 'POST',
      headers: headers
    });

    // 清除前端session cookie
    const response = NextResponse.json({ message: '已登出' });
    response.cookies.set('user_session', '', {
      maxAge: 0
    });

    return response;
  } catch (error: any) {
    console.error('Logout API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/me/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// 强制使用内网回环地址，速度最快且最稳定
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function GET(request: NextRequest) {
  try {
    // 获取浏览器传来的所有 Cookie
    const cookies = request.headers.get('cookie') || '';

    // 调用后端验证 Session 有效性
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/me`, {
      headers: {
        'Cookie': cookies // 关键：转发 Cookie 给后端
      }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // 如果后端验证失败 (401)，前端也要清除 user_session
      const errorData = await backendResponse.json().catch(() => ({ error: 'Not authenticated' }));
      const response = NextResponse.json(errorData, { status: backendResponse.status });

      if (backendResponse.status === 401) {
      response.cookies.set('user_session', '', { maxAge: 0 });
      }
      return response;
    }
  } catch (error: any) {
    console.error('Auth me API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/login/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// 强制使用内网回环地址，速度最快且最稳定
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // 调用后端登录API
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      const response = NextResponse.json(data);

      // --- 关键修复开始 ---
      // 1. 获取后端返回的原始 Set-Cookie 字符串
      // Flask 通常返回类似: "session=eyJ...; HttpOnly; Path=/; SameSite=Lax"
      const setCookieHeader = backendResponse.headers.get('set-cookie');

      if (setCookieHeader) {
        // 简单解析 Cookie 名称和值
        // 注意：如果后端返回多个 Cookie，这里可能需要更复杂的解析，但 Flask 默认通常只返回 session
        const firstPart = setCookieHeader.split(';')[0]; // 获取 "name=value"
        const [name, ...valueParts] = firstPart.split('=');
        const value = valueParts.join('='); // 防止值中包含 =

        if (name && value) {
          // 使用 Next.js API 设置 Cookie，避免与 header 操作冲突
          response.cookies.set({
            name: name.trim(),
            value: value.trim(),
            httpOnly: true, // 保持 HttpOnly 增强安全性
            path: '/',
            sameSite: 'lax',
            secure: false, // 【关键修改】强制为 false，允许HTTP访问
            maxAge: 60 * 60 * 24 * 30 // 30天不过期
          });
        }
      }
      // --- 关键修复结束 ---

      // 2. 设置前端专用的 user_session (用于UI展示)
      response.cookies.set('user_session', JSON.stringify({
        user: data.user,
        timestamp: Date.now()
      }), {
        httpOnly: false, // 允许前端 JS 读取
        secure: false, // 【关键修改】强制为 false，允许HTTP访问
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 * 30 // 30天不过期
      });

      return response;
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Login API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/message-filters/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/message-filters/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/test-similarity/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/api/test_similarity`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend test_similarity error:', errorText);
      return NextResponse.json({ error: errorText }, { status: response.status });
    }

    const result = await response.json();
    return NextResponse.json(result);
  } catch (error: any) {
    console.error('POST /api/test-similarity failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const limit = url.searchParams.get('limit') || '50';
    // 【修复】获取 offset 参数
    const offset = url.searchParams.get('offset') || '0';

    // 【修复】将 offset 参数拼接到后端请求中
    const response = await fetch(`${BACKEND_URL}/api/search_history?limit=${limit}&offset=${offset}`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/search_history`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const historyId = resolvedParams.id;

    const response = await fetch(`${BACKEND_URL}/api/search_history/${historyId}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history/[id] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/announcements/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    // 修复：手动获取并转发 Cookie
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      headers: {
        'Cookie': cookieHeader
      }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/announcements/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/user/settings/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
        headers: {
            'Cookie': cookies
        }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // 捕获错误并返回状态码，前端收到 401 可处理跳转
      const errorData = await backendResponse.json().catch(() => ({ error: 'Failed to fetch settings' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('User settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
      method: 'PUT',
      headers: {
          'Content-Type': 'application/json',
          'Cookie': cookies
      },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/status/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: Request) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/status`, {
      method: 'GET',
      headers: {
        'Cookie': cookieHeader
      }
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/control/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/control`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/route.ts ---
import { NextResponse } from 'next/server';

// 后端 API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const data = await request.json();
    const { url, weidianId } = data;
    const cookieHeader = request.headers.get('cookie') || '';

    // 支持两种输入方式：完整URL或商品ID
    if (!url && !weidianId) {
      return NextResponse.json({ error: 'URL or weidianId is required' }, { status: 400 });
    }

    // 如果提供了weidianId，构造URL
    const finalUrl = url || `https://weidian.com/item.html?itemID=${weidianId}`;

    // 调用后端 API
    const backendResponse = await fetch(`${BACKEND_URL}/scrape`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify({ url: finalUrl })
    });

    // 修复：处理 409 Conflict，不要抛出通用错误，而是传递给前端处理
    if (backendResponse.status === 409) {
        const errorData = await backendResponse.json();
        return NextResponse.json(errorData, { status: 409 });
    }

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend scrape failed' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const type = url.searchParams.get('type');

    if (type === 'indexed') {
      // 获取已建立向量索引的商品URL列表
      const response = await fetch(`${BACKEND_URL}/api/get_indexed_ids`);
      if (response.ok) {
        const data = await response.json();
        return NextResponse.json(data);
      }
      return NextResponse.json({ indexedIds: [] });
    }

    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端 API 获取商品列表
    const response = await fetch(`${BACKEND_URL}/api/products`, { headers });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    } else if (response.status === 401) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    return NextResponse.json([]);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const { id } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });
    if (response.ok) {
      return NextResponse.json({ success: true });
    } else {
      const err = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(err, { status: response.status });
    }
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PUT方法用于更新商品信息
export async function PUT(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Update failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PATCH方法用于删除单个图片
export async function PATCH(request: Request) {
  try {
    const { productId, imageIndex } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${productId}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Delete image failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/image/[productId]/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ productId: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { productId, imageIndex } = resolvedParams;

    const response = await fetch(`${BACKEND_URL}/api/image/${productId}/${imageIndex}`);

    if (!response.ok) {
      return NextResponse.json({ error: 'Image not found' }, { status: response.status });
    }

    const imageBuffer = await response.arrayBuffer();
    const contentType = response.headers.get('content-type') || 'image/jpeg';

    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600',
      },
    });
  } catch (error: any) {
    console.error('GET /api/image/[productId]/[imageIndex] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch shops' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shops/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops/${resolvedParams.id}`, {
      method: 'DELETE',
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// 获取后端 URL
const getBackendUrl = () => {
  return process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const imageFile = formData.get('image') as File
    const threshold = parseFloat(formData.get('threshold') as string) || 0.1

    if (!imageFile) {
      return NextResponse.json({ error: 'No image provided' }, { status: 400 })
    }

    console.log('收到图片搜索请求，文件大小:', imageFile.size, 'bytes')

    // 创建新的 FormData 传递给后端
    const backendFormData = new FormData()
    const buffer = Buffer.from(await imageFile.arrayBuffer())
    const blob = new Blob([buffer], { type: imageFile.type })
    backendFormData.append('image', blob, imageFile.name || 'search.jpg')

    const backendUrl = getBackendUrl()
    console.log('调用后端搜索 API:', `${backendUrl}/search_similar`)

    // 直接调用后端的向量搜索 API (使用 Faiss)
    const response = await fetch(`${backendUrl}/search_similar`, {
      method: 'POST',
      body: backendFormData
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('后端搜索失败:', response.status, errorText)
      return NextResponse.json({
        error: `后端搜索失败: ${response.status}`,
        details: errorText
      }, { status: response.status })
    }

    const result = await response.json()
    console.log('后端搜索结果:', result)

    if (result.success && result.product) {
      // 后端返回成功，格式化响应
      return NextResponse.json({
        success: true,
        similarity: result.similarity,
        product: {
          id: result.product.id,
          title: result.product.title,
          englishTitle: result.product.englishTitle,
          weidianId: result.skuId,
          weidianUrl: result.skuId, // 直接使用 product_url
          cnfansUrl: result.skuId, // 简化处理
          ruleEnabled: result.product.ruleEnabled,
          matchKeywords: result.product.matchKeywords,
          matchType: result.product.matchType,
          images: [] // 可以从数据库加载
        },
        skuId: result.skuId,
        imageIndex: result.imageIndex,
        matchedImage: `/scraped_images/${result.skuId}/${result.imageIndex}.jpg`,
        searchTime: new Date().toISOString()
      })
    } else {
      // 未找到匹配
      return NextResponse.json({
        success: false,
        message: result.message || `未找到相似度超过 ${(threshold * 100).toFixed(0)}% 的商品`
      })
    }

  } catch (error: any) {
    console.error('搜索错误:', error)
    return NextResponse.json({
      error: error.message,
      stack: error.stack
    }, { status: 500 })
  }
}

--- File: ./frontend/app/api/system/stats/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/system/stats`)
    if (!response.ok) {
      const errorData = await response.json()
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/system/stats failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shop-info/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const shopId = searchParams.get('shopId')

    if (!shopId) {
      return NextResponse.json({ error: '缺少shopId参数' }, { status: 400 })
    }

    // 代理请求到后端，使用127.0.0.1避免代理问题
    const backendUrl = `http://localhost:5001/api/shop-info?shopId=${shopId}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      return NextResponse.json({ error: '后端请求失败' }, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)

  } catch (error) {
    console.error('Shop info API error:', error)
    return NextResponse.json({ error: '获取店铺信息失败' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/stream/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// 强制使用内网回环地址，速度最快且最稳定
const BACKEND_URL = 'http://127.0.0.1:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const backendUrl = `${BACKEND_URL}/api/logs/stream`

    // 创建到后端的SSE连接
    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Cookie': cookieHeader
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    // 创建可读流，使用共享状态对象
    const state = { isControllerClosed: false }
    const reader = response.body?.getReader()

    const stream = new ReadableStream({
      start(controller) {
        function push() {
          // 如果controller已关闭，直接返回
          if (state.isControllerClosed) return

          reader?.read().then(({ done, value }) => {
            // 如果controller已关闭，停止处理
            if (state.isControllerClosed) return

            if (done) {
              // 流结束，关闭controller
              if (!state.isControllerClosed) {
                state.isControllerClosed = true
                try {
                  controller.close()
                } catch {
                  // 忽略关闭错误
                }
              }
              return
            }

            // 确保controller没有被关闭再enqueue
            if (!state.isControllerClosed) {
              try {
                controller.enqueue(value)
                push()
              } catch {
                // enqueue失败，静默处理
                state.isControllerClosed = true
              }
            }
          }).catch(() => {
            // 发生读取错误时关闭controller
            if (!state.isControllerClosed) {
              state.isControllerClosed = true
              try {
                controller.close()
              } catch {
                // 忽略关闭错误
              }
            }
          })
        }

        push()
      },
      cancel() {
        // 客户端断开连接时调用
        state.isControllerClosed = true
        reader?.cancel().catch(() => {})
      }
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control',
      },
    })
  } catch (error) {
    console.error('Logs stream API error:', error)
    return NextResponse.json({ error: 'Failed to connect to log stream' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const endpoint = searchParams.get('endpoint') || 'recent'

    const backendUrl = `${BACKEND_URL}/api/logs/${endpoint}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Logs API error:', error)
    return NextResponse.json({ error: 'Failed to fetch logs' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, { headers })
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch accounts' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/rotation/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`)
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ enabled: false, rotationInterval: 10 })
    }
  } catch (error) {
    return NextResponse.json({ enabled: false, rotationInterval: 10 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update rotation config' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/user/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// 分配Discord账号给用户
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const accountId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/accounts/${accountId}/user`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Assign account to user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/accounts/[id]/status/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}/status`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update status' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}`, {
      method: 'DELETE'
    })

    if (response.ok) {
      return NextResponse.json({ success: true })
    } else {
      return NextResponse.json({ error: 'Failed to delete account' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search_similar/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/search_similar`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend search_similar error:', errorText);
      return NextResponse.json({ error: 'Search failed' }, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/search_similar failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// 获取用户列表（管理员权限）
export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, { headers });
    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Users API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// 创建新用户（管理员权限）
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Create user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/password/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function PUT(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const body = await request.json();

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}/password`, {

      method: 'PUT',

      headers: {

        'Content-Type': 'application/json',

        'Cookie': cookieHeader

      },

      body: JSON.stringify(body)

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    const data = await response.json();

    return NextResponse.json(data);

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/users/[id]/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// 更新用户店铺权限
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const userId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users/${userId}/shops`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user shops API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function DELETE(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}`, {

      method: 'DELETE',

      headers: { 'Cookie': cookieHeader }

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    return NextResponse.json({ success: true });

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/bot/start/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId } = body;

    if (!userId) {
      return NextResponse.json({ error: '需要用户ID' }, { status: 400 });
    }

    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端启动机器人API
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/start`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify({ userId })
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Start bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/bot/stop/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    // 获取前端的session cookie并传递给后端
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // 调用后端停止机器人API
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/stop`, {
      method: 'POST',
      headers: headers
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Stop bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/bot/status/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/bot/status`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/bot/status failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      // 404 handling specifically
      if (response.status === 404) {
          return NextResponse.json({ websites: [] });
      }
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/filters/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/filters`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites/[id]/filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/filters`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/websites/[id]/filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/accounts/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/accounts`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites/[id]/accounts failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/accounts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites/[id]/accounts failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/rotation/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/rotation`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/websites/[id]/rotation failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/[channelId]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; channelId: string }> }
) {
  try {
    const { id, channelId } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels/${channelId}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id]/channels/[channelId] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/page.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { DashboardView } from "@/components/dashboard-view"
import { AccountsView } from "@/components/accounts-view"
import { ScraperView } from "@/components/scraper-view"
import { ShopsView } from "@/components/shops-view"
import { ImageSearchView } from "@/components/image-search-view"
import { UsersView } from "@/components/users-view"
import { RulesView } from "@/components/rules-view"
import { LogsView } from "@/components/logs-view"
import { LoginView } from "@/components/login-view"
import { AppSidebar } from "@/components/app-sidebar"
import { SidebarProvider, SidebarInset, SidebarTrigger } from "@/components/ui/sidebar"
import { Separator } from "@/components/ui/separator"
import { Button } from "@/components/ui/button"
import { LogOut, User, Play, Square } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export default function Page() {
  const [currentView, setCurrentView] = useState("dashboard")
  const [currentUser, setCurrentUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [botStatus, setBotStatus] = useState<'stopped' | 'starting' | 'running' | 'stopping'>('stopped')

  // 使用useRef防止重复请求
  const hasFetchedUser = useRef(false)

  useEffect(() => {
    // 检查锁，防止重复请求
    if (!hasFetchedUser.current) {
      hasFetchedUser.current = true // 立即上锁
    checkLoginStatus()
      fetchBotStatus()
    }
  }, [])

  // 调试：监听状态变化
  useEffect(() => {
    console.log('BotStatus changed to:', botStatus)
  }, [botStatus])

  const checkLoginStatus = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setCurrentUser(data.user)
        // 移除预加载，避免重复API调用
      }
    } catch (error) {
      // 未登录或网络错误
    } finally {
      setLoading(false)
    }
  }

  const fetchBotStatus = async () => {
    try {
      const response = await fetch('/api/bot/status')
      if (response.ok) {
        const data = await response.json()
        // 如果后端说是 running，前端就设为 running
        if (data.running) {
          setBotStatus('running')
        }
      }
    } catch (error) {
      console.error('获取机器人状态失败:', error)
    }
  }

  // 移除预加载逻辑，避免重复API调用
  // const preloadCommonData = async (user: User) => {
  //   console.log('预加载已禁用，避免重复API调用')
  // }

  const handleLogin = (user: User) => {
    setCurrentUser(user)
  }

  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      })
      setCurrentUser(null)
      setCurrentView("accounts")
      setBotStatus('stopped')
      toast.success("已登出")
    } catch (error) {
      toast.error("登出失败")
    }
  }

  const handleStartBot = async () => {
    if (!currentUser) {
      toast.error("请先登录")
      return
    }

    console.log('开始启动机器人...')
    setBotStatus('starting')
    try {
      // 调用后端启动账号的API
      const response = await fetch('/api/bot/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ userId: currentUser.id })
      })

      console.log('启动API响应:', response.status, response.ok)

      if (response.ok) {
        console.log('设置状态为running')
        setBotStatus('running')
        // 强制重新获取状态以确认
        setTimeout(() => fetchBotStatus(), 100)
        toast.success("Discord账号已启动")
        window.dispatchEvent(new Event('bot-status-changed'))
      } else {
        const error = await response.json()
        console.log('启动失败，错误:', error)
        setBotStatus('stopped')
        toast.error(error.error || "启动账号失败")
      }
    } catch (error) {
      console.log('网络错误:', error)
      setBotStatus('stopped')
      toast.error("网络错误，无法启动账号")
    }
  }

  const handleStopBot = async () => {
    setBotStatus('stopping')
    try {
      const response = await fetch('/api/bot/stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include'
      })

      if (response.ok) {
        setBotStatus('stopped')
        toast.success("Discord账号已停止")
        window.dispatchEvent(new Event('bot-status-changed'))
      } else {
        setBotStatus('running')
        toast.error("停止账号失败")
      }
    } catch (error) {
      setBotStatus('running')
      toast.error("网络错误，无法停止账号")
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    )
  }

  if (!currentUser) {
    return <LoginView onLogin={handleLogin} />
  }

  return (
    <SidebarProvider defaultOpen={true}>
      <AppSidebar
        currentView={currentView}
        setCurrentView={setCurrentView}
        currentUser={currentUser}
      />
      <SidebarInset>
        <header className="flex h-14 shrink-0 items-center gap-2 border-b px-4">
          <SidebarTrigger />
          <Separator orientation="vertical" className="h-6" />
          <h1 className="text-lg font-semibold">Discord 自动营销系统</h1>
          <div className="flex-1" />
          <div className="flex items-center gap-3">
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <User className="size-4" />
              <span>{currentUser.username}</span>
              {currentUser.role === 'admin' && (
                <span className="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">管理员</span>
              )}
            </div>

            {/* 机器人控制 */}
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <div className={`w-2 h-2 rounded-full ${
                  botStatus === 'running' ? 'bg-green-500' :
                  botStatus === 'starting' ? 'bg-yellow-500 animate-pulse' :
                  botStatus === 'stopping' ? 'bg-orange-500 animate-pulse' :
                  'bg-gray-400'
                }`} />
                <span>
                  {botStatus === 'running' ? '运行中' :
                   botStatus === 'starting' ? '启动中' :
                   botStatus === 'stopping' ? '停止中' :
                   '已停止'}
                </span>
                {/* 调试信息 */}
                <span className="text-[10px] text-gray-500 ml-2">
                  (状态: {botStatus})
                </span>
              </div>

              {botStatus === 'running' ? (
                <Button variant="outline" size="sm" onClick={handleStopBot} disabled={botStatus !== 'running'}>
                  <Square className="size-4 mr-1" />
                  停止账号
                </Button>
              ) : (
                <Button
                  variant="default"
                  size="sm"
                  onClick={handleStartBot}
                  disabled={botStatus === 'starting'}
                  className="bg-green-600 hover:bg-green-700"
                >
                  <Play className="size-4 mr-1" />
                  启动账号
                </Button>
              )}
            </div>

            <Button variant="outline" size="sm" onClick={handleLogout}>
              <LogOut className="size-4 mr-1" />
              登出
            </Button>
          </div>
        </header>
        <main className="flex-1 overflow-auto p-6">
          {/*

            核心修改：

            不再使用条件渲染 (&&)，而是全部渲染但通过 CSS 控制显示隐藏。

            这样切换 Tab 时组件不会卸载，数据和滚动位置得以保留。

          */}
          <div style={{ display: currentView === "dashboard" ? 'block' : 'none', height: '100%' }}>
            <DashboardView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "accounts" ? 'block' : 'none', height: '100%' }}>
            <AccountsView />
          </div>

          {(currentUser.role === 'admin' || (currentUser.shops && currentUser.shops.length > 0)) && (
            <div style={{ display: currentView === "shops" ? 'block' : 'none', height: '100%' }}>
              <ShopsView currentUser={currentUser} />
            </div>
          )}

          <div style={{ display: currentView === "scraper" ? 'block' : 'none', height: '100%' }}>
            {/* ScraperView 内部建议实现轮询机制来获取最新抓取结果 */}
            <ScraperView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "image-search" ? 'block' : 'none', height: '100%' }}>
            <ImageSearchView />
          </div>

          {currentUser.role === 'admin' && (
            <>
              <div style={{ display: currentView === "users" ? 'block' : 'none', height: '100%' }}>
                <UsersView />
              </div>
              <div style={{ display: currentView === "logs" ? 'block' : 'none', height: '100%' }}>
                <LogsView />
              </div>
            </>
          )}
        </main>
      </SidebarInset>
    </SidebarProvider>
  )
}

--- File: ./frontend/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- File: ./frontend/components/theme-provider.tsx ---
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

--- File: ./frontend/components/accounts-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "sonner"
import { Plus, Settings, Save, Trash2, Globe, Link, Hash, X, Edit, Clock } from "lucide-react"

function CooldownTimer({ remaining }: { remaining: number }) {
  if (remaining <= 0) return null
  return (
    <div className="flex items-center text-orange-600 text-xs gap-1 mt-1 bg-orange-50 px-2 py-0.5 rounded border border-orange-100">
      <Clock className="w-3 h-3" />
      <span className="font-mono">{Math.ceil(remaining)}s 冷却中</span>
    </div>
  )
}

export function AccountsView() {
  const [accounts, setAccounts] = useState<any[]>([])
  const [users, setUsers] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddDialog, setShowAddDialog] = useState(false)
  const [newAccount, setNewAccount] = useState({
    token: ""
  })
  const [settings, setSettings] = useState({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
  })
  const [settingsLoading, setSettingsLoading] = useState(false)

  // 新增：当前用户信息状态
  const [currentUser, setCurrentUser] = useState<any>(null)
  const [deleteAccountConfirm, setDeleteAccountConfirm] = useState<any>(null)

  // 使用API缓存hook
  const { cachedFetch } = useApiCache()

  // 网站配置相关状态
  const [websites, setWebsites] = useState<any[]>([])
  const [showAddWebsite, setShowAddWebsite] = useState(false)
  const [editingWebsite, setEditingWebsite] = useState<any>(null)
  const [newWebsite, setNewWebsite] = useState({
    name: '',
    display_name: '',
    url_template: '',
    id_pattern: '',
    badge_color: 'blue'
  })
  const [websiteChannels, setWebsiteChannels] = useState<{[key: number]: string[]}>({})
  const [channelInputs, setChannelInputs] = useState<{[key: number]: string}>({})
  const [rotationEnabled, setRotationEnabled] = useState<{[key: number]: boolean}>({})
  const [rotationInputs, setRotationInputs] = useState<{[key: number]: string}>({})

  const [cooldowns, setCooldowns] = useState<any[]>([])

  // 网站账号绑定相关状态
  const [websiteAccounts, setWebsiteAccounts] = useState<{[key: number]: any[]}>({})
  const [showBindAccount, setShowBindAccount] = useState<number | null>(null)
  const [newAccountBinding, setNewAccountBinding] = useState({
    account_id: '',
    role: 'both'
  })

  // 网站过滤规则相关状态
  const [websiteFilters, setWebsiteFilters] = useState<{[key: number]: any[]}>({})
  const [showAddWebsiteFilter, setShowAddWebsiteFilter] = useState<number | null>(null)

  // 消息过滤相关状态
  const [messageFilters, setMessageFilters] = useState<any[]>([])
  const [showAddFilter, setShowAddFilter] = useState(false)
  const [editingFilter, setEditingFilter] = useState<any>(null)
  const [newFilter, setNewFilter] = useState({
    filter_type: 'contains',
    filter_value: ''
  })


  const fetchWebsites = async (forceRefresh = false) => {
    try {
      const cacheKey = '/api/websites'
      if (forceRefresh) {
        // 强制刷新：清除缓存
        sessionStorage.removeItem(`cache_${cacheKey}`)
      }
      const data = await cachedFetch('/api/websites', { credentials: 'include' })
      const websites = data.websites || []

      // 后端已包含channels和accounts信息
        const channels: {[key: number]: string[]} = {}
      const accounts: {[key: number]: any[]} = {}
      const filters: {[key: number]: any[]} = {}

      // 并行获取所有网站的过滤规则
      const filterPromises = websites.map(async (website: any) => {
        try {
          const res = await fetch(`/api/websites/${website.id}/filters`, { credentials: 'include' })
          if (res.ok) {
            const data = await res.json()
            filters[website.id] = data.filters || []
          } else {
            filters[website.id] = []
          }
        } catch (e) {
          filters[website.id] = []
        }
      })

      websites.forEach((website: any) => {
        channels[website.id] = website.channels || []
        accounts[website.id] = website.accounts || []
        setRotationEnabled(prev => ({ ...prev, [website.id]: website.rotation_enabled !== 0 }))
        setRotationInputs(prev => ({ ...prev, [website.id]: (website.rotation_interval || 180).toString() }))
      })

      // 等待所有过滤规则获取完成
      await Promise.all(filterPromises)

      setWebsites(websites)
        setWebsiteChannels(channels)
      setWebsiteAccounts(accounts)
      setWebsiteFilters(filters)
    } catch (e) {
      console.error('获取网站配置失败:', e)
    }
  }

  const fetchMessageFilters = async () => {
    try {
      const res = await fetch('/api/message-filters', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setMessageFilters(data.filters || [])
      }
    } catch (e) {
      console.error('获取消息过滤规则失败:', e)
    }
  }


  const fetchCooldowns = async () => {
    try {
      const res = await fetch('/api/bot/cooldowns', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setCooldowns(data.cooldowns || [])
      }
    } catch {
      // ignore
    }
  }

  const getCooldownRemaining = (accountId: number, websiteId: number) => {
    const website = websites.find(w => w.id === websiteId)
    if (!website) return 0

    const interval = website.rotation_interval || 180
    const channels = websiteChannels[websiteId] || []

    let maxRemaining = 0

    for (const cd of cooldowns) {
      if (cd.account_id === accountId && channels.includes(cd.channel_id)) {
        const passed = Date.now() / 1000 - cd.last_sent
        const remaining = interval - passed
        if (remaining > maxRemaining) {
          maxRemaining = remaining
        }
      }
    }

    return maxRemaining > 0 ? maxRemaining : 0
  }

  useEffect(() => {
    // 先获取当前用户，再决定是否获取用户列表
    const init = async () => {
        const userRes = await fetch('/api/auth/me', { credentials: 'include' });
        if (userRes.ok) {
            const userData = await userRes.json();
            setCurrentUser(userData.user);

            // 并行获取数据
            fetchAccounts(); // 所有人都能获取账号(自己的)

            // 只有管理员才获取用户列表
            if (userData.user.role === 'admin') {
                fetchUsers();
            }
        }
    };
    init();
    fetchSettings();
    fetchWebsites(true); // 强制刷新，清除旧的缓存数据
    fetchMessageFilters();
    fetchCooldowns();

    // 优化轮询频率：每15秒刷新一次账号状态（降低服务器负载）
    const statusInterval = setInterval(() => {
      if (!document.hidden) { // 只在标签页可见时刷新
        fetchAccounts(true); // 强制刷新，清除缓存
      }
    }, 15000);

    // 优化轮询频率：每10秒刷新一次冷却状态（降低服务器负载）
    const cooldownInterval = setInterval(() => {
      if (!document.hidden) { // 只在标签页可见时刷新
        fetchCooldowns()
      }
    }, 10000)

    const handleStatusChange = () => {
      fetchAccounts(true)
    }
    window.addEventListener('bot-status-changed', handleStatusChange)

    return () => {
      clearInterval(statusInterval);
      clearInterval(cooldownInterval);
      window.removeEventListener('bot-status-changed', handleStatusChange)
    }
  }, [])

  const fetchSettings = async (usePreload: boolean = true) => {
    try {
      // 首先检查是否有预加载数据
      if (usePreload) {
        const preloadData = sessionStorage.getItem('preload_settings')
        if (preloadData) {
          try {
            console.log('使用预加载设置数据')
            const data = JSON.parse(preloadData)
            setSettings({
              discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
              global_reply_min_delay: data.global_reply_min_delay || 3.0,
              global_reply_max_delay: data.global_reply_max_delay || 8.0,
            })

            // 清除预加载数据，避免重复使用
            sessionStorage.removeItem('preload_settings')

            // 在后台获取最新数据，但不显示加载状态
            setTimeout(() => fetchSettings(false), 500)
            return
          } catch (e) {
            console.error('预加载设置数据解析失败:', e)
            // 预加载数据损坏，清除并重新获取
            sessionStorage.removeItem('preload_settings')
          }
        } else {
          // 如果没有预加载数据，等待一下再试
          setTimeout(() => {
            const retryPreload = sessionStorage.getItem('preload_settings')
            if (retryPreload) {
              fetchSettings(true)
            } else {
              fetchSettings(false)
            }
          }, 200)
          return
        }
      }

      console.log('从API获取设置数据')
      const response = await fetch('/api/user/settings', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
          global_reply_min_delay: data.global_reply_min_delay || 3.0,
          global_reply_max_delay: data.global_reply_max_delay || 8.0,
        })
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
    }
  }

  const handleSaveSettings = async () => {
    setSettingsLoading(true)
    try {
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("设置已保存")
      } else {
        toast.error("保存设置失败")
      }
    } catch (error) {
      toast.error("保存设置失败")
    } finally {
      setSettingsLoading(false)
    }
  }

  const fetchAccounts = async (forceRefresh = false) => {
          try {
      console.log('获取账号列表...')
      const cacheKey = '/api/accounts'
      if (forceRefresh) {
        // 强制刷新：清除缓存
        sessionStorage.removeItem(`cache_${cacheKey}`)
      }
      const data = await cachedFetch('/api/accounts', { credentials: 'include' })
            setAccounts(data.accounts || [])
    } catch (error) {
      console.error('获取账号列表出错:', error)
      setAccounts([])
    } finally {
      setLoading(false)
    }
  }

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users') // Next.js 会自动带上浏览器 Cookie
      if (response.ok) {
        const data = await response.json()
        setUsers(data.users || [])
      } else {
        // 不再抛出 toast 错误，而是静默失败或仅记录日志
        // 因为如果是权限不足，上面的逻辑应该已经拦截了，这里是兜底
        console.log('User fetch skipped or failed', response.status)
        setUsers([])
      }
    } catch (error) {
      setUsers([])
    }
  }

  const getUserDisplayName = (userId: number) => {
    const user = users.find(u => u.id === userId)
    return user ? user.username : `用户${userId}`
  }

  const handleAddAccount = async () => {
    if (!newAccount.token) {
      toast.error("请输入 Discord Token")
      return
    }

    try {
      const response = await fetch('/api/accounts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ token: newAccount.token })
      })

      if (response.ok) {
        toast.success("账号添加成功")
        setNewAccount({ token: "" })
        setShowAddDialog(false)
        fetchAccounts()
      } else {
        const error = await response.json()
        toast.error(error.error || "添加账号失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleDeleteAccount = (account: any) => {
    setDeleteAccountConfirm(account)
  }

  const confirmDeleteAccount = async () => {
    if (!deleteAccountConfirm) return

    try {
      const response = await fetch(`/api/accounts/${deleteAccountConfirm.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        toast.success("账号删除成功")
        fetchAccounts()
        setDeleteAccountConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "删除账号失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  // 网站配置处理函数
  const handleAddWebsite = async () => {
    try {
      const res = await fetch('/api/websites', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newWebsite)
      })
      if (res.ok) {
        toast.success('网站配置已添加')
        setShowAddWebsite(false)
        setNewWebsite({ name: '', display_name: '', url_template: '', id_pattern: '', badge_color: 'blue' })
        fetchWebsites()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateWebsite = async () => {
    if (!editingWebsite) return
    try {
      const res = await fetch(`/api/websites/${editingWebsite.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(editingWebsite)
      })
      if (res.ok) {
        toast.success('网站配置已更新')
        setEditingWebsite(null)
        fetchWebsites()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteWebsite = async (website: any) => {
    if (!confirm(`确定要删除网站配置 "${website.display_name}" 吗？`)) return
    try {
      const res = await fetch(`/api/websites/${website.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('网站配置已删除')
        fetchWebsites()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleAddChannel = async (websiteId: number, channelId: string) => {
    if (!channelId.trim()) return
    try {
      const res = await fetch(`/api/websites/${websiteId}/channels`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ channel_id: channelId.trim() })
      })
      if (res.ok) {
        toast.success('频道绑定已添加')
        // 立即更新前端状态，而不是重新获取所有数据
        setWebsiteChannels(prev => ({
          ...prev,
          [websiteId]: [...(prev[websiteId] || []), channelId.trim()]
        }))
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleRemoveChannel = async (websiteId: number, channelId: string) => {
    try {
      // 【修复】如果channelId是完整的Discord URL，提取频道ID
      let actualChannelId = channelId;
      if (channelId.includes('discord.com/channels/')) {
        const parts = channelId.split('/');
        actualChannelId = parts[parts.length - 1];
      }

      const res = await fetch(`/api/websites/${websiteId}/channels/${actualChannelId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('频道绑定已移除')
        // 立即更新前端状态，而不是重新获取所有数据
        setWebsiteChannels(prev => ({
          ...prev,
          [websiteId]: prev[websiteId]?.filter(id => id !== channelId) || []
        }))
      } else {
        toast.error('移除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  // 账号绑定处理函数
  const handleBindAccount = async (websiteId: number) => {
    try {
      const res = await fetch(`/api/websites/${websiteId}/accounts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newAccountBinding)
      })
      if (res.ok) {
        toast.success('账号绑定成功')
        setShowBindAccount(null)

        // 获取绑定的账号信息
        const boundAccount = accounts.find(acc => acc.id.toString() === newAccountBinding.account_id)
        if (boundAccount) {
          // 立即更新前端状态，而不是重新获取所有数据
          setWebsiteAccounts(prev => ({
            ...prev,
            [websiteId]: [...(prev[websiteId] || []), {
              id: Date.now(), // 临时ID，后端会返回真实ID
              account_id: parseInt(newAccountBinding.account_id),
              username: boundAccount.username,
              role: newAccountBinding.role
            }]
          }))
        }

        setNewAccountBinding({ account_id: '', role: 'both' })
      } else {
        const error = await res.json()
        toast.error(error.error || '绑定失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUnbindAccount = async (websiteId: number, accountId: number) => {
    try {
      const res = await fetch(`/api/websites/${websiteId}/accounts/${accountId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('账号解绑成功')
        // 立即更新前端状态，而不是重新获取所有数据
        setWebsiteAccounts(prev => ({
          ...prev,
          [websiteId]: prev[websiteId]?.filter(binding => binding.account_id !== accountId) || []
        }))
      } else {
        toast.error('解绑失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  // 轮换间隔设置
  const handleUpdateRotation = async (websiteId: number, rotationInterval: number) => {
    try {
      const res = await fetch(`/api/websites/${websiteId}/rotation`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ rotation_interval: rotationInterval })
      })
      if (res.ok) {
        toast.success('轮换间隔已更新')
        // 立即更新前端状态，而不是重新获取所有数据
        setWebsites(prev => prev.map(website =>
          website.id === websiteId
            ? { ...website, rotation_interval: rotationInterval }
            : website
        ))
        // 同步更新本地输入框状态
        setRotationInputs(prev => ({ ...prev, [websiteId]: rotationInterval.toString() }))
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  // 网站过滤规则管理
  const handleAddFilter = async (websiteId: number) => {
    try {
      // 首先获取当前网站的过滤规则
      const res = await fetch(`/api/websites/${websiteId}/filters`, { credentials: 'include' })
      if (!res.ok) {
        toast.error('获取当前过滤规则失败')
        return
      }

      const currentData = await res.json()
      const currentFilters = currentData.filters || []

      // 添加新规则
      const newFilters = [...currentFilters, {
        filter_type: newFilter.filter_type,
        filter_value: newFilter.filter_value
      }]

      // 更新过滤规则
      const updateRes = await fetch(`/api/websites/${websiteId}/filters`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ filters: newFilters })
      })

      if (updateRes.ok) {
        toast.success('过滤规则已添加')
        setNewFilter({ filter_type: 'contains', filter_value: '' })
        setShowAddWebsiteFilter(null)

        // 立即更新前端状态，而不是重新获取所有数据
        setWebsiteFilters(prev => ({
          ...prev,
          [websiteId]: newFilters
        }))
      } else {
        toast.error('添加过滤规则失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleRemoveWebsiteFilter = async (websiteId: number, filterIndex: number) => {
    try {
      // 获取当前网站的过滤规则
      const currentFilters = websiteFilters[websiteId] || []

      // 移除指定索引的规则
      const newFilters = currentFilters.filter((_, index) => index !== filterIndex)

      // 更新过滤规则
      const updateRes = await fetch(`/api/websites/${websiteId}/filters`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ filters: newFilters })
      })

      if (updateRes.ok) {
        toast.success('过滤规则已删除')
        // 立即更新前端状态，而不是重新获取所有数据
        setWebsiteFilters(prev => ({
          ...prev,
          [websiteId]: newFilters
        }))
      } else {
        toast.error('删除过滤规则失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  // 消息过滤处理函数
  const handleAddMessageFilter = async () => {
    try {
      const res = await fetch('/api/message-filters', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newFilter)
      })
      if (res.ok) {
        toast.success('过滤规则添加成功')
        setShowAddFilter(false)
        setNewFilter({ filter_type: 'contains', filter_value: '' })
        fetchMessageFilters()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateMessageFilter = async () => {
    if (!editingFilter) return
    try {
      const res = await fetch(`/api/message-filters/${editingFilter.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          filter_type: editingFilter.filter_type,
          filter_value: editingFilter.filter_value,
          is_active: editingFilter.is_active
        })
      })
      if (res.ok) {
        toast.success('过滤规则更新成功')
        setEditingFilter(null)
        fetchMessageFilters()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteMessageFilter = async (filterId: number) => {
    if (!confirm('确定要删除这个过滤规则吗？')) return
    try {
      const res = await fetch(`/api/message-filters/${filterId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('过滤规则删除成功')
        fetchMessageFilters()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }


  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-extrabold tracking-tight">账号管理</h2>
        <p className="text-sm text-muted-foreground mt-1">管理 Discord 账号</p>
      </div>

      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h3 className="text-xl font-bold">账号列表</h3>
            <p className="text-sm text-gray-600 mt-1">
              共 {accounts.length} 个账号
            </p>
          </div>
          <Dialog open={showAddDialog} onOpenChange={setShowAddDialog}>
            <DialogTrigger asChild>
              <Button>
                <Plus className="w-4 h-4 mr-2" />
                添加账号
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>添加 Discord 账号</DialogTitle>
                <DialogDescription>
                  输入 Discord Token，系统将自动验证并获取用户名
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label htmlFor="token">Discord Token</Label>
                  <Input
                    id="token"
                    type="password"
                    value={newAccount.token}
                    onChange={(e) => setNewAccount(prev => ({ ...prev, token: e.target.value }))}
                    placeholder="输入 Discord Token"
                  />
                  <p className="text-xs text-muted-foreground mt-1">
                    Token 将被安全存储，系统会自动验证有效性
                  </p>
                </div>
              </div>
              <DialogFooter>
                <Button onClick={handleAddAccount}>添加账号</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>

        <div className="space-y-2">
          {accounts.map((account) => (
            <div key={account.id} className="flex justify-between items-center p-4 border rounded">
              <div className="flex-1">
                <div className="font-semibold">{account.username}</div>
                <div className="text-sm text-gray-500">
                  {account.user_id ? `所属用户: ${getUserDisplayName(account.user_id)}` : '未分配用户'}
                </div>
                <div className="text-xs text-gray-400 font-mono">
                  {account.token && typeof account.token === 'string' ? `${account.token.substring(0, 20)}...` : 'Token 无效'}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className={`px-2 py-1 rounded text-sm ${
                  account.status === 'online' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
                }`}>
                  {account.status === 'online' ? '在线' : '离线'}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleDeleteAccount(account)}
                  className="text-red-600 hover:text-red-700 hover:bg-red-50"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            </div>
          ))}
        </div>
      </div>


      {/* 设置区域 */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h3 className="text-xl font-bold flex items-center">
              <Settings className="w-5 h-5 mr-2" />
              个人设置
            </h3>
            <p className="text-sm text-gray-600 mt-1">配置您的个性化运行参数</p>
          </div>
          <Button onClick={handleSaveSettings} disabled={settingsLoading}>
            <Save className="w-4 h-4 mr-2" />
            {settingsLoading ? "保存中..." : "保存设置"}
          </Button>
        </div>

        {/* 系统参数设置 - 合并相似度和延迟设置 */}
        <Card>
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">系统参数</CardTitle>
            <CardDescription>配置图片匹配和回复延迟参数</CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* 相似度和延迟设置 - 紧凑布局 */}
            <div className="flex flex-col sm:flex-row gap-6">
              {/* 相似度设置 */}
              <div className="flex-1 space-y-2">
                <div className="flex items-center justify-between">
                  <Label htmlFor="similarity-threshold" className="text-sm font-medium">相似度阈值</Label>
                  <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                    {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                  </span>
                </div>
                <div className="space-y-1">
                  <Input
                    id="similarity-threshold"
                    type="number"
                    step="0.1"
                    min="0.1"
                    max="1.0"
                    value={settings.discord_similarity_threshold}
                    onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                    className="h-9"
                  />
                  <p className="text-xs text-muted-foreground">
                    阈值越低匹配越宽松，建议范围 0.3-0.8
                  </p>
                </div>
              </div>

              {/* 回复延迟设置 */}
              <div className="flex-1 space-y-2">
                <Label className="text-sm font-medium">回复延迟</Label>
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="flex items-center gap-1">
                      <Input
                        id="min-delay"
                        type="number"
                        step="0.1"
                        min="0.1"
                        max="30"
                        value={settings.global_reply_min_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_min_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                      <span className="text-sm text-muted-foreground">-</span>
                      <Input
                        id="max-delay"
                        type="number"
                        step="0.5"
                        min="1"
                        max="60"
                        value={settings.global_reply_max_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_max_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                    </div>
                    <span className="text-xs text-muted-foreground">秒</span>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    每次回复随机延迟 {settings.global_reply_min_delay}-{settings.global_reply_max_delay} 秒
                  </p>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>


        {/* 编辑网站对话框 */}
        {editingWebsite && (
          <Dialog open={!!editingWebsite} onOpenChange={() => setEditingWebsite(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>编辑网站配置</DialogTitle>
                <DialogDescription>修改网站配置信息</DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>网站标识</Label>
                  <Input
                    value={editingWebsite.name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>显示名称</Label>
                  <Input
                    value={editingWebsite.display_name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>URL模板</Label>
                  <Input
                    value={editingWebsite.url_template}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>ID提取模式</Label>
                  <Input
                    value={editingWebsite.id_pattern}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>徽章颜色</Label>
                  <Select value={editingWebsite?.badge_color || 'blue'} onValueChange={value => setEditingWebsite(prev => ({ ...prev, badge_color: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="blue">蓝色</SelectItem>
                      <SelectItem value="green">绿色</SelectItem>
                      <SelectItem value="orange">橙色</SelectItem>
                      <SelectItem value="red">红色</SelectItem>
                      <SelectItem value="purple">紫色</SelectItem>
                      <SelectItem value="gray">灰色</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingWebsite(null)}>取消</Button>
                <Button onClick={handleUpdateWebsite}>保存</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}

        {/* 消息过滤设置 - 每个用户独立配置 */}
        {currentUser && (
          <Card className="mt-6">
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg">消息过滤</CardTitle>
                  <CardDescription>设置账号不回复的消息内容规则</CardDescription>
                </div>
                <Dialog open={showAddFilter} onOpenChange={setShowAddFilter}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      添加过滤规则
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>添加消息过滤规则</DialogTitle>
                      <DialogDescription>设置账号忽略的消息类型</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>过滤类型</Label>
                        <Select value={newFilter.filter_type} onValueChange={value => setNewFilter(prev => ({ ...prev, filter_type: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="contains">包含文本</SelectItem>
                            <SelectItem value="starts_with">开头是</SelectItem>
                            <SelectItem value="ends_with">结尾是</SelectItem>
                            <SelectItem value="regex">正则表达式</SelectItem>
                            <SelectItem value="user_id">用户ID</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      <div>
                        <Label>过滤值</Label>
                        <Input
                          value={newFilter.filter_value}
                          onChange={e => setNewFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                          placeholder={
                            newFilter.filter_type === 'user_id'
                              ? "输入用户ID，多个用逗号分隔"
                              : "输入要过滤的内容"
                          }
                        />
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddFilter(false)}>取消</Button>
                      <Button onClick={handleAddMessageFilter}>添加规则</Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                {messageFilters.map((filter: any) => (
                  <div key={filter.id} className="flex items-center justify-between p-3 border rounded">
                    <div>
                      <div className="font-medium">{filter.filter_type} "{filter.filter_value}"</div>
                      <div className="text-sm text-muted-foreground">
                        创建时间: {new Date(filter.created_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingFilter(filter)}
                      >
                        <Edit className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteMessageFilter(filter.id)}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ))}
                {messageFilters.length === 0 && (
                  <div className="text-center py-4 text-muted-foreground">
                    暂无过滤规则
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 网站配置区域 - 所有登录用户可见 */}
        {currentUser && (
        <Card className="mt-6">
          <CardHeader>
            <div className="flex justify-between items-center">
              <div>
                <CardTitle className="text-lg flex items-center">
                  <Globe className="w-5 h-5 mr-2" />
                  网站配置
                </CardTitle>
                <CardDescription>管理支持的购物网站和频道绑定</CardDescription>
              </div>
              {/* 只有管理员可以添加新网站 */}
              {currentUser?.role === 'admin' && (
                <Dialog open={showAddWebsite} onOpenChange={setShowAddWebsite}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      添加网站
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>添加网站配置</DialogTitle>
                      <DialogDescription>配置新的购物网站支持</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>网站标识</Label>
                        <Input
                          value={newWebsite.name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, name: e.target.value }))}
                          placeholder="例如: kakobuy"
                        />
                      </div>
                      <div>
                        <Label>显示名称</Label>
                        <Input
                          value={newWebsite.display_name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                          placeholder="例如: Kakobuy"
                        />
                      </div>
                      <div>
                        <Label>URL模板</Label>
                        <Input
                          value={newWebsite.url_template}
                          onChange={e => setNewWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                          placeholder="https://www.kakobuy.com/item/details?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD"
                        />
                      </div>
                      <div>
                        <Label>ID提取模式</Label>
                        <Input
                          value={newWebsite.id_pattern}
                          onChange={e => setNewWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                          placeholder="{id}"
                        />
                      </div>
                      <div>
                        <Label>徽章颜色</Label>
                        <Select value={newWebsite.badge_color} onValueChange={value => setNewWebsite(prev => ({ ...prev, badge_color: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="blue">蓝色</SelectItem>
                            <SelectItem value="green">绿色</SelectItem>
                            <SelectItem value="orange">橙色</SelectItem>
                            <SelectItem value="red">红色</SelectItem>
                            <SelectItem value="purple">紫色</SelectItem>
                            <SelectItem value="gray">灰色</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddWebsite(false)}>取消</Button>
                      <Button onClick={handleAddWebsite}>添加</Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              )}
            </div>
          </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {websites.map((website: any) => (
                  <div key={website.id} className="border rounded-lg p-4">
                    <div className="flex justify-between items-start mb-3">
                      <div className="flex items-center gap-2">
                        <span className={`inline-flex items-center rounded-md border font-medium w-fit whitespace-nowrap text-[9px] px-1 py-0 h-4 border-none shrink-0 text-white ${
                          website.badge_color === 'blue' ? 'bg-blue-600' :
                          website.badge_color === 'green' ? 'bg-green-600' :
                          website.badge_color === 'orange' ? 'bg-orange-600' :
                          website.badge_color === 'red' ? 'bg-red-600' :
                          website.badge_color === 'purple' ? 'bg-purple-600' :
                          'bg-gray-600'
                        }`}>
                          {website.display_name}
                        </span>
                        <span className="text-sm font-medium">{website.name}</span>
                      </div>
                      {/* 只有管理员可以编辑/删除网站定义 */}
                      {currentUser?.role === 'admin' && (
                        <div className="flex gap-2">
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => setEditingWebsite(website)}
                          >
                            <Edit className="w-4 h-4" />
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleDeleteWebsite(website)}
                          >
                            <Trash2 className="w-4 h-4" />
                          </Button>
                        </div>
                      )}
                    </div>

                    <div className="text-xs text-muted-foreground mb-3">
                      <div>URL模板: {website.url_template}</div>
                      <div>ID模式: {website.id_pattern}</div>
                    </div>

                    {/* 频道绑定 */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Hash className="w-4 h-4" />
                        <span className="text-sm font-medium">绑定频道</span>
                        <Dialog>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Plus className="w-3 h-3 mr-1" />
                              添加频道
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>添加频道绑定</DialogTitle>
                              <DialogDescription>输入Discord频道ID</DialogDescription>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <Label>频道ID</Label>
                                <Input
                                  placeholder="例如: 1234567890123456789"
                                  value={channelInputs[website.id] || ''}
                                  onChange={(e) => setChannelInputs(prev => ({ ...prev, [website.id]: e.target.value }))}
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter' && channelInputs[website.id]?.trim()) {
                                      handleAddChannel(website.id, channelInputs[website.id].trim())
                                      setChannelInputs(prev => ({ ...prev, [website.id]: '' }))
                                    }
                                  }}
                                />
                              </div>
                            </div>
                            <DialogFooter>
                              <Button variant="outline" onClick={() => setChannelInputs(prev => ({ ...prev, [website.id]: '' }))}>取消</Button>
                              <Button onClick={() => {
                                if (channelInputs[website.id]?.trim()) {
                                  handleAddChannel(website.id, channelInputs[website.id].trim())
                                  setChannelInputs(prev => ({ ...prev, [website.id]: '' }))
                                }
                              }} disabled={!channelInputs[website.id]?.trim()}>添加</Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </div>

                      <div className="flex flex-wrap gap-2">
                        {(websiteChannels[website.id] || []).map((channelId: string) => (
                          <div key={channelId} className="flex items-center gap-1 bg-muted rounded px-2 py-1">
                            <Hash className="w-3 h-3" />
                            <span className="text-xs font-mono">{channelId}</span>
                            <Button
                              variant="ghost"
                              size="sm"
                              className="h-4 w-4 p-0"
                              onClick={() => handleRemoveChannel(website.id, channelId)}
                            >
                              <X className="w-3 h-3" />
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>

                    {/* 账号绑定 */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Settings className="w-4 h-4" />
                        <span className="text-sm font-medium">绑定账号</span>
                        <Dialog open={showBindAccount === website.id} onOpenChange={(open) => {
                          setShowBindAccount(open ? website.id : null)
                          if (!open) setNewAccountBinding({ account_id: '', role: 'both' })
                        }}>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Plus className="w-3 h-3 mr-1" />
                              绑定账号
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>绑定Discord账号</DialogTitle>
                              <DialogDescription>选择账号并设置角色</DialogDescription>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <Label>选择账号</Label>
                                <Select value={newAccountBinding.account_id} onValueChange={value => setNewAccountBinding(prev => ({ ...prev, account_id: value }))}>
                                  <SelectTrigger>
                                    <SelectValue placeholder="选择Discord账号" />
                                  </SelectTrigger>
                                  <SelectContent>
                                    {accounts.filter(account => !websiteAccounts[website.id]?.some(binding => binding.account_id === account.id)).map((account: any) => (
                                      <SelectItem key={account.id} value={account.id.toString()}>
                                        {account.username} ({account.status})
                                      </SelectItem>
                                    ))}
                                  </SelectContent>
                                </Select>
                              </div>
                              <div>
                                <Label>账号角色</Label>
                                <Select value={newAccountBinding.role} onValueChange={value => setNewAccountBinding(prev => ({ ...prev, role: value }))}>
                                  <SelectTrigger>
                                    <SelectValue />
                                  </SelectTrigger>
                                  <SelectContent>
                                    <SelectItem value="listener">监听 (只接收消息)</SelectItem>
                                    <SelectItem value="sender">发送 (只发送回复)</SelectItem>
                                    <SelectItem value="both">两者 (监听+发送)</SelectItem>
                                  </SelectContent>
                                </Select>
                              </div>
                            </div>
                            <DialogFooter>
                              <Button variant="outline" onClick={() => setShowBindAccount(null)}>取消</Button>
                              <Button onClick={() => handleBindAccount(website.id)} disabled={!newAccountBinding.account_id}>
                                绑定
                              </Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </div>

                      <div className="flex flex-wrap gap-2">
                        {(websiteAccounts[website.id] || []).map((binding: any) => {
                          const remaining = getCooldownRemaining(binding.account_id, website.id)
                          return (
                            <div key={binding.id} className="flex flex-col items-start bg-muted rounded px-2 py-1 border">
                              <div className="flex items-center gap-1">
                                <span className="text-xs">{binding.username}</span>
                                <Badge variant="outline" className="text-[9px] px-1 py-0 h-4">
                                  {binding.role === 'listener' ? '监听' : binding.role === 'sender' ? '发送' : '两者'}
                                </Badge>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  className="h-4 w-4 p-0"
                                  onClick={() => handleUnbindAccount(website.id, binding.account_id)}
                                >
                                  <X className="w-3 h-3" />
                                </Button>
                              </div>
                              <CooldownTimer remaining={remaining} />
                            </div>
                          )
                        })}
                      </div>
                    </div>

                    {/* 账号轮换设置 - 每个用户独立配置 */}
                    {currentUser && (
                      <div className="space-y-2">
                        <div className="flex items-center gap-2">
                          <Settings className="w-4 h-4" />
                          <span className="text-sm font-medium">轮换设置 (全局)</span>
                        </div>

                        {/* 轮换启用开关 */}
                        <div className="flex items-center gap-2">
                          <Label className="text-xs">启用轮换:</Label>
                          <Switch
                            checked={rotationEnabled[website.id] ?? (website.rotation_enabled !== 0)}
                            onCheckedChange={(checked) => {
                              setRotationEnabled(prev => ({ ...prev, [website.id]: checked }))
                              // 发送API请求更新轮换启用状态
                              fetch(`/api/websites/${website.id}/rotation`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include',
                                body: JSON.stringify({ rotation_enabled: checked ? 1 : 0 })
                              }).then(response => {
                                if (response.ok) {
                                  toast.success(`轮换功能已${checked ? '启用' : '禁用'}`)
                                } else {
                                  toast.error('更新失败')
                                  // 恢复开关状态
                                  setRotationEnabled(prev => ({ ...prev, [website.id]: !checked }))
                                }
                              }).catch(() => {
                                toast.error('网络错误')
                                // 恢复开关状态
                                setRotationEnabled(prev => ({ ...prev, [website.id]: !checked }))
                              })
                            }}
                          />
                        </div>

                        {/* 轮换间隔设置 */}
                        <div className="flex items-center gap-2">
                          <Label className="text-xs">轮换间隔(秒):</Label>
                          <Input
                            type="number"
                            value={rotationInputs[website.id] ?? (website.rotation_interval ?? 180).toString()}
                            className="w-20 h-7 text-xs"
                            disabled={!(rotationEnabled[website.id] ?? (website.rotation_enabled !== 0))}
                            onChange={(e) => {
                              const value = e.target.value
                              setRotationInputs(prev => ({ ...prev, [website.id]: value }))
                            }}
                            onBlur={(e) => {
                              const value = parseInt(rotationInputs[website.id] ?? (website.rotation_interval ?? 180).toString())
                              if (value > 0 && value !== website.rotation_interval) {
                                handleUpdateRotation(website.id, value)
                              } else if (value <= 0) {
                                toast.error('轮换间隔必须大于0秒')
                                setRotationInputs(prev => ({ ...prev, [website.id]: (website.rotation_interval ?? 180).toString() }))
                              }
                            }}
                          />
                          <span className="text-xs text-muted-foreground">
                            ({(() => {
                              const v = parseInt(rotationInputs[website.id] ?? (website.rotation_interval ?? 180).toString())
                              const sec = Number.isFinite(v) ? v : (website.rotation_interval ?? 180)
                              return `${Math.floor(sec / 60)}分${sec % 60}秒`
                            })()})
                          </span>
                        </div>

                        {/* 状态说明 */}
                        <div className="text-xs text-muted-foreground">
                          {(rotationEnabled[website.id] ?? (website.rotation_enabled !== 0))
                            ? '轮换已启用，将在账号间自动切换'
                            : '轮换已禁用，将使用固定账号发送'
                          }
                        </div>
                      </div>
                    )}

                    {/* 消息过滤规则 */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Settings className="w-4 h-4" />
                        <span className="text-sm font-medium">消息过滤</span>
                        <Dialog open={showAddWebsiteFilter === website.id} onOpenChange={(open) => {
                          setShowAddWebsiteFilter(open ? website.id : null)
                          if (!open) setNewFilter({ filter_type: 'contains', filter_value: '' })
                        }}>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Plus className="w-3 h-3 mr-1" />
                              添加规则
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>添加过滤规则</DialogTitle>
                              <DialogDescription>为网站设置特定的消息过滤规则</DialogDescription>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <Label>过滤类型</Label>
                                <Select value={newFilter.filter_type} onValueChange={value => setNewFilter(prev => ({ ...prev, filter_type: value }))}>
                                  <SelectTrigger>
                                    <SelectValue />
                                  </SelectTrigger>
                                  <SelectContent>
                                    <SelectItem value="contains">包含文本</SelectItem>
                                    <SelectItem value="starts_with">开头是</SelectItem>
                                    <SelectItem value="ends_with">结尾是</SelectItem>
                                    <SelectItem value="regex">正则表达式</SelectItem>
                                    <SelectItem value="user_id">用户ID</SelectItem>
                                  </SelectContent>
                                </Select>
                              </div>
                              <div>
                                <Label>过滤值</Label>
                                <Input
                                  value={newFilter.filter_value}
                                  onChange={e => setNewFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                                  placeholder="输入过滤条件"
                                />
                              </div>
                            </div>
                            <DialogFooter>
                              <Button variant="outline" onClick={() => setShowAddWebsiteFilter(null)}>取消</Button>
                              <Button onClick={() => handleAddFilter(website.id)}>添加</Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </div>

                      <div className="flex flex-wrap gap-2">
                        {(websiteFilters[website.id] || []).map((filter: any, index: number) => (
                          <div key={index} className="flex items-center gap-1 bg-muted rounded px-2 py-1">
                            <Badge variant="outline" className="text-[9px] px-1 py-0 h-4">
                              {filter.filter_type === 'contains' ? '包含' :
                               filter.filter_type === 'starts_with' ? '开头' :
                               filter.filter_type === 'ends_with' ? '结尾' :
                               filter.filter_type === 'regex' ? '正则' : '用户ID'}
                            </Badge>
                            <span className="text-xs truncate max-w-20" title={filter.filter_value}>
                              {filter.filter_value}
                            </span>
                            <Button
                              variant="ghost"
                              size="sm"
                              className="h-4 w-4 p-0"
                              onClick={() => handleRemoveWebsiteFilter(website.id, index)}
                            >
                              <X className="w-3 h-3" />
                            </Button>
                          </div>
                        ))}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        网站特定的过滤规则 (独立于全局规则)
                      </div>
                    </div>

                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 编辑消息过滤对话框 */}
        {editingFilter && (
          <Dialog open={!!editingFilter} onOpenChange={() => setEditingFilter(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>编辑过滤规则</DialogTitle>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>过滤类型</Label>
                  <Select value={editingFilter.filter_type} onValueChange={value => setEditingFilter(prev => ({ ...prev, filter_type: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="contains">包含文本</SelectItem>
                      <SelectItem value="starts_with">开头是</SelectItem>
                      <SelectItem value="ends_with">结尾是</SelectItem>
                      <SelectItem value="regex">正则表达式</SelectItem>
                      <SelectItem value="user_id">用户ID</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label>过滤值</Label>
                  <Input
                    value={editingFilter.filter_value}
                    onChange={e => setEditingFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                  />
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingFilter(null)}>取消</Button>
                <Button onClick={handleUpdateMessageFilter}>保存修改</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}


        {/* 删除账号确认对话框 */}
        <Dialog open={!!deleteAccountConfirm} onOpenChange={() => setDeleteAccountConfirm(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认删除账号</DialogTitle>
              <DialogDescription>
                确定要删除Discord账号 "{deleteAccountConfirm?.username}" 吗？此操作不可恢复。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setDeleteAccountConfirm(null)}>
                取消
              </Button>
              <Button variant="destructive" onClick={confirmDeleteAccount}>
                确认删除
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/image-search-view.tsx ---
"use client"

import type React from "react"
import { useState, useCallback, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Upload, Search, ExternalLink, Settings, X, Clock, Trash2, Copy } from "lucide-react"
import { toast } from "sonner"

export function ImageSearchView() {
  const [uploadedImage, setUploadedImage] = useState<string | null>(null)
  const [imageUrl, setImageUrl] = useState<string>("")
  const [isSearching, setIsSearching] = useState(false)
  const [searchResults, setSearchResults] = useState<any[]>([])
  const [threshold, setThreshold] = useState(30) // 0-100，默认30% (降低阈值以提高匹配成功率)
  const [maxResults, setMaxResults] = useState(5) // 返回最相似的前N个结果

  // 搜索历史相关状态
  const [searchHistory, setSearchHistory] = useState<any[]>([])
  const [currentPage, setCurrentPage] = useState(1)
  const [totalHistory, setTotalHistory] = useState(0)
  const [hasMoreHistory, setHasMoreHistory] = useState(false)
  const [showClearConfirm, setShowClearConfirm] = useState(false)

  // 加载搜索历史
  useEffect(() => {
    fetchSearchHistory()
  }, [])

  const fetchSearchHistory = async (page: number = 1) => {
    try {
      const limit = 10 // 每页显示10条记录
      const offset = (page - 1) * limit
      const response = await fetch(`/api/search_history?limit=${limit}&offset=${offset}`)
      if (response.ok) {
        const result = await response.json()
        setSearchHistory(result.history || [])
        setTotalHistory(result.total || 0)
        setHasMoreHistory(result.has_more || false)
        setCurrentPage(page)
      }
    } catch (error) {
      console.error('Failed to fetch search history:', error)
    }
  }

  // 删除单条搜索历史
  const handleDeleteHistory = async (historyId: number) => {
    try {
      const response = await fetch(`/api/search_history/${historyId}`, {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory(prev => prev.filter(h => h.id !== historyId))
        setTotalHistory(prev => prev - 1)
        toast.success('搜索记录已删除')
      } else {
        toast.error('删除失败')
      }
    } catch (error) {
      console.error('Failed to delete history:', error)
      toast.error('删除失败')
    }
  }

  // 清空所有搜索历史
  const handleClearAllHistory = () => {
    setShowClearConfirm(true)
  }

  const confirmClearAllHistory = async () => {
    setShowClearConfirm(false)
    try {
      const response = await fetch('/api/search_history', {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory([])
        setTotalHistory(0)
        toast.success('所有搜索记录已清空')
      } else {
        toast.error('清空失败')
      }
    } catch (error) {
      console.error('Failed to clear history:', error)
      toast.error('清空失败')
    }
  }

  const handleFileUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("请上传图片文件")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      setUploadedImage(event.target?.result as string)
      // 清空链接输入
      setImageUrl("")
      toast.success("图片已上传")
    }
    reader.readAsDataURL(file)
  }, [])

  const handleClearImage = () => {
    setUploadedImage(null)
  }

  const handleSearch = async () => {
    if (!uploadedImage && !imageUrl.trim()) {
      toast.error("请上传图片或输入图片链接")
      return
    }

    setIsSearching(true)

    try {
      // 创建FormData
      const formData = new FormData();

      if (uploadedImage) {
        // 将base64图片转换为blob
        try {
          const base64Data = uploadedImage.split(',')[1]; // 去掉data:image/jpeg;base64,前缀
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: 'image/jpeg' });
        formData.append('image', blob, 'search.jpg');
        console.log('使用上传的图片进行搜索');
        } catch (error) {
          console.error('图片转换失败:', error);
          toast.error('图片处理失败，请重试');
          setIsSearching(false);
          return;
        }
      } else if (imageUrl.trim()) {
        // 发送图片URL
        formData.append('image_url', imageUrl.trim());
        console.log('使用图片链接进行搜索:', imageUrl.trim());
      }

      formData.append('threshold', (threshold / 100).toString()); // 转换为0-1
      formData.append('limit', maxResults.toString()); // 返回结果数量

      // 发送到后端进行向量搜索
      const searchRes = await fetch('/api/search_similar', {
        method: 'POST',
        body: formData
      });

      if (searchRes.ok) {
        const result = await searchRes.json();
        if (result.success && result.results && result.results.length > 0) {
          // 设置搜索结果
          setSearchResults(result.results)
          // 重新加载搜索历史（新记录已保存到数据库）
          await fetchSearchHistory()
          toast.success(`找到 ${result.results.length} 个相似商品，最佳相似度 ${(result.results[0].similarity * 100).toFixed(1)}%`);
        } else {
          setSearchResults([])
          toast.info(result.message || "未找到相似商品");
        }
      } else {
        const errorText = await searchRes.text();
        console.error('Search failed:', errorText);
        toast.error("搜索失败");
      }
    } catch (error) {
      console.error('Search error:', error);
      toast.error("搜索过程中发生错误");
    } finally {
      setIsSearching(false);
    }
  }




  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">以图搜图</h2>
        <p className="text-muted-foreground">上传图片，测试向量搜索功能并获取 CNFans 链接</p>
      </div>

      <div className="grid gap-6 lg:grid-cols-1">
        <Card>
          <CardHeader>
            <CardTitle>上传图片或输入链接进行搜索</CardTitle>
            <CardDescription>支持 JPG、PNG、WebP 格式，可上传图片文件或输入图片链接进行向量搜索</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex gap-6">
              {/* 左侧：图片输入区域 */}
              <div className="flex-1 space-y-4">
                {/* 图片上传区域 */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">上传图片</label>
                  <div className="space-y-3">
                    {!uploadedImage ? (
                      <label
                        htmlFor="image-upload"
                        className={`flex flex-col items-center justify-center h-48 border-2 border-dashed rounded-lg cursor-pointer transition-colors ${
                          imageUrl.trim()
                            ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50'
                            : 'border-muted-foreground/25 hover:border-muted-foreground/50'
                        }`}
                      >
                        <Upload className="size-12 text-muted-foreground mb-2" />
                        <input
                          id="image-upload"
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={handleFileUpload}
                          disabled={!!imageUrl.trim()}
                        />
                      </label>
                    ) : (
                      <div className="relative">
                        <img
                          src={uploadedImage || "/placeholder.svg"}
                          alt="Uploaded"
                          className="w-full h-48 object-contain rounded-lg border"
                        />
                        <Button
                          variant="destructive"
                          size="icon"
                          className="absolute top-2 right-2 w-8 h-8"
                          onClick={handleClearImage}
                        >
                          <X className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>

                {/* 图片链接输入 */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">图片链接</label>
                  <input
                    type="url"
                    value={imageUrl}
                    onChange={(e) => {
                      setImageUrl(e.target.value)
                      // 当输入链接时，清空已上传的图片
                      if (e.target.value.trim()) {
                        setUploadedImage(null)
                      }
                    }}
                    placeholder="输入图片链接 (https://...)"
                    className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                      uploadedImage ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50' : 'border-gray-300'
                    }`}
                    disabled={!!uploadedImage}
                  />
                  {imageUrl && !uploadedImage && (
                    <div className="flex items-center gap-2">
                      <img
                        src={imageUrl}
                        alt="Preview"
                        className="w-16 h-16 object-cover rounded border"
                        onError={(e) => {
                          e.currentTarget.style.display = 'none';
                        }}
                      />
                      <span className="text-sm text-muted-foreground">图片预览</span>
                    </div>
                  )}
                  {uploadedImage && (
                    <p className="text-xs text-muted-foreground">已上传图片，无法输入链接</p>
                  )}
                </div>
              </div>

              {/* 右侧：搜索设置 */}
              <div className="w-80 space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">相似度阈值</label>
                    <span className="text-sm text-muted-foreground">{threshold}%</span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="1"
                    value={threshold}
                    onChange={(e) => setThreshold(Number.parseInt(e.target.value))}
                    className="w-full"
                  />
                  <p className="text-xs text-muted-foreground">只显示相似度超过此阈值的商品 (0-100%)</p>
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">返回结果数量</label>
                    <span className="text-sm text-muted-foreground">{maxResults}个</span>
                  </div>
                  <select
                    value={maxResults}
                    onChange={(e) => setMaxResults(Number.parseInt(e.target.value))}
                    className="w-full px-3 py-2 border border-input rounded-md bg-background text-sm"
                  >
                    <option value={1}>1个</option>
                    <option value={3}>3个</option>
                    <option value={5}>5个</option>
                    <option value={10}>10个</option>
                    <option value={20}>20个</option>
                  </select>
                  <p className="text-xs text-muted-foreground">返回最相似的前N个结果进行筛选</p>
                </div>

                <Button
                  className="w-full"
                  onClick={handleSearch}
                  disabled={(!uploadedImage && !imageUrl.trim()) || isSearching}
                >
                  <Search className="w-4 h-4 mr-2" />
                  {isSearching ? "搜索中..." : "开始搜索"}
                </Button>

                {isSearching && (
                  <div className="flex items-center justify-center py-4">
                    <div className="text-center space-y-2">
                      <div className="animate-spin size-6 border-4 border-primary border-t-transparent rounded-full mx-auto" />
                      <p className="text-xs text-muted-foreground">正在匹配向量...</p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* 搜索结果 */}
        {searchResults && searchResults.length > 0 && (
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-lg flex items-center gap-2">
                    <Search className="w-5 h-5" />
                    搜索结果
                  </CardTitle>
                  <CardDescription>
                    找到 {searchResults.length} 个相似商品，按相似度排序
                  </CardDescription>
                </div>
                <div className="flex items-center gap-3">
                </div>
              </div>
            </CardHeader>
            <CardContent className="pt-0">
              <div className="space-y-4">
                {searchResults.map((result, index) => (
                  <div key={index} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* 匹配图片和基本信息 */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* 匹配的商品图片 */}
                      <div className="flex-shrink-0">
                        <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                          <img
                            src={result.matchedImage}
                            alt={result.product.title}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              e.currentTarget.src = '/placeholder.jpg'
                            }}
                          />
                        </div>
                      </div>

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{result.product.title}</h4>
                          <Badge
                            className={
                              result.similarity >= 0.95
                                ? "bg-green-600 hover:bg-green-700"
                                : result.similarity >= 0.85
                                ? "bg-blue-600 hover:bg-blue-700"
                                : "bg-yellow-600 hover:bg-yellow-700"
                            }
                          >
                            {(result.similarity * 100).toFixed(1)}% 相似度
                          </Badge>
                        </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{result.product.englishTitle || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {result.product.weidianUrl?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>排名: #{result.rank}</span>
                          <span>|</span>
                          <span>搜索时间: {new Date().toLocaleString('zh-CN')}</span>
                        </div>
                      </div>
                    </div>

                    {/* 网站链接网格显示区域 */}
                    <div className="w-full">
                      <div className="grid grid-cols-2 gap-1 max-w-md">
                        {(result.product.websiteUrls || []).slice(0, 8).map((site: any, index: number) => (
                          <div key={index} className="flex items-center gap-1">
                            <Badge
                              className="text-[8px] px-1 py-0 h-3 border-none min-w-[40px] justify-center shrink-0 text-white"
                              style={{ backgroundColor: site.badge_color || '#6b7280' }}
                            >
                              {site.display_name}
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-1.5 rounded border text-[9px] flex items-center justify-between overflow-hidden min-w-0">
                              <a
                                href={site.url}
                                target="_blank"
                                className="truncate hover:underline"
                                style={{ color: site.badge_color || '#6b7280' }}
                              >
                                {site.url}
                              </a>
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-3 w-3 shrink-0"
                                onClick={() => {
                                  navigator.clipboard.writeText(site.url)
                                  toast.success("已复制链接")
                                }}
                              >
                                <Copy className="h-2 w-2"/>
                              </Button>
                            </div>
                          </div>
                        ))}
                      </div>
                      {(result.product.websiteUrls || []).length > 8 && (
                        <div className="mt-2 text-xs text-muted-foreground">
                          还有 {(result.product.websiteUrls || []).length - 8} 个网站链接...
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* 搜索历史 - 列表形式 */}
        <Card>
          <CardHeader className="pb-4">
            <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
              <div>
                <CardTitle className="text-lg">搜索记录</CardTitle>
                <CardDescription>历史搜索结果，按时间倒序排列</CardDescription>
              </div>
              {searchHistory.length > 0 && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleClearAllHistory}
                  className="shrink-0"
                >
                  <Trash2 className="w-4 h-4 mr-1" />
                  清空历史
                </Button>
              )}
            </div>
          </CardHeader>
          <CardContent className="pt-0">
            {searchHistory.length === 0 ? (
              <div className="text-center py-12 text-muted-foreground">
                <Search className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>暂无搜索记录</p>
                <p className="text-sm">上传图片并搜索后，结果将显示在这里</p>
              </div>
            ) : (
              <div className="space-y-3">
                {searchHistory.map((history) => (
                  <div key={history.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* 匹配图片和基本信息 */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* 匹配的商品图片 */}
                      {history.matched_product_id && (
                        <div className="flex-shrink-0">
                          <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                            <img
                              src={`/api/image/${history.matched_product_id}/${history.matched_image_index}`}
                              alt="匹配的商品图片"
                              className="w-full h-full object-cover"
                              onError={(e) => {
                                e.currentTarget.src = '/placeholder.jpg'
                              }}
                            />
                          </div>
                        </div>
                      )}

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{history.title}</h4>
                            <Badge
                              className={
                                history.similarity >= 0.95
                                  ? "bg-green-600 hover:bg-green-700"
                                  : history.similarity >= 0.85
                                  ? "bg-blue-600 hover:bg-blue-700"
                                  : "bg-yellow-600 hover:bg-yellow-700"
                              }
                            >
                              {(history.similarity * 100).toFixed(1)}% 相似度
                            </Badge>
                          </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{history.english_title || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {history.weidian_url?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>匹配图片: #{history.matched_image_index}</span>
                          <span>|</span>
                          <span>阈值: {history.threshold * 100}%</span>
                          <span>|</span>
                          <span>搜索时间: {new Date(history.search_time).toLocaleString('zh-CN')}</span>
                        </div>
                              </div>
                            </div>

                    {/* 链接显示区域 */}
                    <div className="flex items-center gap-4">
                      <div className="flex flex-col gap-1 min-w-[300px]">
                        <div className="flex items-center gap-1.5">
                          <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-gray-600">
                            微店
                          </Badge>
                          <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                            <a href={history.weidian_url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">
                              {history.weidian_url}
                            </a>
                            <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.weidian_url); toast.success("Copied")}}>
                              <Copy className="h-2.5 w-2.5"/>
                            </Button>
                          </div>
                        </div>
                        {history.cnfans_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-blue-600">
                              CNFans
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.cnfans_url} target="_blank" className="font-mono truncate hover:underline text-blue-500">
                                {history.cnfans_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.cnfans_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                        {history.acbuy_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-purple-600">
                              ACBuy
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.acbuy_url} target="_blank" className="font-mono truncate hover:underline text-purple-500">
                                {history.acbuy_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.acbuy_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                      </div>

                      {/* 删除按钮 */}
                        <Button
                        variant="outline"
                          size="icon"
                        className="h-8 w-8 hover:bg-red-50 hover:text-red-600"
                          onClick={() => handleDeleteHistory(history.id)}
                        >
                        <X className="size-3.5" />
                        </Button>
                    </div>
                  </div>
                ))}

                {/* 分页控件 */}
                {searchHistory.length > 0 && (
                  <div className="flex flex-col sm:flex-row justify-between items-center gap-4 pt-4 border-t mt-4">
                    <div className="text-sm text-muted-foreground font-medium">
                      显示第 {((currentPage - 1) * 10) + 1} - {Math.min(currentPage * 10, totalHistory)} 条，共 {totalHistory} 条记录
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage - 1)}
                        disabled={currentPage <= 1}
                        className="h-8 px-3"
                      >
                        上一页
                      </Button>
                      <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                        {currentPage}
                      </div>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage + 1)}
                        disabled={!hasMoreHistory || searchHistory.length === 0}
                        className="h-8 px-3"
                      >
                        下一页
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* 清空历史确认对话框 */}
        <Dialog open={showClearConfirm} onOpenChange={setShowClearConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认清空历史</DialogTitle>
              <DialogDescription>
                确定要清空所有搜索记录吗？此操作不可撤销。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowClearConfirm(false)}>
                取消
              </Button>
              <Button variant="destructive" onClick={confirmClearAllHistory}>
                确认清空
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/scraper-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Copy, ChevronLeft, ChevronRight, Trash2, ImageIcon, Edit, X, Download, Loader2, List, Upload, Store, CheckSquare, Square, Search, ChevronDown, ChevronUp, Pause, Play, StopCircle } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { Checkbox } from "@/components/ui/checkbox"

export function ScraperView({ currentUser }: { currentUser: any }) {
  const [batchIds, setBatchIds] = useState('')
  const [isBatchScraping, setIsBatchScraping] = useState(false)
  const [batchProgress, setBatchProgress] = useState(0)
  const [products, setProducts] = useState<any[]>([])
  const [totalProducts, setTotalProducts] = useState(0)
  const [currentPage, setCurrentPage] = useState(1)
  const [jumpPage, setJumpPage] = useState("")
  const [itemsPerPage, setItemsPerPage] = useState(50)
  const [editingProduct, setEditingProduct] = useState<any>(null)
  const [selectedProducts, setSelectedProducts] = useState<number[]>([])
  const [selectAll, setSelectAll] = useState(false)
  const [indexedIds, setIndexedIds] = useState<string[]>([])
  const [shopFilter, setShopFilter] = useState('__ALL__')
  const [keywordSearch, setKeywordSearch] = useState('')
  const [isDeleting, setIsDeleting] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [deletingProductId, setDeletingProductId] = useState<number | null>(null)
  // 图片上传 ref
  const uploadInputRef = useRef<HTMLInputElement>(null)
  const [isUploadingImg, setIsUploadingImg] = useState(false)
  const [productUrls, setProductUrls] = useState<{[key: number]: any[]}>({})
  const [expandedProducts, setExpandedProducts] = useState<Set<number>>(new Set())
  const [selectedFiles, setSelectedFiles] = useState<FileList | null>(null)
  const [batchUploading, setBatchUploading] = useState(false)

  // 使用API缓存hook
  const { cachedFetch, invalidateCache } = useApiCache()

  // 抓取相关状态
  const [shopId, setShopId] = useState('')
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [shopScrapeProgress, setShopScrapeProgress] = useState(0)
  const [scrapeStatus, setScrapeStatus] = useState<any>(null)
  const [availableShops, setAvailableShops] = useState<any[]>([])
  const [selectedShopId, setSelectedShopId] = useState('')
  const [totalProductsCount, setTotalProductsCount] = useState(0)
  // 搜索类型状态
  const [searchType, setSearchType] = useState<'all' | 'id' | 'keyword' | 'chinese'>('all')

  // 优化：分离不同类型的加载逻辑
  useEffect(() => {
    fetchIndexedIds()
    fetchAvailableShops()
    fetchProductsCount()
    fetchScrapeStatus() // 初始化时检查抓取状态，恢复进度显示
  }, []) // 静态数据只加载一次

  // 监听店铺更新事件，实时刷新店铺列表
  useEffect(() => {
    const handleShopsUpdated = () => {
      // 清除店铺缓存并重新获取
      invalidateCache('/api/shops')
      fetchAvailableShops()
    }
    window.addEventListener('shops-updated', handleShopsUpdated)
    return () => window.removeEventListener('shops-updated', handleShopsUpdated)
  }, [invalidateCache])

  useEffect(() => {
    fetchProducts(currentPage)
  }, [currentPage, itemsPerPage, keywordSearch, shopFilter]) // 只在相关参数改变时重新加载商品

  useEffect(() => {
    // 当搜索条件改变时，重置到第一页
    if (keywordSearch || shopFilter) {
      setCurrentPage(1)
    }
  }, [keywordSearch, shopFilter])

  // 优化轮询机制：使用智能轮询，避免重复请求
  useEffect(() => {
    let statusInterval: NodeJS.Timeout | null = null

    // 如果没有抓取任务，减少轮询频率到60秒一次
    if (!isShopScraping && !isBatchScraping) {
      statusInterval = setInterval(() => {
        fetchScrapeStatus()
      }, 60000) // 60秒检查一次状态

      return () => {
        if (statusInterval) clearInterval(statusInterval)
      }
    }

    // 如果有抓取任务，使用更智能的轮询策略
    let pollCount = 0
    statusInterval = setInterval(() => {
      pollCount++

      // 总是检查抓取状态
      fetchScrapeStatus()

      // 只有在抓取进行中时才检查商品数量和列表
      // 前30秒（15次）每2秒检查一次，后续每10秒检查一次
      if ((isShopScraping || isBatchScraping)) {
        if (pollCount <= 15) {
          fetchProductsCount()
          fetchProducts(currentPage)
        } else if (pollCount % 5 === 0) {
          // 每10秒检查一次商品数量和列表
          fetchProductsCount()
          fetchProducts(currentPage)
        }
      }
    }, 2000) // 基础间隔2秒

    return () => {
      if (statusInterval) {
        clearInterval(statusInterval)
      }
    }
  }, [isShopScraping, isBatchScraping])

  const fetchProducts = async (page: number = 1, append: boolean = false, usePreload: boolean = true) => {
    try {
      // 首先检查是否有预加载数据（只在第一次加载且未追加时）
      if (page === 1 && !append && usePreload) {
        const preloadData = sessionStorage.getItem('preload_products')
        if (preloadData) {
          try {
            console.log('使用预加载商品数据')
            const data = JSON.parse(preloadData)
            // 使用预加载数据
            const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
              ...product,
              id: product.id,
              shopName: product.shopName || product.shop_name || '未知店铺',
              title: product.title || '',
              englishTitle: product.englishTitle || product.english_title || '',
              weidianUrl: product.weidianUrl || product.product_url || '',
              cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
              acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
              weidianId: product.weidianId || '',
              ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
              customReplyText: product.customReplyText || product.custom_reply_text || '',
              customReplyImages: product.customReplyImages || product.custom_reply_images || [],
              selectedImageIndexes: product.selectedImageIndexes || [],
              customImageUrls: product.customImageUrls || product.custom_image_urls || [],
              imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload')
            }))

            setProducts(processedProducts)
            setTotalProducts(data.total || 0)

            // 清除预加载数据，避免重复使用
            sessionStorage.removeItem('preload_products')

            // 在后台获取最新数据，但不显示加载状态
            setTimeout(() => fetchProducts(1, false, false), 500)
            return
          } catch (e) {
            console.error('预加载数据解析失败:', e)
            // 预加载数据损坏，清除并重新获取
            sessionStorage.removeItem('preload_products')
          }
        } else {
          // 如果没有预加载数据，等待一下再试（给预加载一点时间）
          if (page === 1 && !append) {
            setTimeout(() => {
              const retryPreload = sessionStorage.getItem('preload_products')
              if (retryPreload) {
                fetchProducts(1, false, true)
              } else {
                fetchProducts(1, false, false)
              }
            }, 200)
            return
          }
        }
      }

      console.log('从API获取商品数据')
      const res = await fetch(`/api/products?page=${page}&limit=${itemsPerPage}`)
      const data = await res.json()

      // 调试信息
      console.log('商品列表API响应:', {
        page,
        total: data.total,
        productsCount: data.products?.length || 0,
        debug: data.debug,
        firstProduct: data.products?.[0] ? {
          id: data.products[0].id,
          shopName: data.products[0].shopName || data.products[0].shop_name,
          title: data.products[0].title
        } : null
      })

      const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
        ...product,
        id: product.id,
        shopName: product.shopName || product.shop_name || '未知店铺',
        title: product.title || '',
        englishTitle: product.englishTitle || product.english_title || '',
        weidianUrl: product.weidianUrl || product.product_url || '',
        cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
        acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
        weidianId: product.weidianId || '',
        ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
        customReplyText: product.customReplyText || product.custom_reply_text || '',
        customReplyImages: product.customReplyImages || product.custom_reply_images || [],
        selectedImageIndexes: product.selectedImageIndexes || [],
        customImageUrls: product.customImageUrls || product.custom_image_urls || [],
        imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload'),
        uploadedImages: [], // 新上传的File对象（用户刚选择的）
        existingUploadedImageUrls: product.uploadedImages || [] // 已保存的图片URL（从后端加载）
      }))

      if (append) {
        // 分页加载更多
        setProducts(prev => [...prev, ...processedProducts])
      } else {
        // 重新加载第一页
        setProducts(processedProducts)
      }

      setTotalProducts(data.total || 0)
    } catch (e) {
      toast.error("加载商品库失败")
    }
  }

  const fetchIndexedIds = async () => {
    try {
      const data = await cachedFetch('/api/scrape?type=indexed', { credentials: 'include' })
      setIndexedIds(data.indexedIds || [])
    } catch (e) {
      console.error('获取已索引ID失败:', e)
    }
  }

  const fetchAvailableShops = async () => {
    try {
      const data = await cachedFetch('/api/shops')
      setAvailableShops(data.shops || [])
    } catch (e) {
      console.error('获取店铺列表失败:', e)
    }
  }

  const fetchProductsCount = async () => {
    try {
      const data = await cachedFetch('/api/products/count')
      setTotalProductsCount(data.count || 0)
    } catch (e) {
      console.error('获取商品数量失败:', e)
    }
  }

  const fetchScrapeStatus = async () => {
    try {
      const res = await fetch('/api/scrape/shop/status')
      if (res.ok) {
        const text = await res.text()
        if (text.trim()) {
          const status = JSON.parse(text)
          console.log('店铺抓取状态更新:', status)
          setScrapeStatus(status)
          setIsShopScraping(status.is_scraping)
          setShopScrapeProgress(status.progress || 0)
          // 如果抓取完成，刷新商品列表
          if (!status.is_scraping && status.completed) {
            fetchProducts()
            fetchProductsCount()
          }
        }
      }
    } catch (e) {
      console.error('获取抓取状态失败:', e)
      // 静默失败
    }
  }

  // === 链接生成逻辑 ===

  const getProductLinks = (product: any) => {
    const links = [
        { name: 'cnfans', display_name: 'CNFans', url: product.cnfansUrl, badge_color: 'blue' },
        { name: 'weidian', display_name: '微店', url: product.weidianUrl, badge_color: 'gray' },
        { name: 'acbuy', display_name: 'AcBuy', url: product.acbuyUrl, badge_color: 'orange' }
    ].filter(link => link.url && link.url.trim() !== '');

    // 如果有从后端获取的额外链接，可以合并（这里简化处理，只用上面的）
    return links;
  }

  // ... (保留 handleBatchDelete, confirmBatchDelete, handleUploadImage, handleBatchUploadImages) ...

  const handleBatchDelete = async () => {
    console.log('批量删除按钮被点击，选中商品数量:', selectedProducts.length)
    if (selectedProducts.length === 0) {
      console.log('没有选中商品，返回')
      return
    }
    console.log('设置显示确认对话框')
    setShowDeleteConfirm(true)
  }

  const confirmBatchDelete = async () => {
    setShowDeleteConfirm(false)
    setIsDeleting(true)
    try {
      const res = await fetch(`/api/products?ids=${selectedProducts.join(',')}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success("批量删除成功")
        setProducts(products.filter(p => !selectedProducts.includes(p.id)))
        setSelectedProducts([])
      } else {
        toast.error("批量删除失败")
      }
    } catch (e) {
      toast.error("网络错误")
    } finally {
      setIsDeleting(false)
    }
  }

  const handleUploadImage = async (productId: number, file: File) => {
    if (!file) return
    setIsUploadingImg(true)
    const formData = new FormData()
    formData.append('image', file)
    try {
      const res = await fetch(`/api/products/${productId}/images`, {
        method: 'POST',
        body: formData
      })
      if (res.ok) {
        const data = await res.json()
        setProducts(products.map(p => p.id === productId ? data.product : p))
        toast.success("图片上传成功")
      } else {
        toast.error("上传失败")
      }
    } catch (e) {
      toast.error("上传出错")
    } finally {
      setIsUploadingImg(false)
    }
  }

  const handleBatchUploadImages = async (productId: number, files?: FileList | null) => {
    const filesToUpload = files || selectedFiles
    if (!filesToUpload || filesToUpload.length === 0) return
    setBatchUploading(true)
    let successCount = 0
    try {
      for (let i = 0; i < filesToUpload.length; i++) {
        const file = filesToUpload[i]
        const formData = new FormData()
        formData.append('image', file)
          const res = await fetch(`/api/products/${productId}/images`, {
            method: 'POST',
          body: formData
          })
        if (res.ok) successCount++
      }
      if (successCount > 0) {
        const productRes = await fetch(`/api/products/${productId}`) // Fix: fetch specific product if endpoint exists, else refresh all or return from API
        // Refresh products for simplicity
        fetchProducts();
      }
      toast.success(`上传完成：${successCount}张图片`)
      setSelectedFiles(null)
    } catch (e) {
      toast.error('批量上传错误')
    } finally {
      setBatchUploading(false)
    }
  }

  const handleSelectAll = () => {
    if (selectedProducts.length === currentProducts.length && currentProducts.length > 0) {
      setSelectedProducts([])
    } else {
      setSelectedProducts(currentProducts.map(p => p.id))
    }
  }

  const toggleProductExpansion = (productId: number) => {
    setExpandedProducts(prev => {
      const newSet = new Set(prev)
      if (newSet.has(productId)) newSet.delete(productId)
      else newSet.add(productId)
      return newSet
    })
  }

  const handleDeleteProduct = async (id: number) => {
    setDeletingProductId(id)
    setShowDeleteConfirm(true)
  }

  const confirmDeleteProduct = async () => {
    if (!deletingProductId) return

    setShowDeleteConfirm(false)

    // 显示删除进度提示
    toast.loading("正在删除商品...", { id: `delete-${deletingProductId}` })

    try {
      const response = await fetch(`/api/products/${deletingProductId}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        setProducts(products.filter(p => p.id !== deletingProductId))
        setTotalProducts(totalProducts - 1)
        setSelectedProducts(selectedProducts.filter(pid => pid !== deletingProductId))
        toast.success("删除成功", { id: `delete-${deletingProductId}` })
      } else {
        toast.error("删除失败", { id: `delete-${deletingProductId}` })
      }
    } catch (e) {
      toast.error("删除失败", { id: `delete-${deletingProductId}` })
    } finally {
      setDeletingProductId(null)
    }
  }

  const handleUpdateProduct = async (updatedProduct: any) => {
    try {
      let res;

      // 检查是否有上传的图片文件或已保存的图片URL
      const hasNewUploads = updatedProduct.uploadedImages && updatedProduct.uploadedImages.length > 0;
      const hasExistingUploads = updatedProduct.existingUploadedImageUrls && updatedProduct.existingUploadedImageUrls.length > 0;

      if (hasNewUploads || hasExistingUploads) {
        // 使用FormData发送文件和已有图片信息
        const formData = new FormData();

        // 添加基本数据
        formData.append('id', updatedProduct.id.toString());
        if (updatedProduct.title) formData.append('title', updatedProduct.title);
        if (updatedProduct.englishTitle) formData.append('englishTitle', updatedProduct.englishTitle);
        if (updatedProduct.ruleEnabled !== undefined) formData.append('ruleEnabled', updatedProduct.ruleEnabled.toString());
        if (updatedProduct.customReplyText) formData.append('customReplyText', updatedProduct.customReplyText);
        if (updatedProduct.imageSource) formData.append('imageSource', updatedProduct.imageSource);

        // 添加数组数据（序列化为JSON）
        if (updatedProduct.selectedImageIndexes) {
          formData.append('selectedImageIndexes', JSON.stringify(updatedProduct.selectedImageIndexes));
        }
        if (updatedProduct.customImageUrls) {
          formData.append('customImageUrls', JSON.stringify(updatedProduct.customImageUrls));
        }

        // 添加要保留的已有上传图片URL列表
        if (hasExistingUploads) {
          formData.append('existingUploadedImageUrls', JSON.stringify(updatedProduct.existingUploadedImageUrls));
        }

        // 添加新上传的文件
        if (hasNewUploads) {
          updatedProduct.uploadedImages.forEach((file: File, index: number) => {
            formData.append('uploadedImages', file);
          });
        }

        res = await fetch('/api/products', {
          method: 'PUT',
          credentials: 'include',
          body: formData
        });
      } else {
        // 使用JSON发送普通数据
        res = await fetch('/api/products', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(updatedProduct)
        });
      }

      if (res.ok) {
        const data = await res.json()

        // 转换后端返回的数据格式，将 uploadedImages (URL数组) 转换为 existingUploadedImageUrls
        const transformedProduct = {
          ...data.product,
          uploadedImages: [], // 新上传的File对象（清空）
          existingUploadedImageUrls: data.product.uploadedImages || [] // 已保存的图片URL
        }

        setProducts(products.map(p => p.id === data.product.id ? transformedProduct : p))
        setEditingProduct(null)
        toast.success("更新成功")
      } else {
        const errorData = await res.json().catch(() => ({}));
        toast.error(errorData.error || "更新失败")
      }
    } catch (e) {
      console.error('Update error:', e);
      toast.error("更新失败")
    }
  }


  // ... (保留 handleScrapeShop, handleBatchScrape, handleJumpPage) ...

  const handleScrapeControl = async (action: 'stop') => {
    try {
      console.log(`🎮 发送抓取控制请求: action=${action}`)
      const response = await fetch('/api/scrape/shop/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action
        })
      })

      if (response.ok) {
        const result = await response.json()
        console.log(`🎮 控制API响应内容:`, result)

        if (action === 'stop') {
          // 立即更新本地状态
          setIsShopScraping(false)
          setShopScrapeProgress(100)
          toast.success('抓取已停止')

          // 重新获取状态确认
          setTimeout(() => {
            fetchScrapeStatus()
            fetchProductsCount()
            fetchProducts(currentPage)
          }, 1000)
        }
      } else {
        const errorText = await response.text()
        console.error(`控制API错误响应:`, errorText)
        try {
          const errorData = JSON.parse(errorText)
          toast.error(errorData.error || `操作失败: ${action}`)
        } catch {
          toast.error(`操作失败: ${action}`)
        }
      }
    } catch (error) {
      console.error(`控制请求异常:`, error)
      toast.error(`操作失败: ${action}`)
    }
  }

  const handleScrapeShop = async () => {
    if (!selectedShopId) {
      toast.error("请选择要抓取的店铺")
      return
    }

    // ==========================================
    // 修复：立即设置加载状态，防止UI闪烁
    // ==========================================
    setIsShopScraping(true)
    setShopScrapeProgress(0)
    setScrapeStatus((prev: any) => ({
       ...prev,
       message: '正在发送抓取请求...'
    }))

    try {
      const response = await fetch('/api/scrape/shop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shopId: selectedShopId })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success(`抓取指令已发送`)
        // 不需要在这里 setProducts，因为轮询会自动更新
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || "请求被拒绝")

        // 只有请求失败时，才把状态改回去
        setIsShopScraping(false)
      }
    } catch (error: any) {
      toast.error("网络错误，无法连接服务器")
      setIsShopScraping(false)
    }
    // 注意：这里不要加 finally { setIsShopScraping(false) }
    // 因为抓取是异步的长任务，请求结束不代表抓取结束。
    // 状态应该由 useEffect 里的轮询来决定何时变回 false。
  }

  const handleBatchScrape = async () => {
    const ids = batchIds.split('\n').map(id => id.trim()).filter(id => id && id.match(/^\d+$/))
    if (ids.length === 0) {
      toast.error("请输入有效的商品ID")
      return
    }

    console.log('开始批量上传，商品数量:', ids.length)
    setIsBatchScraping(true)
    setBatchProgress(0)

    try {
      console.log(`发送批量请求到 /api/scrape/batch，商品数量: ${ids.length}`)

      // 调用新的批量API
      const res = await fetch('/api/scrape/batch', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ productIds: ids }),
        signal: AbortSignal.timeout(300000) // 5分钟超时（批量处理需要更长时间）
      })

      console.log(`收到批量响应，状态码: ${res.status}`)

      if(res.ok) {
        const result = await res.json()
        console.log('批量处理结果:', result)

        // 从结果中提取统计信息
        const results = result.results || {}
        const successCount = results.success || 0
        const skipCount = results.skipped || 0
        const cancelledCount = results.cancelled || 0
        const partialCount = results.partial || 0
        const errorCount = results.errors || 0

        // 构建结果消息
        let messageParts = []
        if (successCount > 0) messageParts.push(`成功 ${successCount}`)
        if (skipCount > 0) messageParts.push(`跳过 ${skipCount}`)
        if (cancelledCount > 0) messageParts.push(`取消 ${cancelledCount}`)
        if (partialCount > 0) messageParts.push(`部分完成 ${partialCount}`)
        if (errorCount > 0) messageParts.push(`失败 ${errorCount}`)

        const message = messageParts.length > 0 ? messageParts.join(', ') : '无结果'

        toast.success(`批量上传完成: ${message}`)
        console.log('批量上传完成')

        // 显示处理时间
        if (results.duration) {
          console.log(`处理时间: ${results.duration.toFixed(2)} 秒`)
        }
      } else {
        const errorText = await res.text()
        console.error('批量上传失败:', res.status, errorText)
        toast.error(`批量上传失败: ${errorText}`)
      }

      setBatchProgress(100)

      // 强制刷新数据
      fetchProducts()
      fetchProductsCount()

      // 强制刷新抓取状态，确保UI正确更新
      setTimeout(() => fetchScrapeStatus(), 100)

      setBatchIds('')
    } catch(e: any) {
      console.error('批量上传出现错误:', e)
      if (e.name === 'TimeoutError') {
        toast.error("批量上传超时，请减少商品数量或稍后重试")
      } else {
        toast.error("批量上传失败")
      }
    } finally {
      console.log('设置 isBatchScraping 为 false')
      setIsBatchScraping(false)
    }
  }

  const handleJumpPage = () => { /* ... */ }

  // 筛选和分页逻辑（简化版，避免一次性加载过多数据）
  const uniqueShops = Array.from(new Set(products.map(p => p?.shopName || '').filter(name => name && name.trim()))).sort()

  // 简化分页：直接使用当前页的产品数据，不再进行复杂的内存筛选
  // 这样可以显著提升加载速度，但暂时不支持跨页搜索
  const currentProducts = products.filter(p => {
    // 只有在没有搜索条件时才显示当前页数据
    if (!keywordSearch && !shopFilter) {
      return true
    }

    // 有搜索条件时，对当前加载的数据进行筛选
    let matchesSearch = true
    if (keywordSearch) {
      if (searchType === 'id') {
        matchesSearch = p.weidianId?.includes(keywordSearch)
      } else if (searchType === 'keyword') {
        matchesSearch = p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else if (searchType === 'chinese') {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.weidianId?.includes(keywordSearch)
      }
    }
    const matchesShop = !shopFilter || shopFilter === "__ALL__" || p.shopName === shopFilter
    return matchesSearch && matchesShop
  })

  // 计算总页数（基于总数）
  const totalPages = Math.ceil(totalProducts / itemsPerPage)

  return (
    <div className="space-y-8">
      {/* ... 顶部标题和管理员/普通用户上传区域 (保持不变) ... */}

      <div>
        <h2 className="text-3xl font-bold tracking-tight">微店抓取</h2>
        <p className="text-muted-foreground">商品管理与抓取</p>
      </div>

      {(currentUser?.role === 'admin' || (currentUser?.shops && currentUser.shops.length > 0)) ? (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
             {/* Shop Scrape Card */}
        <Card className="border-2 border-dashed border-purple-300/50 hover:border-purple-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-purple-100 rounded-xl"><Store className="h-6 w-6 text-purple-600"/></div>
                            <div><h4 className="text-xl font-bold">店铺商品抓取</h4><p className="text-sm text-muted-foreground">输入店铺ID</p></div>
                </div>
                        <div className="space-y-3">
                <div>
                                <Label className="text-sm">选择店铺</Label>
                                <Select value={selectedShopId} onValueChange={setSelectedShopId} disabled={isShopScraping}>
                                    <SelectTrigger className="w-full">
                                        <SelectValue placeholder="请选择要抓取的店铺" />
                                    </SelectTrigger>
                                    <SelectContent>
                                        {availableShops.map((shop) => (
                                            <SelectItem key={shop.shop_id} value={shop.shop_id}>
                                                {shop.name} (ID: {shop.shop_id})
                                            </SelectItem>
                                        ))}
                                    </SelectContent>
                                </Select>
                </div>
                            {!isShopScraping ? (
                              <Button onClick={handleScrapeShop} disabled={!selectedShopId} className="w-full">
                                抓取店铺
                              </Button>
                            ) : (
                              <Button
                                variant="destructive"
                                size="sm"
                                onClick={() => handleScrapeControl('stop')}
                                className="w-full"
                              >
                                <StopCircle className="w-4 h-4 mr-2" />
                                取消抓取
                              </Button>
                            )}

                            {/* Shop Scrape Status - 显示在抓取过程中的状态信息 */}
                            {isShopScraping && scrapeStatus && (
                              <div className="mt-3 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                                <div className="flex items-center gap-2 mb-2">
                                  <Loader2 className="h-4 w-4 animate-spin text-amber-600" />
                                  <span className="text-sm font-medium text-amber-800">
                                    {scrapeStatus.message || '正在处理中...'}
                                  </span>
                                </div>
                                <div className="grid grid-cols-2 gap-2 text-xs">
                                  <div className="text-center">
                                    <div className="font-semibold text-green-700">{scrapeStatus.success || 0}</div>
                                    <div className="text-muted-foreground">成功</div>
                                  </div>
                                  <div className="text-center">
                                    <div className="font-semibold text-red-600">{(scrapeStatus.processed || 0) - (scrapeStatus.success || 0)}</div>
                                    <div className="text-muted-foreground">剩余</div>
                                  </div>
                                </div>
                              </div>
                            )}
              </div>
            </div>
          </CardContent>
        </Card>
             {/* Batch Scrape Card */}
        <Card className="border-2 border-dashed border-green-300/50 hover:border-green-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-green-100 rounded-xl"><List className="h-6 w-6 text-green-600"/></div>
                            <div><h4 className="text-xl font-bold">批量上传</h4><p className="text-sm text-muted-foreground">输入商品ID</p></div>
                </div>
              <div className="space-y-3">
                            <textarea placeholder="每行一个ID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-32 p-4 text-sm border-2 rounded-lg resize-none"/>
                            <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">
                                {isBatchScraping ? "上传中..." : `批量上传`}
                  </Button>
              </div>
            </div>
          </CardContent>
        </Card>
        </div>
      ) : (
          /* User View - 普通用户只能看到批量上传 */
        <div className="max-w-2xl mx-auto">
             <Card className="border-2 border-dashed border-green-300/50">
            <CardContent className="p-8">
                    <div className="space-y-4">
                  <h4 className="text-2xl font-bold mb-2">批量商品上传</h4>
                        <textarea id="batch-ids" placeholder="每行一个ID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-40 p-4 border-2 rounded-lg"/>
                        <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">批量上传</Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Progress Bar - 批量抓取进度 */}
      {isBatchScraping && (
        <div className="space-y-3">
          <Progress value={batchProgress} className="h-3" />
          <p className="text-center text-sm text-muted-foreground">{batchProgress.toFixed(1)}%</p>
        </div>
      )}


      {/* Product List */}
      <div className="space-y-4">
        <Card className="shadow-sm overflow-x-hidden">
            <CardHeader className="py-4 border-b">
                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div className="flex flex-col gap-1">
                        <CardTitle className="text-xl font-bold">
                          商品库{isShopScraping ? ' - 抓取中...' : ''}
                        </CardTitle>
            </div>
                    <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center w-full sm:w-auto">
                        {/* 搜索控件 */}
                        <div className="flex gap-2 flex-1 sm:flex-initial">
                <div className="relative">
                                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                                    placeholder={
                                        searchType === 'id' ? '输入商品ID...' :
                                        searchType === 'keyword' ? '输入英文关键词...' :
                                        searchType === 'chinese' ? '输入中文关键词...' :
                                        '输入商品标题、中文关键词、英文关键词或ID...'
                                    }
                    value={keywordSearch}
                                    onChange={e=>setKeywordSearch(e.target.value)}
                                    className="pl-10 h-9 w-full sm:w-[400px]"
                  />
                </div>
                            <Select value={searchType} onValueChange={(value: 'all' | 'id' | 'keyword' | 'chinese') => setSearchType(value)}>
                                <SelectTrigger className="h-9 w-28">
                                    <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="all">全部</SelectItem>
                                    <SelectItem value="id">按ID</SelectItem>
                                    <SelectItem value="keyword">英文关键词</SelectItem>
                                    <SelectItem value="chinese">中文关键词</SelectItem>
                                </SelectContent>
                            </Select>
                  <Select value={shopFilter} onValueChange={setShopFilter}>
                                <SelectTrigger className="h-9 w-32">
                                    <SelectValue placeholder="全部店铺" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__ALL__">全部店铺</SelectItem>
                                    {uniqueShops.map(s=><SelectItem key={s} value={s}>{s}</SelectItem>)}
                    </SelectContent>
                  </Select>
              <Select value={itemsPerPage.toString()} onValueChange={(v) => {
                setItemsPerPage(parseInt(v))
                setCurrentPage(1)
              }}>
                                <SelectTrigger className="h-9 w-24">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                                    <SelectItem value="20">20个/页</SelectItem>
                                    <SelectItem value="50">50个/页</SelectItem>
                                    <SelectItem value="100">100个/页</SelectItem>
                                    <SelectItem value="200">200个/页</SelectItem>
                </SelectContent>
              </Select>
            </div>
                        {/* 操作按钮 */}
                        <div className="flex items-center gap-3">
                            <Button variant={selectedProducts.length===currentProducts.length && currentProducts.length>0?"secondary":"outline"} size="sm" onClick={handleSelectAll}>
                                {selectedProducts.length===currentProducts.length && currentProducts.length>0 ? <CheckSquare className="mr-2 h-4 w-4"/> : <Square className="mr-2 h-4 w-4"/>} 全选 ({currentProducts.length})
            </Button>
                            {selectedProducts.length > 0 && (
                                <Button variant="destructive" size="sm" onClick={handleBatchDelete} disabled={isDeleting}>
                                    <Trash2 className="mr-2 h-4 w-4" /> 删除 ({selectedProducts.length})
                                </Button>
                            )}
          </div>
              </div>
            </div>
            </CardHeader>
            <CardContent className="p-0">
                {/* 列表 */}
          <div className="divide-y">
                    {currentProducts.map((product) => {
                        const links = getProductLinks(product);
                        const showAllLinks = expandedProducts.has(product.id);
                        const displayedLinks = showAllLinks ? links : links.slice(0, 3);
                        return (
              <div key={product.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                <div className="flex gap-3 items-center">
                                <Checkbox checked={selectedProducts.includes(product.id)} onCheckedChange={(checked)=>{
                                    if(checked) setSelectedProducts([...selectedProducts, product.id])
                                    else setSelectedProducts(selectedProducts.filter(id=>id!==product.id))
                                }}/>
                </div>

                            {/* 图片与基本信息 */}
                <div className="flex gap-3 items-center flex-1">
                                {/* 图片弹窗 (保持原逻辑) */}
                  <Dialog>
                    <DialogTrigger asChild>
                                        <Button variant="ghost" className="size-10 p-0 rounded bg-muted flex items-center justify-center flex-shrink-0 border shadow-sm">
                        {product.images && product.images.length > 0 ? (
                                                <img src={product.images[0]} alt="thumb" className="object-cover w-12 h-12 rounded-md" />
                                            ) : <ImageIcon className="size-4 text-muted-foreground" />}
                      </Button>
                    </DialogTrigger>
                    <DialogContent className="max-w-4xl">
                      <DialogHeader>
                        <DialogTitle className="text-xl">商品图集 - {product.weidianId}</DialogTitle>
                        <div className="flex gap-2 mt-2">
                          <input
                            type="file"
                            accept="image/*"
                            multiple
                            className="hidden"
                            id={`upload-${product.id}`}
                            onChange={(e) => {
                              const files = (e.target as HTMLInputElement).files
                              if (files && files.length > 0) {
                                handleBatchUploadImages(product.id, files)
                              }
                            }}
                          />
                          <label htmlFor={`upload-${product.id}`}>
                            <Button size="sm" disabled={isUploadingImg || batchUploading} asChild>
                              <span className="cursor-pointer">
                                <Upload className="mr-2 h-4 w-4" />
                                {isUploadingImg || batchUploading ? "上传中..." : "添加图片"}
                              </span>
                            </Button>
                          </label>
                        </div>
                      </DialogHeader>
                      <ScrollArea className="max-h-[70vh] mt-4">
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-1">
                          {product.images?.map((img: string, idx: number) => (
                            <div key={img} className="aspect-square rounded-xl border-2 bg-muted overflow-hidden group relative">
                              <img src={img} alt={`Img ${idx}`} className="object-cover w-full h-full transition-transform group-hover:scale-110" />
                              <button
                                                            onClick={async (e) => {
                                                                e.preventDefault()
                                                                e.stopPropagation()
                                                                try {
                                                                    // 从图片URL中提取image_index
                                                                    // URL格式: /api/image/{product_id}/{image_index}
                                                                    const urlParts = img.split('/')
                                                                    const imageIndex = urlParts[urlParts.length - 1] // 获取最后一个部分

                                                                    // 验证imageIndex是否为有效数字
                                                                    if (!imageIndex || isNaN(Number(imageIndex))) {
                                                                        toast.error("无法确定要删除的图片")
                                                                        return
                                                                    }

                                                                    const res = await fetch(`/api/products/${product.id}/images/${imageIndex}`, {
                                                                        method: 'DELETE'
                                  })
                                  if (res.ok) {
                                    const data = await res.json()
                                                                        // 更新产品状态，替换整个产品对象
                                                                        setProducts(prevProducts =>
                                                                            prevProducts.map(p =>
                                                                                p.id === product.id ? { ...data.product } : p
                                                                            )
                                                                        )
                                                                        toast.success("图片已删除")
                                  } else {
                                                                        const errorData = await res.json().catch(() => ({ error: 'Delete failed' }))
                                                                        toast.error(errorData.error || "删除失败")
                                                                        console.error('Delete failed:', errorData)
                                                                    }
                                                                } catch (error) {
                                                                    console.error('Delete image error:', error)
                                                                    toast.error("网络错误，删除失败")
                                  }
                                }}
                                                            className="absolute top-1 right-1 p-1 bg-red-500 rounded-full text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 shadow-lg z-10"
                              >
                                <X className="size-3" />
                              </button>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </DialogContent>
                  </Dialog>
                  <div className="space-y-0.5 min-w-0 flex-1">
                    <div className="flex items-center gap-2">
                                        <h4 className="font-bold text-base truncate">{product.title}</h4>
                                        {/* 已删除这里原本的小编辑按钮 */}
                                        {indexedIds.includes(product.weidianId) && <Badge className="bg-blue-600 text-[10px] h-4 px-2">已索引</Badge>}
                                        {product.ruleEnabled && <Badge className="bg-purple-600 text-[10px] h-4 px-2">规则启用</Badge>}
                    </div>
                    <div className="flex items-center gap-2 mt-1">
                                        <p className="text-sm font-bold text-blue-600 truncate">{product.englishTitle || "No English Title"}</p>
                    </div>
                                    <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                                        <span className="font-mono">ID: {product.weidianId}</span>
                                        <span>|</span>
                                        <span>店铺: {product.shopName}</span>
                                        <span>|</span>
                                        <span>{product.images?.length || 0}张图片</span>
                      {((product.createdAt) || (product.created_at)) && (
                                            <>
                                                <span>|</span>
                                                <span>创建: {(() => {
                          try {
                            const date = new Date(product.createdAt || product.created_at);
                            return isNaN(date.getTime()) ? '未知时间' : date.toLocaleString('zh-CN');
                          } catch {
                            return '未知时间';
                          }
                        })()}</span>
                                            </>
                      )}
                    </div>
                  </div>
                </div>
                            {/* 链接显示区域 */}
                <div className="flex items-center gap-4">
                                <div className="flex flex-col gap-1 min-w-0 flex-1 max-w-md">
                                    {displayedLinks.map((link) => (
                      <div key={link.name} className="flex items-center gap-1.5">
                                            <Badge className={`text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white ${
                          link.badge_color === 'blue' ? 'bg-blue-600' :
                          link.badge_color === 'green' ? 'bg-green-600' :
                                                link.badge_color === 'orange' ? 'bg-orange-600' : 'bg-gray-600'
                                            }`}>{link.display_name}</Badge>
                        <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                                                <a href={link.url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">{link.url}</a>
                                                <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(link.url); toast.success("Copied")}}><Copy className="h-2.5 w-2.5"/></Button>
                        </div>
                      </div>
                    ))}
                                    {links.length > 3 && (
                                        <Button variant="ghost" size="sm" className="h-5 text-xs w-full" onClick={()=>toggleProductExpansion(product.id)}>
                                            {showAllLinks ? <ChevronUp className="h-3 w-3"/> : <ChevronDown className="h-3 w-3"/>}
                                            {showAllLinks ? "收起" : `显示更多 (${links.length - 3})`}
                      </Button>
                    )}
                  </div>
                                {/* 操作按钮组 */}
                                <div className="flex items-center gap-1">
                                    {/* 编辑按钮 */}
                                    <Dialog open={editingProduct?.id === product.id} onOpenChange={(open)=>!open && setEditingProduct(null)}>
                      <DialogTrigger asChild>
                                            <Button variant="outline" size="icon" className="h-8 w-8" onClick={()=>setEditingProduct(product)}>
                                                <Edit className="size-3.5"/>
                        </Button>
                      </DialogTrigger>
                                        <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
                        <DialogHeader>
                                                <DialogTitle>编辑商品与规则 - {product.weidianId}</DialogTitle>
                          <DialogDescription>配置商品信息和自动回复规则</DialogDescription>
                        </DialogHeader>

                                            <div className="space-y-6 py-4">
                          <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                              <Label>商品名称 (中文)</Label>
                              <Input value={editingProduct?.title || ""} onChange={(e) => setEditingProduct({...editingProduct, title: e.target.value})} />
                            </div>
                            <div className="space-y-2">
                              <Label>英文关键词</Label>
                              <Input value={editingProduct?.englishTitle || ""} onChange={(e) => setEditingProduct({...editingProduct, englishTitle: e.target.value})} />
                            </div>
                          </div>
                          <div className="flex items-center justify-between p-4 border rounded-lg bg-muted/30">
                            <div className="space-y-1">
                              <Label className="text-sm font-bold">启用自动回复规则</Label>
                                                        <p className="text-xs text-muted-foreground">当检测到关键词时自动发送链接</p>
                            </div>
                                                    <Switch checked={editingProduct?.ruleEnabled || false} onCheckedChange={(c) => setEditingProduct({...editingProduct, ruleEnabled: c})} />
                          </div>

                          {/* 自定义回复设置 - 当自动回复规则关闭时显示 */}
                          {/* 自定义回复设置 - 当自动回复规则关闭时显示 */}
                          {!editingProduct?.ruleEnabled && (
                            <div className="space-y-4 p-4 border rounded-lg bg-blue-50/30">
                              <div className="space-y-2">
                                <Label className="text-sm font-medium">自定义回复消息</Label>
                                <Textarea
                                  value={editingProduct?.customReplyText || ""}
                                  onChange={(e) => setEditingProduct({...editingProduct, customReplyText: e.target.value})}
                                  placeholder="输入自定义回复消息内容..."
                                  rows={3}
                                />
                                <p className="text-xs text-muted-foreground">如果留空，将只发送选中的图片</p>
                              </div>

                              <div className="space-y-3">
                                <Label className="text-sm font-medium">附带图片回复</Label>

                                {/* 图片来源选择器 */}
                                <div className="space-y-2 p-3 bg-gray-50 rounded-md border">
                                  <Label className="text-xs font-medium text-gray-700">选择图片来源</Label>
                                  <div className="flex gap-4">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                      <input
                                        type="radio"
                                        name="imageSource"
                                        value="product"
                                        checked={!editingProduct?.imageSource || editingProduct?.imageSource === 'product'}
                                        onChange={() => {
                                          setEditingProduct({
                                            ...editingProduct,
                                            imageSource: 'product',
                                            uploadedImages: [],
                                            existingUploadedImageUrls: [],
                                            customImageUrls: []
                                          });
                                        }}
                                        className="w-4 h-4"
                                      />
                                      <span className="text-sm">使用商品图片</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                      <input
                                        type="radio"
                                        name="imageSource"
                                        value="upload"
                                        checked={editingProduct?.imageSource === 'upload'}
                                        onChange={() => {
                                          setEditingProduct({
                                            ...editingProduct,
                                            imageSource: 'upload',
                                            selectedImageIndexes: [],
                                            customImageUrls: []
                                          });
                                        }}
                                        className="w-4 h-4"
                                      />
                                      <span className="text-sm">上传本地图片</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                      <input
                                        type="radio"
                                        name="imageSource"
                                        value="custom"
                                        checked={editingProduct?.imageSource === 'custom'}
                                        onChange={() => {
                                          setEditingProduct({
                                            ...editingProduct,
                                            imageSource: 'custom',
                                            selectedImageIndexes: [],
                                            uploadedImages: [],
                                            existingUploadedImageUrls: []
                                          });
                                        }}
                                        className="w-4 h-4"
                                      />
                                      <span className="text-sm">使用图片链接</span>
                                    </label>
                                  </div>
                                </div>

                                {/* 模式1: 使用商品图片 */}
                                {(!editingProduct?.imageSource || editingProduct?.imageSource === 'product') && (
                                  <div className="space-y-2">
                                    <Label className="text-xs text-muted-foreground">勾选现有商品图片</Label>
                                    <div className="grid grid-cols-3 md:grid-cols-4 gap-3 max-h-60 overflow-y-auto p-2 border rounded-md bg-white">
                                      {editingProduct?.images?.map((image: string, index: number) => (
                                        <div
                                          key={`prod-${index}`}
                                          className={`relative aspect-square rounded-md overflow-hidden cursor-pointer border-2 transition-all ${
                                            editingProduct?.selectedImageIndexes?.includes(index)
                                              ? 'border-blue-500 ring-2 ring-blue-200'
                                              : 'border-transparent hover:border-gray-200'
                                          }`}
                                          onClick={() => {
                                            const selectedIndexes = editingProduct?.selectedImageIndexes || [];
                                            const newIndexes = selectedIndexes.includes(index)
                                              ? selectedIndexes.filter((i: number) => i !== index)
                                              : [...selectedIndexes, index];
                                            setEditingProduct({
                                              ...editingProduct,
                                              selectedImageIndexes: newIndexes,
                                              imageSource: 'product'
                                            });
                                          }}
                                        >
                                          <img
                                            src={image}
                                            alt={`图片 ${index + 1}`}
                                            className="w-full h-full object-cover"
                                          />
                                          {editingProduct?.selectedImageIndexes?.includes(index) && (
                                            <div className="absolute top-1 right-1 bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs shadow-sm">
                                              ✓
                                            </div>
                                          )}
                                        </div>
                                      ))}
                                    </div>
                                    <p className="text-xs text-muted-foreground">
                                      已选 {editingProduct?.selectedImageIndexes?.length || 0} 张现有图片
                                    </p>
                                  </div>
                                )}

                                {/* 模式2: 上传本地图片 */}
                                {editingProduct?.imageSource === 'upload' && (
                                  <div className="space-y-2">
                                    {/* 隐藏的文件输入框 */}
                                    <input
                                      type="file"
                                      multiple
                                      accept="image/*"
                                      className="hidden"
                                      id="edit-upload-input"
                                      onChange={(e) => {
                                        const files = Array.from(e.target.files || []);
                                        if (files.length > 0) {
                                          setEditingProduct({
                                            ...editingProduct,
                                            uploadedImages: [...(editingProduct?.uploadedImages || []), ...files],
                                            imageSource: 'upload'
                                          });
                                        }
                                      }}
                                    />
                                    <div className="flex justify-between items-center">
                                      <Label className="text-xs text-muted-foreground">上传本地图片</Label>
                                      <Label
                                        htmlFor="edit-upload-input"
                                        className="cursor-pointer text-xs bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 flex items-center"
                                      >
                                        <Upload className="w-3 h-3 mr-1"/> 选择文件
                                      </Label>
                                    </div>

                                    {/* 显示已保存的图片和新上传的图片 */}
                                    {((editingProduct?.existingUploadedImageUrls?.length > 0) || (editingProduct?.uploadedImages?.length > 0)) && (
                                      <>
                                        <div className="grid grid-cols-3 md:grid-cols-4 gap-3 p-2 border rounded-md bg-white">
                                          {/* 显示已保存的图片（URL） */}
                                          {editingProduct?.existingUploadedImageUrls?.map((url: string, index: number) => (
                                            <div key={`existing-${index}`} className="relative aspect-square rounded-md overflow-hidden border-2 border-blue-500">
                                              <img
                                                src={url}
                                                alt="已保存图片"
                                                className="w-full h-full object-cover"
                                              />
                                              <div className="absolute top-1 right-1 bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs">
                                                ✓
                                              </div>
                                              <button
                                                type="button"
                                                className="absolute bottom-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center"
                                                onClick={(e) => {
                                                  e.stopPropagation();
                                                  const newUrls = editingProduct.existingUploadedImageUrls.filter((_: any, i: number) => i !== index);
                                                  setEditingProduct({
                                                    ...editingProduct,
                                                    existingUploadedImageUrls: newUrls
                                                  });
                                                }}
                                              >
                                                <X className="w-3 h-3"/>
                                              </button>
                                            </div>
                                          ))}

                                          {/* 显示新上传的图片（File对象） */}
                                          {editingProduct?.uploadedImages?.map((file: File, index: number) => (
                                            <div key={`new-${index}`} className="relative aspect-square rounded-md overflow-hidden border-2 border-green-500">
                                              <img
                                                src={URL.createObjectURL(file)}
                                                alt="新上传图片"
                                                className="w-full h-full object-cover"
                                              />
                                              <div className="absolute top-1 right-1 bg-green-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs">
                                                新
                                              </div>
                                              <button
                                                type="button"
                                                className="absolute bottom-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center"
                                                onClick={(e) => {
                                                  e.stopPropagation();
                                                  const newUploads = editingProduct.uploadedImages.filter((_: any, i: number) => i !== index);
                                                  setEditingProduct({
                                                    ...editingProduct,
                                                    uploadedImages: newUploads
                                                  });
                                                }}
                                              >
                                                <X className="w-3 h-3"/>
                                              </button>
                                            </div>
                                          ))}
                                        </div>
                                        <p className="text-xs text-muted-foreground">
                                          已保存: {editingProduct?.existingUploadedImageUrls?.length || 0} 张 | 新上传: {editingProduct?.uploadedImages?.length || 0} 张
                                        </p>
                                      </>
                                    )}
                                  </div>
                                )}

                                {/* 模式3: 使用图片链接 */}
                                {editingProduct?.imageSource === 'custom' && (
                                  <div className="space-y-2">
                                    <Label className="text-xs text-muted-foreground">填写图片链接（每行一个）</Label>
                                    <Textarea
                                      value={Array.isArray(editingProduct?.customImageUrls) ? editingProduct.customImageUrls.join('\n') : (editingProduct?.customImageUrls || "")}
                                      onChange={(e) => {
                                        const urls = e.target.value.split('\n').filter(url => url.trim());
                                        setEditingProduct({
                                          ...editingProduct,
                                          customImageUrls: urls,
                                          imageSource: 'custom'
                                        });
                                      }}
                                      placeholder="https://example.com/image1.jpg&#10;https://example.com/image2.jpg"
                                      rows={4}
                                      className="text-xs"
                                    />
                                    <p className="text-xs text-muted-foreground">
                                      {Array.isArray(editingProduct?.customImageUrls) && editingProduct.customImageUrls.length > 0
                                        ? `已填写 ${editingProduct.customImageUrls.length} 个图片链接`
                                        : '填写后将使用这些链接的图片回复'}
                                    </p>
                                  </div>
                                )}
                              </div>
                            </div>
                          )}
                        </div>
                        <DialogFooter>
                                                <Button variant="outline" onClick={()=>setEditingProduct(null)}>取消</Button>
                                                <Button onClick={()=>handleUpdateProduct(editingProduct)}>保存修改</Button>
                        </DialogFooter>
                      </DialogContent>
                    </Dialog>

                                    {/* 删除按钮 */}
                                    <Button variant="outline" size="icon" className="h-8 w-8 hover:bg-red-50 hover:text-red-600" onClick={()=>handleDeleteProduct(product.id)}>
                                        <Trash2 className="size-3.5"/>
                    </Button>
                  </div>
                </div>
              </div>
                        )
                    })}
          </div>
          
                {/* 分页组件 */}
                {currentProducts.length > 0 && (
                    <div className="flex flex-col sm:flex-row justify-between items-center gap-4 p-6 border-t bg-muted/5">
              <div className="text-sm text-muted-foreground font-medium">
                            显示第 {(currentPage-1)*itemsPerPage + 1} - {Math.min(currentPage*itemsPerPage, currentProducts.length)} 条，共 {currentProducts.length} 条记录
                            <span className="ml-2">({currentPage}/{totalPages}页)</span>
              </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.max(1, p-1))}
                                disabled={currentPage===1}
                                className="h-8 px-3"
                  >
                                <ChevronLeft className="h-4 w-4 mr-1"/> 上一页
                  </Button>
                            <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                    {currentPage} / {totalPages}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.min(totalPages, p+1))}
                                disabled={currentPage===totalPages}
                                className="h-8 px-3"
                  >
                                下一页 <ChevronRight className="h-4 w-4 ml-1"/>
                  </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

        {/* 单个商品删除确认对话框 */}
        <Dialog open={showDeleteConfirm && deletingProductId !== null} onOpenChange={(open) => {
          if (!open) {
            setShowDeleteConfirm(false)
            setDeletingProductId(null)
          }
        }}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>确认删除商品</DialogTitle>
              <DialogDescription>
                确定要删除商品 {deletingProductId} 吗？此操作不可恢复。
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => {
                setShowDeleteConfirm(false)
                setDeletingProductId(null)
              }}>
                取消
              </Button>
              <Button
                variant="destructive"
                onClick={confirmDeleteProduct}
              >
                确认删除
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

      {/* 批量删除确认对话框 */}
        <Dialog open={showDeleteConfirm && deletingProductId === null} onOpenChange={setShowDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
              <DialogTitle>确认批量删除</DialogTitle>
            <DialogDescription>
              确定要删除选中的 {selectedProducts.length} 个商品吗？此操作不可恢复。
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteConfirm(false)}>
              取消
            </Button>
              <Button
                variant="destructive"
                onClick={confirmBatchDelete}
                disabled={isDeleting}
              >
              {isDeleting ? "删除中..." : "确认删除"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/logs-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Pause, Play, Trash2, RefreshCw } from "lucide-react"

type LogEntry = {
  timestamp: string
  level: string
  message: string
  module?: string
  func?: string
  type?: string // 用于心跳包
}

export function LogsView() {
  const [logs, setLogs] = useState<LogEntry[]>([])
  const [isConnected, setIsConnected] = useState(false)
  const [isPaused, setIsPaused] = useState(false)
  const scrollRef = useRef<HTMLDivElement>(null)
  const eventSourceRef = useRef<EventSource | null>(null)

  // 加载历史日志
  const loadRecentLogs = async () => {
    try {
      const response = await fetch('/api/logs?endpoint=recent')
      if (response.ok) {
        const data = await response.json()
        setLogs(data.logs || [])
      }
    } catch (error) {
      console.error('加载历史日志失败:', error)
    }
  }

  // 连接到日志流
  const connectToLogStream = () => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
    }

    const eventSource = new EventSource('/api/logs/stream')
    eventSourceRef.current = eventSource

    eventSource.onopen = () => {
      console.log('日志流连接已建立')
      setIsConnected(true)
    }

    eventSource.onmessage = (event) => {
      try {
        const logEntry: LogEntry = JSON.parse(event.data)

        // 过滤心跳包
        if (logEntry.type === 'heartbeat') {
          return
        }

        setLogs((prev) => [...prev, logEntry].slice(-200)) // 保持最近200条日志
      } catch (error) {
        console.error('解析日志数据失败:', error, event.data)
      }
    }

    eventSource.onerror = (error) => {
      console.error('日志流连接错误:', error)
      setIsConnected(false)

      // 自动重连
      setTimeout(() => {
        if (!isPaused) {
          connectToLogStream()
        }
      }, 5000)
    }
  }

  useEffect(() => {
    // 加载历史日志
    loadRecentLogs()

    // 连接到日志流
    if (!isPaused) {
      connectToLogStream()
    }

    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
      }
    }
  }, [isPaused])

  useEffect(() => {
    if (scrollRef.current && !isPaused) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" })
    }
  }, [logs, isPaused])

  const handleTogglePause = () => {
    setIsPaused(!isPaused)
    if (!isPaused) {
      // 暂停时断开连接
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
        setIsConnected(false)
      }
    } else {
      // 恢复时重新连接
      connectToLogStream()
    }
  }

  const handleClearLogs = () => {
    setLogs([])
  }

  const handleRefresh = () => {
    loadRecentLogs()
  }

  const getLevelColor = (level: string) => {
    switch (level) {
      case "INFO":
        return "bg-blue-600 hover:bg-blue-700"
      case "WARNING":
        return "bg-yellow-600 hover:bg-yellow-700"
      case "ERROR":
        return "bg-red-600 hover:bg-red-700"
      case "CRITICAL":
        return "bg-red-800 hover:bg-red-900"
      default:
        return "bg-gray-600 hover:bg-gray-700"
    }
  }

  const formatTimestamp = (timestamp: string) => {
    try {
      const date = new Date(timestamp)
      return date.toLocaleTimeString("zh-CN", { hour12: false })
    } catch {
      return timestamp
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">实时日志</h2>
          <p className="text-muted-foreground">监控系统运行状态和事件流</p>
        </div>
        <div className="flex items-center gap-2">
          <div className="flex items-center gap-1 text-sm">
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
            <span className="text-muted-foreground">
              {isConnected ? '已连接' : '未连接'}
            </span>
          </div>
          <Button variant="outline" size="sm" onClick={handleTogglePause}>
            {isPaused ? <Play className="size-4" /> : <Pause className="size-4" />}
            {isPaused ? '恢复' : '暂停'}
          </Button>
          <Button variant="outline" size="sm" onClick={handleRefresh}>
            <RefreshCw className="size-4" />
            刷新
          </Button>
          <Button variant="outline" size="sm" onClick={handleClearLogs}>
            <Trash2 className="size-4" />
            清空
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>系统日志流</CardTitle>
          <CardDescription>
            共 {logs.length} 条记录 • {isPaused ? '已暂停' : '实时监控中'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ScrollArea className="h-[600px] w-full rounded-md border bg-black/90 p-4">
            <div className="space-y-3 font-mono text-[11px] leading-relaxed">
              {logs.map((log, index) => (
                <div
                  key={`${log.timestamp}-${index}`}
                  className="flex items-start gap-3 text-green-400 hover:bg-white/5 p-2 rounded transition-colors border-b border-white/5 last:border-0"
                >
                  <span className="text-gray-500 shrink-0 font-bold">
                    {formatTimestamp(log.timestamp)}
                  </span>
                  <Badge className={`${getLevelColor(log.level)} shrink-0 text-[9px] h-4 px-1`}>
                    {log.level}
                  </Badge>
                  <span className="text-cyan-400 shrink-0 font-semibold">
                    [{log.module || 'system'}]
                  </span>
                  <span className="text-gray-200 break-words">{log.message}</span>
                </div>
              ))}
              <div ref={scrollRef} />
            </div>
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}


--- File: ./frontend/components/similarity-test-view.tsx ---
"use client"

import type React from "react"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Upload, TestTube, AlertCircle, CheckCircle } from "lucide-react"
import { toast } from "sonner"
import { Alert, AlertDescription } from "@/components/ui/alert"

export function SimilarityTestView() {
  const [image1, setImage1] = useState<string | null>(null)
  const [image2, setImage2] = useState<string | null>(null)
  const [isTesting, setIsTesting] = useState(false)
  const [result, setResult] = useState<any>(null)

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>, imageNumber: 1 | 2) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("请上传图片文件")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      if (imageNumber === 1) {
        setImage1(event.target?.result as string)
      } else {
        setImage2(event.target?.result as string)
      }
      toast.success(`图片${imageNumber}已上传`)
    }
    reader.readAsDataURL(file)
  }

  const handleTest = async () => {
    if (!image1 || !image2) {
      toast.error("请上传两张图片")
      return
    }

    setIsTesting(true)
    setResult(null)

    try {
      // 将base64图片转换为blob
      const response1 = await fetch(image1)
      const blob1 = await response1.blob()

      const response2 = await fetch(image2)
      const blob2 = await response2.blob()

      // 创建FormData
      const formData = new FormData()
      formData.append('image1', blob1, 'image1.jpg')
      formData.append('image2', blob2, 'image2.jpg')

      // 发送到API进行相似度测试
      const testRes = await fetch('/api/test-similarity', {
        method: 'POST',
        body: formData
      })

      if (testRes.ok) {
        const data = await testRes.json()
        setResult(data)
        toast.success(`相似度测试完成: ${(data.similarity * 100).toFixed(2)}%`)
      } else {
        const errorText = await testRes.text()
        console.error('Test failed:', errorText)
        toast.error("测试失败: " + errorText)
      }
    } catch (error) {
      console.error('Test error:', error)
      toast.error("测试过程中发生错误")
    } finally {
      setIsTesting(false)
    }
  }

  const clearImages = () => {
    setImage1(null)
    setImage2(null)
    setResult(null)
  }

  return (
    <div className="space-y-6">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <h2 className="text-3xl font-bold tracking-tight">相似度测试</h2>
          <p className="text-muted-foreground">测试PP-ShiTuV2模型对两张图片的相似度计算</p>
        </div>
      </div>

      <div className="grid gap-6 lg:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>图片1</CardTitle>
            <CardDescription>选择第一张图片</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image1 ? (
              <label
                htmlFor="image1-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">点击上传第一张图片</p>
                <input id="image1-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 1)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image1}
                  alt="Image 1"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage1(null)}
                >
                  ×
                </Button>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>图片2</CardTitle>
            <CardDescription>选择第二张图片</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image2 ? (
              <label
                htmlFor="image2-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">点击上传第二张图片</p>
                <input id="image2-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 2)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image2}
                  alt="Image 2"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage2(null)}
                >
                  ×
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TestTube className="size-5" />
            测试控制
          </CardTitle>
          <CardDescription>执行相似度测试</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-3">
            <Button
              onClick={handleTest}
              disabled={!image1 || !image2 || isTesting}
              className="flex-1"
            >
              <TestTube className="mr-2 size-4" />
              {isTesting ? "测试中..." : "开始相似度测试"}
            </Button>
            <Button
              variant="outline"
              onClick={clearImages}
              disabled={isTesting}
            >
              清空图片
            </Button>
          </div>

          {isTesting && (
            <div className="space-y-2">
              <Progress value={50} className="h-2" />
              <p className="text-[10px] text-blue-500 animate-pulse font-medium">正在提取特征向量并计算相似度...</p>
            </div>
          )}
        </CardContent>
      </Card>

      {result && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              {result.similarity > 0.9 ? (
                <CheckCircle className="size-5 text-green-500" />
              ) : (
                <AlertCircle className="size-5 text-orange-500" />
              )}
              测试结果
            </CardTitle>
            <CardDescription>PP-ShiTuV2模型相似度分析</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">相似度分数</span>
                  <Badge
                    className={
                      result.similarity > 0.9
                        ? "bg-green-600 hover:bg-green-700"
                        : result.similarity > 0.7
                        ? "bg-blue-600 hover:bg-blue-700"
                        : "bg-orange-600 hover:bg-orange-700"
                    }
                  >
                    {(result.similarity * 100).toFixed(2)}%
                  </Badge>
                </div>
                <Progress value={result.similarity * 100} className="h-3" />
              </div>

              <div className="space-y-2">
                <div className="text-sm">
                  <span className="font-medium">模型名称:</span> {result.model}
                </div>
                <div className="text-sm">
                  <span className="font-medium">向量维度:</span> {result.vector_dimension}
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
              <div>
                <span className="font-medium">图片1特征范数:</span> {result.features1_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">图片2特征范数:</span> {result.features2_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">点积:</span> {result.dot_product?.toFixed(4)}
              </div>
            </div>

            {result.similarity < 0.95 && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  相似度低于95%，可能的原因：
                  1. 图片内容不同
                  2. 图片在处理过程中发生变化（压缩、尺寸调整等）
                  3. 模型特征提取的局限性
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  )
}

--- File: ./frontend/components/dashboard-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
    fetchAnnouncements()

    // 优化轮询频率：每30秒自动刷新统计数据（降低服务器负载）
    const statsInterval = setInterval(() => {
      if (!document.hidden) { // 只在标签页可见时刷新
        fetchStats()
      }
    }, 30000)

    return () => {
      clearInterval(statsInterval)
    }
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('统计数据:', data)
        setStats(data)
      } else {
        console.error('获取统计信息失败:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('获取统计信息失败:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('获取公告失败:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('公告添加成功')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('公告更新成功')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`确定要删除公告 "${announcement.title}" 吗？`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('公告删除成功')
        fetchAnnouncements()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">仪表盘</h2>
        <p className="text-muted-foreground mt-2">系统概览和公告管理</p>
      </div>

      {/* 统计信息 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 lg:gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">店铺数量</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已收录的店铺</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">商品数量</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已抓取的商品</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">图片数量</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已索引的图片</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">用户数量</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">活跃用户</p>
          </CardContent>
        </Card>
      </div>

      {/* 公告管理 - 所有用户可见，但只有管理员可修改 */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                系统公告
              </CardTitle>
              <CardDescription>查看最新系统通知和重要更新</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm" className="shrink-0">
                    <Plus className="w-4 h-4 mr-2" />
                    添加公告
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>添加系统公告</DialogTitle>
                    <DialogDescription>创建新的系统公告</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>公告标题</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="请输入公告标题"
                      />
                    </div>
                    <div>
                      <Label>公告内容</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="请输入公告内容"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>取消</Button>
                    <Button onClick={handleAddAnnouncement}>添加公告</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                暂无公告
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4 hover:bg-muted/30 transition-colors">
                  <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                    <div className="flex-1 min-w-0">
                      <h4 className="font-semibold text-base mb-2">{announcement.title}</h4>
                      <p className="text-sm text-muted-foreground mb-3 leading-relaxed">{announcement.content}</p>
                      <div className="text-xs text-muted-foreground">
                        更新时间: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2 shrink-0">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                          className="h-8 w-8 p-0"
                          title="编辑公告"
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                          className="h-8 w-8 p-0 hover:bg-red-50 hover:text-red-600 hover:border-red-200"
                          title="删除公告"
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* 编辑公告对话框 */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>编辑公告</DialogTitle>
              <DialogDescription>修改公告内容</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>公告标题</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>公告内容</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>取消</Button>
              <Button onClick={handleUpdateAnnouncement}>保存修改</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/settings-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { toast } from "sonner"
import { Settings, Save } from "lucide-react"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

interface UserSettings {
  discord_similarity_threshold: number
  global_reply_min_delay: number
  global_reply_max_delay: number
  user_blacklist: string
  keyword_filters: string
  keyword_reply_enabled: boolean
  image_reply_enabled: boolean
}

interface SystemSettings {
  scrape_threads: number
  download_threads: number
  feature_extract_threads: number
}

export function SettingsView() {
  const [settings, setSettings] = useState<UserSettings>({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
    user_blacklist: '',
    keyword_filters: '',
    keyword_reply_enabled: true,
    image_reply_enabled: true,
  })
  const [systemSettings, setSystemSettings] = useState<SystemSettings>({
    scrape_threads: 2,
    download_threads: 4,
    feature_extract_threads: 4,
  })
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [savingSystem, setSavingSystem] = useState(false)
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  })
  const [changingPassword, setChangingPassword] = useState(false)

  useEffect(() => {
    fetchSettings()
    fetchSystemSettings()
  }, [])

  const fetchSettings = async () => {
    try {
      // 获取用户个性化设置
      const response = await fetch('/api/user/settings')
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold ?? 0.6,
          global_reply_min_delay: data.global_reply_min_delay ?? 3.0,
          global_reply_max_delay: data.global_reply_max_delay ?? 8.0,
          user_blacklist: data.user_blacklist ?? '',
          keyword_filters: data.keyword_filters ?? '',
          keyword_reply_enabled: data.keyword_reply_enabled === 1 || data.keyword_reply_enabled === true,
          image_reply_enabled: data.image_reply_enabled === 1 || data.image_reply_enabled === true,
        })
      } else {
        toast.error("获取设置失败")
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
      toast.error("获取设置失败")
    } finally {
      setLoading(false)
    }
  }

  const handleSaveSystemSettings = async () => {
    setSavingSystem(true)
    try {
      const response = await fetch('/api/config/scrape-threads', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          scrape_threads: systemSettings.scrape_threads
        })
      })

      if (response.ok) {
        toast.success("系统设置已保存")
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || "保存系统设置失败")
      }
    } catch (error) {
      console.error('Failed to save system settings:', error)
      toast.error("保存系统设置失败")
    } finally {
      setSavingSystem(false)
    }
  }

  const fetchSystemSettings = async () => {
    try {
      // 获取抓取线程配置
      const scrapeResponse = await fetch('/api/config/scrape-threads')
      let scrape_threads = 2
      if (scrapeResponse.ok) {
        const data = await scrapeResponse.json()
        scrape_threads = data.scrape_threads ?? 2
      }

      // 注意：其他线程配置目前在后端没有单独的API，这里先使用默认值
      // 后续可以添加更多的API来获取这些配置
      setSystemSettings({
        scrape_threads: scrape_threads,
        download_threads: 4,  // 默认值
        feature_extract_threads: 4,  // 默认值
      })
    } catch (error) {
      console.error('Failed to fetch system settings:', error)
    }
  }

  const handleSave = async () => {
    setSaving(true)
    try {
      // 验证回复延迟设置
      if (settings.global_reply_min_delay >= settings.global_reply_max_delay) {
        toast.error("最小延迟必须小于最大延迟")
        setSaving(false)
        return
      }

      if (settings.global_reply_min_delay < 0 || settings.global_reply_max_delay < 0) {
        toast.error("延迟时间不能为负数")
        setSaving(false)
        return
      }

      // 保存用户个性化设置
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("设置已保存")
      } else {
        toast.error("保存设置失败")
      }
    } catch (error) {
      toast.error("保存设置失败")
    } finally {
      setSaving(false)
    }
  }

  const handleChangePassword = async () => {
    if (!passwordData.currentPassword || !passwordData.newPassword || !passwordData.confirmPassword) {
      toast.error("请填写所有密码字段")
      return
    }

    if (passwordData.newPassword !== passwordData.confirmPassword) {
      toast.error("新密码和确认密码不一致")
      return
    }

    if (passwordData.newPassword.length < 6) {
      toast.error("新密码长度至少6位")
      return
    }

    setChangingPassword(true)
    try {
      const response = await fetch('/api/user/change-password', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          current_password: passwordData.currentPassword,
          new_password: passwordData.newPassword
        })
      })

      if (response.ok) {
        toast.success("密码修改成功")
        setPasswordData({
          currentPassword: '',
          newPassword: '',
          confirmPassword: ''
        })
      } else {
        const error = await response.json()
        toast.error(error.error || "密码修改失败")
      }
    } catch (error) {
      toast.error("密码修改失败")
    } finally {
      setChangingPassword(false)
    }
  }

  if (loading) {
    return (
      <div className="space-y-8">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">系统设置</h2>
          <p className="text-sm text-muted-foreground mt-1">正在加载设置...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">个人设置</h2>
          <p className="text-sm text-muted-foreground mt-1">配置您的个性化运行参数</p>
        </div>
        <div className="flex gap-2">
          <Button onClick={handleSave} disabled={saving} variant="outline">
            <Save className="w-4 h-4 mr-2" />
            {saving ? "保存用户设置..." : "保存用户设置"}
          </Button>
          <Button onClick={handleSaveSystemSettings} disabled={savingSystem}>
            <Settings className="w-4 h-4 mr-2" />
            {savingSystem ? "保存系统设置..." : "保存系统设置"}
          </Button>
        </div>
      </div>

      {/* 密码修改 */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">修改密码</CardTitle>
          <CardDescription>修改您的账号密码</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="current-password">当前密码</Label>
            <Input
              id="current-password"
              type="password"
              value={passwordData.currentPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, currentPassword: e.target.value }))}
              placeholder="请输入当前密码"
            />
          </div>
          <div>
            <Label htmlFor="new-password">新密码</Label>
            <Input
              id="new-password"
              type="password"
              value={passwordData.newPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
              placeholder="请输入新密码"
            />
          </div>
          <div>
            <Label htmlFor="confirm-password">确认新密码</Label>
            <Input
              id="confirm-password"
              type="password"
              value={passwordData.confirmPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
              placeholder="请再次输入新密码"
            />
          </div>
          <Button
            onClick={handleChangePassword}
            disabled={changingPassword}
            className="w-full"
          >
            {changingPassword ? "修改中..." : "修改密码"}
          </Button>
        </CardContent>
      </Card>

      {/* 系统参数设置 */}
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="text-lg">系统参数</CardTitle>
          <CardDescription>配置图片匹配、回复延迟和抓取多线程参数</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* 系统设置 - 多列网格布局 */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            {/* 相似度设置 */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="similarity-threshold" className="text-sm font-medium">相似度阈值</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="similarity-threshold"
                  type="number"
                  step="0.1"
                  min="0.1"
                  max="1.0"
                  value={settings.discord_similarity_threshold}
                  onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  匹配阈值，范围 0.1-1.0
                </p>
              </div>
            </div>

            {/* 商品抓取线程数 */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="scrape-threads" className="text-sm font-medium">商品抓取线程</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.scrape_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="scrape-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="10"
                  value={systemSettings.scrape_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, scrape_threads: parseInt(e.target.value) || 2 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  批量商品处理并发数
                </p>
              </div>
            </div>

            {/* 图片下载线程数 */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="download-threads" className="text-sm font-medium">图片下载线程</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.download_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="download-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="20"
                  value={systemSettings.download_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, download_threads: parseInt(e.target.value) || 4 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  每个商品的图片下载数
                </p>
              </div>
            </div>

            {/* 特征提取线程数 */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="feature-extract-threads" className="text-sm font-medium">特征提取线程</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.feature_extract_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="feature-extract-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="10"
                  value={systemSettings.feature_extract_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, feature_extract_threads: parseInt(e.target.value) || 4 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  AI特征提取并发数
                </p>
              </div>
            </div>
          </div>

            {/* 回复延迟设置 */}
            <div className="flex-1 space-y-2">
              <Label className="text-sm font-medium">回复延迟</Label>
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <div className="flex items-center gap-1">
                    <Input
                      id="min-delay"
                      type="number"
                      step="0.1"
                      min="0.1"
                      max="30"
                      value={settings.global_reply_min_delay}
                      onChange={(e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value) && value >= 0.1 && value <= 30) {
                          setSettings(prev => ({ ...prev, global_reply_min_delay: value }));
                        }
                      }}
                      className="w-16 h-9 text-center"
                    />
                    <span className="text-sm text-muted-foreground">-</span>
                    <Input
                      id="max-delay"
                      type="number"
                      step="0.5"
                      min="1"
                      max="60"
                      value={settings.global_reply_max_delay}
                      onChange={(e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value) && value >= 1 && value <= 60) {
                          setSettings(prev => ({ ...prev, global_reply_max_delay: value }));
                        }
                      }}
                      className="w-16 h-9 text-center"
                    />
                  </div>
                  <span className="text-xs text-muted-foreground">秒</span>
                </div>
                <p className="text-xs text-muted-foreground">
                  每次回复随机延迟 {settings.global_reply_min_delay}-{settings.global_reply_max_delay} 秒
                </p>
              </div>
            </div>
          </div>

          {/* 回复功能开关 */}
          <div className="space-y-4">
            <Label className="text-sm font-medium">回复功能开关</Label>
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="keyword-reply" className="text-sm">关键词回复</Label>
                  <p className="text-xs text-muted-foreground">
                    启用后，机器人会根据文字关键词搜索商品并回复
                  </p>
                </div>
                <Switch
                  id="keyword-reply"
                  checked={settings.keyword_reply_enabled}
                  onCheckedChange={(checked) => setSettings(prev => ({ ...prev, keyword_reply_enabled: checked }))}
                />
              </div>
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="image-reply" className="text-sm">图片回复</Label>
                  <p className="text-xs text-muted-foreground">
                    启用后，机器人会根据图片搜索相似商品并回复
                  </p>
                </div>
                <Switch
                  id="image-reply"
                  checked={settings.image_reply_enabled}
                  onCheckedChange={(checked) => setSettings(prev => ({ ...prev, image_reply_enabled: checked }))}
                />
              </div>
            </div>
          </div>

          {/* 用户黑名单设置 */}
          <div className="space-y-2">
            <Label htmlFor="user-blacklist" className="text-sm font-medium">用户黑名单</Label>
            <div className="space-y-1">
              <Input
                id="user-blacklist"
                type="text"
                value={settings.user_blacklist}
                onChange={(e) => setSettings(prev => ({ ...prev, user_blacklist: e.target.value }))}
                placeholder="输入不回复的用户ID，多个用逗号分隔"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                不会回复这些用户发送的消息，格式：user123,user456,user789
              </p>
            </div>
          </div>

          {/* 关键词过滤设置 */}
          <div className="space-y-2">
            <Label htmlFor="keyword-filters" className="text-sm font-medium">关键词过滤</Label>
            <div className="space-y-1">
              <Input
                id="keyword-filters"
                type="text"
                value={settings.keyword_filters}
                onChange={(e) => setSettings(prev => ({ ...prev, keyword_filters: e.target.value }))}
                placeholder="输入不回复的关键词，多个用逗号分隔"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                消息包含这些关键词时不会回复，格式：广告,刷屏,测试,垃圾
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

        {/* 系统信息 */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">系统信息</CardTitle>
            <CardDescription>当前系统状态</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-muted-foreground">状态:</span>
                <span className="text-green-600">运行正常</span>
              </div>
              <div className="flex justify-between">
                <span className="text-muted-foreground">版本:</span>
                <span>v1.0.0</span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

--- File: ./frontend/components/app-sidebar.tsx ---
"use client"

import { LayoutDashboard, Users, Search, ImageIcon, ListTree, ScrollText, Bot, Settings, TestTube, Store, Shield, Cog, BarChart3 } from "lucide-react"
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuItem,
  SidebarMenuButton,
  SidebarHeader,
  SidebarFooter,
} from "@/components/ui/sidebar"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

const baseMenuItems = [
  { id: "dashboard", icon: BarChart3, label: "仪表盘" },
  { id: "accounts", icon: Users, label: "账号与规则" },
  { id: "scraper", icon: Search, label: "微店抓取" },
  { id: "image-search", icon: ImageIcon, label: "以图搜图" },
  { id: "shops", icon: Store, label: "店铺管理" },
]

// 只有管理员才能访问的功能
const adminOnlyMenuItems = [
  { id: "users", icon: Shield, label: "用户管理" },
  { id: "logs", icon: ScrollText, label: "实时日志" },
]

export function AppSidebar({
  currentView,
  setCurrentView,
  currentUser,
}: {
  currentView: string
  setCurrentView: (view: string) => void
  currentUser: User | null
}) {
  return (
    <Sidebar>
      <SidebarHeader className="border-b p-4">
        <div className="flex items-center gap-2">
          <Bot className="size-6 text-primary" />
          <div>
            <h2 className="text-lg font-bold">Discord 营销</h2>
            <p className="text-xs text-muted-foreground">智能自动回复系统</p>
          </div>
        </div>
      </SidebarHeader>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>主要功能</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {baseMenuItems
                .filter(item => item.id !== 'shops' || currentUser?.role === 'admin')
                .map((item) => (
                <SidebarMenuItem key={item.id}>
                  <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                    <item.icon />
                    <span>{item.label}</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>


        {currentUser?.role === 'admin' && (
          <SidebarGroup>
            <SidebarGroupLabel>管理员功能</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {adminOnlyMenuItems.map((item) => (
                  <SidebarMenuItem key={item.id}>
                    <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                      <item.icon />
                      <span>{item.label}</span>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        )}
      </SidebarContent>
      <SidebarFooter className="border-t p-4">
        <p className="text-xs text-muted-foreground text-center">v1.0.0 • 技术支持</p>
        <p className="text-xs text-muted-foreground text-center mt-1">微信: OceanSeaWang</p>
        <p className="text-xs text-muted-foreground text-center mt-1">Discord: zrnown</p>
      </SidebarFooter>
    </Sidebar>
  )
}

--- File: ./frontend/components/dashboard-view-new.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
    if (currentUser?.role === 'admin') {
      fetchAnnouncements()
    }

    // 每10秒自动刷新统计数据
    const statsInterval = setInterval(() => {
      fetchStats()
    }, 10000)

    return () => {
      clearInterval(statsInterval)
    }
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('统计数据:', data)
        setStats(data)
      } else {
        console.error('获取统计信息失败:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('获取统计信息失败:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements')
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('获取公告失败:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('公告添加成功')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('添加失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('公告更新成功')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('更新失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`确定要删除公告 "${announcement.title}" 吗？`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('公告删除成功')
        fetchAnnouncements()
      } else {
        toast.error('删除失败')
      }
    } catch (e) {
      toast.error('网络错误')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">仪表盘</h2>
        <p className="text-muted-foreground mt-2">系统概览和公告管理</p>
      </div>

      {/* 统计信息 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">店铺数量</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已收录的店铺</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">商品数量</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已抓取的商品</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">图片数量</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">已索引的图片</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">用户数量</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">活跃用户</p>
          </CardContent>
        </Card>
      </div>

      {/* 公告管理 - 所有用户可见，但只有管理员可修改 */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                系统公告
              </CardTitle>
              <CardDescription>查看最新系统通知</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm">
                    <Plus className="w-4 h-4 mr-2" />
                    添加公告
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>添加系统公告</DialogTitle>
                    <DialogDescription>创建新的系统公告</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>公告标题</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="请输入公告标题"
                      />
                    </div>
                    <div>
                      <Label>公告内容</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="请输入公告内容"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>取消</Button>
                    <Button onClick={handleAddAnnouncement}>添加公告</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                暂无公告
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4">
                  <div className="flex justify-between items-start mb-2">
                    <h4 className="font-semibold">{announcement.title}</h4>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground mb-2">{announcement.content}</p>
                  <div className="text-xs text-muted-foreground">
                    更新时间: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* 编辑公告对话框 */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>编辑公告</DialogTitle>
              <DialogDescription>修改公告内容</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>公告标题</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>公告内容</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>取消</Button>
              <Button onClick={handleUpdateAnnouncement}>保存修改</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/login-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Bot, LogIn, User, Shield } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export function LoginView({ onLogin }: { onLogin: (user: User) => void }) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [loading, setLoading] = useState(false)

  const handleLogin = async () => {
    if (!username || !password) {
      toast.error("请输入用户名和密码")
      return
    }

    setLoading(true)
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success("登录成功")
        onLogin(data.user)
      } else {
        const error = await response.json()
        toast.error(error.error || "登录失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    } finally {
      setLoading(false)
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleLogin()
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <Card className="w-full max-w-md shadow-2xl">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <div className="p-3 bg-primary rounded-full">
              <Bot className="h-8 w-8 text-primary-foreground" />
            </div>
          </div>
          <CardTitle className="text-2xl font-bold">Discord 营销系统</CardTitle>
          <CardDescription>智能 Discord 账号营销管理平台</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username" className="text-sm font-medium">
                用户名
              </Label>
              <div className="relative">
                <User className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="username"
                  type="text"
                  placeholder="请输入用户名"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="password" className="text-sm font-medium">
                密码
              </Label>
              <div className="relative">
                <Shield className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="password"
                  type="password"
                  placeholder="请输入密码"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
          </div>

          <Button
            onClick={handleLogin}
            disabled={loading}
            className="w-full h-11 text-base font-semibold"
          >
            {loading ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                登录中...
              </>
            ) : (
              <>
                <LogIn className="mr-2 h-5 w-5" />
                登录
              </>
            )}
          </Button>

        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/rules-view.tsx ---
"use client"

import { useState, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Trash2, Edit, Image as ImageIcon, Search, Upload, X } from "lucide-react"
import { toast } from "sonner"
import { Checkbox } from "@/components/ui/checkbox"

const mockRules: any[] = []

const availableAccounts = ["Sisyphus_Bot_01", "Marketing_Manager", "Auto_Responder_X", "Discord_Helper_04"]

export function RulesView() {
  const [rules, setRules] = useState(mockRules)
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingRule, setEditingRule] = useState<any>(null)
  const [ruleSearch, setRuleSearch] = useState("")
  const [selectedAccountMode, setSelectedAccountMode] = useState("random")
  const [selectedSpecificAccounts, setSelectedSpecificAccounts] = useState<string[]>([])
  const [matchType, setMatchType] = useState("keyword")
  
  const [replyImage, setReplyImage] = useState<string | null>(null)
  const [triggerImage, setTriggerImage] = useState<string | null>(null)
  
  const replyImageInputRef = useRef<HTMLInputElement>(null)
  const triggerImageInputRef = useRef<HTMLInputElement>(null)

  const handleDeleteRule = (id: number) => {
    setRules((prev) => prev.filter((rule) => rule.id !== id))
    toast.success("规则已删除")
  }

  const handleEditRule = (rule: any) => {
    setEditingRule(rule)
    setSelectedAccountMode(rule.accountMode)
    setMatchType(rule.matchType)
    setSelectedSpecificAccounts(rule.assignedAccounts.includes("all") ? [] : rule.assignedAccounts)
    setReplyImage(rule.replyImage || null)
    setTriggerImage(rule.triggerImage || null)
    setIsDialogOpen(true)
  }

  const filteredRules = rules.filter((r: any) =>
    r.keywords.some((k: string) => k.toLowerCase().includes(ruleSearch.toLowerCase())) ||
    r.replyText.toLowerCase().includes(ruleSearch.toLowerCase())
  )

  const toggleAccountSelection = (acc: string) => {
    setSelectedSpecificAccounts(prev => 
      prev.includes(acc) ? prev.filter(a => a !== acc) : [...prev, acc]
    )
  }

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>, type: 'reply' | 'trigger') => {
    const file = e.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        if (type === 'reply') setReplyImage(reader.result as string)
        else setTriggerImage(reader.result as string)
        toast.success("图片已就绪")
      }
      reader.readAsDataURL(file)
    }
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">规则配置</h2>
          <p className="text-sm text-muted-foreground">配置自动回复触发规则、响应内容以及发送账号模式</p>
        </div>
        <div className="flex items-center gap-4">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="搜索规则关键词..."
              className="pl-9 w-[250px] h-10"
              value={ruleSearch}
              onChange={(e) => setRuleSearch(e.target.value)}
            />
          </div>
          <Dialog open={isDialogOpen} onOpenChange={(open) => {
            setIsDialogOpen(open)
            if (!open) {
              setEditingRule(null)
              setSelectedSpecificAccounts([])
              setReplyImage(null)
              setTriggerImage(null)
              setMatchType("keyword")
            }
          }}>
            <DialogTrigger asChild>
              <Button className="h-10 px-6 font-bold">
                <Plus className="mr-2 h-5 w-5" />
                添加新规则
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle className="text-2xl">{editingRule ? "编辑规则" : "创建新规则"}</DialogTitle>
                <DialogDescription>设置触发条件、回复内容及账号分配策略</DialogDescription>
              </DialogHeader>
              <div className="space-y-6 py-6">
                <div className="grid grid-cols-2 gap-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">匹配模式</Label>
                    <Select value={matchType} onValueChange={setMatchType}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="keyword">关键词匹配 (Partial)</SelectItem>
                        <SelectItem value="exact">精确匹配 (Exact)</SelectItem>
                        <SelectItem value="regex">正则表达式 (Regex)</SelectItem>
                        <SelectItem value="image">图片识别 (识别特定照片)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">回复附件 (图片)</Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={replyImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'reply')}
                    />
                    <div className="flex items-center gap-2">
                      {replyImage ? (
                        <div className="relative size-10 border rounded overflow-hidden group">
                          <img src={replyImage} className="object-cover w-full h-full" alt="Reply" />
                          <button 
                            onClick={() => setReplyImage(null)}
                            className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity"
                          >
                            <X className="size-4 text-white" />
                          </button>
                        </div>
                      ) : (
                        <Button 
                          variant="outline" 
                          className="w-full h-10 border-dashed justify-start text-muted-foreground"
                          onClick={() => replyImageInputRef.current?.click()}
                        >
                          <Upload className="mr-2 h-4 w-4" />
                          上传回复图片
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {matchType === 'image' ? (
                  <div className="space-y-2 bg-primary/5 p-4 rounded-lg border-2 border-dashed border-primary/20">
                    <Label className="font-bold text-sm text-primary flex items-center gap-2">
                      <ImageIcon className="size-4" /> 识别目标 (触发照片)
                    </Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={triggerImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'trigger')}
                    />
                    <p className="text-[11px] text-muted-foreground mb-3">当用户在 Discord 发送与此照片高度相似的图片时，将触发回复。</p>
                    {triggerImage ? (
                      <div className="relative w-full aspect-video border rounded-xl overflow-hidden group max-h-[200px]">
                        <img src={triggerImage} className="object-contain w-full h-full bg-black/10" alt="Trigger" />
                        <button 
                          onClick={() => setTriggerImage(null)}
                          className="absolute top-2 right-2 p-1 bg-red-500 rounded-full text-white shadow-lg"
                        >
                          <X className="size-4" />
                        </button>
                      </div>
                    ) : (
                      <Button 
                        variant="secondary" 
                        className="w-full h-24 flex-col gap-2"
                        onClick={() => triggerImageInputRef.current?.click()}
                      >
                        <Upload className="size-6" />
                        <span>点击上传识别模板图</span>
                      </Button>
                    )}
                  </div>
                ) : (
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">触发条件 (关键词)</Label>
                    <Input 
                      id="keywords" 
                      defaultValue={editingRule ? editingRule.keywords.join(", ") : ""} 
                      placeholder="多个关键词用逗号分隔..." 
                      className="h-10" 
                    />
                  </div>
                )}

                <div className="space-y-2">
                  <Label className="font-bold text-sm">回复文字内容</Label>
                  <Textarea 
                    id="reply-text" 
                    defaultValue={editingRule ? editingRule.replyText : ""} 
                    placeholder="输入自动回复的文字（如果为空则只发图片）..." 
                    rows={4} 
                    className="text-base" 
                  />
                </div>

                <div className="grid grid-cols-2 gap-6 border-t pt-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">账号分配模式</Label>
                    <Select value={selectedAccountMode} onValueChange={setSelectedAccountMode}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="random">随机使用 (Random)</SelectItem>
                        <SelectItem value="rotation">顺序轮换 (Rotation)</SelectItem>
                        <SelectItem value="fixed">手动指定 (Specific)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">选择执行账号</Label>
                    <div className="border rounded-md p-3 space-y-2 bg-muted/20 max-h-[150px] overflow-y-auto">
                      {availableAccounts.map(acc => (
                        <div key={acc} className="flex items-center space-x-2">
                          <Checkbox 
                            id={`acc-${acc}`} 
                            checked={selectedSpecificAccounts.includes(acc)}
                            onCheckedChange={() => toggleAccountSelection(acc)}
                          />
                          <label htmlFor={`acc-${acc}`} className="text-xs font-medium cursor-pointer">{acc}</label>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
              <DialogFooter className="border-t pt-6">
                <Button variant="outline" onClick={() => setIsDialogOpen(false)} className="h-10">
                  取消
                </Button>
                <Button
                  className="h-10 px-8 font-bold"
                  onClick={() => {
                    setIsDialogOpen(false)
                    toast.success("规则保存成功")
                  }}
                >
                  {editingRule ? "保存修改" : "确认添加规则"}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>
      </div>

      <Card className="shadow-sm">
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold pl-6">触发规则</TableHead>
                <TableHead className="text-sm font-bold">模式</TableHead>
                <TableHead className="text-sm font-bold">账号模式</TableHead>
                <TableHead className="text-sm font-bold">回复内容</TableHead>
                <TableHead className="text-sm font-bold">延迟</TableHead>
                <TableHead className="text-sm font-bold text-right pr-6">操作</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredRules.map((rule) => (
                <TableRow key={rule.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="pl-6">
                    {rule.matchType === 'image' ? (
                      <div className="flex items-center gap-2">
                        <div className="size-8 rounded border bg-muted overflow-hidden">
                          {rule.triggerImage ? <img src={rule.triggerImage} className="object-cover w-full h-full" alt="Trigger" /> : <ImageIcon className="size-4 m-2 text-muted-foreground" />}
                        </div>
                        <Badge variant="outline" className="text-[10px] bg-blue-50 text-blue-700">图片匹配</Badge>
                      </div>
                    ) : (
                      <div className="flex flex-wrap gap-1.5">
                        {rule.keywords.map((keyword: string, i: number) => (
                          <Badge key={i} variant="secondary" className="text-[11px] font-medium h-5 bg-orange-50 text-orange-700 border-orange-200">
                            {keyword}
                          </Badge>
                        ))}
                      </div>
                    )}
                  </TableCell>
                  <TableCell>
                    <Badge variant="outline" className="text-[11px] font-medium h-5 border-primary/20 text-primary">
                      {rule.matchType === "keyword" && "关键词"}
                      {rule.matchType === "exact" && "精确匹配"}
                      {rule.matchType === "regex" && "正则"}
                      {rule.matchType === "image" && "图片识别"}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge className={`${rule.accountMode === 'rotation' ? "bg-purple-600" : "bg-blue-600"} text-[11px] h-5`}>
                      {rule.accountMode === "random" ? "随机使用" : rule.accountMode === "rotation" ? "自动轮换" : "固定账号"}
                    </Badge>
                  </TableCell>
                  <TableCell className="max-w-[200px]">
                    <div className="flex flex-col gap-1">
                      <span className="text-[11px] truncate font-medium">{rule.replyText || "(仅回复图片)"}</span>
                      {rule.replyImage && <span className="text-[9px] text-blue-500 flex items-center font-bold"><ImageIcon className="size-3 mr-1" /> [附带图片回复]</span>}
                    </div>
                  </TableCell>
                  <TableCell className="text-xs font-mono font-bold">{rule.min_delay}-{rule.max_delay}s</TableCell>
                  <TableCell className="text-right pr-6">
                    <div className="flex items-center justify-end gap-2">
                      <Button variant="ghost" size="icon" className="h-9 w-9" onClick={() => handleEditRule(rule)}>
                        <Edit className="size-4" />
                      </Button>
                      <Button variant="ghost" size="icon" className="h-9 w-9 hover:bg-red-50 hover:text-red-600" onClick={() => handleDeleteRule(rule.id)}>
                        <Trash2 className="size-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
              {filteredRules.length === 0 && (
                <TableRow>
                  <TableCell colSpan={6} className="h-24 text-center text-muted-foreground italic">未找到符合搜索条件的规则</TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/shops-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Plus, Trash2, Store, Loader2, RefreshCw, Search, CheckSquare, Square } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

export function ShopsView({ currentUser }: { currentUser: any }) {

  const [shops, setShops] = useState<any[]>([])
  const [newShopId, setNewShopId] = useState('')
  const [isAddingShop, setIsAddingShop] = useState(false)
  const [selectedShopIds, setSelectedShopIds] = useState<string[]>([])
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [searchKeyword, setSearchKeyword] = useState('')
  const [isBatchDeleting, setIsBatchDeleting] = useState(false)
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false)

  useEffect(() => {
    fetchShops()
  }, [])

  const fetchShops = async () => {
    try {
      const res = await fetch('/api/shops')
      const data = await res.json()
      let allShops = data.shops || []

      // 根据用户权限过滤店铺
      if (currentUser?.role !== 'admin' && currentUser?.shops) {
        // 普通用户只看到分配给他们的店铺
        allShops = allShops.filter((shop: any) => currentUser.shops.includes(shop.shop_id))
      }

      setShops(allShops)
    } catch (e) {
      toast.error("加载店铺列表失败")
    }
  }

  const fetchShopInfo = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shop-info?shopId=${shopId}`)
      const data = await res.json()
      return data.shopName || `店铺 ${shopId}`
    } catch (e) {
      console.error("获取店铺信息失败:", e)
      return `店铺 ${shopId}`
    }
  }

  const handleAddShop = async () => {
    if (!newShopId.trim()) {
      toast.error("请输入店铺ID")
      return
    }

    if (!/^\d+$/.test(newShopId.trim())) {
      toast.error("店铺ID必须是数字")
      return
    }

    setIsAddingShop(true)
    try {
      // 先获取店铺名称
      const shopName = await fetchShopInfo(newShopId.trim())

      const res = await fetch('/api/shops', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopId: newShopId.trim(),
          name: shopName
        })
      })

      const data = await res.json()

      if (res.ok) {
        toast.success("店铺添加成功")
        setNewShopId('')
        fetchShops()
        // 触发自定义事件通知其他组件刷新店铺列表
        window.dispatchEvent(new CustomEvent('shops-updated'))
      } else {
        toast.error(data.error || "添加店铺失败")
      }
    } catch (e) {
      toast.error("添加店铺失败")
    } finally {
      setIsAddingShop(false)
    }
  }

  const handleDeleteShop = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shops/${shopId}`, {
        method: 'DELETE'
      })

      if (res.ok) {
        toast.success("店铺删除成功")
        fetchShops()
        // 触发自定义事件通知其他组件刷新店铺列表
        window.dispatchEvent(new CustomEvent('shops-updated'))
        // 移除选中状态
        setSelectedShopIds(prev => prev.filter(id => id !== shopId))
      } else {
        toast.error("删除店铺失败")
      }
    } catch (e) {
      toast.error("删除店铺失败")
    }
  }


  const handleSelectShop = (shopId: string) => {
    setSelectedShopIds(prev =>
      prev.includes(shopId)
        ? prev.filter(id => id !== shopId)
        : [...prev, shopId]
    )
  }

  const handleSelectAllShops = () => {
    if (selectedShopIds.length === filteredShops.length) {
      setSelectedShopIds([])
    } else {
      setSelectedShopIds(filteredShops.map(shop => shop.shop_id))
    }
  }

  const handleBatchDeleteShops = () => {
    if (selectedShopIds.length === 0) return
    setShowBatchDeleteConfirm(true)
  }

  const confirmBatchDeleteShops = async () => {
    setShowBatchDeleteConfirm(false)
    setIsBatchDeleting(true)

    let successCount = 0
    let failCount = 0

    try {
      for (const shopId of selectedShopIds) {
        try {
          const res = await fetch(`/api/shops/${shopId}`, {
            method: 'DELETE'
          })

          if (res.ok) {
            successCount++
          } else {
            failCount++
          }
        } catch (e) {
          failCount++
        }
      }

      if (successCount > 0) {
        toast.success(`批量删除完成：成功 ${successCount} 个${failCount > 0 ? `，失败 ${failCount} 个` : ''}`)
        setSelectedShopIds([])
        fetchShops()
      } else {
        toast.error("批量删除失败")
      }
    } catch (e) {
      toast.error("批量删除过程中发生错误")
    } finally {
      setIsBatchDeleting(false)
    }
  }

  // 过滤店铺列表
  const filteredShops = shops.filter(shop =>
    shop.name?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    shop.shop_id?.includes(searchKeyword)
  )

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">店铺管理</h2>
        <p className="text-muted-foreground">管理微店店铺，添加新店铺并进行全量抓取</p>
        <div className="flex items-center gap-2 mt-2">
          <span className="text-sm text-muted-foreground">当前用户:</span>
          <span className="font-medium">{currentUser?.username}</span>
          <span className={`text-xs px-2 py-1 rounded ${
            currentUser?.role === 'admin'
              ? 'bg-blue-100 text-blue-700'
              : 'bg-gray-100 text-gray-700'
          }`}>
            {currentUser?.role === 'admin' ? '管理员' : '普通用户'}
          </span>
        </div>
      </div>

      {/* 添加新店铺 - 仅管理员可见 */}
      {currentUser?.role === 'admin' && (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Plus className="h-5 w-5" />
            添加新店铺
          </CardTitle>
          <CardDescription>
            输入微店店铺ID，系统会自动获取店铺名称
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex gap-3">
            <div className="flex-1">
              <Input
                placeholder="输入店铺ID (例如: 1713062461)"
                value={newShopId}
                onChange={(e) => setNewShopId(e.target.value)}
                disabled={isAddingShop}
                onKeyPress={(e) => e.key === 'Enter' && handleAddShop()}
              />
            </div>
            <Button
              onClick={handleAddShop}
              disabled={!newShopId.trim() || isAddingShop}
            >
              {isAddingShop ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  添加中...
                </>
              ) : (
                <>
                  <Plus className="mr-2 h-4 w-4" />
                  添加店铺
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
      )}


      {/* 店铺列表 */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <Store className="h-5 w-5" />
                店铺列表 ({shops.length})
              </CardTitle>
              <CardDescription>
                已添加的店铺，支持批量全量抓取和删除
              </CardDescription>
            </div>
            {selectedShopIds.length > 0 && currentUser?.role === 'admin' && (
              <Button
                variant="destructive"
                size="sm"
                onClick={handleBatchDeleteShops}
                disabled={isBatchDeleting}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                删除选中 ({selectedShopIds.length})
              </Button>
            )}
          </div>
        </CardHeader>

        {/* 搜索和操作工具栏 */}
        {shops.length > 0 && (
          <div className="px-6 pb-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="搜索店铺名称或ID..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                    disabled={isShopScraping}
                  />
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Button
                  variant={selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "secondary" : "outline"}
                  size="sm"
                  onClick={handleSelectAllShops}
                  disabled={isShopScraping || filteredShops.length === 0}
                >
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length
                    ? <CheckSquare className="mr-2 h-4 w-4" />
                    : <Square className="mr-2 h-4 w-4" />
                  }
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "取消全选" : "全选"}
                </Button>
              </div>
            </div>

            {/* 搜索结果状态 */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                搜索结果: <span className="font-medium">{filteredShops.length}</span> 个店铺
                <span className="ml-2">关键词: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}

            {/* 选中状态 */}
            {selectedShopIds.length > 0 && (
              <div className="mt-2 text-sm text-blue-700 bg-blue-50 px-3 py-2 rounded-md border border-blue-200">
                已选择 <span className="font-medium">{selectedShopIds.length}</span> 个店铺
              </div>
            )}
          </div>
        )}
        <CardContent>
          {shops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Store className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">暂无店铺</p>
              <p className="text-sm">请先添加店铺ID</p>
            </div>
          ) : filteredShops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">未找到匹配的店铺</p>
              <p className="text-sm">尝试调整搜索关键词</p>
            </div>
          ) : (
            <div className="space-y-3">
              {filteredShops.map((shop) => (
                <div
                  key={shop.shop_id}
                  className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50 transition-colors"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <input
                      type="checkbox"
                      checked={selectedShopIds.includes(shop.shop_id)}
                      onChange={() => handleSelectShop(shop.shop_id)}
                      disabled={isShopScraping}
                      className="rounded border-gray-300"
                    />
                    <div className="flex-1">
                      <div className="font-medium">{shop.name}</div>
                      <div className="text-sm text-muted-foreground">
                        ID: {shop.shop_id}{shop.product_count > 0 ? ` • 商品数: ${shop.product_count}` : ''}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        添加时间: {(() => {
                          try {
                            const date = new Date(shop.created_at);
                            return isNaN(date.getTime()) ? '未知时间' : date.toLocaleString('zh-CN');
                          } catch {
                            return '未知时间';
                          }
                        })()}
                      </div>
                    </div>
                  </div>
                  {(currentUser?.role === 'admin' || currentUser?.shops?.includes(shop.shop_id)) && (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => handleDeleteShop(shop.shop_id)}
                    disabled={isShopScraping}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                  )}
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* 批量删除确认对话框 */}
      <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>确认批量删除</DialogTitle>
            <DialogDescription>
              确定要删除选中的 {selectedShopIds.length} 个店铺吗？此操作不可恢复。
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
              取消
              </Button>
            <Button variant="destructive" onClick={confirmBatchDeleteShops} disabled={isBatchDeleting}>
              {isBatchDeleting ? "删除中..." : "确认删除"}
              </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
--- File: ./frontend/components/users-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Shield, User, Users, Edit, Trash2, Save, Search } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
  is_active: boolean
  created_at: string
}

export function UsersView() {
  const [users, setUsers] = useState<User[]>([])
  const [shops, setShops] = useState<any[]>([])
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingUser, setEditingUser] = useState<User | null>(null)
  const [newUser, setNewUser] = useState({
    username: "",
    password: "",
    role: "user",
    shops: [] as string[]
  })
  const [loading, setLoading] = useState(true)

  const [resetPasswordUser, setResetPasswordUser] = useState<User | null>(null)
  const [newPassword, setNewPassword] = useState("")
  const [deleteUserConfirm, setDeleteUserConfirm] = useState<User | null>(null)

  // Pagination State
  const [page, setPage] = useState(1)
  const itemsPerPage = 10
  const [searchKeyword, setSearchKeyword] = useState('')

  // 过滤用户列表
  const filteredUsers = users.filter(user =>
    user.username?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    user.role?.toLowerCase().includes(searchKeyword.toLowerCase())
  )

  // 计算分页数据
  const paginatedUsers = filteredUsers.slice((page-1)*itemsPerPage, page*itemsPerPage)
  const totalPages = Math.ceil(filteredUsers.length / itemsPerPage)

  useEffect(() => {
    fetchUsers()
    fetchShops()
  }, [])

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users')
      if (response.ok) {
        const data = await response.json()
        setUsers((data.users || []).map((u: any) => ({ ...u, shops: Array.isArray(u.shops) ? u.shops : [] })))
      }
    } catch (error) {
      console.error('Failed to fetch users:', error)
    } finally {
      setLoading(false)
    }
  }

  const fetchShops = async () => {
    try {
      const response = await fetch('/api/shops')
      if (response.ok) {
        const data = await response.json()
        setShops(data.shops || [])
      }
    } catch (error) {
      console.error('Failed to fetch shops:', error)
    }
  }

  const handleCreateUser = async () => {
    if (!newUser.username || !newUser.password) {
      toast.error("请输入用户名和密码")
      return
    }

    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      })

      if (response.ok) {
        const data = await response.json()
        setUsers([...users, { ...data.user, shops: Array.isArray(data.user?.shops) ? data.user.shops : [] }])
        toast.success("用户创建成功")
        setIsDialogOpen(false)
        setNewUser({ username: "", password: "", role: "user", shops: [] })
      } else {
        const error = await response.json()
        toast.error(error.error || "创建用户失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleDeleteUser = (user: User) => {
    setDeleteUserConfirm(user)
  }

  const confirmDeleteUser = async () => {
    if (!deleteUserConfirm) return

    try {
      const response = await fetch(`/api/users/${deleteUserConfirm.id}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        setUsers(users.filter(u => u.id !== deleteUserConfirm.id))
        toast.success("用户删除成功")
        setDeleteUserConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "删除用户失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const handleResetPassword = async () => {
      if (!resetPasswordUser || !newPassword) return
      try {
          const res = await fetch(`/api/users/${resetPasswordUser.id}/password`, {
              method: 'PUT',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ password: newPassword })
          })
          if (res.ok) {
              toast.success("密码修改成功")
              setResetPasswordUser(null)
              setNewPassword("")
          } else {
              toast.error("修改失败")
          }
      } catch(e) { toast.error("网络错误") }
  }

  const handleUpdateUserShops = async (userId: number, shopIds: string[]) => {
    try {
      const response = await fetch(`/api/users/${userId}/shops`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shops: shopIds })
      })

      if (response.ok) {
        setUsers(users.map(u => u.id === userId ? { ...u, shops: shopIds } : u))
        toast.success("权限更新成功")
        setEditingUser(null)
      } else {
        toast.error("权限更新失败")
      }
    } catch (error) {
      toast.error("网络错误，请重试")
    }
  }

  const getShopNames = (shopIds?: string[]) => {
    const safeIds = Array.isArray(shopIds) ? shopIds : []
    return safeIds.map(id => {
      const shop = shops.find(s => s.shop_id === id)
      return shop ? shop.name : id
    }).join(', ')
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">用户权限管理</h2>
          <p className="text-sm text-muted-foreground mt-1">创建用户并分配店铺管理权限</p>
        </div>
        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 size-5" />
              创建用户
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl">创建新用户</DialogTitle>
              <DialogDescription>设置用户名、密码和权限</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>用户名</Label>
                <Input
                  value={newUser.username}
                  onChange={(e) => setNewUser({...newUser, username: e.target.value})}
                  placeholder="请输入用户名"
                />
              </div>
              <div className="space-y-2">
                <Label>密码</Label>
                <Input
                  type="password"
                  value={newUser.password}
                  onChange={(e) => setNewUser({...newUser, password: e.target.value})}
                  placeholder="请输入密码"
                />
              </div>
              <div className="space-y-2">
                <Label>角色</Label>
                <Select value={newUser.role} onValueChange={(value) => setNewUser({...newUser, role: value})}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="user">普通用户</SelectItem>
                    <SelectItem value="admin">管理员</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label>管理的店铺</Label>
                <div className="max-h-32 overflow-y-auto border rounded p-2 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={shop.shop_id}
                        checked={newUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          if (checked) {
                            setNewUser({...newUser, shops: [...newUser.shops, shop.shop_id]})
                          } else {
                            setNewUser({...newUser, shops: newUser.shops.filter(id => id !== shop.shop_id)})
                          }
                        }}
                      />
                      <Label htmlFor={shop.shop_id} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>取消</Button>
              <Button onClick={handleCreateUser}>创建用户</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>

      <Card className="shadow-sm">
        <CardHeader className="py-5 border-b">
          <CardTitle className="text-2xl font-bold">用户列表</CardTitle>
          <CardDescription className="text-sm">
            共 {users.length} 个用户
          </CardDescription>
        </CardHeader>

        {/* 搜索工具栏 */}
        {users.length > 0 && (
          <div className="px-6 py-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="搜索用户名或角色..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                  />
                </div>
              </div>
            </div>

            {/* 搜索结果状态 */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                搜索结果: <span className="font-medium">{filteredUsers.length}</span> 个用户
                <span className="ml-2">关键词: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}
          </div>
        )}
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold text-foreground pl-6">用户名</TableHead>
                <TableHead className="text-sm font-bold text-foreground">角色</TableHead>
                <TableHead className="text-sm font-bold text-foreground">管理店铺</TableHead>
                <TableHead className="text-sm font-bold text-foreground">状态</TableHead>
                <TableHead className="text-sm font-bold text-foreground text-right pr-6">操作</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {paginatedUsers.map((user) => (
                <TableRow key={user.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="font-medium py-3 pl-6">
                    <div className="flex items-center gap-2">
                      {user.role === 'admin' ? (
                        <Shield className="size-4 text-blue-600" />
                      ) : (
                        <User className="size-4 text-gray-600" />
                      )}
                      <span className="text-base font-semibold">{user.username}</span>
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.role === 'admin' ? (
                      <Badge className="bg-blue-600">管理员</Badge>
                    ) : (
                      <Badge variant="secondary">普通用户</Badge>
                    )}
                  </TableCell>
                  <TableCell className="py-3">
                    <div className="text-sm max-w-xs truncate" title={getShopNames(user.shops)}>
                      {user.shops.length > 0 ? getShopNames(user.shops) : "无"}
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.is_active ? (
                      <Badge className="bg-green-600">活跃</Badge>
                    ) : (
                      <Badge variant="secondary">禁用</Badge>
                    )}
                  </TableCell>
                  <TableCell className="text-right pr-6 py-3">
                    <div className="flex items-center justify-end gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setResetPasswordUser(user)}
                      >
                        修改密码
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingUser(user)}
                      >
                        <Edit className="size-4 mr-1" />
                        权限
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteUser(user)}
                        className="text-red-600 hover:text-red-700 hover:bg-red-50"
                      >
                        <Trash2 className="size-4 mr-1" />
                        删除
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* 编辑用户权限对话框 */}
      {editingUser && (
        <Dialog open={!!editingUser} onOpenChange={() => setEditingUser(null)}>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle>编辑用户权限 - {editingUser.username}</DialogTitle>
              <DialogDescription>修改用户管理的店铺权限</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>管理的店铺</Label>
                <div className="max-h-48 overflow-y-auto border rounded p-3 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={`edit-${shop.shop_id}`}
                        checked={editingUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          const newShops = checked
                            ? [...editingUser.shops, shop.shop_id]
                            : editingUser.shops.filter(id => id !== shop.shop_id)
                          setEditingUser({...editingUser, shops: newShops})
                        }}
                      />
                      <Label htmlFor={`edit-${shop.shop_id}`} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
                {shops.length === 0 && (
                  <p className="text-sm text-muted-foreground">暂无店铺，请先添加店铺</p>
                )}
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingUser(null)}>取消</Button>
              <Button onClick={() => handleUpdateUserShops(editingUser.id, editingUser.shops)}>
                <Save className="size-4 mr-1" />
                保存权限
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}

      {/* 分页控件 */}
      {totalPages > 1 && (
        <div className="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6 px-6 py-4 border-t bg-muted/5">
          <div className="text-sm text-muted-foreground font-medium">
            显示第 {(page-1)*itemsPerPage + 1} - {Math.min(page*itemsPerPage, filteredUsers.length)} 条，共 {filteredUsers.length} 条记录
          </div>
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                disabled={page===1}
                onClick={()=>setPage(p=>p-1)}
                className="h-8 px-3"
              >
                上一页
              </Button>
              <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                {page} / {totalPages}
              </div>
              <Button
                variant="outline"
                size="sm"
                disabled={page===totalPages}
                onClick={()=>setPage(p=>p+1)}
                className="h-8 px-3"
              >
                下一页
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Reset Password Dialog */}
      <Dialog open={!!resetPasswordUser} onOpenChange={()=>setResetPasswordUser(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>重置密码 - {resetPasswordUser?.username}</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <Label>新密码</Label>
            <Input type="password" value={newPassword} onChange={e=>setNewPassword(e.target.value)} />
          </div>
          <DialogFooter>
            <Button onClick={handleResetPassword}>确认修改</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* 删除用户确认对话框 */}
      <Dialog open={!!deleteUserConfirm} onOpenChange={() => setDeleteUserConfirm(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>确认删除用户</DialogTitle>
            <DialogDescription>
              确定要删除用户 "{deleteUserConfirm?.username}" 吗？此操作不可恢复！
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteUserConfirm(null)}>
              取消
            </Button>
            <Button variant="destructive" onClick={confirmDeleteUser}>
              确认删除
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}

--- File: ./frontend/hooks/use-api-cache.ts ---
import { useState, useCallback } from 'react'

interface CacheEntry {
  data: any
  timestamp: number
}

export function useApiCache(cacheDuration: number = 30000) {
  const [cache, setCache] = useState<{[key: string]: CacheEntry}>({})

  const cachedFetch = useCallback(async (url: string, options?: RequestInit): Promise<any> => {
    const cacheKey = `${options?.method || 'GET'}:${url}`
    const now = Date.now()

    // 检查缓存
    const cached = cache[cacheKey]
    if (cached && (now - cached.timestamp) < cacheDuration) {
      console.log(`使用缓存数据: ${cacheKey}`)
      return cached.data
    }

    // 发起新请求
    console.log(`发起API请求: ${cacheKey}`)
    const response = await fetch(url, options)
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`)
    }
    const data = await response.json()

    // 更新缓存
    setCache(prev => ({
      ...prev,
      [cacheKey]: { data, timestamp: now }
    }))

    return data
  }, [cache, cacheDuration])

  const clearCache = useCallback(() => {
    setCache({})
  }, [])

  const invalidateCache = useCallback((url: string, method: string = 'GET') => {
    const cacheKey = `${method}:${url}`
    setCache(prev => {
      const newCache = { ...prev }
      delete newCache[cacheKey]
      return newCache
    })
  }, [])

  return { cachedFetch, clearCache, invalidateCache }
}

--- File: ./frontend/hooks/use-mobile.ts ---
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener('change', onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener('change', onChange)
  }, [])

  return !!isMobile
}

--- File: ./frontend/hooks/use-toast.ts ---
'use client'

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '@/components/ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }

--- File: ./frontend/lib/utils.ts ---
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(dateString: string | undefined | null): string {
  if (!dateString) return '未知时间'

  try {
    const date = new Date(dateString)
    if (isNaN(date.getTime())) return '无效时间'

    return new Intl.DateTimeFormat('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
      timeZone: 'Asia/Shanghai'
    }).format(date)
  } catch {
    return '时间格式错误'
  }
}

--- File: ./backend/config.py ---
import os
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

class Config:
    # === 基础配置 ===
    HOST = '0.0.0.0'
    PORT = 5001
    DEBUG = False  # 生产环境建议关闭调试模式以减少日志

    # === 关键修复：SECRET_KEY 必须在类里面 ===
    SECRET_KEY = 'my-fixed-secret-key-888888'

    # === Session配置 ===
    SESSION_COOKIE_SECURE = False
    SESSION_COOKIE_SAMESITE = 'Lax'
    SESSION_LIFETIME = 86400 * 30

    # === CORS ===
    CORS_ORIGINS = ["*"]

    # === 设备配置 ===
    DEVICE = os.getenv('DEVICE', 'cpu')

    # === Discord 配置 ===
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = 0.6

    # === 延迟配置 ===
    GLOBAL_REPLY_MIN_DELAY = 3.0
    GLOBAL_REPLY_MAX_DELAY = 8.0

    # === 频道配置 ===
    CNFANS_CHANNEL_ID = 0
    ACBUY_CHANNEL_ID = 0
    FORWARD_KEYWORDS = []
    FORWARD_TARGET_CHANNEL_ID = 0

    # === API 地址 ===
    BACKEND_API_URL = os.getenv('BACKEND_API_URL', 'http://127.0.0.1:5001')
    NEXTJS_API_URL = f'{BACKEND_API_URL}/api'

    # === 机器人 ===
    COMMAND_PREFIX = '!'

    # === AI 模型 ===
    DINO_MODEL_NAME = 'facebook/dinov2-small'
    VECTOR_DIMENSION = 384
    YOLO_MODEL_PATH = 'yolov8s-world.pt'
    USE_YOLO_CROP = True

    # === 多线程配置 (针对 10核 CPU 优化) ===
    # 商品信息抓取是IO密集型，可以开大
    SCRAPE_THREADS = int(os.getenv('SCRAPE_THREADS', '10'))
    
    # 图片下载也是IO密集型，可以开更大
    DOWNLOAD_THREADS = int(os.getenv('DOWNLOAD_THREADS', '16'))

    # AI 推理的并发控制 (CPU密集型)：
    # - AI_INTRA_THREADS：单个推理任务内部使用的 CPU 核心数
    # - AI_MAX_WORKERS：同时跑多少个"图片特征提取任务"
    # 【优化建议】如果是 10核 CPU，单次搜索设为 4-6 可以显著加快单张图的搜索速度
    # 【修复】从6改为4，为Flask Web服务留出CPU核心，避免Bot和Web服务争抢资源导致UI卡死
    # 优化后策略：单张图搜索使用4核，批量抓取时2个Worker * 4核 = 8核，留2核给Flask
    AI_INTRA_THREADS = int(os.getenv('AI_INTRA_THREADS', '4'))
    AI_MAX_WORKERS = int(os.getenv('AI_MAX_WORKERS', '2'))

    # 新的 save_product_images_unified 已不依赖该参数做图片特征线程池，保留字段主要用于兼容旧逻辑。
    FEATURE_EXTRACT_THREADS = int(os.getenv('FEATURE_EXTRACT_THREADS', '4'))

    # === FAISS ===
    FAISS_HNSW_M = 64
    FAISS_EF_CONSTRUCTION = 80
    FAISS_EF_SEARCH = 80

    # === 路径 ===
    BASE_DIR = os.path.dirname(os.path.dirname(__file__))
    DATA_DIR = os.path.join(BASE_DIR, 'backend', 'data')
    # 确保这些路径是绝对路径
    IMAGE_SAVE_DIR = os.path.join(DATA_DIR, 'scraped_images')
    LOG_DIR = os.path.join(DATA_DIR, 'logs')
    DATABASE_PATH = os.path.join(DATA_DIR, 'metadata.db')

    FAISS_INDEX_FILE = os.path.join(DATA_DIR, 'faiss_index.bin')
    FAISS_ID_MAP_FILE = os.path.join(DATA_DIR, 'faiss_id_map.pkl')

    # === 网络 ===
    REQUEST_TIMEOUT = 30
    MAX_RETRIES = 3

    @classmethod
    def init_dirs(cls):
        for dir_path in [cls.DATA_DIR, cls.IMAGE_SAVE_DIR, cls.LOG_DIR]:
            os.makedirs(dir_path, exist_ok=True)

# 初始化
config = Config()
config.init_dirs()

--- File: ./backend/database.py ---
import sqlite3
import numpy as np
import os
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager
try:
    from config import config
except ImportError:
    from .config import config

logger = logging.getLogger(__name__)

class Database:
    def __init__(self):
        # SQLite 数据库路径 (用于存储商品元数据和Discord账号信息)
        self.db_path = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

        # 确保数据目录存在
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # 初始化 SQLite 数据库
        self.init_sqlite_database()

    def init_sqlite_database(self):
        """初始化 SQLite 数据库 (用于元数据存储)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # 创建商品表（移除商品级别延迟，使用全局延迟）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_url TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    english_title TEXT,
                    cnfans_url TEXT,
                    acbuy_url TEXT,
                    shop_name TEXT,
                    ruleEnabled BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建索引以优化查询性能
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_shop_name ON products(shop_name)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_rule_enabled ON products(ruleEnabled)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_image_index ON product_images(image_index)')
            except sqlite3.OperationalError:
                pass

            # 创建店铺表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS shops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    shop_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    product_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 为现有表添加新字段（如果不存在）
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN ruleEnabled BOOLEAN DEFAULT 1')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN min_delay INTEGER DEFAULT 3')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN max_delay INTEGER DEFAULT 8')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            # 新增英文标题与 cnfans 链接字段（兼容已有数据库）
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN english_title TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN cnfans_url TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN acbuy_url TEXT')
            except sqlite3.OperationalError:
                pass

            # 添加自定义回复字段
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_text TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_images TEXT')  # JSON格式存储图片索引数组
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_image_urls TEXT')  # JSON格式存储自定义图片URL数组
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN image_source TEXT DEFAULT \'product\'')  # 图片来源：'product'(商品图片), 'upload'(本地上传), 'custom'(URL)
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN shop_name TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN item_id TEXT')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN updated_at TIMESTAMP')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN uploaded_reply_images TEXT')  # JSON格式存储上传的自定义回复图片文件名数组
            except sqlite3.OperationalError:
                pass  # 字段已存在

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN cnfans_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN acbuy_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            # 创建图片表 (milvus_id 替代 faiss_id)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS product_images (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    image_index INTEGER NOT NULL,
                    features TEXT,  -- 存储序列化的特征向量
                    milvus_id INTEGER UNIQUE,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE,
                    UNIQUE(product_id, image_index)
                )
            ''')

            # 创建用户表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT DEFAULT 'user',  -- admin, user
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建用户-店铺权限表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_shop_permissions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    shop_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id, shop_id)
                )
            ''')

            # 创建 Discord 账号表（关联到用户）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS discord_accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    token TEXT UNIQUE NOT NULL,
                    user_id INTEGER,
                    status TEXT DEFAULT 'offline',
                    last_active TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL
                )
            ''')

            # 插入默认管理员用户
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO users (id, username, password_hash, role, is_active)
                    VALUES (1, 'admin', 'hashed_admin123', 'admin', 1)
                ''')  # 密码: admin123
            except sqlite3.Error as e:
                logger.warning(f"创建默认管理员失败: {e}")

            # 创建账号轮换配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS account_rotation_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    enabled BOOLEAN DEFAULT 0,
                    rotation_interval INTEGER DEFAULT 10,
                    current_account_id INTEGER,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认轮换配置
            cursor.execute('''
                INSERT OR IGNORE INTO account_rotation_config (id, enabled, rotation_interval)
                VALUES (1, 0, 10)
            ''')

            # 创建搜索历史表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS search_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    query_image_path TEXT NOT NULL,
                    matched_product_id INTEGER,
                    matched_image_index INTEGER,
                    similarity REAL NOT NULL,
                    threshold REAL NOT NULL,
                    search_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (matched_product_id) REFERENCES products (id) ON DELETE SET NULL
                )
            ''')

            # 【新增优化】为搜索历史创建时间索引，极大提升翻页速度
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_search_history_time ON search_history(search_time DESC)')
            except Exception:
                pass

            # 创建全局延迟配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS global_reply_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    min_delay REAL DEFAULT 3.0,
                    max_delay REAL DEFAULT 8.0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建系统配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    discord_channel_id TEXT DEFAULT '',
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    cnfans_channel_id TEXT DEFAULT '',
                    acbuy_channel_id TEXT DEFAULT '',
                    scrape_threads INTEGER DEFAULT 2,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认系统配置
            cursor.execute('''
                INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                VALUES (1, '', 4, 4, 0.6, '', '')
            ''')

            # 为现有记录添加scrape_threads字段
            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN scrape_threads INTEGER DEFAULT 2')
            except sqlite3.OperationalError:
                pass  # 字段已存在

            # 创建网站配置表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_configs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    display_name TEXT NOT NULL,
                    url_template TEXT NOT NULL,
                    id_pattern TEXT NOT NULL,
                    badge_color TEXT DEFAULT 'blue',
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,  -- 是否启用轮换功能 (1=启用, 0=禁用)
                    message_filters TEXT DEFAULT '[]',  -- JSON格式存储过滤条件数组
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 为website_configs表添加rotation_interval字段
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_interval INTEGER DEFAULT 180')
            except sqlite3.OperationalError:
                pass

            # 为website_configs表添加message_filters字段
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN message_filters TEXT DEFAULT \'[]\'')
            except sqlite3.OperationalError:
                pass

            # 为website_configs表添加rotation_enabled字段
            try:
                cursor.execute('ALTER TABLE website_configs ADD COLUMN rotation_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # 1. 消息处理去重表（防止多个Bot回复同一条消息）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS processed_messages (
                    message_id TEXT PRIMARY KEY,
                    processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建自定义回复内容表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS custom_replies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reply_type TEXT NOT NULL, -- 'text', 'image', 'text_and_link', 'custom_only'
                    content TEXT, -- 文字内容或图片URL
                    image_url TEXT, -- 如果是图片回复
                    is_active BOOLEAN DEFAULT 1,
                    priority INTEGER DEFAULT 0, -- 优先级，数字越大优先级越高
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 2. 修改频道绑定表，增加 user_id 实现用户隔离
            try:
                cursor.execute('ALTER TABLE website_channel_bindings ADD COLUMN user_id INTEGER')
            except sqlite3.OperationalError:
                pass

            # 创建网站频道绑定表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_channel_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    channel_id TEXT NOT NULL,
                    user_id INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(website_id, channel_id)
                )
            ''')

            # 创建网站账号绑定表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_account_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    account_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    role TEXT NOT NULL CHECK (role IN ('listener', 'sender', 'both')),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    FOREIGN KEY (account_id) REFERENCES discord_accounts (id) ON DELETE CASCADE,
                    UNIQUE(website_id, account_id)
                )
            ''')

            # 创建系统公告表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_announcements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建消息过滤规则表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS message_filters (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filter_type TEXT NOT NULL, -- 'contains', 'starts_with', 'ends_with', 'regex'
                    filter_value TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建用户设置表（每个用户的个性化设置）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    global_reply_min_delay REAL DEFAULT 3.0,
                    global_reply_max_delay REAL DEFAULT 8.0,
                    user_blacklist TEXT DEFAULT '',  -- 用户黑名单，逗号分隔
                    keyword_filters TEXT DEFAULT '',  -- 关键词过滤，逗号分隔
                    keyword_reply_enabled INTEGER DEFAULT 1,  -- 是否启用关键词回复
                    image_reply_enabled INTEGER DEFAULT 1,  -- 是否启用图片回复
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id)
                )
            ''')

            # 为 user_settings 表添加新字段（如果不存在）
            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN keyword_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE user_settings ADD COLUMN image_reply_enabled INTEGER DEFAULT 1')
            except sqlite3.OperationalError:
                pass

            # 创建用户级别的网站设置表（轮换设置和消息过滤）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_website_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    website_id INTEGER NOT NULL,
                    rotation_interval INTEGER DEFAULT 180,
                    rotation_enabled INTEGER DEFAULT 1,
                    message_filters TEXT DEFAULT '[]',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(user_id, website_id)
                )
            ''')

            # 创建抓取状态表（持久化存储抓取状态）
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scrape_status (
                    id INTEGER PRIMARY KEY CHECK (id = 1),  -- 只允许一条记录
                    is_scraping BOOLEAN DEFAULT 0,
                    stop_signal BOOLEAN DEFAULT 0,
                    current_shop_id TEXT,
                    total INTEGER DEFAULT 0,
                    processed INTEGER DEFAULT 0,
                    success INTEGER DEFAULT 0,
                    progress REAL DEFAULT 0,
                    message TEXT DEFAULT '等待开始...',
                    completed BOOLEAN DEFAULT 0,
                    thread_id TEXT,  -- 记录当前线程ID
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 插入默认网站配置
            cursor.execute('''
                INSERT OR IGNORE INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                VALUES
                    ('cnfans', 'CNFans', 'https://cnfans.com/product?id={id}&platform=WEIDIAN', '{id}', 'blue'),
                    ('acbuy', 'AcBuy', 'https://www.acbuy.com/product?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD', '{id}', 'orange'),
                    ('weidian', '微店', 'https://weidian.com/item.html?itemID={id}', '{id}', 'gray')
            ''')

            # 插入默认状态记录
            cursor.execute('''
                INSERT OR IGNORE INTO scrape_status (id, is_scraping, stop_signal, message)
                VALUES (1, 0, 0, '等待开始...')
            ''')

            # 插入默认全局延迟配置
            cursor.execute('''
                INSERT OR IGNORE INTO global_reply_config (id, min_delay, max_delay)
                VALUES (1, 3.0, 8.0)
            ''')

            conn.commit()

    def cleanup_processed_messages(self):
        """清理旧的消息处理记录，只保留最近1小时的记录"""
        try:
            with self.get_connection() as conn:
                conn.execute("DELETE FROM processed_messages WHERE processed_at < datetime('now', '-1 hour')")
                conn.commit()
        except Exception as e:
            logger.error(f"清理消息记录失败: {e}")


    @contextmanager
    def get_connection(self):
        """获取 SQLite 数据库连接的上下文管理器"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0) # 增加超时时间
            conn.row_factory = sqlite3.Row

            # 关键优化：开启 WAL 模式
            conn.execute('PRAGMA journal_mode=WAL;')
            conn.execute('PRAGMA synchronous=NORMAL;') # 稍微降低安全性以换取性能

            yield conn
        except sqlite3.IntegrityError:
            # 这是一个逻辑控制信号（如唯一性约束），直接抛出给上层处理，不记录为连接错误
            raise
        except Exception as e:
            logger.error("数据库连接失败: %s", str(e))
            raise
        finally:
            if conn:
                conn.close()

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> List[Dict]:
        """执行查询并返回结果"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            if fetch:
                results = [dict(row) for row in cursor.fetchall()]
                conn.commit()
                return results
            conn.commit()
            return []

    def insert_product(self, product_data: Dict) -> int:
        """插入商品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO products
                (product_url, title, description, english_title, cnfans_url, acbuy_url, shop_name, ruleEnabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                product_data['product_url'],
                product_data.get('title', ''),
                product_data.get('description', ''),
                product_data.get('english_title', ''),
                product_data.get('cnfans_url', ''),
                product_data.get('acbuy_url', ''),
                product_data.get('shop_name', ''),
                product_data.get('ruleEnabled', True)
            ))
            product_id = cursor.lastrowid
            conn.commit()
            return product_id

    def insert_image_record(self, product_id: int, image_path: str, image_index: int, features: np.ndarray = None) -> int:
        """插入图像记录到数据库，返回记录ID供FAISS使用"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 将特征向量序列化为字符串存储
                features_str = None
                if features is not None:
                    import json
                    features_str = json.dumps(features.tolist())

                cursor.execute('''
                    INSERT INTO product_images
                    (product_id, image_path, image_index, features)
                    VALUES (?, ?, ?, ?)
                ''', (product_id, image_path, image_index, features_str))
                conn.commit()
                record_id = cursor.lastrowid
                logger.info(f"图像记录插入成功: product_id={product_id}, image_index={image_index}, record_id={record_id}")
                return record_id

        except Exception as e:
            logger.error(f"插入图像记录失败: {e}")
            raise e

    def search_similar_images(self, query_vector: np.ndarray, limit: int = 1,
                             threshold: float = 0.6, user_shops: Optional[List[str]] = None) -> List[Dict]:
        """使用FAISS搜索相似图像"""
        import time
        start_time = time.time()

        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine

            logger.info(f"开始获取FAISS引擎...")
            engine_start = time.time()
            engine = get_vector_engine()
            logger.info(f"获取FAISS引擎耗时: {time.time() - engine_start:.3f}秒")

            print(f"DEBUG DB: Starting FAISS search, threshold: {threshold}, limit: {limit}")
            print(f"DEBUG DB: Query vector length: {len(query_vector) if hasattr(query_vector, '__len__') else 'unknown'}")

            # 执行FAISS搜索
            faiss_start = time.time()
            faiss_results = engine.search(query_vector, top_k=min(limit * 3, 50))
            logger.info(f"FAISS搜索耗时: {time.time() - faiss_start:.3f}秒")
            print(f"DEBUG DB: FAISS search returned {len(faiss_results)} results")

            matched_results = []

            for result in faiss_results:
                score = result['score']
                db_id = result['db_id']

                print(f"DEBUG DB: Processing result - db_id: {db_id}, score: {score}, threshold: {threshold}")

                # 通过image_db_id获取产品信息
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    print(f"DEBUG DB: Found image info for db_id {db_id}: product_id={image_info['product_id']}")
                    product_info = self._get_product_info_by_id(image_info['product_id'])

                    if product_info:
                        # 如果指定了用户店铺权限，进行过滤
                        if user_shops and product_info.get('shop_name') not in user_shops:
                            print(f"DEBUG DB: Skipping product from shop {product_info.get('shop_name')} - not in user shops {user_shops}")
                            continue

                        print(f"DEBUG DB: Found product info for product_id {image_info['product_id']}: ruleEnabled={product_info.get('ruleEnabled', True)}")
                        result_dict = {
                            **product_info,
                            'similarity': score,
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added result with similarity {score}")

                        # 如果找到了足够的结果，就停止
                        if len(matched_results) >= limit:
                            break
                    else:
                        print(f"DEBUG DB: Product info not found for product_id {image_info['product_id']}")
                else:
                    print(f"DEBUG DB: Image info not found for db_id {db_id}")

            # 如果没有找到任何结果，返回最佳匹配（即使低于阈值）
            if not matched_results and faiss_results:
                print(f"DEBUG DB: No results above threshold {threshold}, returning best match")
                best_result = faiss_results[0]
                db_id = best_result['db_id']
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    product_info = self._get_product_info_by_id(image_info['product_id'])
                    if product_info:
                        result_dict = {
                            **product_info,
                            'similarity': best_result['score'],
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added best match with similarity {best_result['score']}")

            return matched_results

        except Exception as e:
            logger.error(f"FAISS搜索失败: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _get_product_url_by_id(self, product_id: int) -> Optional[str]:
        """根据产品ID获取产品URL"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT product_url FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return row['product_url'] if row else None

    def get_image_info_by_id(self, image_id: int) -> Optional[Dict]:
        """根据图像记录ID获取图像信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM product_images WHERE id = ?", (image_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def _get_product_info_by_id(self, product_id: int) -> Optional[Dict]:
        """根据产品ID获取完整的产品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_indexed_product_ids(self) -> List[str]:
        """获取已建立索引的商品URL列表"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT p.product_url
                FROM products p
                JOIN product_images pi ON p.id = pi.product_id
            ''')
            return [row['product_url'] for row in cursor.fetchall()]

    def get_product_images(self, product_id: int) -> List[Dict]:
        """获取商品的所有图片及其特征向量"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, image_path, image_index, features
                    FROM product_images
                    WHERE product_id = ?
                    ORDER BY image_index
                ''', (product_id,))

                images = []
                for row in cursor.fetchall():
                    image_data = dict(row)
                    # 反序列化特征向量
                    if image_data.get('features'):
                        import json
                        try:
                            features_list = json.loads(image_data['features'])
                            image_data['features'] = np.array(features_list, dtype='float32')
                        except Exception as e:
                            logger.warning(f"反序列化特征向量失败: {e}")
                            image_data['features'] = None
                    else:
                        image_data['features'] = None
                    images.append(image_data)

                return images

        except Exception as e:
            logger.error(f"获取商品图片失败: {e}")
            return []

    def delete_product_images(self, product_id: int) -> bool:
        """删除商品的所有图像和物理文件"""
        try:
            # 获取该商品的所有图像记录ID和文件路径
            image_records = []
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ?", (product_id,))
                image_records = [{'id': row['id'], 'path': row['image_path']} for row in cursor.fetchall()]

            if image_records:
                # 从FAISS中删除向量
                try:
                    # 优先尝试绝对导入
                    from vector_engine import get_vector_engine
                except ImportError:
                    try:
                        # 尝试相对导入
                        from .vector_engine import get_vector_engine
                    except ImportError:
                        # 如果都失败，跳过FAISS操作
                        logger.warning("无法导入vector_engine，跳过FAISS向量删除")
                        engine = None
                    else:
                        engine = get_vector_engine()
                else:
                    engine = get_vector_engine()

                # 如果成功获取到引擎，删除向量
                if engine:
                    for record in image_records:
                        try:
                            engine.remove_vector_by_db_id(record['id'])
                        except Exception as e:
                            logger.warning(f"删除FAISS向量失败 {record['id']}: {e}")

            # 删除物理文件
            for record in image_records:
                if record['path'] and os.path.exists(record['path']):
                    try:
                        os.remove(record['path'])
                        logger.info(f"已删除商品图片文件: {record['path']}")
                    except Exception as e:
                        logger.warning(f"删除商品图片文件失败: {e}")

            # 从 SQLite 删除
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ?", (product_id,))
                cursor.execute("DELETE FROM products WHERE id = ?", (product_id,))
                conn.commit()

            # 保存FAISS索引
            if image_records and engine:
                try:
                    engine.save()
                    logger.info("FAISS索引已保存")
                except Exception as e:
                    logger.warning(f"保存FAISS索引失败: {e}")

            return True
        except Exception as e:
            logger.error(f"删除商品图像失败: {e}")
            return False

    def delete_image_record(self, image_id: int) -> bool:
        """根据图片ID删除图片记录（用于回滚操作）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE id = ?", (image_id,))
                deleted = cursor.rowcount > 0
                if deleted:
                    logger.info(f"已删除图片记录: id={image_id}")
                return deleted
        except Exception as e:
            logger.error(f"删除图片记录失败: {e}")
            return False

    def delete_image_vector(self, product_id: int, image_index: int) -> bool:
        """删除特定的图像向量和物理文件"""
        try:
            # 获取该图像的记录ID和文件路径
            image_path = None
            image_id = None
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))
                row = cursor.fetchone()
                if row:
                    image_id = row['id']
                    image_path = row['image_path']

            if not image_id:
                logger.warning(f"图片不存在: product_id={product_id}, image_index={image_index}")
                return False

            # 从FAISS中删除向量并重建索引
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            success = engine.remove_vector_by_db_id(image_id)
            if not success:
                logger.error(f"FAISS删除向量失败: db_id={image_id}")
                return False

            # 删除物理文件
            if image_path and os.path.exists(image_path):
                try:
                    os.remove(image_path)
                    logger.info(f"已删除图片文件: {image_path}")
                except Exception as e:
                    logger.warning(f"删除图片文件失败: {e}")

            # 从 SQLite 删除记录
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))

               
                conn.commit()

            logger.info(f"图片删除成功: product_id={product_id}, image_index={image_index}")
            return True
        except Exception as e:
            logger.error(f"删除图像向量失败: {e}")
            return False

    def get_product_by_url(self, product_url: str) -> Optional[Dict]:
        """根据商品URL获取商品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_product_by_item_id(self, item_id: str) -> Optional[Dict]:
        """根据微店商品ID获取商品信息"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE item_id = ?", (item_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_all_existing_item_ids(self) -> set:
        """获取数据库中所有已存在的商品item_id，用于快速查重"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT item_id FROM products WHERE item_id IS NOT NULL")
            return {row[0] for row in cursor.fetchall()}

    def cleanup_unused_images(self, days_old: int = 30) -> int:
        """
        清理未使用的图片文件
        删除那些在数据库中不存在记录的图片文件，或者删除超过指定天数的旧图片

        Args:
            days_old: 删除多少天前的图片（默认30天）

        Returns:
            删除的文件数量
        """
        try:
            import os
            import time

            # 获取所有数据库中存在的图片路径
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT image_path FROM product_images")
                db_image_paths = set(row['image_path'] for row in cursor.fetchall())

            # 获取data/images目录下的所有文件
            images_dir = os.path.join('data', 'images')
            if not os.path.exists(images_dir):
                return 0

            deleted_count = 0
            cutoff_time = time.time() - (days_old * 24 * 60 * 60)

            for filename in os.listdir(images_dir):
                filepath = os.path.join(images_dir, filename)

                # 只处理jpg文件
                if not filename.endswith('.jpg'):
                    continue

                # 检查是否在数据库中存在
                if filepath not in db_image_paths:
                    try:
                        os.remove(filepath)
                        logger.info(f"清理未使用的图片文件: {filepath}")
                        deleted_count += 1
                    except Exception as e:
                        logger.warning(f"删除文件失败 {filepath}: {e}")
                # 或者检查是否太旧（即使在数据库中）
                elif os.path.getmtime(filepath) < cutoff_time:
                    # 这里可以选择是否删除旧文件
                    # 暂时保留，避免误删
                    pass

            if deleted_count > 0:
                logger.info(f"图片清理完成，共删除 {deleted_count} 个未使用的文件")

            return deleted_count

        except Exception as e:
            logger.error(f"图片清理失败: {e}")
            return 0

    def get_product_id_by_url(self, product_url: str) -> Optional[int]:
        """根据商品URL获取商品内部ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return row['id'] if row else None

    def get_total_indexed_images(self) -> int:
        """获取已索引的总图片数量"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            return engine.count()
        except Exception as e:
            logger.error(f"获取索引图片数量失败: {e}")
            return 0

    def get_indexed_product_urls(self) -> List[str]:
        """获取已建立索引的商品URL列表"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT DISTINCT p.product_url
                    FROM products p
                    JOIN product_images pi ON p.id = pi.product_id
                ''')
                return [row['product_url'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取已索引商品URL失败: {e}")
            return []

    def add_search_history(self, query_image_path: str, matched_product_id: int,
                          matched_image_index: int, similarity: float, threshold: float) -> bool:
        """添加搜索历史记录"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO search_history
                    (query_image_path, matched_product_id, matched_image_index, similarity, threshold)
                    VALUES (?, ?, ?, ?, ?)
                ''', (query_image_path, matched_product_id, matched_image_index, similarity, threshold))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加搜索历史失败: {e}")
            return False

    def get_search_history(self, limit: int = 50, offset: int = 0) -> Dict:
        """获取搜索历史记录（支持分页）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 获取总数
                cursor.execute('SELECT COUNT(*) FROM search_history')
                total = cursor.fetchone()[0]

                # 获取分页数据
                cursor.execute('''
                    SELECT
                        sh.id,
                        sh.query_image_path,
                        sh.matched_product_id,
                        sh.matched_image_index,
                        sh.similarity,
                        sh.threshold,
                        sh.search_time,
                        p.title,
                        p.english_title,
                        p.product_url as weidian_url,
                        p.cnfans_url,
                        p.acbuy_url,
                        p.ruleEnabled,
                        pi.image_path as matched_image_path
                    FROM search_history sh
                    LEFT JOIN products p ON sh.matched_product_id = p.id
                    LEFT JOIN product_images pi ON sh.matched_product_id = pi.product_id AND sh.matched_image_index = pi.image_index
                    ORDER BY sh.search_time DESC
                    LIMIT ? OFFSET ?
                ''', (limit, offset))
                rows = cursor.fetchall()
                history = []
                for row in rows:
                    history.append({
                        'id': row['id'],
                        'query_image_path': row['query_image_path'],
                        'matched_product_id': row['matched_product_id'],
                        'matched_image_index': row['matched_image_index'],
                        'similarity': row['similarity'],
                        'threshold': row['threshold'],
                        'search_time': row['search_time'],
                        'title': row['title'],
                        'english_title': row['english_title'],
                        'weidian_url': row['weidian_url'],
                        'cnfans_url': row['cnfans_url'],
                        'acbuy_url': row['acbuy_url'],
                        'ruleEnabled': row['ruleEnabled'],
                        'matched_image_path': row['matched_image_path']
                    })

                return {
                    'history': history,
                    'total': total,
                    'limit': limit,
                    'offset': offset,
                    'has_more': offset + limit < total
                }
        except Exception as e:
            logger.error(f"获取搜索历史失败: {e}")
            return []

    def delete_search_history(self, history_id: int) -> bool:
        """删除搜索历史记录"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history WHERE id = ?', (history_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除搜索历史失败: {e}")
            return False

    def clear_search_history(self) -> bool:
        """清空所有搜索历史"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history')
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"清空搜索历史失败: {e}")
            return False

    # ===== 用户权限管理方法 =====

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """用户认证"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, role, is_active, created_at
                    FROM users
                    WHERE username = ? AND is_active = 1
                ''', (username,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    stored_hash = user_dict.get('password_hash')

                    # 验证密码
                    authenticated = False

                    if stored_hash:
                        # 首先尝试Werkzeug哈希验证（新用户）
                        from werkzeug.security import check_password_hash
                        if check_password_hash(stored_hash, password):
                            authenticated = True
                        # 如果失败，尝试旧的哈希方式（兼容旧用户）
                        elif stored_hash == f"hashed_{password}":
                            authenticated = True

                    if authenticated:
                        # 获取用户管理的店铺
                        user_dict['shops'] = self.get_user_shops(user_dict['id'])
                        return user_dict
                return None
        except Exception as e:
            logger.error(f"用户认证失败: {e}")
            return None

    def create_user(self, username: str, password_hash: str, role: str = 'user') -> bool:
        """创建新用户（password_hash 由上层生成）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute('''
                    INSERT INTO users (username, password_hash, role, is_active)
                    VALUES (?, ?, ?, 1)
                ''', (username, password_hash, role))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            logger.warning(f"用户名已存在: {username}")
            return False
        except Exception as e:
            logger.error(f"创建用户失败: {e}")
            return False

    def get_all_users(self) -> List[Dict]:
        """获取所有用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    ORDER BY created_at DESC
                ''')
                users = []
                for row in cursor.fetchall():
                    user = dict(row)
                    user['shops'] = self.get_user_shops(user['id'])
                    users.append(user)
                return users
        except Exception as e:
            logger.error(f"获取用户列表失败: {e}")
            return []

    def get_user_shops(self, user_id: int) -> List[str]:
        """获取用户管理的店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT shop_id FROM user_shop_permissions
                    WHERE user_id = ?
                ''', (user_id,))
                return [row['shop_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取用户店铺权限失败: {e}")
            return []

    def update_user_shops(self, user_id: int, shop_ids: List[str]) -> bool:
        """更新用户的店铺权限"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 先删除旧的权限
                cursor.execute('DELETE FROM user_shop_permissions WHERE user_id = ?', (user_id,))

                # 添加新的权限
                for shop_id in shop_ids:
                    cursor.execute('''
                        INSERT INTO user_shop_permissions (user_id, shop_id)
                        VALUES (?, ?)
                    ''', (user_id, shop_id))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户店铺权限失败: {e}")
            return False

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """根据ID获取用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    WHERE id = ?
                ''', (user_id,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    user_dict['shops'] = self.get_user_shops(user_id)
                    return user_dict
                return None
        except Exception as e:
            logger.error(f"获取用户信息失败: {e}")
            return None

    def update_discord_account_user(self, account_id: int, user_id: Optional[int]) -> bool:
        """更新Discord账号关联的用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET user_id = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新Discord账号用户关联失败: {e}")
            return False

    def get_discord_accounts_by_user(self, user_id: Optional[int]) -> List[Dict]:
        """获取用户关联的Discord账号"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id is None:
                    # 管理员查询所有账号
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                    FROM discord_accounts
                    ORDER BY created_at DESC
                    ''')
                else:
                    # 普通用户查询自己的账号
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                        FROM discord_accounts
                        WHERE user_id = ?
                        ORDER BY created_at DESC
                    ''', (user_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取用户Discord账号失败: {e}")
            return []

    def update_product_title(self, product_id: int, title: str) -> bool:
        """更新商品标题"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE products
                    SET title = ?, updated_at = datetime('now')
                    WHERE id = ?
                ''', (title, product_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新商品标题失败: {e}")
            return False

    def update_product(self, product_id: int, updates: Dict) -> bool:
        """更新商品信息（通用方法）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 构建动态更新语句
                set_parts = []
                params = []
                allowed_fields = [
                    'title', 'english_title', 'ruleEnabled',
                    'custom_reply_text', 'custom_reply_images', 'custom_image_urls',
                    'image_source', 'uploaded_reply_images'
                ]

                for field in allowed_fields:
                    if field in updates:
                        set_parts.append(f'{field} = ?')
                        if (field == 'custom_reply_images' or field == 'custom_image_urls') and isinstance(updates[field], list):
                            # 将图片索引或URL数组转换为JSON字符串
                            params.append(json.dumps(updates[field]))
                        else:
                            params.append(updates[field])

                if not set_parts:
                    return False

                set_parts.append('updated_at = datetime(\'now\')')

                query = f'''
                    UPDATE products
                    SET {', '.join(set_parts)}
                    WHERE id = ?
                '''
                params.append(product_id)

                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新商品失败: {e}")
            return False

    def get_product_by_id(self, product_id: int) -> Optional[Dict]:
        """根据ID获取商品"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM products WHERE id = ?', (product_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            logger.error(f"获取商品失败: {e}")
            return None

    def delete_user(self, user_id: int) -> bool:
        """删除用户"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 首先删除用户的所有相关数据
                # 删除用户的网站账号绑定
                cursor.execute('DELETE FROM website_account_bindings WHERE user_id = ?', (user_id,))
                # 删除用户的Discord账号
                cursor.execute('DELETE FROM discord_accounts WHERE user_id = ?', (user_id,))
                # 删除用户的设置
                cursor.execute('DELETE FROM user_settings WHERE user_id = ?', (user_id,))
                # 删除用户
                cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除用户失败: {e}")
            return False

    def update_account_status(self, account_id: int, status: str) -> bool:
        """更新Discord账号状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET status = ?, last_active = datetime('now')
                    WHERE id = ?
                ''', (status, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新账号状态失败: {e}")
            return False

    def get_website_configs(self) -> List[Dict]:
        """获取所有网站配置及其频道绑定（优化版本，避免N+1查询）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 使用LEFT JOIN一次性获取所有网站和其频道绑定
                cursor.execute('''
                    SELECT
                        wc.id, wc.name, wc.display_name, wc.url_template,
                        wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at,
                        GROUP_CONCAT(wcb.channel_id) as channels
                    FROM website_configs wc
                    LEFT JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                    GROUP BY wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color, wc.rotation_interval, wc.rotation_enabled, wc.message_filters, wc.created_at
                    ORDER BY wc.created_at
                ''')

                configs = []
                for row in cursor.fetchall():
                    config = dict(row)
                    # 将channels字符串解析为数组
                    if config.get('channels'):
                        config['channels'] = config['channels'].split(',') if config['channels'] else []
                    else:
                        config['channels'] = []
                    configs.append(config)

                return configs
        except Exception as e:
            logger.error(f"获取网站配置失败: {e}")
            return []

    def add_website_config(self, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str = 'blue', rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """添加网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO website_configs (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加网站配置失败: {e}")
            return False

    def update_website_config(self, config_id: int, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str, rotation_interval: int = 180, rotation_enabled: int = 1, message_filters: str = '[]') -> bool:
        """更新网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET name = ?, display_name = ?, url_template = ?, id_pattern = ?, badge_color = ?, rotation_interval = ?, rotation_enabled = ?, message_filters = ?
                    WHERE id = ?
                ''', (name, display_name, url_template, id_pattern, badge_color, rotation_interval, rotation_enabled, message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新网站配置失败: {e}")
            return False

    def delete_website_config(self, config_id: int) -> bool:
        """删除网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM website_configs WHERE id = ?', (config_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除网站配置失败: {e}")
            return False

    def get_website_channel_bindings(self, website_id: int, user_id: int = None) -> List[str]:
        """获取网站绑定的频道列表（可选按用户过滤）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ? AND user_id = ?
                        ORDER BY created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT channel_id FROM website_channel_bindings
                        WHERE website_id = ?
                        ORDER BY created_at
                    ''', (website_id,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取网站频道绑定失败: {e}")
            return []

    def add_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """添加网站频道绑定"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO website_channel_bindings (website_id, channel_id, user_id)
                    VALUES (?, ?, ?)
                ''', (website_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"添加网站频道绑定失败: {e}")
            return False

    def remove_website_channel_binding(self, website_id: int, channel_id: str, user_id: int) -> bool:
        """移除网站频道绑定（按用户过滤）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 【修复】兼容完整URL和频道ID两种格式
                # 如果传入的是频道ID，也要匹配数据库中可能存储的完整URL
                # 构造两种可能的匹配模式
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                    AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, channel_id, channel_id, channel_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"移除网站频道绑定失败: {e}")
            return False

    def remove_website_channel_binding_admin(self, website_id: int, channel_id: str) -> bool:
        """移除网站频道绑定（管理员权限，删除所有用户的绑定）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 【修复】兼容完整URL和频道ID两种格式
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ?
                    AND (
                        channel_id = ?
                        OR channel_id LIKE '%/' || ?
                        OR channel_id LIKE '%/' || ? || '/%'
                    )
                ''', (website_id, channel_id, channel_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"管理员移除网站频道绑定失败: {e}")
            return False

    def get_website_config_by_channel(self, channel_id: str, user_id: int = None) -> Dict:
        """根据频道ID获取绑定的网站配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ? AND wcb.user_id = ?
                        LIMIT 1
                    ''', (str(channel_id), user_id))
                else:
                    cursor.execute('''
                        SELECT wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color
                        FROM website_configs wc
                        JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                        WHERE wcb.channel_id = ?
                        LIMIT 1
                    ''', (str(channel_id),))
                row = cursor.fetchone()
                if row:
                    return dict(row)
                return None
        except Exception as e:
            logger.error(f"根据频道获取网站配置失败: {e}")
            return None

    def get_all_bound_channel_ids(self) -> set:
        """【新增】高效获取所有已绑定的频道ID列表（用于Bot白名单缓存）

        返回所有已绑定的频道ID集合，包括:
        1. website_channel_bindings 表中的所有频道
        2. 系统配置中的 CNFANS_CHANNEL_ID 和 ACBUY_CHANNEL_ID

        Returns:
            set: 频道ID字符串集合，用于O(1)快速查找
        """
        try:
            channel_ids = set()

            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 1. 从绑定表中获取所有频道ID
                cursor.execute('SELECT DISTINCT channel_id FROM website_channel_bindings')
                rows = cursor.fetchall()
                for row in rows:
                    channel_id = row[0]
                    if channel_id:
                        # 兼容完整URL格式，提取频道ID
                        if 'discord.com/channels/' in channel_id:
                            parts = channel_id.rstrip('/').split('/')
                            if len(parts) >= 1:
                                channel_id = parts[-1]
                        channel_ids.add(str(channel_id))

            # 2. 添加系统配置中的频道ID（兼容旧配置）
            try:
                from config import config
                if hasattr(config, 'CNFANS_CHANNEL_ID') and config.CNFANS_CHANNEL_ID:
                    channel_ids.add(str(config.CNFANS_CHANNEL_ID))
                if hasattr(config, 'ACBUY_CHANNEL_ID') and config.ACBUY_CHANNEL_ID:
                    channel_ids.add(str(config.ACBUY_CHANNEL_ID))
            except Exception as e:
                logger.debug(f"读取系统配置频道ID失败（可忽略）: {e}")

            logger.debug(f"获取到 {len(channel_ids)} 个已绑定的频道ID")
            return channel_ids

        except Exception as e:
            logger.error(f"获取已绑定频道ID列表失败: {e}")
            return set()

    def generate_website_urls(self, weidian_id: str) -> List[Dict]:
        """根据微店ID生成所有网站的URL"""
        try:
            website_configs = self.get_website_configs()
            urls = []

            for config in website_configs:
                try:
                    # 替换URL模板中的{id}占位符
                    url = config['url_template'].replace('{id}', weidian_id)
                    urls.append({
                        'name': config['name'],
                        'display_name': config['display_name'],
                        'url': url,
                        'badge_color': config['badge_color'],
                        'channels': self.get_website_channel_bindings(config['id'])
                    })
                except Exception as e:
                    logger.warning(f"生成网站URL失败 {config['name']}: {e}")

            return urls
        except Exception as e:
            logger.error(f"生成网站URL失败: {e}")
            return []

    # ===== 网站账号绑定方法 =====

    def add_website_account_binding(self, website_id: int, account_id: int, role: str, user_id: int) -> bool:
        """添加网站账号绑定"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO website_account_bindings
                    (website_id, account_id, role, user_id)
                    VALUES (?, ?, ?, ?)
                ''', (website_id, account_id, role, user_id))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加网站账号绑定失败: {e}")
            return False

    def remove_website_account_binding(self, website_id: int, account_id: int, user_id: int) -> bool:
        """移除网站账号绑定（按用户过滤）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM website_account_bindings
                    WHERE website_id = ? AND account_id = ? AND (user_id = ? OR user_id IS NULL)
                ''', (website_id, account_id, user_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"移除网站账号绑定失败: {e}")
            return False

    def get_website_account_bindings(self, website_id: int, user_id: int = None) -> List[Dict]:
        """获取网站的所有账号绑定（可选按用户过滤）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ? AND wab.user_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id, user_id))
                else:
                    cursor.execute('''
                        SELECT wab.id, wab.account_id, wab.role, wab.created_at,
                               da.username, da.token, da.status
                        FROM website_account_bindings wab
                        JOIN discord_accounts da ON wab.account_id = da.id
                        WHERE wab.website_id = ?
                        ORDER BY wab.created_at
                    ''', (website_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取网站账号绑定失败: {e}")
            return []

    def get_account_website_bindings(self, account_id: int) -> List[Dict]:
        """获取账号的所有网站绑定"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT wab.id, wab.website_id, wab.role, wab.created_at,
                           wc.name, wc.display_name
                    FROM website_account_bindings wab
                    JOIN website_configs wc ON wab.website_id = wc.id
                    WHERE wab.account_id = ?
                    ORDER BY wab.created_at
                ''', (account_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取账号网站绑定失败: {e}")
            return []

    def get_website_senders(self, website_id: int) -> List[int]:
        """获取网站的发送账号ID列表"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('sender', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取网站发送账号失败: {e}")
            return []

    def get_website_listeners(self, website_id: int) -> List[int]:
        """获取网站的监听账号ID列表"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT account_id FROM website_account_bindings
                    WHERE website_id = ? AND role IN ('listener', 'both')
                ''', (website_id,))
                return [row['account_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取网站监听账号失败: {e}")
            return []

    def update_website_config_rotation(self, config_id: int, rotation_interval: int) -> bool:
        """更新网站配置的轮换间隔"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_interval = ?
                    WHERE id = ?
                ''', (rotation_interval, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新网站轮换间隔失败: {e}")
            return False

    def update_website_config_rotation_enabled(self, config_id: int, rotation_enabled: int) -> bool:
        """更新网站配置的轮换启用状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET rotation_enabled = ?
                    WHERE id = ?
                ''', (rotation_enabled, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新网站配置轮换启用状态失败: {e}")
            return False

    def update_website_message_filters(self, config_id: int, message_filters: str) -> bool:
        """更新网站配置的消息过滤条件"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET message_filters = ?
                    WHERE id = ?
                ''', (message_filters, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新网站消息过滤条件失败: {e}")
            return False

    # ===== 用户级别的网站设置方法 =====

    def get_user_website_settings(self, user_id: int, website_id: int) -> Dict:
        """获取用户的网站设置（轮换和过滤）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT rotation_interval, rotation_enabled, message_filters
                    FROM user_website_settings
                    WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                row = cursor.fetchone()
                if row:
                    return {
                        'rotation_interval': row['rotation_interval'],
                        'rotation_enabled': row['rotation_enabled'],
                        'message_filters': row['message_filters']
                    }
                # 返回默认值
                return {
                    'rotation_interval': 180,
                    'rotation_enabled': 1,
                    'message_filters': '[]'
                }
        except Exception as e:
            logger.error(f"获取用户网站设置失败: {e}")
            return {'rotation_interval': 180, 'rotation_enabled': 1, 'message_filters': '[]'}

    def update_user_website_rotation(self, user_id: int, website_id: int, rotation_interval: int = None, rotation_enabled: int = None) -> bool:
        """更新用户的网站轮换设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 先检查是否存在记录
                cursor.execute('''
                    SELECT id FROM user_website_settings WHERE user_id = ? AND website_id = ?
                ''', (user_id, website_id))
                exists = cursor.fetchone()

                if exists:
                    # 更新现有记录
                    updates = []
                    params = []
                    if rotation_interval is not None:
                        updates.append('rotation_interval = ?')
                        params.append(rotation_interval)
                    if rotation_enabled is not None:
                        updates.append('rotation_enabled = ?')
                        params.append(rotation_enabled)
                    if updates:
                        updates.append('updated_at = CURRENT_TIMESTAMP')
                        params.extend([user_id, website_id])
                        cursor.execute(f'''
                            UPDATE user_website_settings
                            SET {', '.join(updates)}
                            WHERE user_id = ? AND website_id = ?
                        ''', params)
                else:
                    # 插入新记录
                    cursor.execute('''
                        INSERT INTO user_website_settings (user_id, website_id, rotation_interval, rotation_enabled)
                        VALUES (?, ?, ?, ?)
                    ''', (user_id, website_id, rotation_interval or 180, rotation_enabled if rotation_enabled is not None else 1))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户网站轮换设置失败: {e}")
            return False

    def update_user_website_filters(self, user_id: int, website_id: int, message_filters: str) -> bool:
        """更新用户的网站消息过滤设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 使用 INSERT OR REPLACE
                cursor.execute('''
                    INSERT INTO user_website_settings (user_id, website_id, message_filters)
                    VALUES (?, ?, ?)
                    ON CONFLICT(user_id, website_id) DO UPDATE SET
                        message_filters = excluded.message_filters,
                        updated_at = CURRENT_TIMESTAMP
                ''', (user_id, website_id, message_filters))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户网站消息过滤失败: {e}")
            return False

    def get_system_stats(self) -> Dict:
        """获取系统统计信息"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 获取店铺数量（从shops表统计）
                cursor.execute("SELECT COUNT(*) FROM shops")
                shop_count = cursor.fetchone()[0] or 0

                # 获取商品数量
                cursor.execute("SELECT COUNT(*) FROM products")
                product_count = cursor.fetchone()[0] or 0

                # 获取图片数量（只统计有对应商品的图片）
                cursor.execute("""
                    SELECT COUNT(*) FROM product_images
                    WHERE product_id IN (SELECT id FROM products)
                """)
                image_count = cursor.fetchone()[0] or 0

                # 获取用户数量
                cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
                user_count = cursor.fetchone()[0] or 0

                return {
                    'shop_count': shop_count,
                    'product_count': product_count,
                    'image_count': image_count,
                    'user_count': user_count
                }
        except Exception as e:
            logger.error(f"获取系统统计信息失败: {e}")
            return {'shop_count': 0, 'product_count': 0, 'image_count': 0, 'user_count': 0}

    def cleanup_orphaned_images(self) -> int:
        """清理孤立的图片记录（没有对应商品的图片）"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # 删除没有对应商品的图片记录
                cursor.execute("""
                    DELETE FROM product_images
                    WHERE product_id NOT IN (SELECT id FROM products)
                """)
                deleted_count = cursor.rowcount
                conn.commit()
                if deleted_count > 0:
                    logger.info(f"清理了 {deleted_count} 条孤立的图片记录")
                return deleted_count
        except Exception as e:
            logger.error(f"清理孤立图片记录失败: {e}")
            return 0

    def get_active_announcements(self) -> List[Dict]:
        """获取活跃的系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, title, content, created_at, updated_at
                    FROM system_announcements
                    WHERE is_active = 1
                    ORDER BY updated_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取系统公告失败: {e}")
            return []

    def create_announcement(self, title: str, content: str) -> bool:
        """创建系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO system_announcements (title, content)
                    VALUES (?, ?)
                ''', (title, content))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"创建系统公告失败: {e}")
            return False

    def update_announcement(self, announcement_id: int, title: str, content: str, is_active: bool) -> bool:
        """更新系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE system_announcements
                    SET title = ?, content = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (title, content, is_active, announcement_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新系统公告失败: {e}")
            return False

    def delete_announcement(self, announcement_id: int) -> bool:
        """删除系统公告"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM system_announcements WHERE id = ?', (announcement_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除系统公告失败: {e}")
            return False

    def get_message_filters(self) -> List[Dict]:
        """获取消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, filter_type, filter_value, is_active, created_at
                    FROM message_filters
                    WHERE is_active = 1
                    ORDER BY created_at
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取消息过滤规则失败: {e}")
            return []

    def add_message_filter(self, filter_type: str, filter_value: str) -> bool:
        """添加消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO message_filters (filter_type, filter_value)
                    VALUES (?, ?)
                ''', (filter_type, filter_value))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加消息过滤规则失败: {e}")
            return False

    def update_message_filter(self, filter_id: int, filter_type: str, filter_value: str, is_active: bool) -> bool:
        """更新消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE message_filters
                    SET filter_type = ?, filter_value = ?, is_active = ?
                    WHERE id = ?
                ''', (filter_type, filter_value, is_active, filter_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新消息过滤规则失败: {e}")
            return False

    def delete_message_filter(self, filter_id: int) -> bool:
        """删除消息过滤规则"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM message_filters WHERE id = ?', (filter_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除消息过滤规则失败: {e}")
            return False

    def get_custom_replies(self) -> List[Dict]:
        """获取自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, reply_type, content, image_url, is_active, priority, created_at
                    FROM custom_replies
                    WHERE is_active = 1
                    ORDER BY priority DESC, created_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"获取自定义回复内容失败: {e}")
            return []

    def add_custom_reply(self, reply_type: str, content: str = None, image_url: str = None, priority: int = 0) -> bool:
        """添加自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO custom_replies (reply_type, content, image_url, priority)
                    VALUES (?, ?, ?, ?)
                ''', (reply_type, content, image_url, priority))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加自定义回复内容失败: {e}")
            return False

    def update_custom_reply(self, reply_id: int, reply_type: str, content: str = None, image_url: str = None, priority: int = 0, is_active: bool = True) -> bool:
        """更新自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE custom_replies
                    SET reply_type = ?, content = ?, image_url = ?, priority = ?, is_active = ?
                    WHERE id = ?
                ''', (reply_type, content, image_url, priority, is_active, reply_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新自定义回复内容失败: {e}")
            return False

    def delete_custom_reply(self, reply_id: int) -> bool:
        """删除自定义回复内容"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM custom_replies WHERE id = ?', (reply_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除自定义回复内容失败: {e}")
            return False

    def get_products_by_user_shops(self, user_shops: List[str], limit: int = None, offset: int = 0) -> Dict:
        """根据用户店铺权限获取商品"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor = conn.cursor()

                if user_shops is None:
                    # 管理员可以看到所有商品（不限制店铺）- 优化查询性能
                    if limit is None or limit <= 0:
                        # 一次性获取所有商品和对应的图片索引
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                        '''
                        cursor.execute(query)
                        rows = cursor.fetchall()

                        # 获取总数
                        cursor.execute('SELECT COUNT(*) FROM products')
                        total = cursor.fetchone()[0]
                    else:
                        # 分页查询 - 使用子查询优化性能
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                            LIMIT ? OFFSET ?
                        '''
                        cursor.execute(query, [limit, offset])
                    rows = cursor.fetchall()

                    # 获取总数
                    cursor.execute('SELECT COUNT(*) FROM products')
                    total = cursor.fetchone()[0]

                    products = []
                    for row in rows:
                        prod = dict(row)
                        # 处理图片路径 - 直接使用预查询的image_indices
                        if prod.get('image_indices'):
                            image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                            prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                        else:
                            prod['images'] = []

                        # 格式化字段名以兼容前端
                        prod['weidianUrl'] = prod.get('product_url')
                        prod['englishTitle'] = prod.get('english_title') or ''
                        prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                        prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                        prod['createdAt'] = prod.get('created_at')
                        prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                        prod['shopName'] = prod.get('shop_name') or '未知店铺'

                        # 提取微店ID
                        try:
                            import re
                            m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                            prod['weidianId'] = m.group(1) if m else ''
                        except:
                            prod['weidianId'] = ''

                        products.append(prod)

                    return {'products': products, 'total': total}

                elif not user_shops:
                    # 如果用户没有店铺权限，返回空结果
                    return {'products': [], 'total': 0}

                # 确保user_shops是list类型
                if not isinstance(user_shops, list):
                    user_shops = []

                # 根据shop_id找到对应的shop_name
                shop_names = []
                for shop_id in user_shops:
                    cursor.execute("SELECT name FROM shops WHERE shop_id = ?", (shop_id,))
                    shop_row = cursor.fetchone()
                    if shop_row:
                        shop_names.append(shop_row[0])

                if not shop_names:
                    # 如果没有找到对应的店铺名称，返回空结果
                    return {'products': [], 'total': 0}

                # 构建IN查询 - 优化性能
                placeholders = ','.join('?' * len(shop_names))
                if limit is None or limit <= 0:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                    '''
                    cursor.execute(query, shop_names)
                    rows = cursor.fetchall()

                    # 获取总数
                    count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                    cursor.execute(count_query, shop_names)
                    total = cursor.fetchone()[0]
                else:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                        LIMIT ? OFFSET ?
                    '''
                    cursor.execute(query, shop_names + [limit, offset])
                rows = cursor.fetchall()

                # 获取总数
                count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                cursor.execute(count_query, shop_names)
                total = cursor.fetchone()[0]

                products = []
                for row in rows:
                    prod = dict(row)
                    # 处理图片路径 - 直接使用预查询的image_indices
                    if prod.get('image_indices'):
                        image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                        prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                    else:
                        prod['images'] = []

                    # 格式化字段名以兼容前端
                    prod['weidianUrl'] = prod.get('product_url')
                    prod['englishTitle'] = prod.get('english_title') or ''
                    prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                    prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                    prod['createdAt'] = prod.get('created_at')
                    prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                    prod['shopName'] = prod.get('shop_name') or '未知店铺'
                    prod['customReplyText'] = prod.get('custom_reply_text') or ''
                    # 解析自定义回复图片索引
                    try:
                        custom_reply_images = prod.get('custom_reply_images')
                        if custom_reply_images:
                            prod['selectedImageIndexes'] = json.loads(custom_reply_images)
                        else:
                            prod['selectedImageIndexes'] = []
                    except:
                        prod['selectedImageIndexes'] = []

                    # 修复：解析本地上传的自定义回复图片 (uploaded_reply_images)
                    # 前端组件 ScraperView 需要 uploadedImages 字段 (URL列表) 来显示"已保存图片"
                    try:
                        if prod.get('uploaded_reply_images'):
                            import json
                            filenames = json.loads(prod['uploaded_reply_images'])
                            prod['uploadedImages'] = [f"/api/custom_reply_image/{prod['id']}/{fn}" for fn in filenames]
                        else:
                            prod['uploadedImages'] = []
                    except:
                        prod['uploadedImages'] = []

                    # 提取微店ID
                    try:
                        import re
                        m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                        prod['weidianId'] = m.group(1) if m else ''
                    except:
                        prod['weidianId'] = ''

                    products.append(prod)

                return {'products': products, 'total': total}

        except Exception as e:
            print(f"DEBUG: Exception in get_products_by_user_shops: {type(e).__name__}: {e}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            logger.error("获取用户商品失败: %s", str(e))
            return {'products': [], 'total': 0}

    def get_global_reply_config(self) -> Dict[str, float]:
        """获取全局回复延迟配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT min_delay, max_delay FROM global_reply_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {'min_delay': row[0], 'max_delay': row[1]}
                return {'min_delay': 3.0, 'max_delay': 8.0}  # 默认值
        except Exception as e:
            logger.error(f"获取全局回复配置失败: {e}")
            return {'min_delay': 3.0, 'max_delay': 8.0}

    def update_global_reply_config(self, min_delay: float, max_delay: float) -> bool:
        """更新全局回复延迟配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE global_reply_config
                    SET min_delay = ?, max_delay = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''', (min_delay, max_delay))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新全局回复配置失败: {e}")
            return False

    def get_system_config(self) -> Dict[str, any]:
        """获取系统配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads FROM system_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_channel_id': row[0] or '',
                        'download_threads': row[1] or 4,
                        'feature_extract_threads': row[2] or 4,
                        'discord_similarity_threshold': row[3] or 0.6,
                        'cnfans_channel_id': row[4] or '',
                        'acbuy_channel_id': row[5] or '',
                        'scrape_threads': row[6] or 2
                    }
                # 如果没有配置记录，创建默认配置
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads)
                    VALUES (1, '', 4, 4, 0.6, '', '', 2)
                ''')
                conn.commit()
                return {
                    'discord_channel_id': '',
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'cnfans_channel_id': '',
                    'acbuy_channel_id': '',
                    'scrape_threads': 2
                }
        except Exception as e:
            logger.error(f"获取系统配置失败: {e}")
            return {
                'discord_channel_id': '',
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'cnfans_channel_id': '',
                'acbuy_channel_id': '',
                'scrape_threads': 2
            }

    def get_user_settings(self, user_id: int) -> Dict[str, any]:
        """获取用户个性化设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT download_threads, feature_extract_threads, discord_similarity_threshold,
                           global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                           keyword_reply_enabled, image_reply_enabled
                    FROM user_settings WHERE user_id = ?
                ''', (user_id,))
                row = cursor.fetchone()
                if row:
                    return {
                        'download_threads': row[0] or 4,
                        'feature_extract_threads': row[1] or 4,
                        'discord_similarity_threshold': row[2] or 0.6,
                        'global_reply_min_delay': row[3] or 3.0,
                        'global_reply_max_delay': row[4] or 8.0,
                        'user_blacklist': row[5] or '',
                        'keyword_filters': row[6] or '',
                        'keyword_reply_enabled': row[7] if row[7] is not None else 1,
                        'image_reply_enabled': row[8] if row[8] is not None else 1,
                    }
                # 如果用户没有设置，返回默认值
                return {
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'global_reply_min_delay': 3.0,
                    'global_reply_max_delay': 8.0,
                    'user_blacklist': '',
                    'keyword_filters': '',
                    'keyword_reply_enabled': 1,
                    'image_reply_enabled': 1,
                }
        except Exception as e:
            logger.error(f"获取用户设置失败: {e}")
            return {
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'global_reply_min_delay': 3.0,
                'global_reply_max_delay': 8.0,
                'user_blacklist': '',
                'keyword_filters': '',
                'keyword_reply_enabled': 1,
                'image_reply_enabled': 1,
            }

    def update_user_settings(self, user_id: int, download_threads: int = None,
                           feature_extract_threads: int = None, discord_similarity_threshold: float = None,
                           global_reply_min_delay: float = None, global_reply_max_delay: float = None,
                           user_blacklist: str = None, keyword_filters: str = None,
                           keyword_reply_enabled: int = None, image_reply_enabled: int = None) -> bool:
        """更新用户个性化设置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 检查用户是否已有设置
                cursor.execute('SELECT id FROM user_settings WHERE user_id = ?', (user_id,))
                existing = cursor.fetchone()

                if existing:
                    # 更新现有设置
                    update_fields = []
                    params = []

                    if download_threads is not None:
                        update_fields.append('download_threads = ?')
                        params.append(download_threads)

                    if feature_extract_threads is not None:
                        update_fields.append('feature_extract_threads = ?')
                        params.append(feature_extract_threads)

                    if discord_similarity_threshold is not None:
                        update_fields.append('discord_similarity_threshold = ?')
                        params.append(discord_similarity_threshold)

                    if global_reply_min_delay is not None:
                        update_fields.append('global_reply_min_delay = ?')
                        params.append(global_reply_min_delay)

                    if global_reply_max_delay is not None:
                        update_fields.append('global_reply_max_delay = ?')
                        params.append(global_reply_max_delay)

                    if user_blacklist is not None:
                        update_fields.append('user_blacklist = ?')
                        params.append(user_blacklist)

                    if keyword_filters is not None:
                        update_fields.append('keyword_filters = ?')
                        params.append(keyword_filters)

                    if keyword_reply_enabled is not None:
                        update_fields.append('keyword_reply_enabled = ?')
                        params.append(keyword_reply_enabled)

                    if image_reply_enabled is not None:
                        update_fields.append('image_reply_enabled = ?')
                        params.append(image_reply_enabled)

                    if update_fields:
                        update_fields.append('updated_at = CURRENT_TIMESTAMP')
                        sql = f'UPDATE user_settings SET {", ".join(update_fields)} WHERE user_id = ?'
                        params.append(user_id)
                        cursor.execute(sql, params)
                else:
                    # 插入新设置
                    cursor.execute('''
                        INSERT INTO user_settings
                        (user_id, download_threads, feature_extract_threads, discord_similarity_threshold,
                         global_reply_min_delay, global_reply_max_delay, user_blacklist, keyword_filters,
                         keyword_reply_enabled, image_reply_enabled)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        user_id,
                        download_threads or 4,
                        feature_extract_threads or 4,
                        discord_similarity_threshold or 0.6,
                        global_reply_min_delay or 3.0,
                        global_reply_max_delay or 8.0,
                        user_blacklist or '',
                        keyword_filters or '',
                        keyword_reply_enabled if keyword_reply_enabled is not None else 1,
                        image_reply_enabled if image_reply_enabled is not None else 1
                    ))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"更新用户设置失败: {e}")
            return False

    def update_system_config(self, discord_channel_id: str = None, discord_similarity_threshold: float = None,
                           cnfans_channel_id: str = None, acbuy_channel_id: str = None) -> bool:
        """更新系统配置"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 首先确保配置记录存在
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')

                # 构建更新语句
                update_fields = []
                params = []

                if discord_channel_id is not None:
                    update_fields.append('discord_channel_id = ?')
                    params.append(discord_channel_id)

                if discord_similarity_threshold is not None:
                    update_fields.append('discord_similarity_threshold = ?')
                    params.append(discord_similarity_threshold)

                if cnfans_channel_id is not None:
                    update_fields.append('cnfans_channel_id = ?')
                    params.append(cnfans_channel_id)

                if acbuy_channel_id is not None:
                    update_fields.append('acbuy_channel_id = ?')
                    params.append(acbuy_channel_id)

                if update_fields:
                    update_fields.append('updated_at = CURRENT_TIMESTAMP')
                    sql = f'UPDATE system_config SET {", ".join(update_fields)} WHERE id = 1'
                    cursor.execute(sql, params)
                    conn.commit()
                    return True
                return False
        except Exception as e:
            logger.error(f"更新系统配置失败: {e}")
            return False

    # ===== 店铺管理方法 =====

    def add_shop(self, shop_id: str, name: str) -> bool:
        """添加新店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 检查店铺是否已存在
                cursor.execute('SELECT id FROM shops WHERE shop_id = ?', (shop_id,))
                if cursor.fetchone():
                    logger.warning(f"店铺 {shop_id} 已存在")
                    return False

                cursor.execute('''
                    INSERT INTO shops (shop_id, name, product_count)
                    VALUES (?, ?, 0)
                ''', (shop_id, name))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"添加店铺失败: {e}")
            return False

    def get_all_shops(self) -> List[Dict]:
        """获取所有店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops ORDER BY created_at DESC')
                rows = cursor.fetchall()

                shops = []
                for row in rows:
                    shops.append({
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    })
                return shops
        except Exception as e:
            logger.error(f"获取店铺列表失败: {e}")
            return []

    def get_shop_by_id(self, shop_id: str) -> Optional[Dict]:
        """根据shop_id获取店铺信息"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops WHERE shop_id = ?', (shop_id,))
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    }
                return None
        except Exception as e:
            logger.error(f"获取店铺信息失败: {e}")
            return None

    def update_shop_product_count(self, shop_id: str, product_count: int) -> bool:
        """更新店铺的商品数量"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE shops
                    SET product_count = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE shop_id = ?
                ''', (product_count, shop_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"更新店铺商品数量失败: {e}")
            return False

    def delete_shop(self, shop_id: str) -> bool:
        """删除店铺"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM shops WHERE shop_id = ?', (shop_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"删除店铺失败: {e}")
            return False

    # ========== 抓取状态管理方法 ==========

    def get_scrape_status(self) -> Dict:
        """获取抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM scrape_status WHERE id = 1')
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'is_scraping': bool(row[1]),
                        'stop_signal': bool(row[2]),
                        'current_shop_id': row[3],
                        'total': row[4] or 0,
                        'processed': row[5] or 0,
                        'success': row[6] or 0,
                        'progress': row[7] or 0.0,
                        'message': row[8] or '等待开始...',
                        'completed': bool(row[9]),
                        'thread_id': row[10],
                        'updated_at': row[11]
                    }
                else:
                    # 如果没有记录，创建默认记录
                    return self.reset_scrape_status()

        except Exception as e:
            logger.error(f"获取抓取状态失败: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': '获取状态失败',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

    def update_scrape_status(self, **kwargs) -> bool:
        """更新抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # 构建更新语句
                fields = []
                values = []
                for key, value in kwargs.items():
                    if key in ['is_scraping', 'stop_signal', 'completed']:
                        fields.append(f'{key} = ?')
                        values.append(1 if value else 0)
                    elif key in ['total', 'processed', 'success']:
                        fields.append(f'{key} = ?')
                        values.append(int(value) if value is not None else 0)
                    elif key == 'progress':
                        fields.append(f'{key} = ?')
                        values.append(float(value) if value is not None else 0.0)
                    elif key in ['current_shop_id', 'message', 'thread_id']:
                        fields.append(f'{key} = ?')
                        values.append(str(value) if value is not None else None)

                if fields:
                    fields.append('updated_at = CURRENT_TIMESTAMP')
                    query = f'UPDATE scrape_status SET {", ".join(fields)} WHERE id = 1'
                    cursor.execute(query, values)
                    conn.commit()
                    return cursor.rowcount > 0

                return False

        except Exception as e:
            logger.error(f"更新抓取状态失败: {e}")
            return False

    def reset_scrape_status(self) -> Dict:
        """重置抓取状态"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scrape_status SET
                        is_scraping = 0,
                        stop_signal = 0,
                        current_shop_id = NULL,
                        total = 0,
                        processed = 0,
                        success = 0,
                        progress = 0,
                        message = '等待开始...',
                        completed = 0,
                        thread_id = NULL,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''')
                conn.commit()

                return {
                    'is_scraping': False,
                    'stop_signal': False,
                    'current_shop_id': None,
                    'total': 0,
                    'processed': 0,
                    'success': 0,
                    'progress': 0.0,
                    'message': '等待开始...',
                    'completed': False,
                    'thread_id': None,
                    'updated_at': None
                }

        except Exception as e:
            logger.error(f"重置抓取状态失败: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': '重置失败',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

# 全局数据库实例
db = Database()

--- File: ./backend/weidian_scraper.py ---
import requests
import re
import json
import time
import logging
from urllib.parse import urlparse, parse_qs, quote
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class WeidianScraper:
    """微店商品信息爬虫 - 使用官方API"""

    def __init__(self):
        self.session = requests.Session()

        # [新增] 优化连接池，防止多线程抓取时连接数不够
        from requests.adapters import HTTPAdapter
        # 设置连接池大小为 50，重试次数 3
        adapter = HTTPAdapter(pool_connections=50, pool_maxsize=50, max_retries=3)
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)

        # 修复：更新 Headers，完全匹配你的 CURL 请求
        self.session.headers.update({
            'accept': 'application/json, */*',  # 注意：curl中是 application/json, / 但实际应该是 /*
            'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'origin': 'https://weidian.com',
            'priority': 'u=1, i',
            'referer': 'https://weidian.com/',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-site',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
        })

        # 修复：更新 Cookies
        self.session.cookies.update({
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '6',
            '__spider__sessionid': 'e0e858ac8efb20a2'
        })

    def extract_item_id(self, url: str) -> Optional[str]:
        """从微店URL中提取商品ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # 尝试从路径中提取
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # 尝试其他格式
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"提取商品ID失败: {e}")
            return None

    def scrape_product_info(self, url: str) -> Optional[Dict]:
        """
        抓取微店商品信息 - 使用官方API
        返回包含标题、描述、图片等信息的字典
        """
        try:
            item_id = self.extract_item_id(url)
            if not item_id:
                logger.error(f"无法从URL提取商品ID: {url}")
                return None

            logger.info(f"开始抓取商品: {item_id}")

            # 获取店铺信息
            shop_name = self._get_shop_name(url)
            if shop_name == "未知店铺":
                logger.info("店铺名称获取失败，尝试从页面HTML提取")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # 尝试从JavaScript数据中提取店铺名称
                        shop_name_pattern = r'"shopName"[^:]*:[^"]*"([^"]+)"'
                        match = re.search(shop_name_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            shop_name = match.group(1).strip()
                            logger.info(f"✅ 从JavaScript数据获取到店铺名称: {shop_name}")
                except Exception as e:
                    logger.warning(f"从页面提取店铺名称失败: {e}")

            # 使用官方API获取商品信息
            product_info = self._scrape_by_api(item_id, url, shop_name)
            if product_info:
                logger.info(f"✅ 商品信息抓取成功: {product_info.get('title', 'Unknown')}")
                return product_info

            # 如果API失败，返回None
            logger.error("API抓取失败，没有备用方法")
            return None

        except Exception as e:
            logger.error(f"商品信息抓取失败: {e}")
            return None

    def _scrape_by_api(self, item_id: str, url: str, shop_name: str = '') -> Optional[Dict]:
        """使用微店官方API抓取商品信息"""
        try:
            # 获取商品标题和SKU信息
            title_info = self._get_item_title_and_sku(item_id)
            title = title_info.get('title', '') if title_info else ''

            # 如果API获取失败，尝试从页面HTML中提取商品标题
            if not title:
                logger.info("API获取标题失败，尝试从页面HTML提取")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # 从页面HTML中提取商品标题
                        title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                        match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            title = match.group(1).strip()
                            logger.info(f"✅ 从页面HTML获取到商品标题: {title}")
                        else:
                            title = f'微店商品 {item_id}'
                except Exception as e:
                    logger.warning(f"从页面HTML提取标题失败: {e}")
                    title = f'微店商品 {item_id}'
            else:
                title = title

            # 获取商品图片信息（即使标题获取失败也要尝试获取图片）
            image_info = self._get_item_images(item_id)
            images = image_info if image_info else []

            # 如果既没有标题也没有图片，返回None
            if not title and not images:
                logger.error("无法获取商品标题和图片信息")
                return None

            # 构建商品信息
            product_info = {
                'id': item_id,
                'weidian_url': url,
                'cnfans_url': f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN",
                'acbuy_url': f"https://www.acbuy.com/product?url=https%253A%252F%252Fweidian.com%252Fitem.html%253FitemID%253D{item_id}%2526spider_token%253D43fe&id={item_id}&source=WD",
                'images': images,
                'title': title,
                'english_title': self._generate_english_title(title),
                'description': f"微店商品ID: {item_id}",
                'shop_name': shop_name
            }

            return product_info

        except Exception as e:
            logger.error(f"API抓取失败: {e}")
            return None

    def _get_item_title_and_sku(self, item_id: str) -> Optional[Dict]:
        """获取商品标题和SKU信息"""
        try:
            # 构造API URL - 使用更新的格式
            param = json.dumps({"itemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getItemSkuInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.info(f"调用SKU API: {api_url}")  # 修改日志级别为 INFO 以便调试

            # 使用与前端 fetch 完全一致的 headers
            headers = {
                "accept": "application/json, */*",
                "accept-language": "en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"macOS"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "referrer": "https://weidian.com/",
                "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
            }

            # 不带 cookies 发送请求 (有时候 cookies 会导致校验失败)
            response = requests.get(api_url, headers=headers, timeout=15)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"标题API返回状态: {data.get('status', {}).get('code')}")

            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                title = result.get('itemTitle', '')
                if title:
                    return {'title': title, 'sku_info': result}

            # API调用失败，记录警告但不尝试HTML fallback

            return None

        except Exception as e:
            logger.error(f"获取商品标题失败: {e}")
            return None

    def _get_item_images(self, item_id: str) -> List[str]:
        """获取商品图片信息 - 同时调用两个API并去重"""
        try:
            all_images = []

            # 1. 获取商品详情图片 (原有API)
            detail_images = self._get_detail_images(item_id)
            all_images.extend(detail_images)

            # 2. 获取SKU属性图片 (新API)
            sku_images = self._get_sku_images(item_id)
            all_images.extend(sku_images)

            # 3. 简单URL去重
            unique_images = []
            seen_urls = set()
            for img_url in all_images:
                if img_url and img_url not in seen_urls:
                    unique_images.append(img_url)
                    seen_urls.add(img_url)

            logger.info(f"✅ 商品 {item_id} 图片获取完成: 共 {len(unique_images)} 张 (详情:{len(detail_images)}, SKU:{len(sku_images)})")
            if len(unique_images) > 0:
                logger.info(f"📸 图片URL样例: {unique_images[:3]}")
            return unique_images

        except Exception as e:
            logger.error(f"获取商品图片失败: {e}")
            return []

    def _get_detail_images(self, item_id: str) -> List[str]:
        """获取商品详情图片 (原有API)"""
        try:
            # 构造API URL
            param = json.dumps({"vItemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getDetailDesc/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.debug(f"调用详情图片API: {api_url}")

            # 使用更稳定的请求头，模拟浏览器行为
            import requests
            headers = {
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'origin': 'https://weidian.com',
                'priority': 'u=1, i',
                'referer': 'https://weidian.com/',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-site',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            # 设置cookies
            cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }

            response = requests.get(api_url, timeout=15, proxies={'http': None, 'https': None}, headers=headers, cookies=cookies)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"详情图片API返回状态: {data.get('status', {}).get('code')}")

            images = []
            if data.get('status', {}).get('code') == 0:
                item_detail = data.get('result', {}).get('item_detail', {})
                desc_content = item_detail.get('desc_content', [])

                for item in desc_content:
                    if item.get('type') == 2 and item.get('url'):
                        images.append(item['url'])

            return images

        except Exception as e:
            logger.error(f"获取详情图片失败: {e}")
            return []

    def _get_sku_images(self, item_id: str) -> List[str]:
        """获取SKU属性图片 (新API + attrList解析)"""
        try:
            logger.info(f"开始获取SKU图片，商品ID: {item_id}")
            title_info = self._get_item_title_and_sku(item_id)
            if not title_info or 'sku_info' not in title_info:
                logger.warning(f"无法获取SKU信息，跳过图片提取: {item_id}")
                return []

            result = title_info['sku_info']
            images = []
            seen_urls = set()

            # 1. 尝试从 attrList 中提取 (这是你提供的JSON中的结构)
            attr_list = result.get('attrList', [])
            if attr_list:
                logger.info(f"解析 attrList，共 {len(attr_list)} 组属性")
                for attr in attr_list:
                    attr_values = attr.get('attrValues', [])
                    for val in attr_values:
                        img_url = val.get('img')
                        if img_url:
                            # 修复 URL 格式
                            if img_url.startswith('//'):
                                img_url = 'https:' + img_url

                            if img_url not in seen_urls:
                                images.append(img_url)
                                seen_urls.add(img_url)

            # 2. 尝试从 skuInfos 中提取 (作为补充)
            sku_infos = result.get('skuInfos', [])
            if sku_infos:
                logger.info(f"解析 skuInfos，共 {len(sku_infos)} 个SKU")
                for sku in sku_infos:
                    # 注意：skuInfo 对象可能嵌套
                    info = sku.get('skuInfo', {})
                    img_url = info.get('img')
                    if img_url:
                        if img_url.startswith('//'):
                            img_url = 'https:' + img_url
                        if img_url not in seen_urls:
                            images.append(img_url)
                            seen_urls.add(img_url)

            logger.info(f"从SKU属性中成功提取 {len(images)} 张图片")
            return images
        except Exception as e:
            logger.error(f"获取SKU图片失败: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return []


    def _generate_english_title(self, chinese_title: str) -> str:
        """根据中文标题生成英文标题 - 使用免费翻译API"""
        if not chinese_title or len(chinese_title.strip()) == 0:
            return ""
        # 优先使用 Google 免费接口，失败再回退到百度，再回退到简单映射
        try:
            return self._translate_with_google(chinese_title)
        except Exception as e:
            logger.debug(f"Google 翻译失败: {e}")
        try:
            res = self._translate_with_baidu(chinese_title)
            if res:
                return res
        except Exception as e:
            logger.debug(f"百度翻译失败: {e}")
        # 最后备用：简单映射
        return self._simple_chinese_to_english(chinese_title)

    def _translate_with_baidu(self, text: str) -> str:
        """使用百度翻译API"""
        try:
            # 百度翻译免费API
            url = "https://fanyi.baidu.com/transapi"

            params = {
                'from': 'zh',
                'to': 'en',
                'query': text[:200]  # 限制长度
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            data = response.json()
            # 尝试多种可能的返回结构，避免直接抛出异常
            translated = ""
            if isinstance(data, dict):
                try:
                    translated = data.get('data', {}).get('result', [{}])[0].get('dst', '') or ''
                except Exception:
                    translated = ''
                if not translated:
                    if 'trans_result' in data:
                        try:
                            translated = data.get('trans_result', [{}])[0].get('dst', '') or ''
                        except Exception:
                            translated = ''
            if translated:
                return translated.strip()
            logger.debug("百度翻译返回空结果")
            return ""
        except Exception as e:
            logger.warning(f"百度翻译API调用异常: {e}")
            return ""

    def _translate_with_google(self, text: str) -> str:
        """使用Google Translate API的免费版本"""
        try:
            # 使用Google Translate的免费API
            url = "https://translate.googleapis.com/translate_a/single"

            params = {
                'client': 'gtx',
                'sl': 'zh-CN',
                'tl': 'en',
                'dt': 't',
                'q': text[:500]  # 限制长度
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # Google返回的是JSON数组
            data = response.json()
            if data and len(data) > 0 and len(data[0]) > 0:
                translated = data[0][0][0]
                if translated:
                    return translated.strip()

            raise Exception("Google翻译返回空结果")

        except Exception as e:
            logger.error(f"Google翻译API调用失败: {e}")
            raise e

    def _simple_chinese_to_english(self, text: str) -> str:
        """简单的中英映射 - 最后的备用方案"""
        # 简单的商品关键词映射
        mappings = {
            '鞋': 'shoes',
            '运动鞋': 'sports shoes',
            '袜子': 'socks',
            '鞋子': 'shoes',
            '衣服': 'clothes',
            '上衣': 'top',
            '裤子': 'pants',
            '包': 'bag',
            '包包': 'bag',
            '手机': 'phone',
            '电脑': 'computer',
            '耳机': 'headphones',
            '手表': 'watch',
            '眼镜': 'glasses',
            '帽子': 'hat',
            '书': 'book',
            '玩具': 'toy',
            '游戏': 'game'
        }

        result = text
        for cn, en in mappings.items():
            result = result.replace(cn, en)

        # 如果有明显的变化，返回翻译结果，否则返回空
        if result != text:
            return result.strip()
        else:
            return ""


    def download_images(self, image_urls: List[str], save_dir: str, item_id: str) -> List[str]:
        """多线程下载商品图片到本地"""
        import os
        import concurrent.futures
        import threading

        saved_paths = []
        os.makedirs(save_dir, exist_ok=True)

        # 移除图片数量限制，抓取所有可用的图片
        # SKU图片通常排在详情图之后，现在可以获取所有图片
        logger.info(f"准备下载 {len(image_urls)} 张图片（无数量限制）")

        def download_single_image(args):
            """下载单张图片的函数"""
            i, img_url = args
            try:
                # 为每个线程创建独立的session
                thread_session = requests.Session()
                thread_session.headers.update(self.session.headers)
                thread_session.cookies.update(self.session.cookies)

                response = thread_session.get(img_url, timeout=10, proxies={'http': None, 'https': None})
                response.raise_for_status()

                # 保存图片
                img_path = os.path.join(save_dir, f"{item_id}_{i}.jpg")
                with open(img_path, 'wb') as f:
                    f.write(response.content)

                logger.info(f"图片下载成功: {img_path}")
                return img_path

            except Exception as e:
                logger.warning(f"图片下载失败 {img_url}: {e}")
                return None

        # 使用线程池并发下载图片
        try:
            from config import config
        except ImportError:
            from .config import config
        max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))  # 使用配置的下载线程数

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 提交所有下载任务
            future_to_image = {
                executor.submit(download_single_image, (i, img_url)): (i, img_url)
                for i, img_url in enumerate(image_urls)
            }

            # 收集结果
            for future in concurrent.futures.as_completed(future_to_image):
                result = future.result()
                if result:
                    saved_paths.append(result)

        # 按索引排序结果
        saved_paths.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

        return saved_paths

    def _get_shop_name(self, url: str) -> str:
        """从商品页面获取店铺名称"""
        try:
            logger.debug(f"开始获取店铺名称: {url}")

            # 使用专门的HTML请求headers（不同于API请求的headers）
            html_headers = {
                'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'cache-control': 'max-age=0',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'document',
                'sec-fetch-mode': 'navigate',
                'sec-fetch-site': 'none',
                'sec-fetch-user': '?1',
                'upgrade-insecure-requests': '1',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            html_cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                '__spider__sessionid': '4cb270eb969f316c'
            }

            # 请求商品页面（使用HTML专用headers）
            response = requests.get(url, headers=html_headers, cookies=html_cookies, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # 解码HTML实体（&#34; -> " 等）
            html_content = response.text
            html_content = html_content.replace('&#34;', '"').replace('&#39;', "'").replace('&quot;', '"')

            # 首先尝试最精确的匹配：em标签中的shop-name-str类（根据用户提供的HTML结构）
            shop_name_pattern1 = r'<em[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</em>'
            match = re.search(shop_name_pattern1, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (em shop-name-str): {shop_name}")
                return shop_name

            # 然后尝试更宽泛的匹配，查找包含shop-name-str类的任何元素
            shop_name_pattern2 = r'<[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</[^>]*>'
            match = re.search(shop_name_pattern2, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (通用shop-name-str): {shop_name}")
                return shop_name

            # 尝试匹配class="shop-name-str"的元素（不限定标签类型）
            shop_name_pattern3 = r'class="shop-name-str"[^>]*>([^<]+)</'
            match = re.search(shop_name_pattern3, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (shop-name-str): {shop_name}")
                return shop_name

            # 尝试从JavaScript数据中提取店铺名称（多种格式）
            # 格式1: "shopName":"Aiseo"
            shop_name_pattern4 = r'"shopName"\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern4, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript): {shop_name}")
                return shop_name

            # 格式2: \"shopName\":\"Aiseo\" (在HTML中被转义)
            shop_name_pattern5 = r'\\"shopName\\"\s*:\s*\\"([^\\"]+)\\"'
            match = re.search(shop_name_pattern5, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript转义): {shop_name}")
                return shop_name

            # 格式3: shopName:"Aiseo" (无引号)
            shop_name_pattern6 = r'shopName\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern6, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"✅ 获取到店铺名称 (JavaScript无引号): {shop_name}")
                return shop_name

            logger.warning("未找到店铺名称，使用默认名称")
            return "未知店铺"

        except Exception as e:
            logger.error(f"获取店铺名称失败: {e}")
            return "未知店铺"

    def close(self):
        """关闭资源 - 占位方法"""
        pass

# 全局爬虫实例
_scraper = None

def get_weidian_scraper() -> WeidianScraper:
    """获取微店爬虫实例"""
    global _scraper
    if _scraper is None:
        _scraper = WeidianScraper()
    return _scraper

--- File: ./backend/bot_config.py ---
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = float(os.getenv('DISCORD_SIMILARITY_THRESHOLD', '0.6'))  # Discord机器人相似度阈值

    # 全局回复延迟配置
    GLOBAL_REPLY_MIN_DELAY = int(os.getenv('GLOBAL_REPLY_MIN_DELAY', '3'))  # 全局最小延迟秒数
    GLOBAL_REPLY_MAX_DELAY = int(os.getenv('GLOBAL_REPLY_MAX_DELAY', '8'))  # 全局最大延迟秒数

    # 关键词转发配置
    FORWARD_KEYWORDS = os.getenv('FORWARD_KEYWORDS', '商品,货源,进货,批发,代理').split(',')  # 触发转发的关键词
    FORWARD_TARGET_CHANNEL_ID = int(os.getenv('FORWARD_TARGET_CHANNEL_ID', 0)) if os.getenv('FORWARD_TARGET_CHANNEL_ID') else 0  # 转发目标频道ID

    # API服务地址（本地服务）
    NEXTJS_API_URL = 'http://localhost:5001/api'
    PADDLE_SERVICE_URL = 'http://localhost:5001'

    # 机器人配置
    COMMAND_PREFIX = '!'

config = Config()

--- File: ./backend/fix_index.py ---
import os
import sys
import json
import time
import shutil
import logging
import numpy as np

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Ensure local imports work
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from database import db
from vector_engine import VectorEngine
from config import config


def _backup_file(path: str) -> None:
    if not os.path.exists(path):
        return
    ts = time.strftime('%Y%m%d-%H%M%S')
    backup_path = f"{path}.bak.{ts}"
    shutil.copy2(path, backup_path)
    logger.info(f"Backed up {path} -> {backup_path}")


def fix_index() -> None:
    logger.info("=" * 50)
    logger.info("🚀 Starting fast FAISS rebuild from DB features")
    logger.info("=" * 50)

    index_file = config.FAISS_INDEX_FILE
    id_map_file = config.FAISS_ID_MAP_FILE

    # Backup existing files first (safer than rm)
    _backup_file(index_file)
    _backup_file(id_map_file)

    # Remove old files (if any)
    for p in (index_file, id_map_file):
        try:
            if os.path.exists(p):
                os.remove(p)
                logger.info(f"Removed old index file: {p}")
        except Exception as e:
            logger.warning(f"Failed to remove {p}: {e}")

    # Create a fresh engine (will create new empty index)
    engine = VectorEngine()

    # Read all rows with features
    logger.info("Reading features from SQLite...")
    with db.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(
            "SELECT id, features FROM product_images WHERE features IS NOT NULL AND features != ''"
        )
        rows = cursor.fetchall()

    total_count = len(rows)
    logger.info(f"Found {total_count} feature rows")
    if total_count == 0:
        logger.warning("No feature data in DB. Cannot rebuild.")
        return

    ok = 0
    bad = 0
    start = time.time()

    for i, row in enumerate(rows, start=1):
        db_id = row['id']
        features_json = row['features']

        try:
            vec = np.array(json.loads(features_json), dtype='float32')
            if vec.ndim != 1 or vec.shape[0] != config.VECTOR_DIMENSION:
                bad += 1
                continue

            engine.add_vector(int(db_id), vec)
            ok += 1

            if i % 5000 == 0:
                logger.info(f"Progress: {i}/{total_count} (ok={ok}, bad={bad})")

        except Exception:
            bad += 1

    logger.info("Saving FAISS index...")
    engine.save()

    dur = time.time() - start
    logger.info("=" * 50)
    logger.info("✅ Rebuild complete")
    logger.info(f"Time: {dur:.2f}s")
    logger.info(f"Success: {ok}")
    logger.info(f"Failed: {bad}")
    logger.info(f"Index total: {engine.count()}")
    logger.info("=" * 50)


if __name__ == '__main__':
    fix_index()


--- File: ./backend/bot.py ---
import discord
import aiohttp
import logging
import time
import asyncio
import random
import os
import json
import io
import sqlite3
from datetime import datetime
try:
    from config import config
except ImportError:
    from .config import config

# 全局变量用于多账号机器人管理
bot_clients = []
bot_tasks = []

# 全局冷却管理器：(account_id, channel_id) -> timestamp (上次发送时间)
account_last_sent = {}

# 【新增】AI并发限制：最多同时2个AI推理任务，防止CPU饱和导致Flask阻塞
ai_concurrency_limit = asyncio.Semaphore(2)


def get_all_cooldowns():
    """获取所有活跃的冷却状态（供 API 查询）"""
    current_time = time.time()
    cooldowns = []

    snapshot = account_last_sent.copy()

    for key, last_sent in snapshot.items():
        try:
            acc_id, ch_id = key
            time_passed = current_time - last_sent

            if time_passed < 86400:
                cooldowns.append({
                    'account_id': int(acc_id),
                    'channel_id': str(ch_id),
                    'last_sent': last_sent,
                    'time_passed': time_passed
                })
        except Exception:
            continue

    return cooldowns

def is_account_on_cooldown(account_id, channel_id, interval):
    """检查账号在指定频道是否在冷却中"""
    key = (int(account_id), str(channel_id))

    last = account_last_sent.get(key, 0)
    time_passed = time.time() - last
    is_cooldown = time_passed < interval

    if is_cooldown:
        logger.info(f"❄️ [冷却中] 账号ID:{account_id} 频道:{channel_id} | 剩余: {interval - time_passed:.1f}秒")

    return is_cooldown

def set_account_cooldown(account_id, channel_id):
    """设置账号在指定频道的冷却时间"""
    key = (int(account_id), str(channel_id))
    account_last_sent[key] = time.time()
    logger.info(f"🔥 [设置冷却] 账号ID:{account_id} 频道:{channel_id} | Key: {key}")

def cleanup_expired_cooldowns():
    """清理过期的冷却状态"""
    current_time = time.time()
    expired_keys = []
    for key, last_sent in account_last_sent.items():
        # 如果冷却时间超过24小时，清理掉（防止内存泄漏）
        if current_time - last_sent > 86400:  # 24小时
            expired_keys.append(key)

    for key in expired_keys:
        del account_last_sent[key]
        logger.debug(f"清理过期冷却: {key}")

    if expired_keys:
        logger.info(f"清理了 {len(expired_keys)} 个过期的冷却状态")

def mark_message_as_processed(message_id):
    """检查消息是否已处理（原子操作）"""
    try:
        from database import db
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO processed_messages (message_id) VALUES (?)", (str(message_id),))
            conn.commit()
        return True  # 抢锁成功
    except sqlite3.IntegrityError:
        return False  # 已经被其他Bot抢锁

def get_response_url_for_channel(product, channel_id, user_id=None):
    """根据频道ID和网站配置决定发送哪个链接"""
    import re
    try:
        from database import db
    except ImportError:
        from .database import db

    channel_id_str = str(channel_id)

    # 1. 首先尝试根据频道绑定获取网站配置
    website_config = db.get_website_config_by_channel(channel_id_str, user_id)

    if website_config and website_config.get('url_template'):
        # 从商品URL中提取微店ID
        weidian_url = product.get('weidianUrl') or product.get('product_url') or ''
        weidian_id = None

        # 尝试从URL中提取itemID
        match = re.search(r'itemID=(\d+)', weidian_url)
        if match:
            weidian_id = match.group(1)
        else:
            # 尝试从weidianId字段获取
            weidian_id = product.get('weidianId')

        if weidian_id:
            # 使用URL模板生成链接
            url = website_config['url_template'].replace('{id}', weidian_id)
            logger.info(f"使用网站配置 '{website_config['name']}' 的URL模板生成链接: {url[:50]}...")
            return url

    # 2. 回退到旧的硬编码逻辑（兼容性）
    if config.CNFANS_CHANNEL_ID and channel_id_str == config.CNFANS_CHANNEL_ID:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        elif product.get('acbuyUrl'):
            return product['acbuyUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

    elif config.ACBUY_CHANNEL_ID and channel_id_str == config.ACBUY_CHANNEL_ID:
        if product.get('acbuyUrl'):
            return product['acbuyUrl']
        elif product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

    # 3. 默认发送CNFans链接
    else:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', '未找到相关商品')

class HTTPLogHandler(logging.Handler):
    """通过HTTP发送日志到Flask应用"""
    def __init__(self):
        super().__init__()
        self.pending_logs = []
        self.is_sending = False

    def emit(self, record):
        try:
            # 只发送我们关心的日志级别
            if record.levelno >= logging.INFO:
                log_data = {
                    'timestamp': datetime.now().isoformat(),
                    'level': record.levelname,
                    'message': self.format(record),
                    'module': record.module,
                    'func': record.funcName
                }

                # 添加到待发送队列
                self.pending_logs.append(log_data)

                # 如果没有正在发送，启动发送任务
                if not self.is_sending:
                    # 在机器人的事件循环中创建任务
                    try:
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            loop.create_task(self.send_pending_logs())
                        else:
                            # 如果循环没有运行，直接发送（同步方式）
                            self.send_sync(log_data)
                    except RuntimeError:
                        # 没有事件循环，直接同步发送
                        self.send_sync(log_data)

        except Exception as e:
            print(f"HTTP日志处理器错误: {e}")

    def send_sync(self, log_data):
        """同步发送日志（作为fallback）"""
        try:
            import requests
            # 【修复】强制使用 127.0.0.1，因为这是进程间通信，不应走公网
            local_api_url = 'http://127.0.0.1:5001/api'
            response = requests.post(f'{local_api_url}/logs/add',
                                   json=log_data, timeout=2, proxies={'http': None, 'https': None, 'all': None})
            if response.status_code != 200:
                print(f"同步发送日志失败: {response.status_code}")
        except Exception as e:
            # 这里的 print 可能会被重定向，但至少不会抛出 ConnectionRefusedError 炸断流程
            pass

    async def send_pending_logs(self):
        """异步发送待处理的日志"""
        if self.is_sending:
            return

        self.is_sending = True

        # 【修复】强制使用 127.0.0.1
        local_api_url = 'http://127.0.0.1:5001/api'

        try:
            while self.pending_logs:
                log_data = self.pending_logs.pop(0)

                try:
                    async with aiohttp.ClientSession(trust_env=False) as session:
                        async with session.post(f'{local_api_url}/logs/add',
                                              json=log_data, timeout=aiohttp.ClientTimeout(total=2)) as resp:
                            if resp.status != 200:
                                print(f"发送日志失败: {resp.status}")
                except Exception as e:
                    # 队列满了就丢弃，不要无限堆积
                    if len(self.pending_logs) < 1000:
                        self.pending_logs.insert(0, log_data)
                    break

                # 小延迟避免发送太快
                await asyncio.sleep(0.01) # 加快发送速度，减少积压

        finally:
            self.is_sending = False

# 配置日志
logging.basicConfig(level=logging.INFO)

# 添加HTTP日志处理器
http_handler = HTTPLogHandler()
http_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(http_handler)

logger = logging.getLogger(__name__)

# 确保discord库也使用我们的日志配置
logging.getLogger('discord').setLevel(logging.INFO)

class DiscordBotClient(discord.Client):
    # 【新增】频道白名单缓存（类级别共享，所有Bot实例共用）
    _bound_channels_cache = set()  # 已绑定的频道ID集合
    _last_cache_update = 0  # 上次缓存更新时间戳
    _cache_ttl = 60  # 缓存有效期（秒）

    def __init__(self, account_id=None, user_id=None, user_shops=None, role='both'):
        # discord.py-self 可能不需要 intents，或者使用不同的语法
        try:
            # 尝试使用标准的 intents
            intents = discord.Intents.default()
            intents.message_content = True
            intents.messages = True
            intents.guilds = True
            super().__init__(intents=intents)
        except AttributeError:
            # 如果 Intents 不存在，直接初始化（discord.py-self 可能不需要）
            super().__init__()
        self.current_token = None
        self.running = False
        self.account_id = account_id
        self.user_id = user_id  # 用户ID，用于获取个性化设置
        self.user_shops = user_shops  # 用户管理的店铺列表
        self.role = role  # 'listener', 'sender', 'both' - 账号角色

    async def _refresh_channel_cache(self):
        """【新增】刷新频道白名单缓存（60秒TTL）

        从数据库获取所有已绑定的频道ID，更新类级别缓存。
        使用TTL机制避免频繁查询数据库。
        """
        current_time = time.time()

        # 检查缓存是否过期
        if current_time - DiscordBotClient._last_cache_update < DiscordBotClient._cache_ttl:
            return  # 缓存仍然有效，无需刷新

        try:
            # 在线程池中执行数据库查询（避免阻塞事件循环）
            try:
                from database import db
            except ImportError:
                from .database import db

            channel_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_all_bound_channel_ids
            )

            # 更新类级别缓存
            DiscordBotClient._bound_channels_cache = channel_ids
            DiscordBotClient._last_cache_update = current_time

            logger.debug(f"✅ 频道白名单缓存已刷新，共 {len(channel_ids)} 个频道")

        except Exception as e:
            logger.error(f"❌ 刷新频道白名单缓存失败: {e}")
            # 失败时不更新时间戳，下次会重试

    async def schedule_reply(self, message, product, custom_reply=None):
        """调度回复到合适的发送账号 (增强版：带详细状态诊断)"""

        try:
            # 清理过期的冷却状态
            cleanup_expired_cooldowns()

            try:
                from database import db
            except ImportError:
                from .database import db

            # 获取用户设置以确定延迟时间
            user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
            min_delay = user_settings.get('global_reply_min_delay', 3.0)
            max_delay = user_settings.get('global_reply_max_delay', 8.0)

            # 生成回复内容
            response_content = self._generate_reply_content(product, message.channel.id, custom_reply)

            # 1. 尝试获取网站配置（必须绑定，否则不回复）
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            if not website_config:
                logger.info(f"频道 {message.channel.id} 未绑定网站配置，跳过回复")
                return

            target_client = None

            # 2. 获取数据库配置的发送者 ID
            db_sender_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_senders, website_config['id']
            )

            if not db_sender_ids:
                logger.warning(
                    f"❌ [配置错误] 网站配置 '{website_config.get('name')}' 未绑定任何【发送】账号。请在网站配置中绑定账号。"
                )
                return

            # === 获取当前真正在线的机器人账号 ID ===
            online_client_ids = [c.account_id for c in bot_clients if c.is_ready() and not c.is_closed()]

            # 调试信息：打印当前状态
            logger.info(f"配置账号ID: {db_sender_ids} | 在线账号ID: {online_client_ids}")

            # 取交集：既在数据库配置了，又是当前在线的
            valid_senders = [uid for uid in db_sender_ids if uid in online_client_ids]

            if not valid_senders:
                logger.warning("❌ [状态错误] 配置的发送账号均不在线。请检查 Discord 账号连接状态。")
                return

            # 3. 轮换/冷却逻辑 - 使用用户级别设置
            # 优先使用用户个性化设置，如果没有则使用全局配置
            rotation_enabled = website_config.get('rotation_enabled', 1)
            rotation_interval = website_config.get('rotation_interval', 180)

            if self.user_id and website_config.get('id'):
                user_website_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_website_settings, self.user_id, website_config['id']
                )
                if user_website_settings:
                    rotation_enabled = user_website_settings.get('rotation_enabled', rotation_enabled)
                    rotation_interval = user_website_settings.get('rotation_interval', rotation_interval)
                    logger.info(f"📋 使用用户级别设置: rotation_interval={rotation_interval}秒, rotation_enabled={rotation_enabled}")

            available_senders = []

            if rotation_enabled:
                # 筛选非冷却的（按频道区分冷却）
                available_senders = [
                    uid for uid in valid_senders
                    if not is_account_on_cooldown(uid, message.channel.id, rotation_interval)
                ]

                # 只有 valid_senders 有值但 available_senders 为空，才是真正的“冷却中”
                if not available_senders:
                    logger.info(
                        f"⏳ [冷却中] 频道 {message.channel.id} 所有在线账号 ({len(valid_senders)}个) "
                        f"均处于 {rotation_interval}秒 冷却期内，跳过发送"
                    )
                    return

            else:
                available_senders = valid_senders

            # 4. 选中一个 ID
            if available_senders:
                selected_id = random.choice(available_senders)
                target_client = next((c for c in bot_clients if c.account_id == selected_id), None)
                logger.info(
                    f"✅ 本次选中发送账号: {target_client.user.name if target_client else selected_id} (ID: {selected_id})"
                )
            else:
                logger.warning("❌ 逻辑异常：有 valid_senders 但无可用发送账号")
                return

            # 5. 执行发送
            if target_client:
                try:
                    target_channel = target_client.get_channel(message.channel.id)

                    if target_channel:
                        async with target_channel.typing():
                            await asyncio.sleep(random.uniform(min_delay, max_delay))

                        # 【关键修复】
                        # 不要使用 message.reply()，因为 message 绑定的是监听者(Listener)客户端
                        # 必须用 target_channel.send(..., reference=message) 才会使用 target_client(Sender) 的 token
                        try:
                            # === 1. 收集所有要发送的图片文件 ===
                            files = []

                            # 检查是否是自定义模式，且有图片
                            is_custom_mode = custom_reply and (
                                custom_reply.get('reply_type') == 'custom_only' or
                                custom_reply.get('reply_type') == 'text'
                            )

                            if is_custom_mode:
                                # 获取图片信息
                                # 注意：如果是从 search_similar_text 返回的 product，字段名可能已经格式化
                                # 需要兼容处理

                                # 1. 尝试获取自定义图片链接
                                custom_urls = product.get('customImageUrls', []) or product.get('custom_image_urls', [])
                                if isinstance(custom_urls, str):
                                    try:
                                        custom_urls = json.loads(custom_urls)
                                    except:
                                        custom_urls = []

                                image_source = product.get('imageSource') or product.get('image_source') or 'product'

                                # 收集图片文件（Discord限制最多10个文件）
                                if image_source == 'custom' and custom_urls:
                                    for url in custom_urls[:10]:  # 限制最多10张
                                        if len(files) >= 10:
                                            break
                                        try:
                                            async with aiohttp.ClientSession() as session:
                                                async with session.get(url) as resp:
                                                    if resp.status == 200:
                                                        data = await resp.read()
                                                        filename = url.split('/')[-1] or 'image.jpg'
                                                        files.append(discord.File(io.BytesIO(data), filename))
                                        except Exception as e:
                                            logger.error(f"下载自定义图片失败: {e}")

                                elif image_source == 'upload':
                                    # 处理上传的自定义回复图片
                                    pid = product.get('id')

                                    # 从 uploaded_reply_images 字段获取上传的图片文件名列表
                                    uploaded_filenames = product.get('uploaded_reply_images', [])
                                    if isinstance(uploaded_filenames, str):
                                        try:
                                            uploaded_filenames = json.loads(uploaded_filenames)
                                        except:
                                            # 如果解析失败，且它本身就是列表，则保持原样，否则置空
                                            uploaded_filenames = uploaded_filenames if isinstance(uploaded_filenames, list) else []

                                    if pid and uploaded_filenames:
                                        # 使用新的API端点获取上传的自定义回复图片
                                        for filename in uploaded_filenames[:10]:  # 限制最多10张
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/custom_reply_image/{pid}/{filename}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), filename))
                                            except Exception as e:
                                                logger.error(f"下载上传的自定义回复图片失败: {e}")

                                elif image_source == 'product':
                                    # 处理商品图集中的图片
                                    pid = product.get('id')
                                    indexes = product.get('selectedImageIndexes', []) or product.get('custom_reply_images', [])

                                    if isinstance(indexes, str):
                                        try:
                                            indexes = json.loads(indexes)
                                        except:
                                            indexes = []

                                    if pid and indexes:
                                        # 使用原有的API端点获取商品图集中的图片
                                        for idx in indexes[:10]:  # 限制最多10张
                                            if len(files) >= 10:
                                                break
                                            img_url = f"{config.BACKEND_API_URL}/api/image/{pid}/{idx}"
                                            try:
                                                async with aiohttp.ClientSession() as session:
                                                    async with session.get(img_url) as resp:
                                                        if resp.status == 200:
                                                            data = await resp.read()
                                                            files.append(discord.File(io.BytesIO(data), f"{pid}_{idx}.jpg"))
                                            except Exception as e:
                                                logger.error(f"下载商品图片失败: {e}")

                            # === 2. 发送文字和所有图片（合并为一条消息） ===
                            if not response_content and not files:
                                logger.warning(
                                    f"⚠️ 无可发送内容: 商品ID={product.get('id')}，未生成文字且无图片"
                                )
                                return

                            await target_channel.send(
                                content=response_content if response_content else None,
                                files=files if files else None,
                                reference=message,
                                mention_author=True
                            )

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"✅ [回复成功] 真实发送账号: {target_client.user.name} (ID: {target_client.account_id}) | 商品ID: {product.get('id')} | 图片数量: {len(files)}"
                            )

                        except Exception as reply_error:
                            logger.warning(f"回复失败，尝试直接发送: {reply_error}")
                            if response_content:
                                await target_channel.send(response_content)

                            if hasattr(target_client, 'account_id') and target_client.account_id:
                                set_account_cooldown(target_client.account_id, message.channel.id)

                            logger.info(
                                f"✅ [发送成功] 真实发送账号: {target_client.user.name} | 商品ID: {product.get('id')}"
                            )

                    else:
                        logger.warning(
                            f"❌ 选中的账号 {target_client.user.name} 无法访问频道 {message.channel.id} (可能不在该服务器)"
                        )
                        return

                except Exception as e:
                    logger.error(f"❌ 发送异常: {e}")

        except Exception as e:
            logger.error(f"❌ 严重错误: {e}")

    def _generate_reply_content(self, product, channel_id, custom_reply=None):
        """生成回复内容"""
        if custom_reply:
            reply_type = custom_reply.get('reply_type')

            if reply_type == 'custom_only':
                # 只发送自定义内容，不发送链接
                return custom_reply.get('content', '')

            elif reply_type == 'text_and_link':
                # 发送文字 + 链接
                response = get_response_url_for_channel(product, channel_id, self.user_id)
                return f"{custom_reply.get('content', '')}\n{response}".strip()

            elif reply_type == 'text':
                # 只发送文字
                return custom_reply.get('content', '')

        # 默认行为：发送链接
        return get_response_url_for_channel(product, channel_id, self.user_id)

    def get_website_config_by_channel(self, channel_id):
        """根据频道ID获取对应的网站配置"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 查询频道绑定的网站配置
            configs = db.get_website_configs()
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"获取频道网站配置失败: {e}")
            return None

    async def get_website_config_by_channel_async(self, channel_id):
        """异步版本：根据频道ID获取对应的网站配置"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 异步查询频道绑定的网站配置
            configs = await asyncio.get_event_loop().run_in_executor(None, db.get_website_configs)
            for config in configs:
                channels = config.get('channels', [])
                if str(channel_id) in channels:
                    return config
            return None
        except Exception as e:
            logger.error(f"异步获取频道网站配置失败: {e}")
            return None

    def _should_filter_message(self, message):
        """检查消息是否应该被过滤"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 1. 检查全局消息过滤规则
            filters = db.get_message_filters()
            message_content = message.content.lower()

            for filter_rule in filters:
                filter_value = filter_rule['filter_value'].lower()
                filter_type = filter_rule['filter_type']

                if filter_type == 'contains':
                    if filter_value in message_content:
                        logger.info(f'消息被过滤: 包含 "{filter_value}"')
                        return True
                elif filter_type == 'starts_with':
                    if message_content.startswith(filter_value):
                        logger.info(f'消息被过滤: 以 "{filter_value}" 开头')
                        return True
                elif filter_type == 'ends_with':
                    if message_content.endswith(filter_value):
                        logger.info(f'消息被过滤: 以 "{filter_value}" 结尾')
                        return True
                elif filter_type == 'regex':
                    import re
                    try:
                        if re.search(filter_value, message_content, re.IGNORECASE):
                            logger.info(f'消息被过滤: 匹配正则 "{filter_value}"')
                            return True
                    except re.error:
                        logger.warning(f'无效的正则表达式: {filter_value}')
                elif filter_type == 'user_id':
                    # 检查用户ID过滤
                    filter_user_ids = [uid.strip() for uid in filter_value.split(',') if uid.strip()]
                    sender_id = str(message.author.id)
                    sender_name = str(message.author.name).lower()

                    for blocked_id in filter_user_ids:
                        blocked_id = blocked_id.strip()
                        if blocked_id == sender_id or blocked_id.lower() in sender_name:
                            logger.info(f'消息被过滤: 用户 {message.author.name} (ID: {sender_id}) 在过滤列表中')
                            return True

            # 2. 检查用户个性化设置的过滤规则
            if self.user_id:
                user_settings = db.get_user_settings(self.user_id)
                if user_settings:
                    # 检查用户黑名单
                    user_blacklist = user_settings.get('user_blacklist', '')
                    if user_blacklist:
                        blacklist_users = [u.strip().lower() for u in user_blacklist.split(',') if u.strip()]
                        sender_name = str(message.author.name).lower()
                        sender_id = str(message.author.id).lower()

                        for blocked_user in blacklist_users:
                            blocked_user = blocked_user.lower()
                            if blocked_user in sender_name or blocked_user == sender_id:
                                logger.info(f'消息被过滤: 用户 {message.author.name} 在黑名单中')
                                return True

                    # 检查关键词过滤
                    keyword_filters = user_settings.get('keyword_filters', '')
                    if keyword_filters:
                        filter_keywords = [k.strip().lower() for k in keyword_filters.split(',') if k.strip()]

                        for keyword in filter_keywords:
                            if keyword in message_content:
                                logger.info(f'消息被过滤: 包含关键词 "{keyword}"')
                                return True

        except Exception as e:
            logger.error(f'检查消息过滤失败: {e}')

        return False

    def _get_custom_reply(self):
        """获取自定义回复内容"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            replies = db.get_custom_replies()

            if replies:
                # 返回优先级最高的活跃回复
                return replies[0]
        except Exception as e:
            logger.error(f'获取自定义回复失败: {e}')

        return None

    async def on_ready(self):
        logger.info(f'Discord机器人已登录: {self.user} (ID: {self.user.id})')
        logger.info(f'机器人已就绪，开始监听消息')
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            bound_channels = await asyncio.get_event_loop().run_in_executor(None, db.get_all_bound_channel_ids)
            if bound_channels:
                bound_list = sorted(bound_channels)
                preview = ", ".join(bound_list[:5])
                suffix = " ..." if len(bound_list) > 5 else ""
                logger.info(f'监听频道: 已绑定 {len(bound_list)} 个 ({preview}{suffix})')
            else:
                logger.info('监听频道: 未绑定频道')
        except Exception as e:
            logger.error(f'获取监听频道失败: {e}')
        self.running = True

        # 更新数据库中的账号状态为在线
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            if hasattr(self, 'account_id'):
                db.update_account_status(self.account_id, 'online')
                logger.info(f'账号 {self.account_id} 状态已更新为在线')
        except Exception as e:
            logger.error(f'更新账号状态失败: {e}')

    async def on_message(self, message):
        if not self.running:
            return

        # 忽略自己的消息
        if message.author == self.user:
            return

        # 忽略机器人和webhook的消息
        if message.author.bot or message.webhook_id:
            return

        # 1. 忽略 @别人的信息
        if message.mentions:
            return

        # 2. 忽略回复别人的信息
        if message.reference is not None:
            return

        # 3. 角色过滤：纯 sender 账号完全不处理消息
        if self.role == 'sender':
            return

        # =================================================================
        # 【核心修复】先检查：这条消息所在的频道，是否归当前账号"监听"？
        # =================================================================
        try:
            # 异步获取该频道绑定的网站配置
            website_config = await self.get_website_config_by_channel_async(message.channel.id)

            # 如果这个频道没有绑定任何配置，直接忽略
            if not website_config:
                # logger.debug(f"频道 {message.channel.id} 未绑定配置，账号 {self.account_id} 忽略此消息")
                return

            # 进一步检查：当前账号是否是该配置的合法监听者？
            # 这是一个关键步骤，防止未绑定的账号处理已绑定频道的消息
            try:
                from database import db
            except ImportError:
                from .database import db

            # 获取该网站配置绑定的所有监听者ID
            listener_ids = await asyncio.get_event_loop().run_in_executor(
                None, db.get_website_listeners, website_config['id']
            )

            # 如果当前账号不在监听列表中，直接忽略
            if self.account_id not in listener_ids:
                # logger.debug(f"账号 {self.account_id} 不是频道 {message.channel.id} 的监听者，忽略")
                return

        except Exception as e:
            logger.error(f"检查频道绑定权限失败: {e}")
            return

        # =================================================================
        # 【核心修复】确认我有资格处理后，再抢全局锁
        # =================================================================
        try:
            if not mark_message_as_processed(message.id):
                logger.info(f"消息 {message.id} 已被其他(合法的)Bot处理，跳过")
                return
        except Exception as e:
            logger.error(f"消息去重检查失败: {e}")
            return

        # 4. 触发内容过滤规则
        if self._should_filter_message(message):
            return

        logger.info(f'📨 [接收] 账号:{self.user.name} | 频道:{message.channel.name} | 内容: "{message.content[:50]}..."')

        # 获取用户设置
        keyword_reply_enabled = True
        image_reply_enabled = True
        if self.user_id:
            try:
                user_settings = await asyncio.get_event_loop().run_in_executor(
                    None, db.get_user_settings, self.user_id
                )
                keyword_reply_enabled = user_settings.get('keyword_reply_enabled', 1) == 1
                image_reply_enabled = user_settings.get('image_reply_enabled', 1) == 1
            except Exception as e:
                logger.error(f'获取用户回复开关设置失败: {e}')

        # 处理关键词消息转发
        await self.handle_keyword_forward(message)

        # 处理关键词搜索
        if keyword_reply_enabled:
            await self.handle_keyword_search(message)

        # 处理图片
        if image_reply_enabled and message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and attachment.content_type.startswith('image/'):
                    logger.info(f"📷 检测到图片，开始处理: {attachment.filename}")
                    await self.handle_image(message, attachment)

    async def handle_image(self, message, attachment):
        try:
            # 【增强稳定性】增加超时时间，添加代理支持
            timeout = aiohttp.ClientTimeout(total=30, connect=10)  # 30秒总超时，10秒连接超时
            image_data = None

            # 【代理配置】从环境变量获取代理（支持国内网络环境）
            proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None

            # 【伪装头】添加 User-Agent 防止被 Discord CDN 拒绝
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }

            # 重试最多3次
            for attempt in range(3):
                try:
                    logger.info(f"下载Discord图片 (尝试 {attempt + 1}/3): {attachment.filename}")
                    # 【关键修复】trust_env=True 允许使用系统代理
                    async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                        async with session.get(attachment.url, proxy=proxy_url) as resp:
                            if resp.status == 200:
                                image_data = await resp.read()
                                logger.info(f"图片下载成功，大小: {len(image_data)} bytes")
                                break
                            else:
                                logger.warning(f"图片下载失败，状态码: {resp.status}")
                except aiohttp.ClientError as e:
                    logger.warning(f"图片下载网络错误 (尝试 {attempt + 1}/3): {e}")
                    if attempt < 2:  # 不是最后一次尝试
                        await asyncio.sleep(2)  # 【增强】等待2秒后重试
                except Exception as e:
                    logger.error(f"图片下载未知错误 (尝试 {attempt + 1}/3): {e}")
                    break

            if image_data is None:
                logger.error("图片下载失败，已达到最大重试次数")
                return  # 静默失败，不发送错误消息

            # 【新增】AI并发限制：最多同时2个AI推理任务
            # 使用Semaphore控制并发，防止CPU饱和导致Flask主线程阻塞
            async with ai_concurrency_limit:
                logger.debug(f"🔒 获取AI并发锁，当前等待队列: {ai_concurrency_limit._value}")

                # 调用 DINOv2 服务识别图片，不使用店铺过滤（所有用户都能识别所有商品）
                result = await self.recognize_image(image_data, user_shops=None)

                logger.debug(f"🔓 释放AI并发锁")

            logger.info(f'图片识别结果: success={result.get("success") if result else False}, results_count={len(result.get("results", [])) if result else 0}')

            if result and result.get('success') and result.get('results'):
                # 获取最佳匹配结果
                best_match = result['results'][0]
                similarity = best_match.get('similarity', 0)

                # 获取用户个性化相似度阈值，如果没有则使用全局默认值
                user_threshold = config.DISCORD_SIMILARITY_THRESHOLD  # 默认值
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # 异步获取用户设置
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            user_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'获取用户相似度设置失败: {e}')

                logger.info(f'最佳匹配相似度: {similarity:.4f}, 用户阈值: {user_threshold:.4f}')

                # 严格执行用户设置的阈值
                if similarity >= user_threshold:
                    product = best_match.get('product', {})
                    logger.info(f'✅ 匹配成功! 相似度: {similarity:.2f} | 商品: {product.get("id")} | 频道: {message.channel.name}')

                    # 检查商品是否启用了自动回复规则
                    product_rule_enabled = product.get('ruleEnabled', True)

                    if product_rule_enabled:
                        # 使用全局自定义回复
                        custom_reply = self._get_custom_reply()

                        # 使用调度机制回复，而不是直接回复
                        await self.schedule_reply(message, product, custom_reply)
                    else:
                        # 商品级自定义回复
                        custom_text = product.get('custom_reply_text', '').strip()
                        custom_image_indexes = product.get('selectedImageIndexes', [])
                        custom_image_urls = product.get('customImageUrls', [])

                        # 发送自定义文本消息
                        if custom_text:
                            await message.reply(custom_text)

                        # 发送图片（按优先级：本地上传 > 自定义链接 > 商品图片）
                        images_sent = False

                        # 优先检查图片来源类型
                        image_source = product.get('image_source', 'product')

                        if image_source == 'upload':
                            # 发送本地上传的图片
                            try:
                                from database import db
                                # 获取该商品的所有图片（包括上传的）
                                product_images = db.get_product_images(product['id'])
                                if product_images:
                                    for img_data in product_images[:10]:  # 最多发送10张图片
                                        try:
                                            image_path = img_data.get('image_path')
                                            # 如果是相对路径，构建完整路径
                                            if image_path and not os.path.isabs(image_path):
                                                image_path = os.path.join(os.path.dirname(__file__), image_path)
                                            if image_path and os.path.exists(image_path):
                                                await message.reply(file=discord.File(image_path, os.path.basename(image_path)))
                                                images_sent = True
                                        except Exception as e:
                                            logger.error(f'发送本地上传图片失败: {e}')
                            except Exception as e:
                                logger.error(f'处理本地上传图片回复失败: {e}')

                        elif image_source == 'custom' and custom_image_urls and len(custom_image_urls) > 0:
                            # 发送自定义图片链接
                            try:
                                # 【代理配置】从环境变量获取代理
                                proxy_url = os.getenv("HTTPS_PROXY") or os.getenv("HTTP_PROXY") or None
                                # 【伪装头】添加 User-Agent
                                headers = {
                                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                                }
                                timeout = aiohttp.ClientTimeout(total=30, connect=10)

                                for url in custom_image_urls[:10]:  # 最多发送10张图片
                                    try:
                                        # 【关键修复】trust_env=True 允许使用系统代理
                                        async with aiohttp.ClientSession(timeout=timeout, headers=headers, trust_env=True) as session:
                                            async with session.get(url.strip(), proxy=proxy_url) as resp:
                                                if resp.status == 200:
                                                    image_data = await resp.read()
                                                    # 从URL提取文件名
                                                    filename = url.split('/')[-1].split('?')[0] or f"image_{custom_image_urls.index(url)}.jpg"
                                                    if not filename.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
                                                        filename += '.jpg'
                                                    await message.reply(file=discord.File(io.BytesIO(image_data), filename))
                                                    images_sent = True
                                    except Exception as e:
                                        logger.error(f'发送自定义图片失败 {url}: {e}')
                            except Exception as e:
                                logger.error(f'处理自定义图片回复失败: {e}')

                        elif custom_image_indexes and len(custom_image_indexes) > 0:
                            # 发送选中的商品图片
                            try:
                                import aiofiles
                                from database import db

                                for image_index in custom_image_indexes:
                                    try:
                                        # 获取图片路径
                                        image_path = db.get_product_image_path(product['id'], image_index)
                                        if image_path and os.path.exists(image_path):
                                            # 发送图片文件
                                            await message.reply(file=discord.File(image_path, f"image_{image_index}.jpg"))
                                            images_sent = True
                                    except Exception as e:
                                        logger.error(f'发送商品图片失败: {e}')
                            except Exception as e:
                                logger.error(f'处理商品图片回复失败: {e}')

                        # 如果既没有文本也没有图片，则发送默认链接
                        if not custom_text and not images_sent:
                            response = get_response_url_for_channel(product, message.channel.id, self.user_id)
                            await message.reply(response)

                    logger.info(f'图片识别成功，相似度: {similarity:.4f}')
                else:
                    # 相似度低于阈值，不回复任何消息
                    logger.info(f'图片识别相似度 {similarity:.4f} 低于用户阈值 {user_threshold:.4f}，不回复')

        except Exception as e:
            logger.error(f'Error handling image: {e}')
            # 不发送错误消息到Discord，只记录日志

    async def handle_keyword_forward(self, message):
        """处理关键词消息转发"""
        try:
            # 检查消息内容是否包含关键词
            message_content = message.content.lower() if message.content else ""
            has_keyword = any(keyword.strip().lower() in message_content for keyword in config.FORWARD_KEYWORDS)

            if has_keyword and config.FORWARD_TARGET_CHANNEL_ID:
                # 获取目标频道
                target_channel = self.get_channel(config.FORWARD_TARGET_CHANNEL_ID)
                if target_channel:
                    # 构建转发消息
                    forward_embed = discord.Embed(
                        title="📢 商品相关消息转发",
                        description=f"**原始消息:** {message.content[:500]}{'...' if len(message.content) > 500 else ''}",
                        color=0x00ff00,
                        timestamp=message.created_at
                    )

                    forward_embed.add_field(
                        name="发送者",
                        value=f"{message.author.name}#{message.author.discriminator}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="来源频道",
                        value=f"#{message.channel.name}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="服务器",
                        value=message.guild.name if message.guild else "DM",
                        inline=True
                    )

                    # 如果有附件，添加到embed中
                    if message.attachments:
                        attachment_urls = [att.url for att in message.attachments]
                        forward_embed.add_field(
                            name="附件",
                            value="\n".join(attachment_urls),
                            inline=False
                        )

                    forward_embed.set_footer(text=f"消息ID: {message.id}")

                    await target_channel.send(embed=forward_embed)
                    logger.info(f"转发了包含关键词的消息: {message.content[:100]}...")
                else:
                    logger.warning(f"找不到目标频道: {config.FORWARD_TARGET_CHANNEL_ID}")

        except Exception as e:
            logger.error(f'Error handling keyword forward: {e}')

    async def handle_keyword_search(self, message):
        """处理关键词商品搜索"""
        try:
            # 只处理纯文字消息（不包含图片的）
            if not message.content or message.attachments:
                return

            search_query = message.content.strip()
            if not search_query:
                return

            # 过滤太短的消息（至少需要2个字符）
            if len(search_query) < 2:
                return

            # 过滤纯数字消息（如 "1", "2", "123"）
            if search_query.isdigit():
                return

            # 过滤只包含数字和空格的消息（如 "1 2 3"）
            if search_query.replace(' ', '').isdigit():
                return

            # 过滤常见的无意义短消息
            meaningless_patterns = {'ok', 'no', 'yes', 'hi', 'hey', 'lol', 'lmao', 'wtf', 'omg', 'bruh'}
            if search_query.lower() in meaningless_patterns:
                return

            # 调用搜索API
            result = await self.search_products_by_keyword(search_query)

            products = []
            if result and result.get('success') and result.get('products'):
                products = result['products'][:5]  # 最多显示5个结果

            # 只在找到商品时回复和记录日志
            if products:
                logger.info(f'关键词搜索成功: "{search_query}" -> 找到 {len(products)} 个商品')
                product = products[0]

                # 检查频道是否绑定了网站配置（必须绑定才能回复）
                website_config = await self.get_website_config_by_channel_async(message.channel.id)
                if not website_config:
                    logger.info(f"频道 {message.channel.id} 未绑定网站配置，跳过关键词回复")
                    return

                # === 关键修复逻辑 ===
                # 检查规则是否启用（兼容字符串/数字）
                # 注意：后端API返回的 autoReplyEnabled 即 ruleEnabled
                rule_enabled = product.get('autoReplyEnabled', True)
                if isinstance(rule_enabled, str):
                    rule_enabled = rule_enabled.strip().lower() not in {'0', 'false', 'no', 'off'}
                elif isinstance(rule_enabled, (int, float)):
                    rule_enabled = bool(rule_enabled)

                custom_reply = None

                # 检查是否配置了自定义图片
                def _coerce_list(value):
                    if not value:
                        return []
                    if isinstance(value, str):
                        try:
                            parsed = json.loads(value)
                        except json.JSONDecodeError:
                            return []
                        return parsed if isinstance(parsed, list) else []
                    if isinstance(value, list):
                        return value
                    return []

                has_custom_images = False
                image_source = product.get('imageSource') or product.get('image_source')

                if image_source == 'upload':
                    uploaded_imgs = _coerce_list(product.get('uploaded_reply_images'))
                    product['uploaded_reply_images'] = uploaded_imgs
                    has_custom_images = bool(uploaded_imgs)
                elif image_source == 'custom':
                    custom_urls = _coerce_list(product.get('customImageUrls')) or _coerce_list(product.get('custom_image_urls'))
                    if custom_urls:
                        product['customImageUrls'] = custom_urls
                    has_custom_images = bool(custom_urls)
                elif image_source == 'product':
                    selected_indexes = _coerce_list(product.get('selectedImageIndexes')) or _coerce_list(product.get('custom_reply_images'))
                    if selected_indexes:
                        product['selectedImageIndexes'] = selected_indexes
                    has_custom_images = bool(selected_indexes)

                # 如果规则禁用了，或者配置了自定义图片，都需要创建 custom_reply
                if not rule_enabled or has_custom_images:
                    # 构造 custom_reply 对象供 schedule_reply 使用
                    custom_text = (product.get('custom_reply_text') or '').strip()

                    # 即使没有文本，只要是要发图片，也需要传递 custom_reply 信号
                    # schedule_reply 会进一步处理图片逻辑
                    custom_reply = {
                        'reply_type': 'text' if custom_text else 'custom_only', # custom_only 表示不发默认链接
                        'content': custom_text,
                        # 传递图片信息供 schedule_reply 内部处理
                        'product_data': product
                    }
                    if not rule_enabled:
                        logger.info(f"商品 {product['id']} 规则已禁用，准备发送自定义回复")
                    elif has_custom_images:
                        logger.info(f"商品 {product['id']} 配置了自定义图片，准备发送自定义回复")

                # 使用 schedule_reply 统一发送
                await self.schedule_reply(message, product, custom_reply)
            else:
                # 没有找到商品，不回复任何消息
                logger.info(f'关键词搜索无结果: {search_query}')

        except Exception as e:
            logger.error(f'Error handling keyword search: {e}')
            # 不发送错误消息到Discord，只记录日志

    async def search_products_by_keyword(self, keyword):
        """根据关键词搜索商品"""
        try:
            # 设置超时时间
            timeout = aiohttp.ClientTimeout(total=10)  # 10秒超时
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # 构建搜索请求
                search_data = {
                    'query': keyword,
                    'limit': 10  # 搜索更多结果，但只显示前5个
                }

                # 调用后端搜索API
                async with session.post(f'{config.BACKEND_API_URL}/api/search_similar_text',
                                      json=search_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'Keyword search API error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error searching products by keyword: {e}')
            return None

    async def recognize_image(self, image_data, user_shops=None):
        try:
            # 增加超时时间，FAISS搜索可能需要更长时间
            timeout = aiohttp.ClientTimeout(total=30)  # 30秒超时
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # 准备图片数据
                form_data = aiohttp.FormData()
                form_data.add_field('image', image_data, filename='image.jpg', content_type='image/jpeg')
                # 使用配置的阈值
                # 使用用户个性化阈值，如果没有则使用全局默认值
                api_threshold = config.DISCORD_SIMILARITY_THRESHOLD
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        # 异步获取用户设置
                        user_settings = await asyncio.get_event_loop().run_in_executor(None, db.get_user_settings, self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            api_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'获取用户相似度设置失败: {e}')

                form_data.add_field('threshold', str(api_threshold))
                form_data.add_field('limit', '1')  # Discord只返回最相似的一个结果

                # 如果指定了用户店铺权限，添加到请求中
                if user_shops:
                    form_data.add_field('user_shops', json.dumps(user_shops))

                # 调用 DINOv2 + FAISS 服务（本地）
                async with session.post(f'{config.BACKEND_API_URL.replace("/api", "")}/search_similar', data=form_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        return None

        except asyncio.TimeoutError:
            logger.error('Error recognizing image: Request timeout (30s)')
            return None
        except aiohttp.ClientError as e:
            logger.error(f'Error recognizing image: Network error - {type(e).__name__}: {e}')
            return None
        except Exception as e:
            logger.error(f'Error recognizing image: {type(e).__name__}: {e}')
            return None

async def get_all_accounts_from_backend():
    """从后端 API 获取所有可用的 Discord 账号"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f'{config.BACKEND_API_URL}/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    # 只返回状态为online的账号
                    return [account for account in accounts if account.get('status') == 'online']
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def bot_loop(client):
    """主循环，定期检查并重连"""
    while True:
        try:
            token = await get_token_from_backend()
            if token:
                if not client.is_ready():
                    logger.info('Starting Discord bot with token from database...')
                    await client.start(token, reconnect=True)
                elif client.current_token != token:
                    logger.info('Token changed, reconnecting...')
                    await client.close()
                    await asyncio.sleep(2)
                    client.current_token = token
                    await client.start(token, reconnect=True)
            else:
                logger.warning('No active token found in database, waiting...')
                if client.is_ready():
                    await client.close()
                client.current_token = None

        except Exception as e:
            logger.error(f'Bot loop error: {e}')
            if client.is_ready():
                await client.close()

        # 等待 30 秒后再次检查
        await asyncio.sleep(30)

async def start_multi_bot_loop():
    """启动多账号机器人循环，定期检查账号状态"""
    global bot_clients, bot_tasks

    while True:
        try:
            # 获取当前所有账号
            accounts = await get_all_accounts_from_backend()
            current_account_ids = {account['id'] for account in accounts}

            # 停止已删除账号的机器人
            to_remove = []
            for i, client in enumerate(bot_clients):
                if client.account_id not in current_account_ids:
                    logger.info(f'停止已删除账号的机器人: {client.account_id}')
                    try:
                        if not client.is_closed():
                            await client.close()
                    except Exception as e:
                        logger.error(f'停止机器人时出错: {e}')

                    # 取消对应的任务
                    if i < len(bot_tasks) and bot_tasks[i] and not bot_tasks[i].done():
                        bot_tasks[i].cancel()

                    to_remove.append(i)

            # 从列表中移除已停止的机器人
            for i in reversed(to_remove):
                bot_clients.pop(i)
                if i < len(bot_tasks):
                    bot_tasks.pop(i)

            # 为新账号启动机器人
            existing_account_ids = {client.account_id for client in bot_clients}
            for account in accounts:
                account_id = account['id']
                if account_id not in existing_account_ids:
                    token = account['token']
                    username = account.get('username', f'account_{account_id}')

                    logger.info(f'启动新账号机器人: {username}')

                    # 创建机器人实例
                    client = DiscordBotClient(account_id=account_id)

                    # 启动机器人
                    try:
                        task = asyncio.create_task(client.start(token, reconnect=True))
                        bot_clients.append(client)
                        bot_tasks.append(task)
                        logger.info(f'机器人启动成功: {username}')
                    except Exception as e:
                        logger.error(f'启动机器人失败 {username}: {e}')

            # 等待一段时间后再次检查
            await asyncio.sleep(30)

        except Exception as e:
            logger.error(f'多账号机器人循环错误: {e}')
            await asyncio.sleep(30)

async def main():
    client = DiscordBotClient()

    # 启动主循环
    await bot_loop(client)

if __name__ == '__main__':
    asyncio.run(main())

--- File: ./backend/feature_extractor.py ---
import os

# === 性能优化配置 ===
# 允许底层计算库每个任务使用少量核心。
# 配合上层有限并发（例如 3 个并发任务），在 10 核 CPU 上更容易吃满但不打架。
# 可通过环境变量 AI_INTRA_THREADS 调整。
try:
    from .config import config as _cfg
except Exception:
    try:
        from config import config as _cfg
    except Exception:
        _cfg = None

_intra_threads = None
try:
    if _cfg is not None and hasattr(_cfg, 'AI_INTRA_THREADS'):
        _intra_threads = int(_cfg.AI_INTRA_THREADS)
except Exception:
    _intra_threads = None

if not _intra_threads or _intra_threads <= 0:
    _intra_threads = int(os.getenv('AI_INTRA_THREADS', '3'))

os.environ["OMP_NUM_THREADS"] = str(_intra_threads)
os.environ["MKL_NUM_THREADS"] = str(_intra_threads)
os.environ["OPENBLAS_NUM_THREADS"] = str(_intra_threads)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(_intra_threads)
os.environ["NUMEXPR_NUM_THREADS"] = str(_intra_threads)

import warnings
warnings.filterwarnings("ignore", message="Could not initialize NNPACK")
import torch

# === 添加这段代码 ===
try:
    # 显式禁用 NNPACK
    torch.backends.nnpack.enabled = False
except Exception:
    pass
# =================
import numpy as np
import cv2  # OpenCV for color histogram and structure comparison
import threading
from typing import List, Optional, Union, Dict
import logging
from pathlib import Path
from PIL import Image
from transformers import AutoImageProcessor, AutoModel
from ultralytics import YOLO
try:
    from .config import config
except ImportError:
    from config import config
from functools import lru_cache
import hashlib

logger = logging.getLogger(__name__)

# 全局单例变量
_global_extractor = None
_extractor_lock = threading.Lock()

class DINOv2FeatureExtractor:
    """
    "猎鹰"架构特征提取器
    DINOv2 (大脑) + YOLO-World (眼睛)
    专为鞋类识别优化，自动裁剪鞋子主体后提取高精度特征
    """

    def __init__(self):
        self.device = torch.device(config.DEVICE)
        logger.info(f"正在初始化猎鹰AI引擎，使用设备: {self.device}")

        # 加载YOLOv8-Nano (眼睛 - 主体检测)
        self._load_yolo_detector()

        # 加载DINOv2 (大脑 - 特征提取)
        self._load_dino_model()

        # 初始化缓存用于检测结果
        self._detection_cache = {}

    def _get_image_hash(self, image_path: str) -> str:
        """计算图片文件的哈希值用于缓存"""
        try:
            with open(image_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception:
            # 如果读取失败，使用文件路径+修改时间作为备用
            import os
            stat = os.stat(image_path)
            return hashlib.md5(f"{image_path}:{stat.st_mtime}".encode()).hexdigest()

    def _load_yolo_detector(self):
        """强制加载YOLO-World模型用于商品识别"""
        try:
            # 减少日志级别
            logging.getLogger("ultralytics").setLevel(logging.WARNING)
            self.detector = YOLO(config.YOLO_MODEL_PATH)

            # [核心配置] 定义全自动识别的范围
            # 优化后的商品类别，覆盖微店/代购场景95%的商品
            # YOLO-World 会自动忽略人脸、手、家具、背景
            self.target_classes = [
                # 鞋类 (高优先级)
                "shoe", "sneaker", "boot", "sandal", "slipper", "heel",
                # 服装 (高优先级)
                "shirt", "t-shirt", "jacket", "coat", "pants", "jeans",
                "dress", "skirt", "shorts", "hoodie", "sweater", "suit",
                # 包袋配饰 (中优先级)
                "bag", "handbag", "backpack", "wallet", "belt", "hat", "cap",
                "watch", "jewelry", "necklace", "ring", "glasses",
                # 电子产品 (中优先级)
                "phone", "laptop", "headphone", "camera", "watch",
                # 家居用品 (低优先级)
                "toy", "box", "bottle", "cup", "lamp"
            ]

            # 将这些类别注入模型
            self.detector.set_classes(self.target_classes)

            logger.info("🎉 YOLO-World模型加载成功！")
            logger.info(f"🎯 支持自动识别 {len(self.target_classes)} 种商品类别")
            logger.info(f"📋 YOLO-World目标类别: {', '.join(self.target_classes[:10])}...")
            logger.info("⚡ YOLO-World优化说明: 使用多维度评分(面积×置信度×位置×类别权重)，显著提升裁剪准确率")

            # 验证CLIP库是否正确安装
            try:
                import clip
                logger.info(f"✅ CLIP库版本验证: {getattr(clip, '__version__', '未知')}")
                if hasattr(clip, 'load'):
                    logger.info("✅ CLIP.load方法可用")
                else:
                    logger.warning("⚠️ CLIP.load方法不可用，可能影响YOLO-World性能")
            except ImportError as e:
                logger.warning(f"⚠️ 无法导入CLIP库: {e}")

        except Exception as e:
            logger.error(f"💥 YOLO-World模型加载失败: {e}")

            # 检查是否是CLIP相关的问题，如果是则尝试备用方案
            if "clip" in str(e).lower():
                logger.warning("🔍 检测到CLIP库问题，尝试备用加载方式...")

                try:
                    # 尝试不依赖CLIP的加载方式
                    import ultralytics
                    logger.info(f"Ultralytics版本: {ultralytics.__version__}")

                    # 直接创建YOLO-World实例，不设置类别
                    self.detector = YOLO('yolov8s-world.pt')
                    self.target_classes = None  # 不设置自定义类别

                    logger.warning("⚠️ YOLO-World以基础模式加载 (无自定义类别)")
                    logger.warning("📊 影响: 将使用YOLO-World的内置80类进行检测")
                    logger.info("✅ YOLO-World基础模式加载成功")

                except Exception as backup_error:
                    logger.error(f"💥 备用加载方式也失败: {backup_error}")
                    logger.error("🔥 用户要求强制使用YOLO-World，但所有加载方式都失败！")
                    logger.error("💡 最终解决方案:")
                    logger.error("   1. pip uninstall clip torch torchvision ultralytics")
                    logger.error("   2. pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu")
                    logger.error("   3. pip install ultralytics")
                    logger.error("   4. pip install git+https://github.com/openai/CLIP.git")
                    raise RuntimeError("YOLO-World加载失败，所有备用方案均无效") from e
            else:
                # 不是CLIP问题，直接报错
                logger.error("🔥 YOLO-World加载失败，错误不相关CLIP库")
                logger.error("💡 建议检查网络连接和ultralytics版本")
                raise RuntimeError("YOLO-World加载失败") from e

    def _load_dino_model(self):
        """加载DINOv2模型用于特征提取"""
        try:
            model_name = config.DINO_MODEL_NAME
            logger.info(f"加载DINOv2特征模型: {model_name}...")

            self.processor = AutoImageProcessor.from_pretrained(model_name)
            self.model = AutoModel.from_pretrained(model_name)

            # 安全地将模型移动到设备，避免meta tensor错误
            try:
                if hasattr(self.model, 'to'):
                    self.model = self.model.to(self.device)
                else:
                    logger.warning("模型没有to()方法，使用原模型")
            except Exception as device_error:
                logger.warning(f"模型移动到设备失败: {device_error}，尝试其他方法...")
                try:
                    # 尝试使用to_empty方法
                    if hasattr(self.model, 'to_empty'):
                        self.model = self.model.to_empty(device=self.device)
                    else:
                        logger.error("模型不支持to_empty方法，使用CPU")
                        self.device = torch.device('cpu')
                        self.model = self.model.to(self.device)
                except Exception as fallback_error:
                    logger.error(f"所有设备移动方法都失败: {fallback_error}")
                    raise

            self.model.eval()
            logger.info("✅ DINOv2模型加载成功")
        except Exception as e:
            logger.error(f"❌ DINOv2模型加载失败: {e}")
            raise RuntimeError("DINOv2模型加载失败") from e

    def _crop_main_object(self, image_path: str) -> Image.Image:
        """全自动裁剪商品主体 + [新增] 尺寸优化

        全自动裁剪逻辑：
        1. 在预设的商品类别中检测所有物体
        2. 自动过滤掉背景、人、手
        3. 在剩下的商品中，选出最显著的一个（最大+最中心）
        4. [新增] 缩小图片尺寸以加快AI推理速度
        """
        try:
            if not config.USE_YOLO_CROP:
                return self._resize_for_ai(Image.open(image_path).convert("RGB"))

            # 检查缓存
            image_hash = self._get_image_hash(image_path)
            if image_hash in self._detection_cache:
                logger.debug("使用缓存的检测结果")
                cached_result = self._detection_cache[image_hash]
                if cached_result is None:
                    # 缓存中表示未检测到商品
                    return self._resize_for_ai(Image.open(image_path).convert("RGB"))
                # 返回缓存的裁剪结果
                return cached_result

            # conf=0.1: 降低门槛，宁可多检不要漏检，反正我们有逻辑过滤
            results = self.detector(image_path, conf=0.1, verbose=False)

            if not results or len(results[0].boxes) == 0:
                logger.info("未检测到通用商品，降级使用原图")
                # 缓存未检测到商品的结果
                self._detection_cache[image_hash] = None
                return self._resize_for_ai(Image.open(image_path).convert("RGB"))

            boxes = results[0].boxes
            img = Image.open(image_path).convert("RGB")
            img_w, img_h = img.size
            center_x, center_y = img_w / 2, img_h / 2

            # --- 智能评分逻辑 ---
            # 在所有检测到的"商品"中，选出主角

            best_box = None
            max_score = -1

            for box in boxes:
                # 1. 获取坐标
                coords = box.xyxy[0].cpu().numpy()  # [x1, y1, x2, y2]
                x1, y1, x2, y2 = coords

                # 2. 计算面积
                width = x2 - x1
                height = y2 - y1
                area = width * height

                # 3. 计算离图片中心的距离
                box_center_x = x1 + width / 2
                box_center_y = y1 + height / 2
                dist_to_center = ((box_center_x - center_x)**2 + (box_center_y - center_y)**2) ** 0.5

                # 4. 综合评分公式：
                # 面积越大越好 (权重 0.7)
                # 越靠中心越好 (权重 0.3)
                # 这个公式能保证：即使角落里有个大包，也会优先选中间的小鞋子
                norm_area = area / (img_w * img_h)
                norm_dist = 1 - (dist_to_center / ((img_w**2 + img_h**2)**0.5))

                score = (norm_area * 0.7) + (norm_dist * 0.3) + (float(box.conf) * 0.1)

                if score > max_score:
                    max_score = score
                    best_box = coords

            if best_box is None:
                logger.info("未找到合适的商品框，使用原图")
                # 缓存失败结果
                self._detection_cache[image_hash] = None
                return self._resize_for_ai(img)

            # 执行裁剪
            x1, y1, x2, y2 = best_box

            # 扩充 5% - 10% 的边缘，保留一点点上下文
            pad_x = (x2 - x1) * 0.05
            pad_y = (y2 - y1) * 0.05

            crop_box = (
                max(0, x1 - pad_x),
                max(0, y1 - pad_y),
                min(img_w, x2 + pad_x),
                min(img_h, y2 + pad_y)
            )

            cropped_img = img.crop(crop_box)
            logger.info(f"成功裁剪商品区域: {crop_box}")

            # 优化：Resize 裁剪后的图片
            final_img = self._resize_for_ai(cropped_img)

            # 缓存成功结果
            self._detection_cache[image_hash] = final_img.copy()

            return final_img

        except Exception as e:
            logger.warning(f"自动裁剪出错: {e}, 使用原图")
            # 缓存失败结果
            try:
                image_hash = self._get_image_hash(image_path)
                self._detection_cache[image_hash] = None
            except:
                pass
            return self._resize_for_ai(Image.open(image_path).convert("RGB"))

    def _resize_for_ai(self, img: Image.Image, max_size: int = 640) -> Image.Image:
        """[新增] 将图片缩小到适合 AI 推理的尺寸，大幅提升速度

        Args:
            img: 输入图片
            max_size: 最大尺寸（默认640px），对于特征提取任务已经足够精确

        Returns:
            缩放后的图片
        """
        w, h = img.size
        if max(w, h) > max_size:
            scale = max_size / max(w, h)
            new_w = int(w * scale)
            new_h = int(h * scale)
            return img.resize((new_w, new_h), Image.Resampling.LANCZOS)
        return img

    def extract_feature(self, image_path: Union[str, Path]) -> Optional[np.ndarray]:
        """提取单张图片的特征向量 (384维或768维)"""
        try:
            image_path = str(image_path)

            if not os.path.exists(image_path):
                logger.error(f"文件不存在: {image_path}")
                return None

            # 1. YOLO裁剪主体
            img = self._crop_main_object(image_path)

            # 2. 预处理（DINOv2会自动处理）
            inputs = self.processor(images=img, return_tensors="pt").to(self.device)

            # 3. 特征提取
            with torch.no_grad():
                outputs = self.model(**inputs)

            # 4. 获取CLS token特征 (DINOv2的最佳实践)
            # outputs.last_hidden_state.shape: [1, num_patches+1, dim]
            # 第0个是CLS token，代表整张图的语义
            embedding = outputs.last_hidden_state[0, 0, :].cpu().numpy()

            # 5. L2归一化 (对余弦相似度至关重要)
            norm = float(np.linalg.norm(embedding))
            if norm > 0:
                embedding = embedding / norm

            # 6. 确保数据类型为float32 (FAISS要求)
            return embedding.astype('float32')

        except Exception as e:
            logger.error(f"DINOv2特征提取失败 {image_path}: {e}")
            import traceback
            traceback.print_exc()
            return None

    def extract_features_batch(self, image_paths: List[Union[str, Path]]) -> List[Optional[np.ndarray]]:
        """批量提取特征向量"""
        results = []
        for image_path in image_paths:
            feature = self.extract_feature(image_path)
            results.append(feature)
        return results

    def prepare_hybrid_query(self, img_path: str) -> Optional[Dict]:
        """预先计算查询图的颜色/结构特征，便于重排序阶段复用"""
        try:
            img = cv2.imread(img_path)
            if img is None:
                logger.warning(f"无法读取查询图片: {img_path}")
                return None
            return self._build_hybrid_signature(img)
        except Exception as e:
            logger.warning(f"查询图特征预计算失败: {e}")
            return None

    def _build_hybrid_signature(self, img: np.ndarray) -> Dict:
        """构建用于混合相似度的颜色/结构签名"""
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        hist = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])
        cv2.normalize(hist, hist, 0, 1, cv2.NORM_MINMAX)

        img_small = cv2.resize(img, (64, 64))
        gray_small = cv2.cvtColor(img_small, cv2.COLOR_BGR2GRAY)

        return {
            'hsv_hist': hist,
            'gray_small': gray_small
        }

    def calculate_hybrid_similarity(self, img_path1: str, img_path2: str, dino_score: float,
                                    query_signature: Optional[Dict] = None) -> dict:
        """
        【新增】计算综合相似度 (Re-ranking)

        综合分 = DINO语义分(60%) + 颜色分(25%) + 轮廓分(15%)

        Args:
            img_path1: 查询图片路径
            img_path2: 候选图片路径
            dino_score: DINOv2原始相似度分数

        Returns:
            dict: {'score': 综合分数, 'details': {'dino': ..., 'color': ..., 'structure': ...}}
        """
        try:
            if query_signature is None:
                img1 = cv2.imread(img_path1)
                if img1 is None:
                    logger.warning(f"无法读取图片，使用原始DINO分数: {img_path1}")
                    return {'score': dino_score, 'details': {}}
                query_signature = self._build_hybrid_signature(img1)

            img2 = cv2.imread(img_path2)
            if img2 is None:
                logger.warning(f"无法读取图片，使用原始DINO分数: {img_path2}")
                return {'score': dino_score, 'details': {}}

            candidate_signature = self._build_hybrid_signature(img2)

            # 巴氏距离比较 (结果 0-1, 1为完全匹配)
            color_score = cv2.compareHist(query_signature['hsv_hist'], candidate_signature['hsv_hist'], cv2.HISTCMP_CORREL)
            color_score = max(0.0, color_score)  # 修正可能的负值

            # 2. 轮廓/结构相似度 (简化版：缩小后比较像素差异)
            diff = cv2.absdiff(query_signature['gray_small'], candidate_signature['gray_small'])
            structure_score = 1.0 - (np.mean(diff) / 255.0)

            # === 综合评分公式 (可调优) ===
            # DINO (语义/版型): 权重 0.6
            # Color (颜色): 权重 0.25 (对区分不同配色的同款鞋很有用)
            # Structure (细节): 权重 0.15

            final_score = (dino_score * 0.6) + (color_score * 0.25) + (structure_score * 0.15)

            logger.debug(f"综合评分: DINO={dino_score:.3f}, Color={color_score:.3f}, Structure={structure_score:.3f}, Final={final_score:.3f}")

            return {
                'score': float(final_score),
                'details': {
                    'dino': float(dino_score),
                    'color': float(color_score),
                    'structure': float(structure_score)
                }
            }

        except Exception as e:
            logger.error(f"计算综合相似度出错: {e}")
            import traceback
            traceback.print_exc()
            return {'score': dino_score, 'details': {}}

    def get_status(self) -> Dict:
        """获取AI模型状态和性能信息"""
        status = {
            'device': str(self.device),
            'yolo_available': self.detector is not None,
            'yolo_type': 'None'
        }

        if self.detector is not None:
            if self.target_classes and len(self.target_classes) > 20:
                status['yolo_type'] = 'YOLO-World'
                status['target_classes_count'] = len(self.target_classes)
                status['target_classes'] = self.target_classes[:10]  # 只显示前10个
            else:
                status['yolo_type'] = 'YOLOv8-Nano'
                status['target_classes_count'] = len(self.target_classes) if self.target_classes else 0

        status['detection_cache_size'] = len(self._detection_cache)
        status['confidence_threshold'] = 0.05
        status['iou_threshold'] = 0.5

        # 性能提示
        tips = []
        if self.detector is None:
            tips.append("YOLO裁剪已禁用，建议修复YOLO加载问题以提升准确性")
        elif status['yolo_type'] == 'YOLOv8-Nano':
            tips.append("当前使用YOLOv8-Nano，建议升级依赖以启用YOLO-World获得更好效果")

        if status['detection_cache_size'] > 1000:
            tips.append("检测缓存较大，考虑定期清理缓存")

        status['performance_tips'] = tips if tips else ["AI模型运行正常"]

        return status

# 向后兼容的别名
class FeatureExtractor(DINOv2FeatureExtractor):
    """向后兼容的别名"""
    pass

def get_feature_extractor() -> 'DINOv2FeatureExtractor':
    """全局获取特征提取器实例（线程安全单例）"""
    global _global_extractor

    if _global_extractor is not None:
        return _global_extractor

    with _extractor_lock:
        # 双重检查锁定
        if _global_extractor is None:
            logger.info("🚀 [系统] 初始化 AI 模型 (DINOv2 + YOLO)...")
            try:
                _global_extractor = DINOv2FeatureExtractor()
                logger.info("✅ [系统] AI 模型初始化完成")
            except Exception as e:
                logger.error(f"❌ [系统] AI 模型初始化失败: {e}")
                raise e
        return _global_extractor

--- File: ./backend/vector_engine.py ---
import faiss
import numpy as np
import os
import pickle
import logging
import json
from typing import List, Dict, Tuple
try:
    from .config import config
except ImportError:
    from config import config

logger = logging.getLogger(__name__)

class VectorEngine:
    """
    FAISS HNSW向量搜索引擎
    纯文件系统存储，无需Docker
    支持百万级向量毫秒级查询
    """

    def __init__(self, index_file=None, id_map_file=None):
        self.index_file = index_file or config.FAISS_INDEX_FILE
        self.id_map_file = id_map_file or config.FAISS_ID_MAP_FILE

        self.dimension = config.VECTOR_DIMENSION
        self.index = None

        # FAISS只能存整数ID，我们需要一个映射：FAISS内部ID -> 数据库(product_images表的ID)
        # 这个列表的索引是FAISS ID，值是数据库ID
        self.id_map = []

        self._load_or_create_index()

    def _load_or_create_index(self):
        """加载或创建FAISS HNSW索引"""
        if os.path.exists(self.index_file) and os.path.exists(self.id_map_file):
            logger.info("正在加载FAISS索引...")
            try:
                self.index = faiss.read_index(self.index_file)
                with open(self.id_map_file, 'rb') as f:
                    self.id_map = pickle.load(f)
                if hasattr(self.index, 'efSearch'):
                    self.index.efSearch = config.FAISS_EF_SEARCH
                    logger.info(f"设置efSearch = {config.FAISS_EF_SEARCH}")
                logger.info(f"✅ FAISS索引加载完成，当前包含 {self.index.ntotal} 个向量")
            except Exception as e:
                logger.error(f"加载索引失败，将创建新索引: {e}")
                self._create_new_index()
        else:
            logger.info("创建新的FAISS HNSW索引...")
            self._create_new_index()

    def _create_new_index(self):
        """创建新的FAISS HNSW索引，优化参数设置"""
        logger.info("创建新的FAISS HNSW索引...")

        # HNSW64: 图结构，查询极快，准确率高
        # InnerProduct (IP) 在归一化向量上等同于余弦相似度
        self.index = faiss.IndexHNSWFlat(
            self.dimension,
            config.FAISS_HNSW_M,
            faiss.METRIC_INNER_PRODUCT
        )

        # 设置构建参数 (兼容不同版本的FAISS)
        ef_construction_set = False
        ef_search_set = False

        try:
            # 尝试设置HNSW参数 (新版本FAISS >= 1.7.0)
            if hasattr(self.index, 'efConstruction'):
                self.index.efConstruction = config.FAISS_EF_CONSTRUCTION  # 构建时的深度，越高越准但构建越慢
                ef_construction_set = True
                logger.info(f"设置efConstruction = {config.FAISS_EF_CONSTRUCTION}")

            if hasattr(self.index, 'efSearch'):
                self.index.efSearch = config.FAISS_EF_SEARCH  # 搜索时的深度，越高越准但搜索越慢
                ef_search_set = True
                logger.info(f"设置efSearch = {config.FAISS_EF_SEARCH}")

        except AttributeError:
            logger.warning("FAISS版本不支持efConstruction/efSearch参数，将使用默认值")

        # 如果无法设置参数，提供性能优化建议
        if not ef_construction_set or not ef_search_set:
            logger.info("💡 FAISS性能优化建议:")
            logger.info(f"   - 当前FAISS版本: {faiss.__version__}")
            logger.info("   - 建议升级到FAISS >= 1.7.0以获得最佳性能")
            logger.info("   - 或者使用: pip install faiss-cpu --upgrade")

        # 设置其他兼容性参数
        try:
            # 设置HNSW的M参数 (如果支持)
            if hasattr(self.index, 'hnsw'):
                logger.info(f"HNSW M参数 = {config.FAISS_HNSW_M}")
        except:
            pass

        self.id_map = []

        # 确保目录存在
        os.makedirs(os.path.dirname(self.index_file), exist_ok=True)

        logger.info("✅ FAISS HNSW索引创建完成")

    def save(self):
        """保存索引到磁盘 (百万级数据保存大约需要几秒)"""
        try:
            faiss.write_index(self.index, self.index_file)
            with open(self.id_map_file, 'wb') as f:
                pickle.dump(self.id_map, f)
            logger.info("FAISS索引已保存到磁盘")
        except Exception as e:
            logger.error(f"保存索引失败: {e}")

    def add_vector(self, db_id: int, vector: np.ndarray) -> bool:
        """添加向量到FAISS索引"""
        try:
            # 确保向量是正确的形状和类型
            if isinstance(vector, list):
                vector = np.array(vector, dtype='float32')
            elif vector.dtype != np.float32:
                vector = vector.astype('float32')

            vector = vector.reshape(1, -1)  # 确保是[1, dim]形状

            # 添加到FAISS
            self.index.add(vector)

            # 记录ID映射：FAISS内部ID -> 数据库ID
            faiss_id = self.index.ntotal - 1  # 新添加的向量ID
            if len(self.id_map) <= faiss_id:
                self.id_map.extend([None] * (faiss_id - len(self.id_map) + 1))
            self.id_map[faiss_id] = db_id

            return True

        except Exception as e:
            logger.error(f"添加向量失败: {e}")
            return False

    def search(self, query_vector: np.ndarray, top_k: int = 1) -> List[Dict]:
        """搜索最相似的向量"""
        import time
        start_time = time.time()

        if self.index.ntotal == 0:
            logger.info("FAISS索引为空，跳过搜索")
            return []

        try:
            # 确保查询向量格式正确
            if isinstance(query_vector, list):
                query_vector = np.array(query_vector, dtype='float32')
            elif query_vector.dtype != np.float32:
                query_vector = query_vector.astype('float32')

            query_vector = query_vector.reshape(1, -1)

            logger.info(f"开始FAISS搜索，索引大小: {self.index.ntotal}, top_k: {top_k}")

            # 执行搜索
            # 强制使用单线程进行搜索，防止在 Flask/MacOS 环境下发生 OpenMP 死锁
            faiss.omp_set_num_threads(1)
            search_start = time.time()
            distances, indices = self.index.search(query_vector, top_k)
            search_time = time.time() - search_start
            logger.info(f"FAISS搜索完成，耗时: {search_time:.3f}秒")

            results = []
            for i in range(min(top_k, len(indices[0]))):
                faiss_id = indices[0][i]
                score = distances[0][i]

                if faiss_id != -1 and faiss_id < len(self.id_map) and self.id_map[faiss_id] is not None:
                    db_id = self.id_map[faiss_id]
                    results.append({
                        'db_id': db_id,
                        'score': float(score)
                    })

            total_time = time.time() - start_time
            logger.info(f"搜索总耗时: {total_time:.3f}秒, 返回{len(results)}个结果")
            return results

        except Exception as e:
            logger.error(f"搜索失败: {e}")
            return []

    def remove_vector_by_db_id(self, db_id: int) -> bool:
        """
        从FAISS索引中删除向量。由于FAISS不支持直接删除单个向量，
        我们标记删除并定期重建索引（性能优化版本）。
        """
        try:
            # 标记要删除的向量
            vector_removed = False
            for i, mapped_id in enumerate(self.id_map):
                if mapped_id == db_id:
                    self.id_map[i] = None
                    vector_removed = True
                    logger.info(f"标记向量删除: db_id={db_id}, faiss_id={i}")
                    break

            # 性能优化：不立即重建索引，只保存状态
            # 只有当删除的向量比例超过阈值时才重建
            if vector_removed:
                deleted_count = sum(1 for id_val in self.id_map if id_val is None)
                total_count = len(self.id_map)
                deletion_ratio = deleted_count / total_count if total_count > 0 else 0

                # 如果删除比例超过30%，则重建索引清理碎片
                if deletion_ratio > 0.3:
                    logger.info(f"删除比例({deletion_ratio:.1%})过高，重建索引清理碎片")
                    self._rebuild_index_after_removal()
                else:
                    # 只保存索引状态，不重建
                    self.save()

            return True
        except Exception as e:
            logger.error(f"删除向量失败: {e}")
            return False

    def _rebuild_index_after_removal(self):
        """删除向量后重建索引（优化版：直接使用数据库中已存的 features，不重新跑模型）"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            valid_vectors = []

            # 只保留那些仍然“未被标记删除”的 db_id
            alive_db_ids = {mapped_id for mapped_id in self.id_map if mapped_id is not None}

            with db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, features FROM product_images WHERE id IS NOT NULL AND features IS NOT NULL")
                for row in cursor.fetchall():
                    img_id = row['id']
                    if img_id not in alive_db_ids:
                        continue

                    features_str = row['features']
                    try:
                        vec = np.array(json.loads(features_str), dtype='float32')
                        if vec.shape[0] != self.dimension:
                            continue
                        valid_vectors.append((img_id, vec))
                    except Exception:
                        continue

            # 重建索引
            self._create_new_index()
            for img_id, vec in valid_vectors:
                self.add_vector(img_id, vec)

            self.save()
            logger.info(f"索引重建完成，包含 {len(valid_vectors)} 个向量")

        except Exception as e:
            logger.error(f"重建索引失败: {e}")

    def rebuild_index(self, vectors_data: List[Tuple[int, np.ndarray]]) -> bool:
        """
        重建整个索引 (用于清理已删除的向量或批量更新)

        vectors_data: [(db_id, vector), ...]
        """
        try:
            logger.info("开始重建FAISS索引...")

            # 删除旧的索引文件
            try:
                if os.path.exists(self.index_file):
                    os.remove(self.index_file)
                if os.path.exists(self.id_map_file):
                    os.remove(self.id_map_file)
            except Exception as e:
                logger.warning(f"删除旧索引文件失败: {e}")

            # 创建新索引
            self._create_new_index()

            # 重新添加所有向量
            for db_id, vector in vectors_data:
                self.add_vector(db_id, vector)

            # 立即保存新索引
            self.save()

            logger.info(f"索引重建完成，包含 {self.index.ntotal} 个向量")
            return True

        except Exception as e:
            logger.error(f"重建索引失败: {e}")
            # 尝试重新加载旧索引
            try:
                self._load_or_create_index()
            except:
                pass
            return False

    def count(self) -> int:
        """返回当前索引中的向量数量"""
        return self.index.ntotal

    def get_stats(self) -> Dict:
        """获取索引统计信息"""
        ef_construction = getattr(self.index, 'efConstruction', '不支持')
        ef_search = getattr(self.index, 'efSearch', '不支持')

        return {
            'total_vectors': self.index.ntotal,
            'dimension': self.dimension,
            'index_type': 'HNSW',
            'metric_type': 'InnerProduct (Cosine)',
            'ef_construction': ef_construction,
            'ef_search': ef_search,
            'memory_usage_mb': self._estimate_memory_usage(),
            'faiss_version': faiss.__version__,
            'performance_tips': self._get_performance_tips()
        }

    def _get_performance_tips(self) -> List[str]:
        """获取性能优化建议"""
        tips = []

        # 检查FAISS版本
        try:
            version_parts = faiss.__version__.split('.')
            major = int(version_parts[0])
            minor = int(version_parts[1])

            if major < 1 or (major == 1 and minor < 7):
                tips.append("建议升级FAISS到1.7.0+版本以获得efConstruction/efSearch参数支持")
        except:
            tips.append("无法检测FAISS版本，建议升级到最新版本")

        # 检查ef参数
        if not hasattr(self.index, 'efConstruction'):
            tips.append("当前FAISS版本不支持efConstruction参数，搜索性能可能受限")

        if not hasattr(self.index, 'efSearch'):
            tips.append("当前FAISS版本不支持efSearch参数，建议手动设置搜索参数")

        # 检查向量数量
        if self.index.ntotal < 1000:
            tips.append("向量数量较少，考虑增加更多商品数据以提高搜索准确性")

        # 检查内存使用
        memory_mb = self._estimate_memory_usage()
        if memory_mb > 1000:  # 超过1GB
            tips.append(f"内存使用量较大 ({memory_mb:.1f}MB)，建议监控内存使用情况")

        return tips if tips else ["系统运行正常，无性能优化建议"]

    def _estimate_memory_usage(self) -> float:
        """估算内存使用量 (MB)"""
        # HNSW索引内存估算：向量数据 + 图结构
        vector_memory = self.index.ntotal * self.dimension * 4  # float32 = 4 bytes
        graph_memory = self.index.ntotal * config.FAISS_HNSW_M * 4  # 邻居指针
        total_bytes = vector_memory + graph_memory
        return total_bytes / (1024 * 1024)

# 全局单例
_engine = None

def get_vector_engine() -> VectorEngine:
    global _engine
    if _engine is None:
        _engine = VectorEngine()
    return _engine

--- File: ./backend/scripts/clear_database.py ---
#!/usr/bin/env python3
"""
数据库清理脚本
清空所有数据库数据、图片文件和向量索引

使用方法:
cd backend
python3 clear_database.py

或者直接运行:
python3 clear_database.py --confirm
"""

import os
import sys
import sqlite3
import shutil
from pathlib import Path

def clear_all_data(confirm=False):
    """清空所有数据"""
    if not confirm:
        print("⚠️ 警告: 此操作将清空所有数据！")
        print("包括: 用户账户、商品数据、图片文件、向量索引等")
        print("")
        response = input("确认要清空所有数据吗？输入 'YES' 确认: ")
        if response != 'YES':
            print("操作已取消")
            return

    # 数据目录
    DATA_DIR = Path('data')

    # 所有数据库文件
    DB_FILES = [
        'data/app.db',
        'data/metadata.db',
        'data/milvus.db',
        'data/discord_bot.db'  # 万一存在
    ]

    print('🗑️ 开始全面清空所有数据库和相关数据...')

    # 1. 清空所有SQLite数据库
    for db_path in DB_FILES:
        if os.path.exists(db_path):
            print(f'📄 清空SQLite数据库: {db_path}')
            try:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()

                # 获取所有表名
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = cursor.fetchall()

                # 清空所有表
                for table in tables:
                    table_name = table[0]
                    if table_name != 'sqlite_sequence':  # 跳过SQLite内部表
                        print(f'  删除表 {table_name} 的所有数据')
                        cursor.execute(f'DELETE FROM {table_name}')

                        # 重置自增ID
                        cursor.execute(f'DELETE FROM sqlite_sequence WHERE name="{table_name}"')

                conn.commit()
                conn.close()
                print(f'✅ {db_path} 已清空')

            except Exception as e:
                print(f'❌ 清空 {db_path} 失败: {e}')
        else:
            print(f'⚠️ 数据库文件不存在: {db_path}')

    # 2. 删除图片文件
    IMAGES_DIR = DATA_DIR / 'scraped_images'
    if IMAGES_DIR.exists():
        print(f'🖼️ 删除图片目录: {IMAGES_DIR}')
        try:
            shutil.rmtree(IMAGES_DIR)
            print('✅ 图片目录已删除')
        except Exception as e:
            print(f'❌ 删除图片目录失败: {e}')
    else:
        print('⚠️ 图片目录不存在')

    # 3. 删除向量数据目录
    VECTOR_DIR = DATA_DIR / 'vectors'
    if VECTOR_DIR.exists():
        print(f'🔍 删除向量数据目录: {VECTOR_DIR}')
        try:
            shutil.rmtree(VECTOR_DIR)
            print('✅ 向量数据目录已删除')
        except Exception as e:
            print(f'❌ 删除向量数据目录失败: {e}')
    else:
        print('⚠️ 向量数据目录不存在')

    # 4. 删除向量索引文件
    vector_extensions = ['*.faiss', '*.index', '*.pkl', '*.npy', '*.bin']
    vector_files = []
    for ext in vector_extensions:
        vector_files.extend(list(DATA_DIR.glob(ext)))

    if vector_files:
        print('🔍 删除向量索引文件:')
        for vf in vector_files:
            try:
                vf.unlink()
                print(f'  ✅ 删除: {vf}')
            except Exception as e:
                print(f'  ❌ 删除失败 {vf}: {e}')

    # 5. 删除临时文件
    temp_files = list(DATA_DIR.glob('temp_*')) + list(DATA_DIR.glob('*.tmp'))
    if temp_files:
        print('🗂️ 删除临时文件:')
        for tf in temp_files:
            try:
                tf.unlink()
                print(f'  ✅ 删除: {tf}')
            except Exception as e:
                print(f'  ❌ 删除失败 {tf}: {e}')

    print('\n🎉 全面数据库清理完成！')
    print('\n📋 清理内容总结:')
    print('  - 所有SQLite数据库 (app.db, metadata.db, milvus.db) 已清空')
    print('  - 自增ID计数器已重置')
    print('  - 图片文件目录已删除')
    print('  - 向量数据目录已删除')
    print('  - 向量索引文件 (*.faiss, *.index, *.pkl, *.npy, *.bin) 已删除')
    print('  - 临时文件已删除')
    print('\n⚠️ 注意: 所有用户账户、商品数据、系统配置、向量索引都已被清空')
    print('   这是一个不可逆的操作，如需恢复请从备份恢复')

if __name__ == '__main__':
    confirm = '--confirm' in sys.argv
    clear_all_data(confirm)

--- File: ./backend/scripts/create_admin.py ---
#!/usr/bin/env python3
"""
创建管理员账号脚本

使用方法:
# 推荐：在项目根目录运行
cd /path/to/project
python3 create_admin.py

# 或者在backend目录下运行
cd backend
python3 scripts/create_admin.py

# 指定用户名和密码
python3 create_admin.py --username admin --password admin123
"""

import sys
import getpass
import argparse
import os

# 确保在正确的目录下运行
if not os.path.exists('database.py'):
    print("❌ 请在 backend 目录下运行此脚本")
    print("正确用法:")
    print("  cd backend")
    print("  python3 scripts/create_admin.py")
    sys.exit(1)

try:
    from database import Database
except ImportError as e:
    print(f"❌ 导入数据库模块失败: {e}")
    print("请确保在 backend 目录下运行此脚本")
    sys.exit(1)

from werkzeug.security import generate_password_hash

def create_admin_user(username=None, password=None):
    """创建管理员用户"""
    db = Database()

    # 如果没有提供参数，交互式输入
    if not username:
        username = input("请输入管理员用户名: ").strip()
        if not username:
            print("❌ 用户名不能为空")
            return

    if not password:
        password = getpass.getpass("请输入管理员密码: ").strip()
        if not password:
            print("❌ 密码不能为空")
            return

        # 确认密码
        confirm_password = getpass.getpass("请再次输入密码确认: ").strip()
        if password != confirm_password:
            print("❌ 两次输入的密码不一致")
            return

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 检查用户名是否已存在
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = cursor.fetchone()

            if existing_user:
                print(f"❌ 用户名 '{username}' 已存在")
                return

            # 创建管理员用户
            hashed_password = generate_password_hash(password)
            cursor.execute("""
                INSERT INTO users (username, password_hash, role, created_at, updated_at)
                VALUES (?, ?, 'admin', datetime('now'), datetime('now'))
            """, (username, hashed_password))

            user_id = cursor.lastrowid
            conn.commit()

            print("✅ 管理员账号创建成功！")
            print(f"   用户名: {username}")
            print(f"   角色: 管理员")
            print(f"   用户ID: {user_id}")
            print("\n🔐 请妥善保管账号信息")

    except Exception as e:
        print(f"❌ 创建管理员账号失败: {e}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='创建管理员账号')
    parser.add_argument('--username', help='管理员用户名')
    parser.add_argument('--password', help='管理员密码')

    args = parser.parse_args()

    if args.username and args.password:
        create_admin_user(args.username, args.password)
    else:
        create_admin_user()

--- File: ./backend/app.py ---
# ============================================================
# 【优化修复】移除全局单线程限制，允许 PyTorch/DINOv2 使用多核加速
# FAISS 的死锁保护已在 vector_engine.py 中通过 faiss.omp_set_num_threads(1) 单独处理
# 移除这些限制可以让 AI 推理速度提升 3-5 倍
# ============================================================
import os
import multiprocessing  # Windows多进程兼容性必需
# 已移除全局线程限制，让 PyTorch 能够利用多核 CPU
# os.environ["OMP_NUM_THREADS"] = "1"
# os.environ["MKL_NUM_THREADS"] = "1"
# os.environ["OPENBLAS_NUM_THREADS"] = "1"
# os.environ["VECLIB_MAXIMUM_THREADS"] = "1"
# os.environ["NUMEXPR_NUM_THREADS"] = "1"

from flask import Flask, request, jsonify, Response, session
import numpy as np
import logging
import sys
from datetime import datetime
from threading import Lock

# 自动加载.env文件
try:
    from dotenv import load_dotenv
    # 从项目根目录加载.env文件
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    env_path = os.path.join(project_root, '.env')
    if os.path.exists(env_path):
        load_dotenv(env_path)
        print(f"✅ 已加载环境变量文件: {env_path}")
    else:
        print("ℹ️  未找到.env文件，使用系统环境变量")
except ImportError:
    print("ℹ️  python-dotenv未安装，使用系统环境变量")

try:
    from feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
except ImportError:
    from .feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
try:
    from database import db
    from config import config
except ImportError:
    from .database import db
    from .config import config
import requests
import json
from flask_cors import CORS
import queue
import threading
import time
from urllib.parse import quote
import hashlib
import uuid

# === 全局状态变量 ===
ai_model_ready = False  # AI模型是否已就绪

# 在应用启动时从数据库加载系统配置
def load_system_config():
    """从数据库加载系统配置到内存"""
    # 在函数内部定义logger，因为此时全局logger可能还没有初始化
    import logging
    func_logger = logging.getLogger(__name__)

    try:
        sys_config = db.get_system_config()
        config.DISCORD_SIMILARITY_THRESHOLD = sys_config['discord_similarity_threshold']
        config.DISCORD_CHANNEL_ID = sys_config['discord_channel_id']
        config.CNFANS_CHANNEL_ID = sys_config['cnfans_channel_id']
        config.ACBUY_CHANNEL_ID = sys_config['acbuy_channel_id']

        # 加载全局回复延迟配置
        reply_config = db.get_global_reply_config()
        config.GLOBAL_REPLY_MIN_DELAY = reply_config['min_delay']
        config.GLOBAL_REPLY_MAX_DELAY = reply_config['max_delay']

        # 设置环境变量（供机器人使用）
        discord_channel_id = sys_config['discord_channel_id']
        if discord_channel_id:
            os.environ['DISCORD_CHANNEL_ID'] = discord_channel_id

        func_logger.info("系统配置已从数据库加载")
        func_logger.info(f"下载线程: {config.DOWNLOAD_THREADS}")
        func_logger.info(f"特征提取线程: {config.FEATURE_EXTRACT_THREADS}")
        func_logger.info(f"Discord相似度阈值: {config.DISCORD_SIMILARITY_THRESHOLD} ({config.DISCORD_SIMILARITY_THRESHOLD*100:.0f}%)")
        func_logger.info(f"全局回复延迟设置为: {config.GLOBAL_REPLY_MIN_DELAY}-{config.GLOBAL_REPLY_MAX_DELAY}秒")
        func_logger.info(f"Discord频道ID: {discord_channel_id or '未设置(监听所有频道)'}")
    except Exception as e:
        func_logger.warning(f"加载系统配置失败，使用默认值: {e}")

def check_duplicate_image(new_features, existing_features_list, threshold=0.99):
    """
    检查新图片的特征向量是否与现有列表中的图片重复

    :param new_features: 新图片的特征向量 (numpy array)
    :param existing_features_list: 现有图片的特征向量列表 (可以是json字符串列表或numpy列表)
    :param threshold: 相似度阈值，默认99%
    :return: (is_duplicate, similarity_score)
    """
    if not existing_features_list:
        return False, 0.0

    try:
        # 确保 new_features 是 1D 数组
        new_features = np.array(new_features, dtype='float32').flatten()

        # 预计算新向量的范数
        norm_new = float(np.linalg.norm(new_features))
        if norm_new == 0:
            return False, 0.0

        for feat_item in existing_features_list:
            try:
                # 处理输入可能是 JSON 字符串或已经是 numpy 数组的情况
                if isinstance(feat_item, str):
                    feat_vec = np.array(json.loads(feat_item), dtype='float32').flatten()
                else:
                    feat_vec = np.array(feat_item, dtype='float32').flatten()

                norm_existing = float(np.linalg.norm(feat_vec))
                if norm_existing == 0:
                    continue

                # 计算余弦相似度
                dot_product = float(np.dot(new_features, feat_vec))
                similarity = dot_product / (norm_new * norm_existing)

                if similarity > threshold:
                    return True, float(similarity)

            except Exception:
                continue

    except Exception as e:
        logger.error(f"向量比对出错: {e}")

    return False, 0.0

def process_and_save_image_core(product_id, image_url_or_file, index, existing_features=None, save_faiss_immediately=True):
    """
    核心图片处理单元：保存 -> 特征提取 -> 查重 -> 数据库 -> FAISS

    :param product_id: 商品ID
    :param image_url_or_file: 或者是 URL 字符串，或者是 Flask 的 FileStorage 对象
    :param index: 图片索引
    :param existing_features: 现有特征向量列表，用于查重
    :param save_faiss_immediately: 是否立即保存FAISS索引（单张上传时为True，批量处理时为False）
    :return: 处理结果字典
    """
    import os
    import time

    # 1. 确定保存路径（使用配置的目录）
    timestamp = int(time.time() * 1000000)
    filename = f"{product_id}_{index}_{timestamp}.jpg"
    save_path = os.path.join(config.IMAGE_SAVE_DIR, str(product_id), filename)
    os.makedirs(os.path.dirname(save_path), exist_ok=True)

    img_db_id = None  # 初始化数据库 ID

    try:
        # 2. 保存文件
        if hasattr(image_url_or_file, 'save'):
            # 是上传的文件对象 (FileStorage)
            image_url_or_file.save(save_path)
        else:
            # 是 URL 字符串
            import requests
            resp = requests.get(image_url_or_file, timeout=config.REQUEST_TIMEOUT, proxies={'http': None, 'https': None})
            if resp.status_code != 200:
                return {'success': False, 'error': f'Download failed: {resp.status_code}'}
            with open(save_path, 'wb') as f:
                f.write(resp.content)

        # 验证文件大小
        if os.path.getsize(save_path) == 0:
            os.remove(save_path)
            return {'success': False, 'error': 'Empty file'}

        # 3. 特征提取 (DINOv2 + YOLO)
        extractor = get_global_feature_extractor()
        if extractor is None:
            os.remove(save_path)
            return {'success': False, 'error': 'Feature extractor not initialized'}

        features = extractor.extract_feature(save_path)
        if features is None:
            os.remove(save_path)
            return {'success': False, 'error': 'Feature extraction failed'}

        # 4. 查重逻辑 (99.5%相似度)
        if existing_features:
            is_dup, score = check_duplicate_image(features, existing_features, threshold=0.995)
            if is_dup:
                os.remove(save_path)
                logger.info(f"🚫 图片高度相似 (相似度: {score:.4f})，已跳过: {filename}")
                return {'success': True, 'skipped': True}  # 标记为成功但跳过，以免报错

        # 5. 入库 (SQLite)
        img_db_id = db.insert_image_record(product_id, save_path, index, features)

        # 6. 入库 (FAISS)
        try:
            from vector_engine import get_vector_engine
            engine = get_vector_engine()

            # === FAISS 线程安全锁 ===
            with faiss_lock:  # 加锁，确保同一时间只有一个线程写入 FAISS
                engine.add_vector(img_db_id, features)
                # 性能优化：单张上传时立即保存，批量处理时延迟保存
                if save_faiss_immediately:
                    engine.save()
        except Exception as faiss_err:
            logger.error(f"FAISS 入库失败: {faiss_err}")
            # FAISS失败时删除数据库记录和文件，回滚操作
            try:
                db.delete_image_record(img_db_id)
            except:
                pass
            if os.path.exists(save_path):
                os.remove(save_path)
            return {'success': False, 'error': f'FAISS error: {faiss_err}'}

        # 7. 更新对比列表，确保下一张图能跟这张比
        if existing_features is not None:
            existing_features.append(features)  # 关键：实时加入列表

        # 8. 完成
        return {
            'success': True,
            'image_path': save_path,
            'features': features,
            'index': index,
            'filename': filename,
            'db_id': img_db_id
        }

    except Exception as e:
        logger.error(f'图片处理总出错，尝试清理: {e}')
        if os.path.exists(save_path):
            os.remove(save_path)
        # 如果已经插入数据库但后续失败，需要回滚
        if img_db_id:
            try:
                db.delete_image_record(img_db_id)
            except:
                pass
        return {'success': False, 'error': str(e)}

# 线程配置现在统一在 config.py 中管理

# 【修复】移除全局 load_system_config() 调用，防止子进程重复初始化
# load_system_config() 现在在 initialize_runtime() 中调用

# === 重构：店铺抓取状态控制 ===
# 移除全局状态变量，改为数据库持久化存储
# scrape_status现在通过db.get_scrape_status()和db.update_scrape_status()管理

# 线程管理：跟踪当前运行的抓取线程
current_scrape_thread = None
scrape_thread_lock = threading.Lock()
scrape_stop_event = threading.Event()  # 抓取停止事件，用于线程间通信

# FAISS 线程安全锁：防止多线程同时写入向量索引导致崩溃
faiss_lock = Lock()

# 全局关闭事件，用于优雅关闭
shutdown_event = None

# 【修复】移除全局日志配置，防止子进程重复初始化
# 日志配置现在在 initialize_runtime() 中执行

# 日志队列和客户端列表（数据结构，需要在全局）
log_queue = queue.Queue()
log_clients = []
all_logs = []

class QueueHandler(logging.Handler):
    """自定义日志处理器，将日志发送到队列"""
    def emit(self, record):
        try:
            # 过滤掉HTTP请求日志和不重要的系统日志
            if self._should_filter_log(record):
                return

            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'level': record.levelname,
                'message': self.format(record),
                'module': record.module,
                'func': record.funcName
            }

            # 添加到日志列表（限制大小）
            all_logs.append(log_entry)
            if len(all_logs) > 200:  # 最多保存200条日志
                all_logs.pop(0)

            log_queue.put(log_entry)

            # 通知所有连接的客户端
            for client_queue in log_clients[:]:  # 复制列表以避免修改时的问题
                try:
                    client_queue.put(log_entry)
                except:
                    # 如果客户端队列已满或断开，移除它
                    if client_queue in log_clients:
                        log_clients.remove(client_queue)
        except Exception as e:
            print(f"日志队列错误: {e}")

    def _should_filter_log(self, record):
        """判断是否应该过滤掉这条日志"""
        # 过滤Werkzeug的HTTP请求日志
        if record.module == '_internal':
            return True

        # 过滤包含HTTP请求模式的日志
        message = self.format(record)
        if any(pattern in message for pattern in [
            '"GET ', '"POST ', '"PUT ', '"DELETE ',
            'HTTP/1.1"', 'HTTP/1.0"',
            'werkzeug',
            '127.0.0.1 - -',  # 过滤访问日志
        ]):
            return True

        # 过滤一些不重要的系统日志
        if record.module in ['urllib3', 'requests', 'aiohttp']:
            return True

        # 2. 关键修复：允许 weidian_scraper 和 app 的 INFO 日志通过
        # 只要是这些模块，即使是 INFO 级别也允许通过
        whitelist_modules = [
            '__main__', 'app', 'database', 'bot',
            'weidian_scraper', 'feature_extractor',
            'vector_engine', 'migrate_data'
        ]

        if record.module in whitelist_modules:
            return False

        # 对于其他未知模块，只显示WARNING级别以上
        if record.levelno < logging.WARNING:
            return True

        return False

# 【修复】移除全局队列处理器和日志级别设置，防止子进程重复初始化
# 这些配置现在在 initialize_runtime() 中执行

logger = logging.getLogger(__name__)

# 机器人相关变量
# [修改] 从 bot 模块导入列表，确保 app.py 和 bot.py 操作同一个列表对象
from bot import bot_clients, bot_tasks, get_all_cooldowns
bot_running = False  # 标记机器人是否正在运行

# 全局特征提取器实例（在应用启动时创建）
feature_extractor_instance = None

def initialize_feature_extractor():
    """在应用启动时初始化特征提取器，确保单例模式"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        print("🚀 初始化全局特征提取器实例...")
        try:
            from feature_extractor import DINOv2FeatureExtractor
            feature_extractor_instance = DINOv2FeatureExtractor()
            print("✅ 全局特征提取器实例初始化完成")
        except Exception as e:
            print(f"❌ 特征提取器初始化失败: {e}")
            feature_extractor_instance = None
    return feature_extractor_instance

def get_global_feature_extractor():
    """获取全局特征提取器实例"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        return initialize_feature_extractor()
    return feature_extractor_instance

# 在应用启动时初始化
# 【修复】注释掉模块级别的初始化，避免多进程环境下重复初始化
# 实际的初始化在 if __name__ == '__main__' 块中的预热阶段执行
# initialize_feature_extractor()

# 【新增】定义项目内的临时文件目录 (在 backend/data/tmp)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TEMP_DIR = os.path.join(BASE_DIR, 'data', 'tmp')
# 确保目录存在
os.makedirs(TEMP_DIR, exist_ok=True)

# Flask配置初始化（简化版 - 解决HTTP IP访问问题）
app = Flask(__name__)
app.secret_key = config.SECRET_KEY

# CORS 配置（允许所有来源）
CORS(app, origins=config.CORS_ORIGINS, supports_credentials=True)

# 强制更新配置，覆盖默认的安全设置
app.config.update(
    SECRET_KEY=config.SECRET_KEY,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE=config.SESSION_COOKIE_SAMESITE,
    SESSION_COOKIE_SECURE=config.SESSION_COOKIE_SECURE,  # 确保是False
    SESSION_COOKIE_DOMAIN=None,
    PERMANENT_SESSION_LIFETIME=config.SESSION_LIFETIME,  # 30天不过期
)

def initialize_runtime():
    """
    初始化运行时环境 (日志、配置等)
    只在主进程中执行，防止子进程重复初始化
    """
    print(f"🔧 [系统] 正在初始化运行时环境 (PID: {os.getpid()})...")

    # 1. 加载系统配置
    load_system_config()

    # 2. 配置日志系统
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    # 清除现有的所有处理器（防止重复）
    if root_logger.handlers:
        root_logger.handlers = []

    # 创建控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)
    root_logger.addHandler(console_handler)

    # 创建并添加队列处理器
    queue_handler = QueueHandler()
    queue_handler.setLevel(logging.INFO)
    root_logger.addHandler(queue_handler)

    # 屏蔽噪音日志
    for lib in ['werkzeug', 'urllib3', 'requests', 'ultralytics', 'aiohttp']:
        logging.getLogger(lib).setLevel(logging.WARNING)

    # 3. 重置数据库状态
    print("🧹 [系统] 正在重置抓取任务状态...")
    try:
        db.update_scrape_status(
            is_scraping=False,
            stop_signal=False,
            message='系统重启，任务状态已重置'
        )
        # 重置所有Discord账号状态为离线
        with db.get_connection() as conn:
            conn.execute("UPDATE discord_accounts SET status = 'offline'")
            conn.commit()
        print("✅ [系统] 数据库状态已重置")
    except Exception as e:
        print(f"⚠️ [系统] 状态重置失败: {e}")

    # 4. 【异步】预热AI模型（不阻塞Flask启动）
    import threading
    def async_warmup_ai():
        global ai_model_ready
        try:
            print("🤖 [后台] 正在预热AI模型...")
            get_global_feature_extractor()
            ai_model_ready = True
            print("✅ [后台] AI模型预热完成，系统已就绪")
        except Exception as e:
            print(f"⚠️ [后台] AI预热失败: {e}")
            ai_model_ready = False

    ai_warmup_thread = threading.Thread(target=async_warmup_ai, daemon=True)
    ai_warmup_thread.start()
    print("🚀 [系统] AI模型正在后台预热，Flask服务即将启动...")

    # 5. 启动后台清理线程
    cleanup_thread = threading.Thread(target=run_cleanup_task, daemon=True)
    cleanup_thread.start()
    logger.info("🚀 后台清理任务已启动")

    print(f"✅ [系统] 运行时环境初始化完成")

def extract_features(image_path):
    """使用深度学习模型提取图像特征"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            logger.error("特征提取器未初始化")
            return None
        features = extractor.extract_feature(image_path)
        # 如果特征提取失败，返回 None（上层将处理并返回错误）
        if features is None:
            logger.warning(f"特征提取失败: {image_path}")
            return None

        return features

    except Exception as e:
        logger.error(f"特征提取异常: {e}")
        return None

@app.route('/search_similar', methods=['POST'])
def search_similar():
    """搜索相似图像 - 使用 FAISS HNSW"""
    try:
        image_url = request.form.get('image_url')
        threshold = float(request.form.get('threshold', 0.6))  # DINOv2需要更高的阈值
        limit = int(request.form.get('limit', 5))  # 返回结果数量，默认5个

        # 获取用户店铺权限过滤（用于Discord机器人）
        user_shops = None
        user_shops_json = request.form.get('user_shops')
        if user_shops_json:
            try:
                user_shops = json.loads(user_shops_json)
            except:
                user_shops = None

        # 调试信息
        print(f"DEBUG: Received threshold: {threshold}")
        print(f"DEBUG: User shops filter: {user_shops}")
        print(f"DEBUG: Form data: {list(request.form.keys())}")
        print(f"DEBUG: Files: {list(request.files.keys()) if request.files else 'No files'}")
        print(f"DEBUG: Content-Type: {request.content_type}")
        print(f"DEBUG: Method: {request.method}")
        print(f"DEBUG: image_url parameter: '{image_url}'")

        # 处理图片来源
        import uuid
        import os
        image_file = None  # 初始化变量，避免作用域问题

        if image_url:
            print(f"DEBUG: Processing image URL: {image_url}")
            # 验证URL格式
            if not image_url.startswith(('http://', 'https://')):
                return jsonify({'error': 'Invalid URL format, must start with http:// or https://'}), 400

            # 从URL下载图片
            import requests
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                response = requests.get(image_url, timeout=15, headers=headers, stream=True)
                print(f"DEBUG: URL response status: {response.status_code}")
                print(f"DEBUG: Content-Type: {response.headers.get('content-type', 'unknown')}")

                if response.status_code != 200:
                    return jsonify({'error': f'Failed to download image from URL, status: {response.status_code}'}), 400

                # 检查内容类型
                content_type = response.headers.get('content-type', '').lower()
                if not any(img_type in content_type for img_type in ['image/', 'application/octet-stream']):
                    print(f"DEBUG: Warning - Content-Type '{content_type}' may not be an image")

                temp_filename = f"{uuid.uuid4()}.jpg"
                # 【修改】使用项目目录下的 TEMP_DIR
                image_path = os.path.join(TEMP_DIR, temp_filename)

                with open(image_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)

                # 检查文件大小
                file_size = os.path.getsize(image_path)
                print(f"DEBUG: Image downloaded to: {image_path}, size: {file_size} bytes")

                if file_size == 0:
                    os.remove(image_path)
                    return jsonify({'error': 'Downloaded file is empty'}), 400

                if file_size > 10 * 1024 * 1024:  # 10MB limit
                    os.remove(image_path)
                    return jsonify({'error': 'Image file too large (max 10MB)'}), 400

            except requests.exceptions.RequestException as e:
                print(f"DEBUG: Network error downloading image: {str(e)}")
                return jsonify({'error': f'Network error downloading image: {str(e)}'}), 400
            except Exception as e:
                print(f"DEBUG: Failed to download image: {str(e)}")
                return jsonify({'error': f'Failed to download image: {str(e)}'}), 400
        elif 'image' in request.files:
            print("DEBUG: No image_url provided, checking for uploaded file")
            image_file = request.files['image']
            print(f"DEBUG: Found uploaded file: {image_file.filename if image_file else 'None'}")

            temp_filename = f"{uuid.uuid4()}.jpg"
            # 【修改】使用项目目录下的 TEMP_DIR
            image_path = os.path.join(TEMP_DIR, temp_filename)
            image_file.save(image_path)

        else:
            print("DEBUG: No image_url and no uploaded file")
            return jsonify({'error': 'No image provided (url or file)'}), 400

        try:
            # 提取特征 (使用 DINOv2 + YOLOv8)
            query_features = extract_features(image_path)

            if query_features is None:
                return jsonify({'error': 'Feature extraction failed'}), 500

            # 【优化】使用 FAISS HNSW 向量搜索 + 综合评分重排序
            print(f"DEBUG: Searching with threshold: {threshold}, vector length: {len(query_features)}")

            # 1. 扩大召回范围：FAISS 先找前 30 个候选 (Primary Search)
            # 使用较低的阈值召回，防止漏掉可能的匹配
            candidates_limit = 30
            raw_results = db.search_similar_images(query_features, limit=candidates_limit, threshold=0.05)
            print(f"DEBUG: FAISS recalled {len(raw_results) if raw_results else 0} candidates")

            # 2. 重排序 (Re-ranking) - 综合评分
            refined_results = []

            if raw_results:
                # 获取全局特征提取器实例用来计算颜色/结构
                extractor = get_global_feature_extractor()
                query_signature = extractor.prepare_hybrid_query(image_path) if extractor else None

                for res in raw_results:
                    # 获取候选图片的本地路径
                    candidate_img_path = res.get('image_path')

                    # 如果文件不存在，只能用原始 DINO 分数
                    if not candidate_img_path or not os.path.exists(candidate_img_path):
                        final_score = res['similarity']
                        breakdown = {}
                        print(f"DEBUG: Candidate image not found, using DINO score: {final_score:.3f}")
                    else:
                        # 计算综合评分
                        hybrid_data = extractor.calculate_hybrid_similarity(
                            image_path,  # 上传的查询图 (临时文件)
                            candidate_img_path,  # 数据库里的图
                            res['similarity'],  # 原始 DINO 分数
                            query_signature
                        )
                        final_score = hybrid_data['score']
                        breakdown = hybrid_data.get('details', {})

                    # 更新分数
                    res['original_similarity'] = res['similarity']  # 保留原分用于调试
                    res['similarity'] = final_score  # 更新为综合分
                    res['score_breakdown'] = breakdown

                    refined_results.append(res)

                # 3. 按新的综合分数重新排序
                refined_results.sort(key=lambda x: x['similarity'], reverse=True)
                print(f"DEBUG: Re-ranking completed, best score: {refined_results[0]['similarity']:.3f}")

            # 4. 应用用户阈值和店铺过滤
            results = []
            for result in refined_results:
                similarity = result.get('similarity', 0)
                # 应用用户相似度阈值
                if similarity >= threshold:
                    # 检查店铺权限
                    if user_shops and result.get('shop_name') not in user_shops:
                        print(f"DEBUG: Skipping result from shop {result.get('shop_name')} - not in user shops {user_shops}")
                        continue
                    results.append(result)
                    if len(results) >= limit:
                        break

            print(f"DEBUG: Filtered results count (threshold {threshold}): {len(results)}")
            if results:
                print(f"DEBUG: Best match similarity: {results[0]['similarity']:.3f} (original DINO: {results[0].get('original_similarity', 0):.3f})")
            print(f"DEBUG: Total indexed images: {db.get_total_indexed_images()}")

            # 严格执行阈值：如果没有满足阈值的结果，则返回空结果
            # 不再使用任何硬编码阈值兜底（例如 >0.8）

            response_data = {
                'success': True,
                'results': [],
                'totalResults': 0,
                'message': f'未找到相似度超过{threshold*100:.0f}%的商品',
                'searchTime': datetime.now().isoformat(),
                'debugInfo': {
                    'totalIndexedImages': db.get_total_indexed_images(),
                    'threshold': threshold,
                    'searchedVectors': len(results) if results else 0
                }
            }

            if results:
                # 处理多个搜索结果
                processed_results = []

                # 预先导入 json，防止循环中报错
                import json

                for i, result in enumerate(results):
                    # 获取完整产品信息
                    product_info = db._get_product_info_by_id(result['id'])

                    # 获取实际的图片URL列表
                    actual_images = []
                    if product_info:
                        with db.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (result['id'],))
                            actual_images = [f"/api/image/{result['id']}/{row[0]}" for row in cursor.fetchall()]

                    # 生成所有网站的链接
                    weidian_id = None
                    if product_info and product_info.get('product_url'):
                        import re
                        match = re.search(r'itemID=(\d+)', product_info['product_url'])
                        if match:
                            weidian_id = match.group(1)

                    website_urls = []
                    if weidian_id:
                        website_urls = db.generate_website_urls(weidian_id)

                    result_data = {
                        'rank': i + 1,
                        'similarity': float(result['similarity']),
                        'originalSimilarity': float(result.get('original_similarity', result['similarity'])),  # 原始DINO分数
                        'scoreBreakdown': result.get('score_breakdown', {}),  # 评分详情
                        'imageIndex': result['image_index'],
                        'matchedImage': f"/api/image/{result['id']}/{result['image_index']}",
                        'product': {
                            'id': result['id'],
                            'title': product_info['title'] if product_info else result.get('title', ''),
                            'englishTitle': product_info.get('english_title', ''),
                            'weidianUrl': product_info['product_url'] if product_info else result.get('product_url', ''),
                            'cnfansUrl': product_info.get('cnfans_url', ''),
                            'acbuyUrl': product_info.get('acbuy_url', ''),
                            'ruleEnabled': product_info.get('ruleEnabled', True) if product_info else True,
                            # 修复：机器人需要 imageSource 和 uploaded_reply_images 才能发送本地图片
                            'imageSource': product_info.get('image_source', 'product') if product_info else 'product',
                            'custom_reply_text': product_info.get('custom_reply_text', '') if product_info else '',
                            'uploaded_reply_images': json.loads(product_info.get('uploaded_reply_images', '[]')) if product_info and product_info.get('uploaded_reply_images') else [],
                            'images': actual_images if actual_images else [f"/api/image/{result['id']}/{result['image_index']}"],  # 使用实际图片列表
                            'websiteUrls': website_urls  # 添加所有网站的链接
                        }
                    }
                    processed_results.append(result_data)

                # 保存最佳匹配的搜索历史
                if processed_results:
                    best_match = processed_results[0]
                    db.add_search_history(
                        query_image_path=image_path,
                        matched_product_id=best_match['product']['id'],
                        matched_image_index=best_match['imageIndex'],
                        similarity=best_match['similarity'],
                        threshold=threshold
                    )

                response_data = {
                    'success': True,
                    'results': processed_results,
                    'totalResults': len(processed_results),
                    'searchTime': datetime.now().isoformat(),
                    'debugInfo': {
                        'totalIndexedImages': db.get_total_indexed_images(),
                        'threshold': threshold,
                        'limit': limit,
                        'searchedVectors': len(results) if results else 0
                    }
                }

            return jsonify(response_data)

        finally:
            # 清理临时文件
            if os.path.exists(image_path):
                os.unlink(image_path)

    except Exception as e:
        logger.error(f"搜索失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/scrape', methods=['POST'])
def scrape_product():
    """抓取商品并建立索引"""
    try:
        logger.info("收到商品抓取请求")
        data = request.get_json()
        if data is None:
            logger.error("请求体为空")
            return jsonify({'error': 'Invalid request body'}), 400

        logger.info(f"请求数据: {data}")

        # 支持两种输入方式：完整URL或商品ID
        url = data.get('url')
        weidian_id = data.get('weidianId')

        if not url and not weidian_id:
            logger.error("缺少URL或weidianId")
            return jsonify({'error': 'URL or weidianId is required'}), 400

        # 如果提供了weidianId，构造URL
        if weidian_id and not url:
            url = f"https://weidian.com/item.html?itemID={weidian_id}"
            logger.info(f"构造URL: {url}")

        # 验证URL格式
        if 'weidian.com' not in url:
            logger.error(f"不支持的URL格式: {url}")
            return jsonify({'error': '只支持微店商品链接'}), 400

        logger.info(f"开始抓取商品: {url}")

        # 检查商品是否已存在
        existing = db.get_product_by_url(url)
        if existing:
            return jsonify({'error': '商品已存在', 'existing': True}), 409

        # 使用真正的爬虫
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        # 抓取商品信息
        product_info = scraper.scrape_product_info(url)

        if not product_info:
            return jsonify({'error': '商品信息抓取失败，请检查URL是否正确'}), 500

        # 生成acbuy链接
        acbuy_url = ''
        if product_info['weidian_url']:
            # 从weidian_url中提取itemID
            import re
            item_id_match = re.search(r'itemID=(\d+)', product_info['weidian_url'])
            if item_id_match:
                item_id = item_id_match.group(1)
                # 构建acbuy链接
                encoded_url = product_info['weidian_url'].replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
                acbuy_url = f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'

        # 保存到数据库（使用全局延迟配置）
        product_id = db.insert_product({
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'description': product_info['description'],
            'english_title': product_info.get('english_title') or '',
            'cnfans_url': product_info.get('cnfans_url') or '',
            'acbuy_url': acbuy_url,
            'shop_name': product_info.get('shop_name', ''),  # 从product_info获取店铺名称
            'ruleEnabled': True  # 默认启用自动回复规则
        })

        # 下载图片并建立向量索引
        if product_info['images']:
            logger.info(f"下载 {len(product_info['images'])} 张图片并建立索引")

            # 创建图片保存目录
            import os
            images_dir = os.path.join(os.path.dirname(__file__), 'data', 'scraped_images', product_info['id'])
            os.makedirs(images_dir, exist_ok=True)

            # 下载图片
            saved_image_paths = scraper.download_images(
                product_info['images'],
                images_dir,
                product_info['id']
            )
            # 为每张图片建立向量索引
            # 注意：YOLO裁剪已集成在DINOv2特征提取过程中，无需额外步骤
            # 使用全局特征提取器
            extractor = get_global_feature_extractor()
            if extractor is None:
                logger.error("特征提取器未初始化")
                return

            # 串行建立向量索引 (SQLite不支持多线程写入)
            # 但先使用多线程进行特征提取，然后串行插入数据库
            import concurrent.futures
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()

            def extract_features_only(img_path):
                """只提取特征，不插入数据库"""
                try:
                    features = extractor.extract_feature(img_path)
                    return features
                except Exception as e:
                    logger.error(f"特征提取失败 {img_path}: {e}")
                    return None

            # 第一步：多线程特征提取
            logger.info("开始多线程特征提取...")
            features_list = []
            max_workers = min(config.FEATURE_EXTRACT_THREADS, len(saved_image_paths))

            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # 提交特征提取任务
                future_to_image = {
                    executor.submit(extract_features_only, img_path): (i, img_path)
                    for i, img_path in enumerate(saved_image_paths)
                }

                # 收集特征提取结果
                for future in concurrent.futures.as_completed(future_to_image):
                    i, img_path = future_to_image[future]
                    try:
                        features = future.result()
                        features_list.append((i, img_path, features))
                    except Exception as e:
                        logger.error(f"特征提取异常 {img_path}: {e}")
                        features_list.append((i, img_path, None))

            # 按索引排序结果
            features_list.sort(key=lambda x: x[0])

            # 第二步：串行插入数据库和FAISS索引
            logger.info("开始串行数据库插入和索引建立...")
            indexed_images = []

            for i, img_path, features in features_list:
                try:
                    if features is None:
                        logger.error(f"跳过图片 {i}: 特征提取失败")
                        continue

                    # 插入数据库记录
                    image_db_id = db.insert_image_record(product_id, img_path, i)
                    if not image_db_id:
                        logger.error(f"图片 {i} 元数据插入失败")
                        continue

                    # 插入FAISS向量索引
                    with faiss_lock:  # FAISS 线程安全锁
                        success = engine.add_vector(image_db_id, features)
                    if success:
                        indexed_images.append(f"{i}.jpg")
                        logger.info(f"图片 {i} 索引建立成功")
                    else:
                        logger.error(f"图片 {i} 索引建立失败")

                except Exception as e:
                    logger.error(f"处理图片 {i} 时出错: {e}")
                    continue

            # 检查是否有图片处理失败
            if len(indexed_images) != len(saved_image_paths):
                failed_count = len(saved_image_paths) - len(indexed_images)
                logger.warning(f"有 {failed_count} 张图片处理失败，但继续执行")

            # 如果一张图片都没成功，认为是错误
            if not indexed_images:
                logger.error("所有图片处理都失败了")
                try:
                    db.delete_product_images(product_id)
                except Exception as del_e:
                    logger.error(f"回滚删除失败: {del_e}")
                return jsonify({'error': 'All image processing failed'}), 500

            # 实时保存FAISS索引
            engine.save()

            logger.info(f"共建立 {len(indexed_images)} 张图片的索引")
        else:
            logger.warning("未找到商品图片")

        # 返回完整的商品信息
        result = {
            'id': product_id,
            'weidianId': product_info['id'],  # 添加微店商品ID
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'englishTitle': product_info['english_title'],
            'weidianUrl': product_info['weidian_url'],
            'cnfansUrl': product_info['cnfans_url'],
            'description': product_info['description'],
            'ruleEnabled': True,  # 默认启用规则
            'createdAt': datetime.now().isoformat(),
            'images': product_info['images']  # 返回图片URL列表
        }

        logger.info(f"商品抓取完成: {product_info['title']}")
        return jsonify(result)

    except Exception as e:
        logger.error(f"抓取失败: {e}")
        return jsonify({'error': str(e)}), 500

# Discord 账号管理 API
# ===== 用户认证和权限管理API =====

def get_current_user():
    """获取当前登录用户"""
    user_id = session.get('user_id')
    if user_id:
        return db.get_user_by_id(user_id)
    return None

def require_admin():
    """检查是否为管理员"""
    user = get_current_user()
    return user and user.get('role') == 'admin'

def can_manage_shops():
    """检查用户是否有管理店铺的权限（管理员或有分配的店铺）"""
    user = get_current_user()
    if not user:
        return False
    # 管理员可以管理所有店铺
    if user.get('role') == 'admin':
        return True
    # 普通用户如果有分配的店铺，也可以管理
    user_shops = user.get('shops', [])
    return len(user_shops) > 0

def require_login():
    """检查是否已登录"""
    # 开发模式下跳过认证
    if config.DEBUG:
        # 开发模式下自动设置为admin用户
        if 'user_id' not in session:
            session['user_id'] = 1  # 默认admin用户ID
        return True
    return get_current_user() is not None

@app.route('/api/bot/cooldowns', methods=['GET'])
def get_bot_cooldowns():
    """获取当前所有账号的冷却状态"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        cooldowns = get_all_cooldowns()
        return jsonify({'cooldowns': cooldowns})
    except Exception as e:
        logger.error(f"获取冷却状态失败: {e}")
        return jsonify({'cooldowns': []}), 500

@app.route('/api/auth/login', methods=['POST'])
def login():
    """用户登录"""
    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': '用户名和密码不能为空'}), 400

        username = data['username']
        password = data['password']

        user = db.authenticate_user(username, password)
        if user:
            session['user_id'] = user['id']
            # 不返回密码哈希
            user_info = {k: v for k, v in user.items() if k != 'password_hash'}
            return jsonify({'user': user_info, 'message': '登录成功'})
        else:
            return jsonify({'error': '用户名或密码错误'}), 401
    except Exception as e:
        logger.error(f"登录失败: {e}")
        return jsonify({'error': '登录失败'}), 500

@app.route('/api/auth/logout', methods=['POST'])
def logout():
    """用户登出"""
    session.pop('user_id', None)
    return jsonify({'message': '已登出'})

@app.route('/api/auth/me', methods=['GET'])
def get_current_user_info():
    """获取当前用户信息"""
    user = get_current_user()
    if user:
        # 不返回密码哈希
        user_info = {k: v for k, v in user.items() if k != 'password_hash'}
        return jsonify({'user': user_info})
    return jsonify({'error': '未登录'}), 401

@app.route('/api/users', methods=['GET'])
def get_users():
    """获取所有用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        users = db.get_all_users()
        # 不返回密码哈希
        for user in users:
            user.pop('password_hash', None)
        return jsonify({'users': users})
    except Exception as e:
        logger.error(f"获取用户列表失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users', methods=['POST'])
def create_user():
    """创建新用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': '用户名和密码不能为空'}), 400

        username = data['username'].strip()
        password = data['password'].strip()
        role = data.get('role', 'user')
        shop_ids = data.get('shops', [])

        if len(password) < 6:
            return jsonify({'error': '密码长度至少6位'}), 400

        from werkzeug.security import generate_password_hash
        password_hash = generate_password_hash(password)

        if db.create_user(username, password_hash, role):
            with db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, username, role, is_active, created_at FROM users WHERE username = ?", (username,))
                user = cursor.fetchone()

            if user:
                user_dict = dict(user)
                if shop_ids:
                    db.update_user_shops(user_dict['id'], shop_ids)
                return jsonify({'user': user_dict, 'message': '用户创建成功'})
            else:
                return jsonify({'error': '用户创建后无法检索信息'}), 500
        else:
            return jsonify({'error': '用户名已存在或数据库错误'}), 400
    except Exception as e:
        logger.error(f"创建用户失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """删除用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        current_user = get_current_user()
        if current_user['id'] == user_id:
            return jsonify({'error': '不能删除自己的账号'}), 400

        # 检查用户是否存在
        user = db.get_user_by_id(user_id)
        if not user:
            return jsonify({'error': '用户不存在'}), 404

        # 删除用户
        if db.delete_user(user_id):
            logger.info(f"管理员 {current_user['username']} 删除了用户 {user['username']}")
            return jsonify({'message': '用户删除成功'})
        else:
            return jsonify({'error': '用户删除失败'}), 500
    except Exception as e:
        logger.error(f"删除用户失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：管理员修改用户密码 ===
@app.route('/api/users/<int:user_id>/password', methods=['PUT'])
def reset_user_password(user_id):
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        new_password = data.get('password')
        if not new_password:
            return jsonify({'error': '密码不能为空'}), 400

        from werkzeug.security import generate_password_hash
        password_hash = generate_password_hash(new_password)

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (password_hash, user_id))
            conn.commit()

        return jsonify({'success': True, 'message': '密码已重置'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# === 新增：网站配置管理API ===
@app.route('/api/websites', methods=['GET'])
def get_website_configs():
    """获取所有网站配置及其用户相关的频道绑定和账号绑定"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        configs = db.get_website_configs()

        # 为每个配置添加绑定信息
        for config in configs:
            config_id = config['id']

            # 1) 账号绑定：只返回当前用户自己的绑定
            config['accounts'] = db.get_website_account_bindings(config_id, current_user['id'])

            # 2) 频道绑定：只返回当前用户自己的绑定
            config['channels'] = db.get_website_channel_bindings(config_id, current_user['id'])

            # 3) 用户级别的轮换设置
            user_settings = db.get_user_website_settings(current_user['id'], config_id)
            config['rotation_interval'] = user_settings.get('rotation_interval', 180)
            config['rotation_enabled'] = user_settings.get('rotation_enabled', 1)

        return jsonify({'websites': configs})
    except Exception as e:
        logger.error(f"获取网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites', methods=['POST'])
def add_website_config():
    """添加网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': '所有字段都是必填的'}), 400

        if db.add_website_config(name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': '网站配置已添加'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['PUT'])
def update_website_config(config_id):
    """更新网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': '所有字段都是必填的'}), 400

        if db.update_website_config(config_id, name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': '网站配置已更新'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['DELETE'])
def delete_website_config(config_id):
    """删除网站配置"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_website_config(config_id):
            return jsonify({'success': True, 'message': '网站配置已删除'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除网站配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['GET'])
def get_website_channels(config_id):
    """获取网站绑定的频道（按用户过滤）"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        channels = db.get_website_channel_bindings(config_id, current_user['id'])
        return jsonify({'channels': channels})
    except Exception as e:
        logger.error(f"获取网站频道失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['POST'])
def add_website_channel(config_id):
    """添加网站频道绑定"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        channel_id = data.get('channel_id')

        if not channel_id:
            return jsonify({'error': '频道ID不能为空'}), 400

        # 【修复】如果输入的是完整的Discord URL，提取频道ID
        # Discord URL格式: https://discord.com/channels/{server_id}/{channel_id}
        if 'discord.com/channels/' in channel_id:
            # 提取URL中的最后一部分作为频道ID
            parts = channel_id.rstrip('/').split('/')
            if len(parts) >= 1:
                channel_id = parts[-1]

        # 验证频道ID是否为纯数字
        if not channel_id.isdigit():
            return jsonify({'error': '无效的频道ID格式'}), 400

        current_user = get_current_user()
        if db.add_website_channel_binding(config_id, channel_id, current_user['id']):
            return jsonify({'success': True, 'message': '频道绑定已添加'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加网站频道绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels/<channel_id>', methods=['DELETE'])
def remove_website_channel(config_id, channel_id):
    """移除网站频道绑定"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        # 【修复】如果channel_id是完整的Discord URL，提取频道ID
        # Discord URL格式: https://discord.com/channels/{server_id}/{channel_id}
        if 'discord.com/channels/' in channel_id:
            # 提取URL中的最后一部分作为频道ID
            parts = channel_id.rstrip('/').split('/')
            if len(parts) >= 1:
                channel_id = parts[-1]

        current_user = get_current_user()

        # 【修复】管理员可以删除任何频道，普通用户只能删除自己的
        if current_user.get('role') == 'admin':
            # 管理员：删除该频道的所有绑定
            success = db.remove_website_channel_binding_admin(config_id, channel_id)
        else:
            # 普通用户：只删除自己的绑定
            success = db.remove_website_channel_binding(config_id, channel_id, current_user['id'])

        if success:
            return jsonify({'success': True, 'message': '频道绑定已移除'})
        else:
            return jsonify({'error': '移除失败'}), 500
    except Exception as e:
        logger.error(f"移除网站频道绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

# ===== 网站账号绑定API =====

@app.route('/api/websites/<int:config_id>/accounts', methods=['GET'])
def get_website_accounts(config_id):
    """获取网站绑定的账号（按用户过滤）"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        accounts = db.get_website_account_bindings(config_id, current_user['id'])
        return jsonify({'accounts': accounts})
    except Exception as e:
        logger.error(f"获取网站账号绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/accounts', methods=['POST'])
def add_website_account(config_id):
    """为网站绑定账号"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        account_id = data.get('account_id')
        role = data.get('role', 'both')  # 'listener', 'sender', 'both'

        if not account_id or role not in ['listener', 'sender', 'both']:
            return jsonify({'error': '无效的账号ID或角色'}), 400

        # 权限检查：确保该账号属于当前用户
        current_user = get_current_user()
        # 获取该账号的详情
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT user_id FROM discord_accounts WHERE id = ?", (account_id,))
            row = cursor.fetchone()
            if not row:
                return jsonify({'error': '账号不存在'}), 404

            account_owner_id = row[0]

            # 如果不是管理员，且账号不属于当前用户，拒绝
            if current_user['role'] != 'admin' and account_owner_id != current_user['id']:
                return jsonify({'error': '您无权操作此账号'}), 403

        if db.add_website_account_binding(config_id, account_id, role, current_user['id']):
            return jsonify({'success': True, 'message': f'账号绑定成功，角色: {role}'})
        else:
            return jsonify({'error': '绑定失败'}), 500
    except Exception as e:
        logger.error(f"添加网站账号绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/accounts/<int:account_id>', methods=['DELETE'])
def remove_website_account(config_id, account_id):
    """移除网站账号绑定"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        if db.remove_website_account_binding(config_id, account_id, current_user['id']):
            return jsonify({'success': True, 'message': '账号绑定已移除'})
        else:
            return jsonify({'error': '移除失败'}), 500
    except Exception as e:
        logger.error(f"移除网站账号绑定失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/rotation', methods=['GET'])
def get_website_rotation(config_id):
    """获取用户的网站轮换配置"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        settings = db.get_user_website_settings(current_user['id'], config_id)
        return jsonify({
            'rotation_interval': settings['rotation_interval'],
            'rotation_enabled': settings['rotation_enabled']
        })
    except Exception as e:
        logger.error(f"获取网站轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/rotation', methods=['PUT'])
def update_website_rotation(config_id):
    """更新用户的网站轮换配置（间隔和启用状态）"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        data = request.get_json()
        messages = []

        rotation_interval = data.get('rotation_interval')
        rotation_enabled = data.get('rotation_enabled')

        # 验证参数
        if rotation_interval is not None and rotation_interval <= 0:
            return jsonify({'error': '轮换间隔必须大于0秒'}), 400
        if rotation_enabled is not None and rotation_enabled not in [0, 1]:
            return jsonify({'error': '轮换启用状态必须是0或1'}), 400

        # 使用用户级别的设置方法
        if db.update_user_website_rotation(current_user['id'], config_id, rotation_interval, rotation_enabled):
            if rotation_interval is not None:
                messages.append(f'轮换间隔已设置为 {rotation_interval} 秒')
            if rotation_enabled is not None:
                status_text = '启用' if rotation_enabled else '禁用'
                messages.append(f'轮换功能已{status_text}')
            return jsonify({'success': True, 'message': '; '.join(messages) if messages else '设置已更新'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新网站轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/filters', methods=['GET'])
def get_website_filters(config_id):
    """获取用户的网站消息过滤条件"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        settings = db.get_user_website_settings(current_user['id'], config_id)

        import json
        filters = json.loads(settings.get('message_filters', '[]'))
        return jsonify({'filters': filters})
    except Exception as e:
        logger.error(f"获取网站过滤条件失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/filters', methods=['PUT'])
def update_website_filters(config_id):
    """更新用户的网站消息过滤条件"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        data = request.get_json()
        filters = data.get('filters', [])

        # 验证过滤条件格式
        for filter_item in filters:
            if not isinstance(filter_item, dict) or 'filter_type' not in filter_item or 'filter_value' not in filter_item:
                return jsonify({'error': '过滤条件格式无效'}), 400

        import json
        filters_json = json.dumps(filters)

        if db.update_user_website_filters(current_user['id'], config_id, filters_json):
            return jsonify({'success': True, 'message': f'已更新 {len(filters)} 个过滤条件'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新网站过滤条件失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>/urls', methods=['GET'])
def get_product_urls(product_id):
    """获取商品的所有网站URL"""
    try:
        # 获取商品信息
        product = db._get_product_info_by_id(product_id)
        if not product:
            return jsonify({'error': '商品不存在'}), 404

        # 从商品URL中提取微店ID
        weidian_url = product.get('product_url', '')
        weidian_id = None

        if 'itemID=' in weidian_url:
            # 提取itemID参数
            import re
            match = re.search(r'itemID=([^&]+)', weidian_url)
            if match:
                weidian_id = match.group(1)

        if not weidian_id:
            return jsonify({'urls': []})

        # 生成所有网站的URL
        urls = db.generate_website_urls(weidian_id)
        return jsonify({'urls': urls})
    except Exception as e:
        logger.error(f"获取商品URL失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 健康检查端点（不需要认证，快速响应）===
@app.route('/api/health', methods=['GET'])
def health_check():
    """健康检查端点，返回后端和AI模型状态"""
    return jsonify({
        'status': 'ok',
        'backend': 'running',
        'ai_ready': ai_model_ready,
        'timestamp': datetime.now().isoformat()
    })

# === 新增：系统统计信息API ===
@app.route('/api/system/stats', methods=['GET'])
def get_system_stats():
    """获取系统统计信息"""
    try:
        stats = db.get_system_stats()
        return jsonify(stats)
    except Exception as e:
        logger.error(f"获取系统统计信息失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/cleanup-orphaned-images', methods=['POST'])
def cleanup_orphaned_images():
    """清理孤立的图片记录"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        deleted_count = db.cleanup_orphaned_images()
        return jsonify({
            'message': f'清理完成，删除了 {deleted_count} 条孤立记录',
            'deleted_count': deleted_count
        })
    except Exception as e:
        logger.error(f"清理孤立图片记录失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：公告管理API ===
@app.route('/api/announcements', methods=['GET'])
def get_announcements():
    """获取所有公告"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        announcements = db.get_active_announcements()
        return jsonify({'announcements': announcements})
    except Exception as e:
        logger.error(f"获取公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements', methods=['POST'])
def create_announcement():
    """创建公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')

        if not title or not content:
            return jsonify({'error': '标题和内容都是必填的'}), 400

        if db.create_announcement(title, content):
            return jsonify({'success': True, 'message': '公告创建成功'})
        else:
            return jsonify({'error': '创建失败'}), 500
    except Exception as e:
        logger.error(f"创建公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['PUT'])
def update_announcement(announcement_id):
    """更新公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')
        is_active = data.get('is_active', True)

        if not title or not content:
            return jsonify({'error': '标题和内容都是必填的'}), 400

        if db.update_announcement(announcement_id, title, content, is_active):
            return jsonify({'success': True, 'message': '公告更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新公告失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['DELETE'])
def delete_announcement(announcement_id):
    """删除公告"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_announcement(announcement_id):
            return jsonify({'success': True, 'message': '公告删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除公告失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：消息过滤规则API ===
@app.route('/api/message-filters', methods=['GET'])
def get_message_filters():
    """获取消息过滤规则"""
    try:
        filters = db.get_message_filters()
        return jsonify({'filters': filters})
    except Exception as e:
        logger.error(f"获取消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters', methods=['POST'])
def add_message_filter():
    """添加消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')

        if not filter_type or not filter_value:
            return jsonify({'error': '过滤类型和值都是必填的'}), 400

        if db.add_message_filter(filter_type, filter_value):
            return jsonify({'success': True, 'message': '过滤规则添加成功'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['PUT'])
def update_message_filter(filter_id):
    """更新消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')
        is_active = data.get('is_active', True)

        if not filter_type or not filter_value:
            return jsonify({'error': '过滤类型和值都是必填的'}), 400

        if db.update_message_filter(filter_id, filter_type, filter_value, is_active):
            return jsonify({'success': True, 'message': '过滤规则更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['DELETE'])
def delete_message_filter(filter_id):
    """删除消息过滤规则"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_message_filter(filter_id):
            return jsonify({'success': True, 'message': '过滤规则删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除消息过滤规则失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 新增：自定义回复内容API ===
@app.route('/api/custom-replies', methods=['GET'])
def get_custom_replies():
    """获取自定义回复内容"""
    try:
        replies = db.get_custom_replies()
        return jsonify({'replies': replies})
    except Exception as e:
        logger.error(f"获取自定义回复内容失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies', methods=['POST'])
def add_custom_reply():
    """添加自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)

        if not reply_type:
            return jsonify({'error': '回复类型是必填的'}), 400

        if db.add_custom_reply(reply_type, content, image_url, priority):
            return jsonify({'success': True, 'message': '自定义回复添加成功'})
        else:
            return jsonify({'error': '添加失败'}), 500
    except Exception as e:
        logger.error(f"添加自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['PUT'])
def update_custom_reply(reply_id):
    """更新自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)
        is_active = data.get('is_active', True)

        if not reply_type:
            return jsonify({'error': '回复类型是必填的'}), 400

        if db.update_custom_reply(reply_id, reply_type, content, image_url, priority, is_active):
            return jsonify({'success': True, 'message': '自定义回复更新成功'})
        else:
            return jsonify({'error': '更新失败'}), 500
    except Exception as e:
        logger.error(f"更新自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['DELETE'])
def delete_custom_reply(reply_id):
    """删除自定义回复内容"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        if db.delete_custom_reply(reply_id):
            return jsonify({'success': True, 'message': '自定义回复删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除自定义回复失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>/shops', methods=['PUT'])
def update_user_shops(user_id):
    """更新用户店铺权限（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        shop_ids = data.get('shops', [])

        if db.update_user_shops(user_id, shop_ids):
            return jsonify({'message': '权限更新成功'})
        else:
            return jsonify({'error': '权限更新失败'}), 500
    except Exception as e:
        logger.error(f"更新用户权限失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """获取所有 Discord 账号"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()
    try:
        # 所有用户（包括管理员）只能看到自己的账号
        accounts = db.get_discord_accounts_by_user(current_user['id'])

        return jsonify({'accounts': accounts})
    except Exception as e:
        logger.error(f"获取账号列表失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['GET'])
def list_products():
    """列出用户有权限的商品及其图片"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()
    try:
        # 获取分页参数
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 50))  # 默认每页50条
        offset = (page - 1) * limit

        # 根据用户权限获取商品（支持分页）
        if current_user['role'] == 'admin':
            # 管理员可以看到所有商品
            logger.info(f"管理员用户 {current_user['username']} 获取商品列表 (页{page}, 每页{limit}条)")
            result = db.get_products_by_user_shops(None, limit=limit, offset=offset)
        else:
            # 普通用户只能看到自己管理的店铺的商品
            user_shops = current_user.get('shops', [])
            logger.info(f"普通用户 {current_user['username']} 获取店铺商品 (页{page}, 每页{limit}条)，分配的店铺: {user_shops}")
            result = db.get_products_by_user_shops(user_shops, limit=limit, offset=offset)

            # 调试：检查数据库中的商品和店铺匹配情况
            if user_shops:
                with db.get_connection() as conn:
                    cursor = conn.cursor()
                    placeholders = ','.join('?' * len(user_shops))
                    cursor.execute(f"SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})", user_shops)
                    matching_products = cursor.fetchone()[0]
                    logger.info(f"数据库中匹配的商品数量: {matching_products}")

                    # 列出所有店铺名称
                    cursor.execute("SELECT DISTINCT shop_name FROM products")
                    all_shop_names = [row[0] for row in cursor.fetchall()]
                    logger.info(f"数据库中的所有店铺名称: {all_shop_names}")

        logger.info(f"返回商品数量: {len(result['products'])}")

        # 添加调试信息到响应中
        response_data = {
            'products': result['products'],
            'total': result['total'],
            'debug': {
                'user_role': current_user['role'],
                'user_shops': current_user.get('shops', []),
                'is_admin': current_user['role'] == 'admin'
            }
        }

        # 添加缓存头以优化性能（5分钟缓存）
        response = jsonify(response_data)
        response.headers['Cache-Control'] = 'private, max-age=300'
        return response
    except Exception as e:
        logger.error(f"列出商品失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['PUT'])
def update_product():
    """更新商品信息"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    current_user = get_current_user()

    # 提取公共权限检查逻辑
    def check_permission(product_id):
        """检查用户是否有权限更新指定商品"""
        if current_user['role'] == 'admin':
            return True

        user_shop_ids = current_user.get('shops', [])
        product = db.get_product_by_id(int(product_id))

        if not product:
            return False

        # 将店铺ID转换为店铺名称进行对比
        allowed_shop_names = []
        for shop_id in user_shop_ids:
            shop_info = db.get_shop_by_id(shop_id)
            if shop_info:
                allowed_shop_names.append(shop_info['name'])

        # 对比商品所属店铺名是否在用户允许的店铺名列表中
        if product.get('shop_name') in allowed_shop_names:
            return True

        return False

    def get_full_product_data(pid):
        """获取并格式化完整的商品数据，用于前端状态更新"""
        product = db._get_product_info_by_id(pid)
        if not product:
            return None

        # 获取所有图片
        images_data = db.get_product_images(pid)
        # 按索引排序并生成URL
        sorted_images = sorted(images_data, key=lambda x: x['image_index'])
        image_urls = [f"/api/image/{pid}/{img['image_index']}" for img in sorted_images]

        # 格式化字段以匹配前端需求 (CamelCase)
        weidian_id = ''
        try:
            if 'itemID=' in product.get('product_url', ''):
                weidian_id = product.get('product_url', '').split('itemID=')[1]
            elif product.get('item_id'):
                weidian_id = product.get('item_id')
        except:
            pass

        # 解析自定义图片URL和索引
        selected_indexes = []
        custom_urls = []
        uploaded_reply_image_urls = []
        try:
            if product.get('custom_reply_images'):
                selected_indexes = json.loads(product.get('custom_reply_images'))
            if product.get('custom_image_urls'):
                custom_urls = json.loads(product.get('custom_image_urls'))
            # 解析上传的自定义回复图片
            if product.get('uploaded_reply_images'):
                uploaded_filenames = json.loads(product.get('uploaded_reply_images'))
                # 生成图片URL数组
                uploaded_reply_image_urls = [f"/api/custom_reply_image/{pid}/{filename}" for filename in uploaded_filenames]
        except:
            pass

        # 关键：必须返回前端需要的每一个字段，否则前端会变白
        return {
            'id': product['id'],
            'title': product.get('title', ''),
            'englishTitle': product.get('english_title', ''),
            'weidianUrl': product.get('product_url', ''),
            'cnfansUrl': product.get('cnfans_url', ''),
            'acbuyUrl': product.get('acbuy_url', ''),
            'shopName': product.get('shop_name', '未知店铺'),
            'description': product.get('description', ''),

            # 规则相关
            'ruleEnabled': bool(product.get('ruleEnabled', True)),
            'customReplyText': product.get('custom_reply_text', ''),
            'imageSource': product.get('image_source', 'product'),

            # 图片相关
            'selectedImageIndexes': selected_indexes,
            'customImageUrls': custom_urls,
            'images': image_urls, # 包含所有商品图片
            'uploadedImages': uploaded_reply_image_urls, # 上传的自定义回复图片URL数组

            'weidianId': weidian_id,
            'createdAt': product.get('created_at')
        }

    # ---------------------------------------------------------
    # 场景 A: 包含文件上传 (Multipart)
    # ---------------------------------------------------------
    if request.content_type and 'multipart/form-data' in request.content_type:
        product_id = request.form.get('id')
        if not product_id:
            return jsonify({'error': '商品ID不能为空'}), 400

        try:
            pid_int = int(product_id)
            if not check_permission(pid_int):
                return jsonify({'error': '无权限更新此商品'}), 403

            # 1. 处理上传的自定义回复图片
            # 注意：这些图片只用于自定义回复，不添加到商品图集和FAISS索引

            # 1.1 获取要保留的已有图片文件名列表（从前端传来）
            existing_filenames_to_keep = []
            if 'existingUploadedImageUrls' in request.form:
                try:
                    # 前端发送的是URL数组的JSON字符串，需要提取文件名
                    existing_urls = json.loads(request.form.get('existingUploadedImageUrls'))
                    for url in existing_urls:
                        # URL格式: /api/custom_reply_image/{product_id}/{filename}
                        # 提取最后一部分作为文件名
                        filename = url.split('/')[-1]
                        existing_filenames_to_keep.append(filename)
                except:
                    pass

            # 1.2 处理新上传的文件
            new_uploaded_filenames = []
            if 'uploadedImages' in request.files:
                import uuid
                import os

                # 创建自定义回复图片目录
                custom_reply_dir = os.path.join('data', 'custom_reply_images', str(pid_int))
                os.makedirs(custom_reply_dir, exist_ok=True)

                files = request.files.getlist('uploadedImages')
                for file in files:
                    if file and file.filename:
                        # 生成唯一文件名
                        filename = f"{uuid.uuid4()}_{file.filename}"
                        file_path = os.path.join(custom_reply_dir, filename)

                        # 保存文件（不添加到商品图集，不提取特征，不加入FAISS）
                        file.save(file_path)
                        new_uploaded_filenames.append(filename)

                if new_uploaded_filenames:
                    logger.info(f"保存了 {len(new_uploaded_filenames)} 张新的自定义回复图片到 {custom_reply_dir}")

            # 1.3 合并已有图片和新上传的图片
            all_uploaded_filenames = existing_filenames_to_keep + new_uploaded_filenames
            if existing_filenames_to_keep:
                logger.info(f"保留了 {len(existing_filenames_to_keep)} 张已有的自定义回复图片")

            # 2. 构建更新数据
            updates = {}

            # 如果有上传的自定义回复图片（已有的或新上传的），将文件名列表存储到数据库
            if all_uploaded_filenames:
                updates['uploaded_reply_images'] = json.dumps(all_uploaded_filenames)
            for key in ['title', 'englishTitle', 'ruleEnabled', 'customReplyText', 'imageSource']:
                value = request.form.get(key)
                if value is not None:
                    if key == 'englishTitle':
                        updates['english_title'] = value
                    elif key == 'ruleEnabled':
                        # 兼容字符串 'true'/'false' 和 '1'/'0'
                        if str(value).lower() in ['true', '1']:
                            updates['ruleEnabled'] = 1
                        else:
                            updates['ruleEnabled'] = 0
                    elif key == 'customReplyText':
                        updates['custom_reply_text'] = value
                    elif key == 'imageSource':
                        updates['image_source'] = value
                    else:
                        updates[key] = value

            # 3. 处理数组数据 (JSON)
            if 'selectedImageIndexes' in request.form:
                updates['custom_reply_images'] = request.form.get('selectedImageIndexes') # 已经是JSON字符串

            if 'customImageUrls' in request.form:
                updates['custom_image_urls'] = request.form.get('customImageUrls') # 已经是JSON字符串

            # 4. 执行更新
            if updates:
                db.update_product(pid_int, updates)

            # 5. 返回完整数据 (解决闪烁问题)
            full_product = get_full_product_data(pid_int)
            return jsonify({'message': '商品更新成功', 'product': full_product})

        except Exception as e:
            logger.error(f"更新商品失败: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return jsonify({'error': '更新失败'}), 500
    # ---------------------------------------------------------
    # 场景 B: 仅 JSON 数据更新
    # ---------------------------------------------------------
    else:
        data = request.get_json()
        if not data or not data.get('id'):
            return jsonify({'error': '商品ID不能为空'}), 400

        product_id = data['id']

        try:
            if not check_permission(product_id):
                return jsonify({'error': '无权限更新此商品'}), 403

            updates = {}
            if 'title' in data:
                updates['title'] = data['title']
            if 'englishTitle' in data:
                updates['english_title'] = data['englishTitle']
            if 'ruleEnabled' in data:
                updates['ruleEnabled'] = 1 if data['ruleEnabled'] else 0
            if 'customReplyText' in data:
                updates['custom_reply_text'] = data['customReplyText']
            if 'selectedImageIndexes' in data:
                updates['custom_reply_images'] = json.dumps(data['selectedImageIndexes'])
            if 'customImageUrls' in data:
                updates['custom_image_urls'] = json.dumps(data['customImageUrls'])
            if 'imageSource' in data:
                updates['image_source'] = data['imageSource']

            if updates:
                db.update_product(product_id, updates)

            # 返回完整数据
            full_product = get_full_product_data(product_id)
            return jsonify({'message': '商品更新成功', 'product': full_product})

        except Exception as e:
            logger.error(f"更新商品失败: {e}")
            return jsonify({'error': '更新失败'}), 500


@app.route('/api/backfill_products', methods=['POST'])
def backfill_products():
    """为已存在但缺少英名或 cnfans 链接的商品回填数据"""
    try:
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        updated = []
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, product_url, english_title, cnfans_url FROM products")
            rows = cursor.fetchall()

            for row in rows:
                pid = row['id']
                url = row['product_url']
                need_english = not row['english_title']
                need_cnfans = not row['cnfans_url']
                if not (need_english or need_cnfans):
                    continue

                product_info = scraper.scrape_product_info(url)
                if not product_info:
                    logger.warning(f"回填失败，无法抓取: {url}")
                    continue

                english = product_info.get('english_title') or ''
                cnfans = product_info.get('cnfans_url') or ''

                cursor.execute("""
                    UPDATE products
                    SET english_title = ?, cnfans_url = ?
                    WHERE id = ?
                """, (english, cnfans, pid))
                conn.commit()
                updated.append(pid)

        return jsonify({'updated': updated, 'count': len(updated)})
    except Exception as e:
        logger.error(f"回填失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/rebuild_index', methods=['POST'])
def rebuild_index():
    """重建FAISS索引，清理被删除的向量"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        from feature_extractor import get_feature_extractor

        logger.info("开始重建FAISS索引...")

        # 获取所有有效的图片记录（确保图片文件存在）
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT pi.id, pi.product_id, pi.image_path, pi.image_index
                FROM product_images pi
                JOIN products p ON pi.product_id = p.id
                ORDER BY pi.id
            """)
            all_records = cursor.fetchall()

        # 过滤出文件存在的记录
        image_records = []
        for record in all_records:
            if os.path.exists(record['image_path']):
                image_records.append(record)
            else:
                logger.warning(f"图片文件不存在，跳过: {record['image_path']}")

        if not image_records:
            return jsonify({'error': '没有找到图片记录'}), 400

        logger.info(f"找到 {len(image_records)} 张图片记录")

        # 重新提取特征并重建索引
        extractor = get_feature_extractor()
        engine = get_vector_engine()

        # 创建新索引
        vectors_data = []
        for record in image_records:
            try:
                image_path = record['image_path']
                if not os.path.exists(image_path):
                    logger.warning(f"图片文件不存在: {image_path}")
                    continue

                # 提取特征
                features = extractor.extract_feature(image_path)
                if features is not None:
                    vectors_data.append((record['id'], features))
                    logger.info(f"重新提取特征: {record['id']}")
                else:
                    logger.warning(f"特征提取失败: {image_path}")

            except Exception as e:
                logger.error(f"处理图片 {record['id']} 失败: {e}")
                continue

        # 重建索引
        success = engine.rebuild_index(vectors_data)
        if success:
            logger.info(f"索引重建完成，包含 {len(vectors_data)} 个向量")
            return jsonify({
                'success': True,
                'message': f'索引重建完成，包含 {len(vectors_data)} 个有效向量',
                'total_vectors': len(vectors_data)
            })
        else:
            return jsonify({'error': '索引重建失败'}), 500

    except Exception as e:
        logger.error(f"重建索引失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/rebuild_vectors', methods=['POST'])
def rebuild_vectors():
    """为已有商品（或缺失向量的图片）重建特征并插入 FAISS"""
    try:
        extractor = get_feature_extractor()
        rebuilt = []
        failed = []

        with db.get_connection() as conn:
            cursor = conn.cursor()
            # 查找所有 product_images 中 milvus_id 为空或 NULL 的记录
            cursor.execute("SELECT id, product_id, image_path, image_index FROM product_images WHERE milvus_id IS NULL OR milvus_id = ''")
            rows = cursor.fetchall()

        for row in rows:
            pid = row['product_id']
            img_path = row['image_path']
            idx = row['image_index']
            try:
                features = extractor.extract_feature(img_path)
                if features is None:
                    logger.error(f"重建特征失败: {img_path}")
                    failed.append({'product_id': pid, 'image_index': idx})
                    continue

                success = db.insert_image_vector(product_id=pid, image_path=img_path, image_index=idx, vector=features)
                if success:
                    rebuilt.append({'product_id': pid, 'image_index': idx})
                else:
                    failed.append({'product_id': pid, 'image_index': idx})
            except Exception as e:
                logger.error(f"重建向量出错: {e}")
                failed.append({'product_id': pid, 'image_index': idx})

        return jsonify({'rebuilt': rebuilt, 'failed': failed, 'count': len(rebuilt)})
    except Exception as e:
        logger.error(f"重建向量失败: {e}")
        return jsonify({'error': str(e)}), 500



@app.route('/api/image/<int:product_id>/<int:image_index>', methods=['GET'])
def serve_product_image(product_id: int, image_index: int):
    """返回指定商品指定序号的图片文件（用于前端缩略图/查看）"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_path FROM product_images WHERE product_id = ? AND image_index = ?", (product_id, image_index))
            row = cursor.fetchone()
            if not row:
                return jsonify({'error': 'Image not found'}), 404
            image_path = row[0]

        # 安全检查并返回文件
        from flask import send_file
        if not os.path.exists(image_path):
            return jsonify({'error': 'Image file missing'}), 404
        return send_file(image_path, mimetype='image/jpeg')
    except Exception as e:
        logger.error(f"serve_product_image 失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/custom_reply_image/<int:product_id>/<filename>', methods=['GET'])
def serve_custom_reply_image(product_id: int, filename: str):
    """返回指定商品的自定义回复图片文件"""
    try:
        # 从数据库读取 uploaded_reply_images 字段，验证文件名
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT uploaded_reply_images FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            if not row or not row[0]:
                return jsonify({'error': 'Product not found or no uploaded images'}), 404

            # 解析 JSON 数组
            try:
                uploaded_filenames = json.loads(row[0])
            except:
                return jsonify({'error': 'Invalid image data'}), 500

            # 安全检查：验证文件名是否在列表中
            if filename not in uploaded_filenames:
                return jsonify({'error': 'Image not found'}), 404

        # 构建文件路径
        import os
        image_path = os.path.join('data', 'custom_reply_images', str(product_id), filename)

        # 安全检查并返回文件
        from flask import send_file
        if not os.path.exists(image_path):
            return jsonify({'error': 'Image file missing'}), 404
        return send_file(image_path, mimetype='image/jpeg')
    except Exception as e:
        logger.error(f"serve_custom_reply_image 失败: {e}")
        return jsonify({'error': str(e)}), 500

def verify_discord_token(token):
    """验证Discord token并获取用户信息"""
    try:
        headers = {
            'Authorization': f'Bot {token}' if token.startswith('Bot ') else token,
            'User-Agent': 'DiscordBot/1.0'
        }

        # 首先尝试作为Bot token验证
        response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 401:
            # 如果Bot token失败，尝试作为User token
            if not token.startswith('Bot '):
                headers['Authorization'] = f'Bot {token}'
                response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 200:
            user_data = response.json()
            return {
                'valid': True,
                'username': f"{user_data.get('username', 'Unknown')}#{user_data.get('discriminator', '0000')}",
                'user_id': user_data.get('id'),
                'avatar': user_data.get('avatar'),
                'bot': user_data.get('bot', False)
            }
        else:
            return {
                'valid': False,
                'error': f'HTTP {response.status_code}: {response.text}'
            }
    except requests.exceptions.RequestException as e:
        return {
            'valid': False,
            'error': f'网络错误: {str(e)}'
        }
    except Exception as e:
        return {
            'valid': False,
            'error': f'验证失败: {str(e)}'
        }

@app.route('/api/accounts', methods=['POST'])
def add_account():
    """添加新的 Discord 账号"""
    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': '需要登录'}), 401

        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        token = data.get('token')
        username = data.get('username', '')

        if not token:
            return jsonify({'error': 'Token is required'}), 400

        # 验证token并获取真实用户名
        logger.info("正在验证Discord token...")
        token_info = verify_discord_token(token)

        if not token_info['valid']:
            return jsonify({'error': f'Token验证失败: {token_info["error"]} 请检查token是否正确'}), 400

        # 如果没有提供用户名，使用从token获取的用户名
        if not username:
            username = token_info['username']
            logger.info(f"自动获取用户名: {username}")

        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 首先检查token是否已存在
            cursor.execute("SELECT id, username, user_id FROM discord_accounts WHERE token = ?", (token,))
            existing_account = cursor.fetchone()

            if existing_account:
                # 如果token已存在，检查是否属于当前用户
                if existing_account[2] == current_user['id']:
                    # 属于当前用户，更新信息
                    cursor.execute("""
                        UPDATE discord_accounts
                        SET username = ?, status = 'offline', updated_at = CURRENT_TIMESTAMP
                        WHERE token = ?
                    """, (username, token))
                    account_id = existing_account[0]
                    logger.info(f"更新现有账号: {username} (用户ID: {current_user['id']})")
                else:
                    # 属于其他用户，返回错误
                    return jsonify({'error': '此Discord token已被其他用户使用'}), 400
            else:
                # token不存在，插入新记录
                cursor.execute("""
                    INSERT INTO discord_accounts (username, token, status, user_id)
                    VALUES (?, ?, 'offline', ?)
                """, (username, token, current_user['id']))
                account_id = cursor.lastrowid
                logger.info(f"添加新账号: {username} (用户ID: {current_user['id']})")

            # 获取账号信息
            cursor.execute("SELECT id, username, token, status, last_active, user_id FROM discord_accounts WHERE id = ?", (account_id,))
            account = cursor.fetchone()
            conn.commit()

        logger.info(f"账号添加成功: {username} (用户ID: {current_user['id']})")
        return jsonify({
            'id': account[0],
            'username': account[1],
            'token': account[2],
            'status': account[3],
            'lastActive': account[4],
            'user_id': account[5],
            'verified': True
        })
    except Exception as e:
        logger.error(f"添加账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/user', methods=['PUT'])
def assign_account_to_user(account_id):
    """将Discord账号分配给用户（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        data = request.get_json()
        user_id = data.get('user_id')

        if db.update_discord_account_user(account_id, user_id):
            return jsonify({'message': '账号分配成功'})
        else:
            return jsonify({'error': '账号分配失败'}), 500
    except Exception as e:
        logger.error(f"分配账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>', methods=['DELETE'])
def delete_account(account_id):
    """删除 Discord 账号"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM discord_accounts WHERE id = ?", (account_id,))
            conn.commit()

        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"删除账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/status', methods=['PUT'])
def update_account_status(account_id):
    """更新账号状态"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        status = data.get('status')

        if status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status'}), 400

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE discord_accounts
                SET status = ?, updated_at = datetime('now')
                WHERE id = ?
            """, (status, account_id))
            conn.commit()

        return jsonify({'success': True, 'status': status})
    except Exception as e:
        logger.error(f"更新账号状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/current', methods=['GET'])
def get_current_account():
    """获取当前可用的 Discord 账号 (状态为online的第一个)"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, username, token, status, last_active
                FROM discord_accounts
                WHERE status = 'online'
                ORDER BY last_active DESC NULLS LAST, created_at ASC
                LIMIT 1
            """)
            account = cursor.fetchone()

            if account:
                return jsonify({
                    'id': account[0],
                    'username': account[1],
                    'token': account[2],
                    'status': account[3],
                    'lastActive': account[4]
                })
            else:
                return jsonify({'error': 'No active account found'}), 404
    except Exception as e:
        logger.error(f"获取当前账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/verify-all', methods=['POST'])
def verify_all_accounts():
    """重新验证所有账号"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            # 获取所有账号
            cursor.execute("SELECT id, username, token FROM discord_accounts")
            accounts = cursor.fetchall()

            verified_count = 0
            invalid_count = 0
            results = []

            for account in accounts:
                account_id, username, token = account
                logger.info(f"正在验证账号: {username}")

                token_info = verify_discord_token(token)

                if token_info['valid']:
                    # 更新用户名（如果有变化）
                    new_username = token_info['username']
                    if new_username != username:
                        cursor.execute("""
                            UPDATE discord_accounts
                            SET username = ?
                            WHERE id = ?
                        """, (new_username, account_id))
                        logger.info(f"用户名已更新: {username} -> {new_username}")

                    verified_count += 1
                    results.append({
                        'id': account_id,
                        'username': new_username,
                        'valid': True
                    })
                else:
                    invalid_count += 1
                    results.append({
                        'id': account_id,
                        'username': username,
                        'valid': False,
                        'error': token_info['error']
                    })

            conn.commit()

        return jsonify({
            'success': True,
            'total': len(accounts),
            'verified': verified_count,
            'invalid': invalid_count,
            'results': results
        })
    except Exception as e:
        logger.error(f"批量验证账号失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/bulk-status', methods=['POST'])
def bulk_update_status():
    """批量开启或停止用户自己的账号"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        new_status = data.get('status')
        if new_status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status. Must be "online" or "offline"'}), 400

        current_user = get_current_user()

        with db.get_connection() as conn:
            cursor = conn.cursor()

            if new_status == 'online':
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'online', last_active = ?
                    WHERE user_id = ?
                """, (datetime.now(), current_user['id']))
            else:
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'offline'
                    WHERE user_id = ?
                """, (current_user['id'],))

            updated_count = cursor.rowcount
            conn.commit()

        logger.info(f"批量更新账号状态: {updated_count} 个账号设置为 {new_status}")

        return jsonify({
            'success': True,
            'updated_count': updated_count,
            'new_status': new_status
        })
    except Exception as e:
        logger.error(f"批量更新账号状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/rotation', methods=['GET'])
def get_rotation_config():
    """获取账号轮换配置"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT enabled, rotation_interval, current_account_id
                FROM account_rotation_config
                LIMIT 1
            """)
            row = cursor.fetchone()

        if row:
            return jsonify({
                'enabled': row[0],
                'rotationInterval': row[1],
                'currentAccountId': row[2]
            })
        return jsonify({'enabled': False, 'rotationInterval': 10})
    except Exception as e:
        logger.error(f"获取轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/user/settings', methods=['GET'])
def get_user_settings():
    """获取当前用户的个性化设置"""
    user = get_current_user()
    if not user:
        return jsonify({'error': '需要登录'}), 401

    try:
        settings = db.get_user_settings(user['id'])
        return jsonify(settings)
    except Exception as e:
        logger.error(f"获取用户设置失败: {e}")
        return jsonify({'error': '获取设置失败'}), 500

@app.route('/api/user/settings', methods=['PUT'])
def update_user_settings():
    """更新当前用户的个性化设置"""
    user = get_current_user()
    if not user:
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        # 调试延迟设置
        min_delay = data.get('global_reply_min_delay')
        max_delay = data.get('global_reply_max_delay')
        logger.info(f"用户设置延迟 - 最小: {min_delay}, 最大: {max_delay}")

        # 处理开关设置（boolean 转 integer）
        keyword_reply = data.get('keyword_reply_enabled')
        image_reply = data.get('image_reply_enabled')
        if keyword_reply is not None:
            keyword_reply = 1 if keyword_reply else 0
        if image_reply is not None:
            image_reply = 1 if image_reply else 0

        success = db.update_user_settings(
            user_id=user['id'],
            download_threads=data.get('download_threads'),
            feature_extract_threads=data.get('feature_extract_threads'),
            discord_similarity_threshold=data.get('discord_similarity_threshold'),
            global_reply_min_delay=min_delay,
            global_reply_max_delay=max_delay,
            user_blacklist=data.get('user_blacklist'),
            keyword_filters=data.get('keyword_filters'),
            keyword_reply_enabled=keyword_reply,
            image_reply_enabled=image_reply
        )

        if success:
            return jsonify({'message': '设置更新成功'})
        else:
            return jsonify({'error': '设置更新失败'}), 500
    except Exception as e:
        logger.error(f"更新用户设置失败: {e}")
        return jsonify({'error': '更新设置失败'}), 500

@app.route('/api/accounts/rotation', methods=['POST'])
def update_rotation_config():
    """更新账号轮换配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        enabled = data.get('enabled', False)
        rotation_interval = data.get('rotationInterval', 10)

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE account_rotation_config
                SET enabled = ?, rotation_interval = ?, updated_at = datetime('now')
                WHERE id = 1
            """, (enabled, rotation_interval))
            conn.commit()

        return jsonify({'success': True, 'enabled': enabled, 'rotationInterval': rotation_interval})
    except Exception as e:
        logger.error(f"更新轮换配置失败: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/get_indexed_ids', methods=['GET'])
def get_indexed_ids():
    """获取已建立索引的商品URL列表"""
    try:
        indexed_urls = db.get_indexed_product_urls()
        return jsonify({'indexedIds': indexed_urls})
    except Exception as e:
        logger.error(f"获取已索引ID失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：批量删除 API ===
@app.route('/api/products/batch', methods=['DELETE'])
def batch_delete_products():
    """批量删除商品（多线程高性能版）"""
    try:
        data = request.get_json()
        ids = data.get('ids', [])
        if not ids:
            return jsonify({'error': 'No IDs provided'}), 400

        logger.info(f"开始批量删除 {len(ids)} 个商品")

        # 使用多线程删除
        import concurrent.futures
        max_threads = min(5, len(ids))  # 删除用较少的线程，避免IO冲突

        deleted_count = 0
        failed_ids = []

        def delete_single_product(product_id):
            """删除单个商品"""
            try:
                # 创建新的数据库实例避免多线程冲突
                from database import Database
                temp_db = Database()
                if temp_db.delete_product_images(product_id):
                    return {'success': True, 'id': product_id}
                else:
                    return {'success': False, 'id': product_id}
            except Exception as e:
                logger.error(f"删除商品 {product_id} 失败: {e}")
                return {'success': False, 'id': product_id}

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(delete_single_product, pid) for pid in ids]

            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result['success']:
                    deleted_count += 1
                else:
                    failed_ids.append(result['id'])

        logger.info(f"批量删除完成: {deleted_count}/{len(ids)} 个商品成功删除")

        response = {'success': True, 'count': deleted_count, 'total': len(ids)}
        if failed_ids:
            response['failed_ids'] = failed_ids
            response['warning'] = f'{len(failed_ids)} 个商品删除失败'

        return jsonify(response)
    except Exception as e:
        logger.error(f"批量删除失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/batch-delete-all', methods=['DELETE'])
def batch_delete_all_products():
    """删除所有商品（全选删除）"""
    try:
        # 获取所有商品ID
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products")
            all_ids = [row['id'] for row in cursor.fetchall()]

        if not all_ids:
            return jsonify({'success': True, 'count': 0, 'message': '没有商品需要删除'})

        logger.info(f"开始删除所有 {len(all_ids)} 个商品")

        # 使用多线程删除所有商品
        import concurrent.futures
        max_threads = min(5, len(all_ids))

        deleted_count = 0
        failed_ids = []

        def delete_single_product(product_id):
            try:
                # 创建新的数据库实例避免多线程冲突
                from database import Database
                temp_db = Database()
                if temp_db.delete_product_images(product_id):
                    return {'success': True, 'id': product_id}
                else:
                    return {'success': False, 'id': product_id}
            except Exception as e:
                logger.error(f"删除商品 {product_id} 失败: {e}")
                return {'success': False, 'id': product_id}

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(delete_single_product, pid) for pid in all_ids]

            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result['success']:
                    deleted_count += 1
                else:
                    failed_ids.append(result['id'])

        logger.info(f"全选删除完成: {deleted_count}/{len(all_ids)} 个商品成功删除")

        response = {
            'success': True,
            'count': deleted_count,
            'total': len(all_ids),
            'message': f'成功删除 {deleted_count} 个商品'
        }

        if failed_ids:
            response['failed_ids'] = failed_ids
            response['warning'] = f'{len(failed_ids)} 个商品删除失败'

        return jsonify(response)
    except Exception as e:
        logger.error(f"全选删除失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>', methods=['GET'])
def get_product(product_id):
    """获取单个商品的详细信息"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        product = db._get_product_info_by_id(product_id)
        if not product:
            return jsonify({'error': '商品不存在'}), 404

        # 获取商品图片
        images = db.get_product_images(product_id)
        product['images'] = [f"/api/image/{product_id}/{img['image_index']}" for img in images]

        return jsonify(product)
    except Exception as e:
        logger.error(f"获取商品失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>', methods=['DELETE'])
def delete_product(product_id):
    """删除商品及其所有相关数据"""
    try:
        # 删除商品及其向量数据
        if db.delete_product_images(product_id):
            return jsonify({'success': True, 'message': f'商品 {product_id} 已删除'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f"删除商品失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：商品图片上传 API ===
@app.route('/api/products/<int:product_id>/images', methods=['POST'])
def upload_product_image(product_id):
    """上传新图片到商品（调用完整的核心处理函数）"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    file = request.files.get('image')
    if not file:
        return jsonify({'error': '无文件'}), 400

    try:
        # 获取现有特征用于查重
        existing_images = db.get_product_images(product_id)
        existing_feats = [img['features'] for img in existing_images if img.get('features') is not None]

        # 获取下一个 index
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT MAX(image_index) FROM product_images WHERE product_id = ?", (product_id,))
            row = cursor.fetchone()
            next_index = (row[0] + 1) if row and row[0] is not None else 0

            # 检查图片数量限制（每个商品最多20张图片）
            cursor.execute("SELECT COUNT(*) FROM product_images WHERE product_id = ?", (product_id,))
            count_row = cursor.fetchone()
            if count_row and count_row[0] >= 20:
                return jsonify({'error': '每个商品最多只能上传20张图片'}), 400

        # 调用核心处理函数（现在包含完整的数据库和FAISS操作）
        result = process_and_save_image_core(product_id, file, next_index, existing_feats)

        if not result['success']:
            return jsonify({'error': result['error']}), 400

        # 返回更新后的商品信息
        product = db._get_product_info_by_id(product_id)

        # 获取所有图片
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            images = [f"/api/image/{product_id}/{row[0]}" for row in cursor.fetchall()]

        product['images'] = images

        # 格式化以匹配前端
        product['weidianId'] = product.get('product_url', '').split('itemID=')[1] if 'itemID=' in product.get('product_url', '') else ''
        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['ruleEnabled'] = product.get('ruleEnabled')
        product['matchType'] = 'fuzzy'

        return jsonify({'success': True, 'product': product})

    except Exception as e:
        logger.error(f"上传图片失败: {e}")
        return jsonify({'error': str(e)}), 500

# === 修复：删除图片后返回最新 Product 对象 ===
@app.route('/api/products/<int:product_id>/images/<int:image_index>', methods=['DELETE'])
def delete_product_image(product_id, image_index):
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        logger.info(f"开始删除图片: product_id={product_id}, image_index={image_index}")


        # 验证参数
        try:
            product_id = int(product_id)
            image_index = int(image_index)
        except ValueError:
            return jsonify({'error': '参数格式错误'}), 400

        # 调用数据库删除逻辑
        success = db.delete_image_vector(product_id, image_index)

        if not success:
            logger.warning(f"删除图片失败: product_id={product_id}, image_index={image_index}")
            return jsonify({'error': '删除失败，图片可能不存在'}), 404

        # 获取最新商品信息
        product = db._get_product_info_by_id(product_id)

        if not product:
            logger.error(f"删除后商品不存在: product_id={product_id}")
            return jsonify({'error': '商品不存在'}), 404

        # 获取剩余所有图片
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            image_indices = [row[0] for row in cursor.fetchall()]
            images = [f"/api/image/{product_id}/{idx}" for idx in image_indices]

        product['images'] = images

        # 格式化商品信息
        try:
            if 'itemID=' in product.get('product_url', ''):
                product['weidianId'] = product.get('product_url', '').split('itemID=')[1]
            else:
                product['weidianId'] = ''
        except:
            product['weidianId'] = ''

        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['acbuyUrl'] = product.get('acbuy_url')
        product['ruleEnabled'] = product.get('ruleEnabled')

        logger.info(f"删除图片成功: product_id={product_id}, image_index={image_index}, 剩余图片数量={len(images)}")

        return jsonify({'success': True, 'product': product})

    except Exception as e:
        logger.error(f"删除图片失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/cleanup/images', methods=['POST'])
def cleanup_images():
    """清理未使用的图片文件"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': '只有管理员可以执行清理操作'}), 403

        # 获取清理参数
        data = request.get_json() or {}
        days_old = data.get('days_old', 30)

        # 执行清理
        deleted_count = db.cleanup_unused_images(days_old)

        return jsonify({
            'success': True,
            'message': f'清理完成，共删除 {deleted_count} 个未使用的图片文件',
            'deleted_count': deleted_count
        })

    except Exception as e:
        logger.error(f"图片清理失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/ai-status', methods=['GET'])
def get_ai_status():
    """获取AI系统完整状态和诊断信息"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            return {'error': '特征提取器未初始化'}
        ai_status = extractor.get_status()

        # 获取FAISS状态
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        faiss_engine = get_vector_engine()
        faiss_status = faiss_engine.get_stats()

        # 综合状态
        overall_status = {
            'ai_model_status': ai_status,
            'vector_engine_status': faiss_status,
            'system_health': '良好' if ai_status['yolo_available'] and faiss_status['total_vectors'] >= 0 else '需要优化',
            'recommendations': []
        }

        # 生成建议
        recommendations = []
        recommendations.extend(ai_status.get('performance_tips', []))
        recommendations.extend(faiss_status.get('performance_tips', []))

        # 额外的系统级建议
        if not ai_status['yolo_available']:
            recommendations.append("YOLO裁剪功能已禁用，图像识别准确率会降低")
        if faiss_status['total_vectors'] == 0:
            recommendations.append("向量数据库为空，建议添加商品数据")
        if faiss_status['ef_construction'] == '不支持' or faiss_status['ef_search'] == '不支持':
            recommendations.append("FAISS版本较旧，建议升级以获得最佳搜索性能")

        overall_status['recommendations'] = recommendations[:5]  # 最多显示5条建议

        return jsonify(overall_status)
    except Exception as e:
        logger.error(f"获取AI状态失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/rebuild-index', methods=['POST'])
def rebuild_faiss_index():
    """重建FAISS索引，清理已删除的向量"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': '只有管理员可以重建索引'}), 403

        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()

        # 获取所有有效的图片数据
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, image_path FROM product_images WHERE id IS NOT NULL")
            all_images = cursor.fetchall()

        # 重新提取所有特征
        valid_vectors = []
        for row in all_images:
            try:
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("特征提取器未初始化")
                    continue
                features = extractor.extract_feature(row['image_path'])
                if features is not None:
                    valid_vectors.append((row['id'], features))
            except Exception as e:
                logger.warning(f"重新提取特征失败 {row['image_path']}: {e}")

        # 重建索引
        engine.rebuild_index(valid_vectors)

        return jsonify({
            'success': True,
            'message': f'索引重建完成，包含 {len(valid_vectors)} 个向量',
            'total_vectors': len(valid_vectors)
        })

    except Exception as e:
        logger.error(f"重建索引失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config', methods=['GET'])
def get_config():
    """获取系统配置信息"""
    try:
        from config import config
        return jsonify({
            'version': '1.0.0',
            'features': {
                'multithread_scraping': True,
                'ai_image_processing': True,
                'discord_bot': True,
                'real_time_monitoring': True
            },
            'limits': {
                'max_scrape_threads': config.SCRAPE_THREADS,
                'max_download_threads': config.DOWNLOAD_THREADS,
                'max_feature_threads': config.FEATURE_EXTRACT_THREADS
            }
        })
    except Exception as e:
        logger.error(f"获取配置信息失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['GET'])
def get_discord_threshold():
    """获取Discord相似度阈值"""
    try:
        sys_config = db.get_system_config()
        threshold = sys_config['discord_similarity_threshold']
        return jsonify({
            'threshold': threshold,
            'threshold_percentage': threshold * 100
        })
    except Exception as e:
        logger.error(f"获取Discord阈值失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['POST'])
def update_discord_threshold():
    """更新Discord相似度阈值"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        threshold = float(data.get('threshold', 0.4))

        # 验证范围
        if not (0.0 <= threshold <= 1.0):
            return jsonify({'error': '阈值必须在0.0-1.0之间'}), 400

        # 保存到数据库
        if db.update_system_config(discord_similarity_threshold=threshold):
            # 同时更新内存中的配置

            return jsonify({
                'message': f'Discord相似度阈值已更新为 {threshold}',
                'threshold': threshold
            })

        return jsonify({'error': '更新配置失败'}), 500
    except ValueError as e:
        return jsonify({'error': '阈值必须是数字'}), 400
    except Exception as e:
        logger.error(f"更新Discord阈值失败: {e}")
        return jsonify({'error': '更新配置失败'}), 500

@app.route('/api/config/scrape-threads', methods=['GET', 'POST'])
def config_scrape_threads():
    """配置抓取多线程数量"""
    if request.method == 'GET':
        config = db.get_system_config()
        return jsonify({
            'scrape_threads': config.get('scrape_threads', 2)
        })

    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        scrape_threads = int(data.get('scrape_threads', 2))

        # 确保线程数在合理范围内
        if scrape_threads < 1 or scrape_threads > 10:
            return jsonify({'error': '抓取线程数必须是1-10之间的整数'}), 400

        # 保存到数据库
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('UPDATE system_config SET scrape_threads = ?, updated_at = CURRENT_TIMESTAMP WHERE id = 1',
                          (scrape_threads,))
            conn.commit()

        return jsonify({
            'message': f'抓取线程数已设置为 {scrape_threads}',
            'scrape_threads': scrape_threads
        })

    except ValueError as e:
        return jsonify({'error': '线程数必须是整数'}), 400
    except Exception as e:
        logger.error(f"更新抓取线程配置失败: {e}")
        return jsonify({'error': '更新配置失败'}), 500

@app.route('/api/config/global-reply-delay', methods=['GET'])
def get_global_reply_delay():
    """获取全局回复延迟配置"""
    try:
        delay_config = db.get_global_reply_config()
        return jsonify({
            'min_delay': delay_config['min_delay'],
            'max_delay': delay_config['max_delay'],
            'description': f'{delay_config["min_delay"]}-{delay_config["max_delay"]}秒随机延迟'
        })
    except Exception as e:
        logger.error(f"获取全局回复延迟失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/debug/faiss_status', methods=['GET'])
def get_faiss_status():
    """获取FAISS向量数据库状态"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()
        stats = engine.get_stats()

        # 尝试搜索一个测试向量
        test_vector = np.zeros(config.VECTOR_DIMENSION, dtype='float32')
        test_results = engine.search(test_vector, top_k=1)

        return jsonify({
            'index_exists': True,
            'entity_count': stats['total_vectors'],
            'test_search_works': len(test_results) > 0,
            'vector_dimension': config.VECTOR_DIMENSION,
            'index_type': stats['index_type'],
            'metric_type': stats['metric_type'],
            'memory_usage_mb': stats['memory_usage_mb'],
            'ef_construction': stats['ef_construction'],
            'ef_search': stats['ef_search']
        })
    except Exception as e:
        logger.error(f"获取FAISS状态失败: {e}")
        return jsonify({
            'error': str(e),
            'index_exists': False,
            'entity_count': 0
        }), 500


@app.route('/api/config/global-reply-delay', methods=['POST'])
def update_global_reply_delay():
    """更新全局回复延迟配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        min_delay = float(data.get('min_delay', 3))
        max_delay = float(data.get('max_delay', 8))

        # 验证范围
        if min_delay < 0 or max_delay < 0:
            return jsonify({'error': '延迟时间不能为负数'}), 400
        if min_delay > max_delay:
            return jsonify({'error': '最小延迟不能大于最大延迟'}), 400
        if max_delay > 300:
            return jsonify({'error': '最大延迟不能超过300秒'}), 400

        # 保存到数据库
        if db.update_global_reply_config(min_delay, max_delay):
            # 同时更新内存中的配置
            config.GLOBAL_REPLY_MIN_DELAY = min_delay
            config.GLOBAL_REPLY_MAX_DELAY = max_delay

            logger.info(f"全局回复延迟设置为: {min_delay}-{max_delay}秒")

            return jsonify({
                'success': True,
                'min_delay': min_delay,
                'max_delay': max_delay,
                'description': f'{min_delay}-{max_delay}秒随机延迟',
                'message': '全局回复延迟设置已更新，所有自动回复将使用此设置'
            })
        else:
            return jsonify({'error': '保存失败'}), 500

    except Exception as e:
        logger.error(f"更新全局回复延迟失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['GET'])
def get_discord_channel():
    """获取Discord频道配置"""
    try:
        sys_config = db.get_system_config()
        return jsonify({
            'channel_id': sys_config['discord_channel_id'],
            'cnfans_channel_id': sys_config['cnfans_channel_id'],
            'acbuy_channel_id': sys_config['acbuy_channel_id']
        })
    except Exception as e:
        logger.error(f"获取Discord频道配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['POST'])
def update_discord_channel():
    """更新Discord频道配置"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        channel_id = data.get('channel_id', '').strip()
        cnfans_channel_id = data.get('cnfans_channel_id', '').strip()
        acbuy_channel_id = data.get('acbuy_channel_id', '').strip()

        # 验证频道ID格式（应该是数字）
        for cid_name, cid_value in [('channel_id', channel_id), ('cnfans_channel_id', cnfans_channel_id), ('acbuy_channel_id', acbuy_channel_id)]:
            if cid_value and not cid_value.isdigit():
                return jsonify({'error': f'{cid_name} 必须是数字'}), 400

        # 保存到数据库
        if db.update_system_config(
            discord_channel_id=channel_id,
            cnfans_channel_id=cnfans_channel_id,
            acbuy_channel_id=acbuy_channel_id
        ):
            # 同时更新环境变量和bot_config
            if channel_id:
                os.environ['DISCORD_CHANNEL_ID'] = channel_id
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = int(channel_id)
                logger.info(f"Discord频道ID设置为: {channel_id}")
            else:
                os.environ.pop('DISCORD_CHANNEL_ID', None)
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = 0
                logger.info("Discord频道ID已清除")

            return jsonify({
                'success': True,
                'channel_id': channel_id,
                'message': f'Discord频道ID已设置为: {channel_id or "无(监听所有频道)"}'
            })
        else:
            return jsonify({'error': '保存失败'}), 500
    except Exception as e:
        logger.error(f"更新Discord频道配置失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['GET'])
def get_search_history():
    """获取搜索历史记录（支持分页）"""
    try:
        limit = min(int(request.args.get('limit', 20)), 100)  # 最多100条
        offset = max(int(request.args.get('offset', 0)), 0)
        page = max(int(request.args.get('page', 1)), 1)

        # 如果提供了page参数，计算offset
        if 'page' in request.args and 'offset' not in request.args:
            offset = (page - 1) * limit

        result = db.get_search_history(limit, offset)
        return jsonify(result)
    except Exception as e:
        logger.error(f"获取搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_similar_text', methods=['POST'])
def search_similar_text():
    """根据文字关键词搜索相似商品"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        query = data.get('query', '').strip()
        limit = min(int(data.get('limit', 5)), 20)

        if not query:
            return jsonify({'error': 'Query is required'}), 400

        logger.info(f'文字搜索请求: "{query}", 限制: {limit}')

        with db.get_connection() as conn:
            cursor = conn.cursor()
            query_lower = query.lower()

            # =======================================================
            # 修复: 移除 `AND ruleEnabled = 1`
            # 即使规则被禁用(用于自定义回复)，也必须能被搜出来，
            # 否则机器人永远找不到这个商品，也就无法发送自定义回复。
            # =======================================================
            cursor.execute("""
                SELECT id, product_url, title, english_title, description,
                       ruleEnabled, min_delay, max_delay, created_at,
                       cnfans_url, shop_name, custom_reply_text,
                       custom_reply_images, custom_image_urls, image_source,
                       uploaded_reply_images
                FROM products
                WHERE (LOWER(english_title) LIKE ? OR LOWER(title) LIKE ?)
                ORDER BY created_at DESC
                LIMIT ?
            """, (f'%{query_lower}%', f'%{query_lower}%', limit))

            rows = cursor.fetchall()

            products = []
            for row in rows:
                prod = dict(row)
                # 简单获取第一张图作为预览
                cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index LIMIT 1", (prod['id'],))
                img_row = cursor.fetchone()
                # 构造符合 Bot 逻辑的 image 路径
                if img_row:
                    prod['images'] = [f"/api/image/{prod['id']}/{img_row[0]}"]
                else:
                    prod['images'] = []

                # 补充 Bot 需要的字段
                prod['weidianUrl'] = prod.get('product_url')
                prod['autoReplyEnabled'] = bool(prod.get('ruleEnabled', True))

                # 解析 JSON 字段供 Bot 使用
                try:
                    if prod.get('custom_reply_images'):
                        prod['selectedImageIndexes'] = json.loads(prod['custom_reply_images'])
                    if prod.get('custom_image_urls'):
                        prod['customImageUrls'] = json.loads(prod['custom_image_urls'])
                    # 解析上传的自定义回复图片
                    if prod.get('uploaded_reply_images'):
                        prod['uploaded_reply_images'] = json.loads(prod['uploaded_reply_images'])
                except:
                    pass

                products.append(prod)

        logger.info(f'文字搜索完成，找到 {len(products)} 个商品')

        return jsonify({
            'success': True,
            'query': query,
            'products': products,
            'total': len(products)
        })

    except Exception as e:
        logger.error(f"文字搜索失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history/<int:history_id>', methods=['DELETE'])
def delete_search_history(history_id):
    """删除搜索历史记录"""
    try:
        if db.delete_search_history(history_id):
            return jsonify({'success': True})
        else:
            return jsonify({'error': '记录不存在'}), 404
    except Exception as e:
        logger.error(f"删除搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['DELETE'])
def clear_search_history():
    """清空所有搜索历史"""
    try:
        if db.clear_search_history():
            return jsonify({'success': True})
        else:
            return jsonify({'error': '清空失败'}), 500
    except Exception as e:
        logger.error(f"清空搜索历史失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/stream')
def log_stream():
    """Server-Sent Events 日志流"""
    import json

    def generate():
        # 为这个客户端创建队列
        client_queue = queue.Queue(maxsize=100)  # 限制队列大小
        log_clients.append(client_queue)

        try:
            # 发送最近的日志历史
            for log_entry in all_logs[-20:]:  # 发送最近20条历史日志
                yield f"data: {json.dumps(log_entry)}\n\n"

            # 持续监听新日志
            while True:
                try:
                    # 等待新日志，超时时间设为30秒
                    log_entry = client_queue.get(timeout=30)
                    yield f"data: {json.dumps(log_entry)}\n\n"
                except queue.Empty:
                    # 发送心跳包保持连接
                    yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': datetime.now().isoformat()})}\n\n"

        except GeneratorExit:
            # 客户端断开连接
            pass
        finally:
            # 清理客户端队列
            if client_queue in log_clients:
                log_clients.remove(client_queue)

    return Response(generate(), mimetype='text/event-stream',
                   headers={'Cache-Control': 'no-cache',
                           'Access-Control-Allow-Origin': '*',
                           'Access-Control-Allow-Headers': 'Cache-Control'})

@app.route('/api/logs/recent')
def get_recent_logs():
    """获取最近的日志记录"""
    try:
        # 从日志列表中返回最近50条日志
        return jsonify({
            'logs': all_logs[-50:],
            'total': len(all_logs)
        })
    except Exception as e:
        logger.error(f"获取最近日志失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/add', methods=['POST'])
def add_external_log():
    """接收外部进程发送的日志"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid log data'}), 400

        # 创建日志条目
        log_entry = {
            'timestamp': data.get('timestamp', datetime.now().isoformat()),
            'level': data.get('level', 'INFO'),
            'message': data.get('message', ''),
            'module': data.get('module', 'external'),
            'func': data.get('func', '')
        }

        # 添加到日志列表
        all_logs.append(log_entry)
        if len(all_logs) > 200:
            all_logs.pop(0)

        # 添加到队列
        log_queue.put(log_entry)

        return jsonify({'success': True})
    except Exception as e:
        print(f"添加外部日志失败: {e}")
        return jsonify({'error': str(e)}), 500

def start_discord_bot(user_id=None):
    """启动Discord机器人 - 支持多账号"""
    global bot_running

    if bot_running:
        logger.warning("机器人已经在运行中")
        return

    try:
        import asyncio
        from bot import DiscordBotClient

        logger.info(f"正在启动Discord机器人... (用户ID: {user_id})")

        # 获取账号 - 如果指定了用户ID，只获取该用户的账号
        if user_id:
            accounts = db.get_discord_accounts_by_user(user_id)
        else:
            # 获取所有账号
            accounts = db.get_discord_accounts_by_user(None)

        if not accounts:
            logger.warning("没有找到可用的Discord账号")
            return

        logger.info(f"找到 {len(accounts)} 个Discord账号，开始启动...")

        # 在新的事件循环中运行机器人
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        # 为每个账号创建机器人实例
        for account in accounts:
            account_id = account['id']
            token = account['token']
            username = account.get('username', f'account_{account_id}')
            user_id = account.get('user_id')

            # 获取用户管理的店铺
            user_shops = None
            if user_id:
                user = db.get_user_by_id(user_id)
                if user:
                    user_shops = user.get('shops', [])

            # 确定账号角色：检查是否绑定了任何网站配置
            account_bindings = db.get_account_website_bindings(account_id)
            if account_bindings:
                # 检查账号是否有发送或监听角色
                has_sender = any(b['role'] in ['sender', 'both'] for b in account_bindings)
                has_listener = any(b['role'] in ['listener', 'both'] for b in account_bindings)

                if has_sender and has_listener:
                    role = 'both'
                elif has_sender:
                    role = 'sender'
                elif has_listener:
                    role = 'listener'
                else:
                    role = 'both'  # 默认
            else:
                role = 'both'  # 未绑定的账号默认为both

            logger.info(f"正在启动机器人账号: {username} (用户ID: {user_id}, 管理店铺: {user_shops}, 角色: {role})")

            # 创建机器人实例，传入角色参数
            client = DiscordBotClient(account_id=account_id, user_id=user_id, user_shops=user_shops, role=role)

            # 启动机器人
            try:
                task = loop.create_task(client.start(token, reconnect=True))
                bot_clients.append(client)
                bot_tasks.append(task)
                logger.info(f"Discord机器人启动成功: {username}")
            except Exception as e:
                logger.error(f"启动机器人失败 {username}: {e}")

        # 在后台线程中运行事件循环
        import threading
        bot_thread = threading.Thread(target=loop.run_forever, daemon=True)
        bot_thread.start()

        if bot_clients:
            bot_running = True
            logger.info(f"共启动了 {len(bot_clients)} 个Discord机器人")
        else:
            logger.warning("没有成功启动任何机器人")

    except ImportError as e:
        logger.warning(f"Discord机器人模块不可用: {e}")
        logger.info("Flask应用将继续运行，但机器人功能不可用")
    except Exception as e:
        logger.error(f"Discord机器人启动失败: {e}")
        logger.info("Flask应用将继续运行，但机器人功能不可用")

def stop_discord_bot(user_id=None):
    """停止Discord机器人 (支持按用户停止)"""
    global bot_running

    # 如果没有客户端，直接返回
    if not bot_clients:
        logger.info("没有正在运行的机器人")
        bot_running = False
        return

    logger.info(f"正在停止机器人... {'(特定用户: ' + str(user_id) + ')' if user_id else '(所有用户)'}")

    try:
        import asyncio
        # 获取当前的事件循环，如果是在 Flask 线程中可能需要处理
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

        # 筛选需要停止的客户端索引
        indices_to_remove = []

        for i, client in enumerate(bot_clients):
            # 如果指定了 user_id，只停止该用户的机器人
            # client.user_id 是我们在 DiscordBotClient 初始化时传入的
            if user_id is not None and getattr(client, 'user_id', None) != user_id:
                continue

            try:
                if client and not client.is_closed():
                    # 更新账号状态为offline
                    if hasattr(client, 'account_id') and client.account_id:
                        db.update_account_status(client.account_id, 'offline')
                        logger.info(f"账号 {client.account_id} 状态已更新为离线")

                    # 停止机器人
                    asyncio.run_coroutine_threadsafe(client.close(), loop)
                    logger.info(f"Discord机器人 {i} (用户 {getattr(client, 'user_id', 'unknown')}) 已停止信号发送")
            except Exception as e:
                logger.error(f"停止机器人 {i} 时出错: {e}")

            indices_to_remove.append(i)

        # 从列表中移除已停止的机器人和任务
        # 从后往前删，避免索引偏移
        for i in sorted(indices_to_remove, reverse=True):
            if i < len(bot_clients):
                bot_clients.pop(i)
            if i < len(bot_tasks):
                # 尝试取消任务
                task = bot_tasks[i]
                if task and not task.done():
                    task.cancel()
                bot_tasks.pop(i)

        if not bot_clients:
            bot_running = False
            logger.info("所有机器人已停止")
        else:
            logger.info(f"剩余 {len(bot_clients)} 个机器人仍在运行")

    except Exception as e:
        logger.error(f"停止机器人流程出错: {e}")

# ===== 机器人控制API =====

@app.route('/api/bot/start', methods=['POST'])
def start_bot():
    """启动Discord机器人"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        data = request.get_json()
        user_id = data.get('userId')

        if not user_id:
            return jsonify({'error': '需要用户ID'}), 400

        # 检查用户是否有权限的账号
        user_accounts = db.get_discord_accounts_by_user(user_id)

        if not user_accounts:
            return jsonify({'error': '用户没有Discord账号，请先添加账号'}), 400

        # 启动机器人（启动所有账号，不管是否在线）
        start_discord_bot(user_id)

        logger.info(f"用户 {user_id} 启动机器人成功，共有 {len(user_accounts)} 个账号")
        return jsonify({
            'message': '账号启动成功',
            'totalAccounts': len(user_accounts)
        })

    except Exception as e:
        logger.error(f"启动机器人失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/bot/stop', methods=['POST'])
def stop_bot():
    """停止Discord机器人"""
    if not require_login():
        return jsonify({'error': '需要登录'}), 401

    try:
        current_user = get_current_user()

        # 如果是管理员，且请求中包含 targetUserId，则停止指定用户的
        # 否则停止当前用户的
        # 这里简化逻辑：用户只能停止自己的
        user_id = current_user['id']

        stop_discord_bot(user_id)

        logger.info(f"用户 {user_id} 的机器人已停止")
        return jsonify({'message': '机器人停止成功'})

    except Exception as e:
        logger.error(f"停止机器人失败: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/bot/status', methods=['GET'])
def get_bot_status():
    """获取Discord机器人全局运行状态"""
    try:
        # 通过检查数据库中是否有账号状态为online来确定机器人是否在运行
        # 这样可以避免依赖内存中的全局变量，在多进程环境下更可靠
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM discord_accounts WHERE status = 'online'")
            online_count = cursor.fetchone()[0]
            is_running = online_count > 0
        return jsonify({'running': is_running})
    except Exception as e:
        logger.error(f"获取机器人状态失败: {e}")
        return jsonify({'running': False}), 500

@app.route('/api/shop-info', methods=['GET'])
def get_shop_info():
    """获取店铺信息"""
    try:
        shop_id = request.args.get('shopId')
        if not shop_id:
            return jsonify({'error': '缺少shopId参数'}), 400

        shop_id = shop_id.strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        logger.info(f'获取店铺信息: {shop_id}')

        # 调用微店API获取店铺信息
        try:
            param = json.dumps({"shop_id": shop_id, "page_id": 0})
            encoded_param = quote(param)

            api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

            response = requests.get(api_url, headers={
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'Origin': 'https://weidian.com',
                'Referer': 'https://weidian.com/',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-site',
            }, cookies={
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }, timeout=10)

            if response.status_code == 200:
                data = response.json()
                if data.get('status', {}).get('code') == 0:
                    shop_name = data.get('result', {}).get('shareTitle', f'店铺 {shop_id}')
                    return jsonify({'shopName': shop_name})
                else:
                    logger.warning(f'API返回错误状态: {data}')
            else:
                logger.warning(f'API请求失败: {response.status_code}')

        except Exception as e:
            logger.error(f'获取店铺信息失败: {e}')

        # 如果API失败，返回默认名称
        return jsonify({'shopName': f'店铺 {shop_id}'})

    except Exception as e:
        logger.error(f'获取店铺信息出错: {e}')
        return jsonify({'error': '获取店铺信息失败'}), 500

# ===== 店铺管理API =====

@app.route('/api/shops', methods=['GET'])
def get_shops():
    """获取店铺列表（根据用户权限过滤）"""
    try:
        # 获取所有店铺
        all_shops = db.get_all_shops()

        current_user = get_current_user()
        if not current_user:
            # 如果未登录，返回空
            return jsonify({'shops': []})

        # 如果是管理员，返回所有
        if current_user['role'] == 'admin':
            return jsonify({'shops': all_shops})

        # 如果是普通用户，只筛选出他有权限的店铺
        user_permitted_shop_ids = current_user.get('shops', [])
        filtered_shops = [s for s in all_shops if s['shop_id'] in user_permitted_shop_ids]

        return jsonify({'shops': filtered_shops})
    except Exception as e:
        logger.error(f'获取店铺列表失败: {e}')
        return jsonify({'error': '获取店铺列表失败'}), 500

@app.route('/api/shops', methods=['POST'])
def add_shop():
    """添加新店铺"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId') or not data.get('name'):
            return jsonify({'error': '缺少shopId或name参数'}), 400

        shop_id = data['shopId'].strip()
        name = data['name'].strip()

        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        # 获取真实的店铺名称
        shop_info = get_shop_info_from_api(shop_id)
        if shop_info and shop_info.get('shopName'):
            name = shop_info['shopName']

        if db.add_shop(shop_id, name):
            return jsonify({'success': True, 'message': '店铺添加成功'})
        else:
            return jsonify({'error': '店铺已存在或添加失败'}), 400
    except Exception as e:
        logger.error(f'添加店铺失败: {e}')
        return jsonify({'error': '添加店铺失败'}), 500

@app.route('/api/shops/<shop_id>', methods=['DELETE'])
def delete_shop(shop_id):
    """删除店铺"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        # 获取店铺信息，检查用户是否有权限删除
        shop_info = db.get_shop_by_id(shop_id)
        if not shop_info:
            return jsonify({'error': '店铺不存在'}), 404

        current_user = get_current_user()
        # 管理员可以删除任何店铺，普通用户只能删除分配给他们的店铺
        if current_user['role'] != 'admin' and shop_info['shop_id'] not in current_user.get('shops', []):
            return jsonify({'error': '无权限删除此店铺'}), 403

        if db.delete_shop(shop_id):
            return jsonify({'success': True, 'message': '店铺删除成功'})
        else:
            return jsonify({'error': '删除失败'}), 500
    except Exception as e:
        logger.error(f'删除店铺失败: {e}')
        return jsonify({'error': '删除店铺失败'}), 500

def get_shop_info_from_api(shop_id):
    """从API获取店铺信息"""
    try:
        import json
        from urllib.parse import quote
        import time

        param = json.dumps({"shop_id": shop_id, "page_id": 0})
        encoded_param = quote(param)

        api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

        response = requests.get(api_url, headers={
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'Origin': 'https://weidian.com',
            'Referer': 'https://weidian.com/',
            'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'Sec-Ch-Ua-Mobile': '?0',
            'Sec-Ch-Ua-Platform': '"macOS"',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site',
        }, cookies={
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '2',
            '__spider__sessionid': 'c7da7d6e06b1f1ac'
        }, timeout=10, proxies={'http': None, 'https': None})

        if response.status_code == 200:
            data = response.json()
            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                shop_name = result.get('shareTitle', '')
                if shop_name:
                    return {'shopName': shop_name}

    except Exception as e:
        logger.warning(f'获取店铺信息失败: {e}')

    return None

@app.route('/api/scrape/shop', methods=['POST'])
def scrape_shop():
    """抓取整个店铺的所有商品"""
    if not can_manage_shops():
        return jsonify({'error': '需要管理店铺的权限'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId'):
            return jsonify({'error': '缺少shopId参数'}), 400

        shop_id = data['shopId'].strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopId必须是数字'}), 400

        # 检查是否已有抓取任务在运行
        current_status = db.get_scrape_status()
        if current_status.get('is_scraping', False):
            return jsonify({'error': '已有抓取任务在运行中，请等待完成后再试'}), 409

        logger.info(f'开始抓取店铺: {shop_id}')

        # 在后台线程中运行抓取任务，避免阻塞其他操作
        import threading

        def run_scrape_task():
            """后台抓取任务"""
            try:
                scrape_shop_products(shop_id)
            except Exception as e:
                logger.error(f'抓取任务异常: {e}')
            finally:
                # 确保状态正确重置
                error_msg = f'抓取异常结束: {str(e)}' if 'e' in locals() else '抓取已完成'
                db.update_scrape_status(is_scraping=False, message=error_msg)

        # 创建守护线程，确保不会阻塞应用退出
        scrape_thread = threading.Thread(target=run_scrape_task, daemon=True, name=f'scrape-{shop_id}')
        scrape_thread.start()

        logger.info(f'已启动后台抓取线程处理店铺 {shop_id}')

        return jsonify({
            'success': True,
            'message': '抓取任务已启动，请查看进度'
        })

    except Exception as e:
        logger.error(f'店铺抓取失败: {e}')
        return jsonify({'error': str(e)        }), 500


@app.route('/api/scrape/shop/control', methods=['POST'])
def control_shop_scrape():
    """控制抓取任务: start, stop"""
    action = request.json.get('action')
    shop_id = request.json.get('shopId')  # 可选参数

    global current_scrape_thread, scrape_thread_lock, scrape_stop_event

    # 获取当前状态
    current_status = db.get_scrape_status()
    logger.info(f"收到抓取控制请求: action={action}, shop_id={shop_id}, 当前状态: is_scraping={current_status.get('is_scraping')}, stop_signal={current_status.get('stop_signal')}")

    if action == 'stop':
        # 立即停止 - 设置停止事件和数据库状态
        scrape_stop_event.set()  # 设置停止事件，通知线程停止

        success = db.update_scrape_status(
            is_scraping=False,
            stop_signal=True,
            completed=True,
            message='抓取已停止',
            progress=100
        )

        if success:
            logger.info("✅ 抓取任务已强制停止")

            # 等待线程终止（最多等待10秒）
            with scrape_thread_lock:
                if current_scrape_thread and current_scrape_thread.is_alive():
                    logger.info("等待抓取线程终止...")
                    current_scrape_thread.join(timeout=10.0)
                    if current_scrape_thread.is_alive():
                        logger.warning("抓取线程未能在10秒内终止")
                    current_scrape_thread = None

            updated_status = db.get_scrape_status()
            return jsonify(updated_status)
        else:
            return jsonify({'error': '停止抓取失败'}), 500

    if action == 'start':
        if current_status.get('is_scraping', False):
            return jsonify({'error': '已有任务在运行'}), 400

        # 检查是否有线程在运行
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                return jsonify({'error': '已有线程在运行'}), 400

        # 清除停止事件，为新任务做准备
        scrape_stop_event.clear()

        # 重置状态
        success = db.update_scrape_status(
            is_scraping=True,
            stop_signal=False,
            current_shop_id=shop_id,
            total=0,
            processed=0,
            success=0,
            progress=0,
            message='初始化抓取...',
            completed=False,
            thread_id=None
        )

        if not success:
            return jsonify({'error': '重置状态失败'}), 500

        # 异步启动
        with scrape_thread_lock:
            current_scrape_thread = threading.Thread(
                target=run_shop_scrape_task,
                args=(shop_id,),
                daemon=True,
                name=f'scrape-{shop_id}'
            )
            current_scrape_thread.start()

            # 更新线程ID到数据库
            db.update_scrape_status(thread_id=current_scrape_thread.ident)

        updated_status = db.get_scrape_status()
        return jsonify(updated_status)

    return jsonify({'error': 'Invalid action'}), 400

@app.route('/api/scrape/batch', methods=['POST'])
def batch_scrape_products():
    """批量抓取多个商品（高性能多线程版本）"""
    # 在函数开始就导入所有需要的模块，避免变量作用域问题
    import concurrent.futures
    import time
    import threading

    # 确保threading变量在函数作用域内可用
    threading = threading

    try:
        data = request.get_json()
        if not data or not data.get('productIds'):
            return jsonify({'error': '缺少productIds参数'}), 400

        product_ids = data.get('productIds', [])
        if not isinstance(product_ids, list) or len(product_ids) == 0:
            return jsonify({'error': 'productIds必须是非空数组'}), 400

        # ====================================================
        # 修复：确保SCRAPE_THREADS从config正确获取
        # ====================================================
        max_threads = getattr(config, 'SCRAPE_THREADS', 10)

        # 创建停止事件用于优雅关闭
        shutdown_event = threading.Event()

        logger.info(f"✅ 开始批量抓取 {len(product_ids)} 个商品，使用 {max_threads} 个线程")

        results = {
            'total': len(product_ids),
            'processed': 0,
            'success': 0,
            'skipped': 0,
            'cancelled': 0,
            'partial': 0,
            'errors': 0,
            'start_time': time.time()
        }

        def process_single_product_batch(product_id):
            """处理单个商品（用于线程池）"""
            try:
                # === 检查停止信号 ===
                current_status = db.get_scrape_status()
                if current_status.get('stop_signal', False):
                    logger.info(f"🔴 处理商品前检测到停止信号，取消处理商品 {product_id}")
                    return {'status': 'cancelled', 'product_id': product_id, 'message': '任务已取消'}

                # 调用现有的单个商品处理逻辑
                from app import process_single_product

                # 构建商品信息
                product_info = {
                    'item_id': str(product_id),
                    'item_url': f'https://weidian.com/item.html?itemID={product_id}',
                    'shop_name': '批量上传'
                }

                # 处理商品
                product_data = process_single_product(product_info)

                if product_data:
                    # === 再次检查停止信号 ===
                    current_status = db.get_scrape_status()
                    if current_status.get('stop_signal', False):
                        logger.info(f"🔴 获取商品数据后检测到停止信号，跳过商品 {product_id}")
                        return {'status': 'cancelled', 'product_id': product_id, 'message': '任务已取消'}

                    # 检查是否已存在
                    if db.get_product_by_url(product_data['product_url']):
                        return {'status': 'skipped', 'product_id': product_id, 'message': '商品已存在'}

                    # 入库
                    product_id_db = db.insert_product(product_data)

                    # === 再次检查停止信号 ===
                    current_status = db.get_scrape_status()
                    if current_status.get('stop_signal', False):
                        logger.info(f"🔴 入库后检测到停止信号，商品 {product_id} 已入库但跳过图片处理")
                        return {'status': 'partial', 'product_id': product_id, 'message': '商品已入库，图片处理被取消'}

                    # 处理图片（使用优化后的多线程图片处理）
                    if product_data.get('images'):
                        save_product_images_unified(product_id_db, product_data['images'], shutdown_event=shutdown_event)

                    return {'status': 'success', 'product_id': product_id, 'message': '处理成功'}
                else:
                    return {'status': 'error', 'product_id': product_id, 'message': '获取商品数据失败'}

            except Exception as e:
                logger.error(f"处理商品 {product_id} 失败: {e}")
                return {'status': 'error', 'product_id': product_id, 'message': str(e)}

        # 使用线程池并发处理商品
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            # 提交所有任务
            future_to_product = {
                executor.submit(process_single_product_batch, pid): pid
                for pid in product_ids
            }

            # 收集结果 - 支持优雅停止
            pending_futures = set(future_to_product.keys())
            stop_detected = False

            try:
                while pending_futures:
                    # 检查是否有停止信号或关闭事件
                    current_status = db.get_scrape_status()
                    should_stop = (current_status.get('stop_signal', False) or
                                 (shutdown_event and shutdown_event.is_set()))

                    if should_stop and not stop_detected:
                        logger.info("🔴 检测到停止信号，正在等待已提交的任务完成...")
                        db.update_scrape_status(message='正在等待当前商品完成...')
                        stop_detected = True
                        # 不关闭线程池，让已提交的任务继续完成

                    # 等待任意一个任务完成
                    done, pending_futures = concurrent.futures.wait(
                        pending_futures,
                        timeout=1.0,
                        return_when=concurrent.futures.FIRST_COMPLETED
                    )

                    # 处理已完成的任务
                    for future in done:
                        product_id = future_to_product[future]
                        try:
                            result = future.result()
                            results['processed'] += 1

                            if result['status'] == 'success':
                                results['success'] += 1
                                logger.info(f"商品 {product_id} 处理成功")
                            elif result['status'] == 'skipped':
                                results['skipped'] += 1
                                logger.info(f"商品 {product_id} 已存在，跳过")
                            elif result['status'] == 'cancelled':
                                results['cancelled'] += 1
                                logger.info(f"商品 {product_id} 处理被取消")
                            elif result['status'] == 'partial':
                                results['partial'] += 1
                                logger.info(f"商品 {product_id} 部分完成（已入库，图片处理被取消）")
                            else:
                                results['errors'] += 1
                                logger.error(f"商品 {product_id} 处理失败: {result.get('message', '未知错误')}")

                        except Exception as e:
                            results['processed'] += 1
                            results['errors'] += 1
                            logger.error(f"处理商品 {product_id} 时发生异常: {e}")

                    # 如果检测到停止信号且没有待处理的任务，退出循环
                    if stop_detected and len(pending_futures) == 0:
                        logger.info("✅ 所有已提交的任务已完成，退出批量处理")
                        break

            except KeyboardInterrupt:
                logger.warning("收到键盘中断，正在优雅关闭...")
                executor.shutdown(wait=True, timeout=10.0)
                raise
            finally:
                # 确保线程池被正确关闭
                if not executor._shutdown:
                    executor.shutdown(wait=False)

        # 计算处理时间
        results['end_time'] = time.time()
        results['duration'] = results['end_time'] - results['start_time']

        logger.info(f"批量处理完成: {results}")

        # 注意：批量抓取不应该重置店铺抓取的状态
        # 批量抓取有自己的状态管理，不影响店铺抓取的状态显示

        return jsonify({
            'message': f'批量处理完成，共处理 {results["total"]} 个商品，成功 {results["success"]} 个，跳过 {results["skipped"]} 个，取消 {results["cancelled"]} 个，部分完成 {results["partial"]} 个，失败 {results["errors"]} 个',
            'results': results
        })

    except Exception as e:
        logger.error(f"批量抓取失败: {e}")
        logger.error(f"错误发生在: {e.__class__.__name__}")
        import traceback
        logger.error(f"完整堆栈:\n{traceback.format_exc()}")
        return jsonify({'error': f'批量抓取失败: {str(e)}'}), 500

@app.route('/api/scrape/shop/status', methods=['GET'])
def get_scrape_status():
    """获取抓取状态"""
    try:
        status = db.get_scrape_status()

        # 确保返回必要的字段（兼容前端期望的字段名）
        result = {
            'is_scraping': status.get('is_scraping', False),
            'progress': status.get('progress', 0),
            'total': status.get('total', 0),
            'current': status.get('processed', 0),  # 前端期望current字段
            'processed': status.get('processed', 0),
            'success': status.get('success', 0),
            'message': status.get('message', ''),
            'completed': status.get('completed', False),
            'current_shop_id': status.get('current_shop_id'),
            'thread_id': status.get('thread_id')
        }

        # 调试日志
        logger.debug(f"DEBUG: Scrape status - is_scraping: {result.get('is_scraping')}, message: {result.get('message')}")

        return jsonify(result)
    except Exception as e:
        logger.error(f'获取抓取状态失败: {e}')
        return jsonify({
            'is_scraping': False,
            'progress': 0,
            'total': 0,
            'current': 0,
            'processed': 0,
            'success': 0,
            'message': '获取状态失败',
            'completed': False,
            'current_shop_id': None,
            'thread_id': None
        })

@app.route('/api/products/count', methods=['GET'])
def get_products_count():
    """获取商品总数"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM products")
            count = cursor.fetchone()[0]
            return jsonify({'count': count})
    except Exception as e:
        logger.error(f"获取商品数量失败: {e}")
        return jsonify({'count': 0}), 500

@app.route('/api/debug/user_permissions', methods=['GET'])
def debug_user_permissions():
    """调试用户权限和商品分配（管理员权限）"""
    if not require_admin():
        return jsonify({'error': '需要管理员权限'}), 403

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # 获取所有用户
            cursor.execute('SELECT id, username, role FROM users')
            users = []
            for row in cursor.fetchall():
                user_dict = dict(row)
                user_dict['shops'] = db.get_user_shops(user_dict['id'])
                users.append(user_dict)

            # 获取所有店铺
            cursor.execute('SELECT id, name FROM shops')
            shops = [dict(row) for row in cursor.fetchall()]

            # 获取商品统计
            cursor.execute('SELECT shop_name, COUNT(*) as count FROM products GROUP BY shop_name')
            product_stats = [dict(row) for row in cursor.fetchall()]

            # 获取用户店铺权限统计
            cursor.execute('SELECT user_id, COUNT(*) as shop_count FROM user_shop_permissions GROUP BY user_id')
            permission_stats = []
            for row in cursor.fetchall():
                user_id, shop_count = row
                user = next((u for u in users if u['id'] == user_id), None)
                if user:
                    permission_stats.append({
                        'username': user['username'],
                        'shop_count': shop_count,
                        'shops': user['shops']
                    })

            return jsonify({
                'users': users,
                'shops': shops,
                'product_stats': product_stats,
                'permission_stats': permission_stats
            })
    except Exception as e:
        logger.error(f"调试用户权限失败: {e}")
        return jsonify({'error': str(e)}), 500

def run_shop_scrape_task(shop_id):
    """后台任务包装器 - 调用真正的抓取逻辑"""
    try:
        logger.info(f"🧵 后台抓取线程启动: {shop_id}")
        scrape_shop_products(shop_id)
    except Exception as e:
        logger.error(f"❌ 后台抓取线程崩溃: {e}")
        db.update_scrape_status(message=f"系统错误: {str(e)}")
    finally:
        # 确保状态正确重置
        final_status = db.get_scrape_status()
        db.update_scrape_status(
            is_scraping=False,
            completed=True
        )
        if not final_status.get('stop_signal', False):
            db.update_scrape_status(message='任务结束')
        logger.info("🧵 后台抓取线程结束")

def get_all_category_ids(shop_id, session):
    """
    获取店铺所有分类ID (包括子分类)
    API: decorate/itemCate.getCateTree
    """
    try:
        import time
        from urllib.parse import quote

        url = "https://thor.weidian.com/decorate/itemCate.getCateTree/1.0"
        param = json.dumps({
            "shopId": str(shop_id),
            "attrQuery": [],
            "from": "h5"
        })
        full_url = f"{url}?param={quote(param)}&wdtoken=8ea9315c&_={int(time.time()*1000)}"

        logger.info(f"正在获取店铺分类树: {shop_id}")
        response = session.get(full_url, timeout=10)
        data = response.json()

        cate_ids = []

        if data.get('status', {}).get('code') == 0:
            cate_list = data.get('result', {}).get('cateList', [])

            def extract_ids(nodes):
                for node in nodes:
                    cid = node.get('cateId')
                    cname = node.get('cateName')
                    count = node.get('speCateItemNum', 0)

                    if cid:
                        cate_ids.append({'id': cid, 'name': cname, 'count': count})

                    children = node.get('childCateList', [])
                    if children:
                        extract_ids(children)

            extract_ids(cate_list)
            logger.info(f"✅ 成功获取 {len(cate_ids)} 个分类: {[c['name'] for c in cate_ids]}")
        else:
            logger.warning(f"获取分类树失败: {data}")

        return cate_ids

    except Exception as e:
        logger.error(f"获取分类树异常: {e}")
        return []

def fetch_category_items(shop_id, cate_id, cate_name, session, limit=20):
    """
    生成器：抓取指定分类下的所有商品
    API: decorate/itemCate.getCateItemList
    """
    import time
    from urllib.parse import quote

    offset = 0

    while True:
        try:
            url = "https://thor.weidian.com/decorate/itemCate.getCateItemList/1.0"
            param = json.dumps({
                "cateId": str(cate_id),
                "shopId": str(shop_id),
                "offset": offset,
                "limit": limit,
                "sortField": "all",
                "sortType": "desc",
                "isQdFx": False,
                "isHideSold": False,
                "hideItemRealAmount": False,
                "from": "h5"
            })
            full_url = f"{url}?param={quote(param)}&wdtoken=8ea9315c&_={int(time.time()*1000)}"

            response = session.get(full_url, timeout=10)
            data = response.json()

            if data.get('status', {}).get('code') != 0:
                logger.warning(f"分类[{cate_name}] Offset {offset} API错误: {data.get('status')}")
                break

            result = data.get('result', {})
            items = result.get('itemList', [])

            if not items:
                break

            for item in items:
                yield item

            if len(items) < limit:
                break

            offset += limit
            time.sleep(0.3)

        except Exception as e:
            logger.error(f"抓取分类[{cate_name}]异常: {e}")
            break

def scrape_shop_products(shop_id):
    """抓取店铺所有商品的实现 (分类树方案 - 突破2000条限制)"""
    import requests
    import time
    from weidian_scraper import get_weidian_scraper
    import concurrent.futures

    # 获取配置的线程数
    try:
        from config import config
        max_threads = config.SCRAPE_THREADS
    except:
        max_threads = 2

    # 导入全局停止事件
    global scrape_stop_event

    scraper = get_weidian_scraper()
    unique_product_tasks = {}  # 使用字典去重：item_id -> product_info

    # 初始化状态
    db.update_scrape_status(
        is_scraping=True,
        paused=False,
        stop_signal=False,
        progress=0,
        total=0,
        processed=0,
        success=0,
        message='正在初始化...'
    )

    # 获取店铺名称
    shop_info = get_shop_info_from_api(shop_id)
    shop_name = shop_info.get('shopName', f'店铺 {shop_id}') if shop_info else f'店铺 {shop_id}'

    db.update_scrape_status(message=f'正在抓取店铺: {shop_name}')
    logger.info(f"开始收集商品列表，店铺: {shop_name}")

    # 【性能优化】一次性获取所有已存在的商品ID，避免逐个查询数据库
    logger.info("正在加载已存在的商品ID...")
    existing_item_ids = db.get_all_existing_item_ids()
    logger.info(f"已加载 {len(existing_item_ids)} 个已存在的商品ID，将快速跳过")

    # =========================================================================
    # 阶段 1: 通过分类树抓取所有商品 (多线程优化版)
    # =========================================================================
    logger.info("=== 阶段 1: 通过分类树并发抓取商品 ===")

    db.update_scrape_status(message='正在获取店铺分类树...')

    if not (scrape_stop_event.is_set() or db.get_scrape_status().get('stop_signal', False)):
        try:
            # 1. 获取所有分类 ID
            categories = get_all_category_ids(shop_id, scraper.session)

            if not categories:
                logger.warning("未获取到任何分类，尝试使用Tab 0备用方案...")
                db.update_scrape_status(message='未找到分类，使用备用方案...')
            else:
                logger.info(f"获取到 {len(categories)} 个分类，准备并发扫描...")

                # 定义单个分类的处理函数
                def process_category(cate):
                    if scrape_stop_event.is_set() or db.get_scrape_status().get('stop_signal', False):
                        return 0

                    cate_id = cate['id']
                    cate_name = cate['name']
                    # 跳过空分类
                    if cate['count'] == 0:
                        return 0

                    local_new_count = 0
                    # 注意：fetch_category_items 内部会有分页请求，这里是 IO 密集型
                    for item in fetch_category_items(shop_id, cate_id, cate_name, scraper.session):
                        item_id = str(item.get('itemId', ''))

                        # 检查停止信号
                        if scrape_stop_event.is_set():
                            break

                        if item_id:
                            # 字典操作的线程安全性：Python字典的key唯一性天然去重
                            if item_id not in unique_product_tasks:
                                # 检查数据库去重
                                if item_id in existing_item_ids:
                                    continue

                                unique_product_tasks[item_id] = {
                                    'item_id': item_id,
                                    'item_url': item.get('itemUrl', f"https://weidian.com/item.html?itemID={item_id}"),
                                    'shop_name': shop_name
                                }
                                local_new_count += 1
                    return local_new_count

                # 使用线程池并发扫描分类
                # 分类扫描主要是网络请求，可以开较高的并发
                cate_workers = min(10, len(categories))
                with concurrent.futures.ThreadPoolExecutor(max_workers=cate_workers) as cate_executor:
                    # 提交任务
                    future_to_cate = {cate_executor.submit(process_category, cate): cate for cate in categories}

                    completed_cates = 0
                    for future in concurrent.futures.as_completed(future_to_cate):
                        cate = future_to_cate[future]
                        try:
                            count = future.result()
                            completed_cates += 1
                            logger.info(f"[{completed_cates}/{len(categories)}] 分类 '{cate['name']}' 扫描完成，新增 {count} 个商品")
                            # 实时更新前端显示的总数
                            db.update_scrape_status(total=len(unique_product_tasks), message=f"正在并发扫描分类 ({completed_cates}/{len(categories)})...")
                        except Exception as e:
                            logger.error(f"扫描分类 '{cate['name']}' 失败: {e}")

        except Exception as e:
            logger.error(f"分类遍历过程异常: {e}")

    logger.info(f"✅ 分类树抓取完成，共收集 {len(unique_product_tasks)} 个商品")

    # =========================================================================
    # 阶段 2: 并发处理
    # =========================================================================

    # 转回列表用于处理
    all_product_tasks = list(unique_product_tasks.values())
    total_products = len(all_product_tasks)
    logger.info(f"✅ 商品收集阶段结束，去重后最终待处理: {total_products} 个商品")

    # 更新状态：开始处理
    db.update_scrape_status(
        total=total_products,
        progress=0, # 重置进度条为0，开始第二阶段
        message=f'收集完成，准备并发处理 {total_products} 个商品...'
    )

    # 第二阶段：使用全局线程池并发处理所有商品
    processed_count = 0
    success_count = 0

    if all_product_tasks:
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            # 提交所有商品任务到线程池
            future_to_product = {
                executor.submit(process_and_save_single_product_sync, product_info): product_info
                for product_info in all_product_tasks
            }

            # 处理完成的任务
            for future in concurrent.futures.as_completed(future_to_product):
                # 检查停止事件或停止信号
                if scrape_stop_event.is_set() or db.get_scrape_status().get('stop_signal', False):
                    logger.info("🔴 检测到停止事件/信号，正在取消剩余任务...")
                    # 取消所有待处理的任务
                    for f in future_to_product:
                        if not f.done():
                            f.cancel()
                    break

                try:
                    product_info = future_to_product[future]
                    success = future.result()
                    processed_count += 1

                    if success:
                        success_count += 1

                    # 改为每5个更新一次，反馈更及时
                    if processed_count % 5 == 0 or processed_count == total_products:
                        # 计算进度 (避免除以0)
                        progress = int((processed_count / total_products) * 100) if total_products > 0 else 100
                        db.update_scrape_status(
                            processed=processed_count,
                            success=success_count,
                            progress=progress,
                            message=f'正在抓取详情与图片... ({processed_count}/{total_products})'
                        )
                        logger.info(f'已处理 {processed_count}/{total_products} 个商品，成功 {success_count} 个')

                except Exception as e:
                    logger.error(f"商品处理异常: {e}")
                    processed_count += 1

    # 结束
    db.update_scrape_status(
        is_scraping=False,
        completed=True,
        progress=100,
        message=f'抓取完成，共处理 {processed_count} 个商品，成功 {success_count} 个'
    )
    logger.info(f"✅ 店铺 {shop_id} 抓取任务完成: {success_count}/{processed_count} 商品成功处理")

    return {
        "total_products": processed_count,
        "success_count": success_count
    }

def process_and_save_single_product_sync(product_info):
    """同步处理单个商品，避免重复处理"""
    try:
        item_id = product_info.get('item_id', '')

        # === 检查停止事件或停止信号 ===
        global scrape_stop_event
        if scrape_stop_event.is_set():
            logger.info(f"🔴 处理商品前检测到停止事件，取消处理商品 {item_id}")
            return False

        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"🔴 处理商品前检测到停止信号，取消处理商品 {item_id}")
            return False

        # === 0. 基于item_id的强力去重 ===
        if db.get_product_by_item_id(item_id):
            logger.info(f"⏭️ 商品 {item_id} 已存在，跳过重复处理")
            return True  # 已存在算处理成功

        # 1. 抓取详情
        from app import process_single_product  # 引用 app.py 中的逻辑
        product_data = process_single_product(product_info)

        if not product_data:
            return False

        # === 再次检查停止状态 ===
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"🔴 抓取详情后检测到停止信号，取消处理商品 {item_id}")
            return False

        # 2. 再次查重 (双重保险)
        if db.get_product_by_url(product_data['product_url']):
            logger.info(f"⏭️ 商品URL已存在: {product_data['product_url']}")
            return True  # 已存在算处理成功

        # 3. 入库 (添加item_id字段)
        product_data['item_id'] = item_id  # 确保item_id被保存
        product_id = db.insert_product(product_data)

        logger.info(f"✅ 商品 {item_id} 成功入库，数据库ID: {product_id}")

        # === 再次检查停止状态 ===
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"🔴 入库后检测到停止信号，商品 {item_id} 已入库但跳过图片处理")
            return True  # 商品已入库，算成功

        # 4. 图片处理 (使用多线程版本)
        if product_data.get('images'):
            from app import save_product_images_unified
            processed_count = save_product_images_unified(product_id, product_data['images'])
            logger.info(f"🖼️ 商品 {item_id} 图片处理完成，共处理 {processed_count} 张图片")

        return True
    except Exception as e:
        logger.error(f"❌ 处理商品出错 {product_info.get('item_id')}: {e}")
        return False

def scrape_product_info(product_url):
    """根据商品URL获取商品详细信息"""
    try:
        from weidian_scraper import get_weidian_scraper

        scraper = get_weidian_scraper()
        product_info = scraper.scrape_product_info(product_url)

        if product_info:
            # 重新格式化返回数据
            return {
                'title': product_info.get('title', ''),
                'description': product_info.get('description', ''),
                # 修复：移除 [:5] 限制，返回所有抓取到的图片
                'images': product_info.get('images', []),
                'shop_name': product_info.get('shop_name', '')
            }

        return None

    except Exception as e:
        logger.error(f'获取商品详细信息失败: {e}')
        return None

def generate_acbuy_url(weidian_url):
    """生成AcBuy链接"""
    if not weidian_url:
        return ''

    try:
        import re
        item_id_match = re.search(r'itemID=(\d+)', weidian_url)
        if item_id_match:
            item_id = item_id_match.group(1)
            # 构建acbuy链接
            encoded_url = weidian_url.replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
            return f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'
    except Exception as e:
        logger.error(f'生成AcBuy链接失败: {e}')

    return ''

def generate_cnfans_url(item_id):
    """生成CNFans链接"""
    if not item_id:
        return ''
    return f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN"

def generate_english_title(chinese_title):
    """将中文标题翻译为英文标题"""
    if not chinese_title:
        return ''

    try:
        import re
        import requests

        # 首先尝试提取已有的英文部分
        english_parts = re.findall(r'[a-zA-Z\s]+', chinese_title)
        if english_parts and len(' '.join(english_parts).strip()) > 5:
            # 如果英文部分足够长，直接返回
            return ' '.join(english_parts).strip()

        # 品牌名称映射（扩展版）
        brand_mappings = {
            'Nike': 'Nike', '阿迪': 'Adidas', 'Adidas': 'Adidas', '李宁': 'LiNing',
            '安踏': 'Anta', '匹克': 'Peak', '乔丹': 'Jordan', 'New Balance': 'New Balance',
            'Converse': 'Converse', 'Vans': 'Vans', 'Supreme': 'Supreme', 'BAPE': 'BAPE',
            'Palace': 'Palace', 'Stone Island': 'Stone Island', 'Off-White': 'Off-White',
            'Balenciaga': 'Balenciaga', 'Gucci': 'Gucci', 'Louis Vuitton': 'Louis Vuitton',
            'Chanel': 'Chanel', 'Dior': 'Dior', 'Yeezy': 'Yeezy', 'Puma': 'Puma',
            'Reebok': 'Reebok', 'Under Armour': 'Under Armour', 'Fila': 'Fila',
            'The North Face': 'The North Face', 'Columbia': 'Columbia', 'Patagonia': 'Patagonia',
            'Arc\'teryx': 'Arc\'teryx', 'Canada Goose': 'Canada Goose', 'Moncler': 'Moncler',
            'Burberry': 'Burberry', 'Prada': 'Prada', 'Versace': 'Versace', 'Fendi': 'Fendi',
            'Hermes': 'Hermes', 'Rolex': 'Rolex', 'Cartier': 'Cartier', 'Omega': 'Omega',
            'IWC': 'IWC', 'Jaeger-LeCoultre': 'Jaeger-LeCoultre', 'Patek Philippe': 'Patek Philippe'
        }

        # 应用品牌映射
        title = chinese_title
        for zh, en in brand_mappings.items():
            title = title.replace(zh, en)

        # 检查是否还有中文字符
        has_chinese = any('\u4e00' <= char <= '\u9fff' for char in title)

        if has_chinese:
            # 使用百度翻译API或其他免费翻译服务
            try:
                # 这里使用一个简单的翻译API示例
                # 实际部署时需要替换为稳定的翻译服务
                api_url = "https://api.mymemory.translated.net/get"
                params = {
                    'q': chinese_title,
                    'langpair': 'zh-CN|en-US',
                    'de': 'your-email@example.com'  # MyMemory要求提供邮箱
                }

                response = requests.get(api_url, params=params, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code == 200:
                    data = response.json()
                    translated = data.get('responseData', {}).get('translatedText', '')
                    if translated and translated != chinese_title:
                        # 清理翻译结果
                        translated = re.sub(r'[^\w\s\-]', '', translated)
                        return translated.strip()

            except Exception as e:
                logger.warning(f'在线翻译失败: {e}')

            # 如果翻译失败，返回提取的英文部分或原标题
            english_parts = re.findall(r'[a-zA-Z\s\-]+', title)
            if english_parts:
                result = ' '.join(english_parts).strip()
                if len(result) > 3:
                    return result

        # 如果没有中文或翻译失败，返回处理后的标题
        return re.sub(r'[^\w\s\-]', '', title).strip()

    except Exception as e:
        logger.error(f'生成英文标题失败: {e}')
        return chinese_title

def process_single_product(product_info):
    """处理单个商品的详情抓取"""
    try:
        item_id = product_info['item_id']
        item_url = product_info['item_url']
        shop_name = product_info['shop_name']

        # 检查停止事件
        global scrape_stop_event
        if scrape_stop_event.is_set():
            logger.info(f"🔴 处理商品 {item_id} 时检测到停止事件，中止处理")
            return None

        # 获取商品详细信息
        product_details = scrape_product_info(item_url)

        if product_details:
            # 生成英文标题
            english_title = generate_english_title(product_details.get('title', ''))

            # 优先使用从商品详情中获取的店铺名称，如果没有则使用传入的
            actual_shop_name = product_details.get('shop_name', '') or shop_name

            return {
                'product_url': item_url,
                'title': product_details.get('title', ''),
                'description': product_details.get('description', ''),
                'english_title': english_title,
                'cnfans_url': generate_cnfans_url(item_id),
                'acbuy_url': generate_acbuy_url(item_url),
                'shop_name': actual_shop_name,
                'images': product_details.get('images', []),
                'ruleEnabled': True
            }
        return None

    except Exception as e:
        logger.error(f'处理商品失败: {e}')
        return None

def process_products_multithreaded(products_list):
    """多线程处理商品详情抓取"""
    import concurrent.futures

    processed_products = []

    # 获取配置的线程数
    max_workers = config.DOWNLOAD_THREADS

    logger.info(f'开始多线程处理 {len(products_list)} 个商品，使用 {max_workers} 个线程')

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        # 提交所有任务
        future_to_product = {
            executor.submit(process_single_product, product): product
            for product in products_list
        }

        # 收集结果
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                if result:
                    processed_products.append(result)
            except Exception as e:
                logger.error(f'商品处理任务失败: {e}')

    logger.info(f'多线程处理完成，共处理 {len(processed_products)} 个商品')
    return processed_products

def process_page_multithreaded(products_list, page_num):
    """
    多线程处理整个页面：获取详情 + 插入数据库 + 下载图片
    每个线程负责一个商品的完整处理流程
    """
    import concurrent.futures

    processed_count = 0

    # 获取配置的线程数
    max_workers = config.DOWNLOAD_THREADS

    logger.info(f'第 {page_num} 页开始多线程处理 {len(products_list)} 个商品')

    def process_and_save_product(product):
        """处理单个商品的完整流程：获取详情 -> 插入数据库 -> 下载图片"""
        try:
            # 1. 获取商品详情
            product_data = process_single_product(product)
            if not product_data:
                logger.warning(f'商品详情获取失败: {product}')
                return 0

            # 2. 检查商品是否已存在
            existing = db.get_product_by_url(product_data['product_url'])
            if existing:
                logger.info(f'商品已存在，跳过: {product_data["title"]} (URL: {product_data["product_url"]})')
                return 0

            # 3. 插入商品到数据库
            product_id = db.insert_product(product_data)
            logger.info(f'✅ 成功插入新商品: {product_data["title"]} (ID: {product_id})')

            # 4. 下载并保存图片
            if product_data.get('images'):
                save_product_images(product_id, product_data['images'])
                logger.info(f'📸 商品图片下载完成: {product_data["title"]} ({len(product_data["images"])}张)')

            return 1  # 成功处理一个商品

        except Exception as e:
            logger.error(f'处理商品失败: {e}')
            return 0

    # 降低并发数避免内存爆炸，YOLO模型现在是单例模式
    max_workers_page = min(2, len(products_list))  # 最多2个并发
    logger.info(f"页面处理使用 {max_workers_page} 个线程")

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers_page) as executor:
        # 提交所有任务，每个商品一个任务
        future_to_product = {
            executor.submit(process_and_save_product, product): product
            for product in products_list
        }

        # 收集结果
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                processed_count += result
            except Exception as e:
                logger.error(f'页面处理任务失败: {e}')

    logger.info(f'第 {page_num} 页处理完成，成功新增 {processed_count} 个商品')
    return processed_count

def save_product_images(product_id, image_urls):
    """
    统一的图片保存入口（向后兼容的别名）
    实际调用 save_product_images_unified
    """
    return save_product_images_unified(product_id, image_urls)

def save_product_images_unified(product_id, image_urls, max_workers=None, shutdown_event=None):
    """
    【性能优化版】统一的批量图片处理函数

    策略：多线程并发下载 -> 有限并发 AI 特征提取 -> 批量数据库/FAISS 写入
    解决 CPU 争抢和 GIL 锁导致的假死/卡顿问题。

    - 下载阶段：IO 密集，允许高并发
    - AI 阶段：CPU 密集，使用有限并发（并发数建议与 config.AI_MAX_WORKERS 对齐）
    - FAISS：一个商品只写入/保存一次，减少锁竞争
    """
    if not image_urls:
        return 0

    import os
    import time
    import requests
    import concurrent.futures
    import threading

    # 1. 准备目录
    save_dir = os.path.join(config.IMAGE_SAVE_DIR, str(product_id))
    os.makedirs(save_dir, exist_ok=True)

    # 动态决定下载线程数 (IO密集型，可以多开)
    download_workers = min(getattr(config, 'DOWNLOAD_THREADS', 8), len(image_urls))

    downloaded_images = []  # (index, save_path)

    logger.info(f"🚀 [商品 {product_id}] 阶段1: 开始并发下载 {len(image_urls)} 张图片...")

    def download_task(index, url):
        try:
            if shutdown_event and shutdown_event.is_set():
                return None

            timestamp = int(time.time() * 1000000)
            filename = f"{product_id}_{index}_{timestamp}.jpg"
            save_path = os.path.join(save_dir, filename)

            resp = requests.get(url, timeout=config.REQUEST_TIMEOUT, proxies={'http': None, 'https': None})
            if resp.status_code != 200:
                return None

            with open(save_path, 'wb') as f:
                f.write(resp.content)

            if os.path.getsize(save_path) == 0:
                try:
                    os.remove(save_path)
                except Exception:
                    pass
                return None

            return (index, save_path)

        except Exception as e:
            logger.warning(f"下载失败 {url}: {e}")
            return None

    with concurrent.futures.ThreadPoolExecutor(max_workers=download_workers) as executor:
        futures = [executor.submit(download_task, i, url) for i, url in enumerate(image_urls)]
        for future in concurrent.futures.as_completed(futures):
            res = future.result()
            if res:
                downloaded_images.append(res)

    if not downloaded_images:
        logger.warning(f"⚠️ [商品 {product_id}] 没有成功下载任何图片")
        return 0

    downloaded_images.sort(key=lambda x: x[0])
    logger.info(f"✅ [商品 {product_id}] 下载完成，准备处理 {len(downloaded_images)} 张图片")

    # --- 阶段 2: 有限并发 AI 特征提取 (CPU 密集) ---
    extractor = get_global_feature_extractor()
    if extractor is None:
        logger.error("特征提取器未初始化")
        return 0

    existing_images = db.get_product_images(product_id)
    existing_feats = [img['features'] for img in existing_images if img.get('features') is not None]

    processed_count = 0
    vectors_to_add = []  # (db_id, features)

    # AI 并发数优先级：显式参数 > config.AI_MAX_WORKERS > 默认 3
    ai_max_workers = getattr(config, 'AI_MAX_WORKERS', 3)
    if max_workers is not None:
        try:
            ai_max_workers = max(1, int(max_workers))
        except Exception:
            ai_max_workers = getattr(config, 'AI_MAX_WORKERS', 3)

    # 保护：不要超过待处理数量
    ai_max_workers = min(ai_max_workers, len(downloaded_images)) if downloaded_images else 1

    results_lock = threading.Lock()

    logger.info(f"🧠 [商品 {product_id}] 阶段2: 启动 {ai_max_workers} 个 AI 线程进行特征提取...")

    def process_image_task(args):
        index, save_path = args

        if shutdown_event and shutdown_event.is_set():
            return None

        try:
            features = extractor.extract_feature(save_path)
            if features is None:
                try:
                    os.remove(save_path)
                except Exception:
                    pass
                return None

            # 查重：必须加锁同步读写 existing_feats
            with results_lock:
                is_dup, score = check_duplicate_image(features, existing_feats, threshold=0.995)
                if not is_dup:
                    existing_feats.append(features)

            if is_dup:
                logger.info(f"♻️ [商品 {product_id}] 图片重复 (相似度 {score:.3f})，跳过")
                try:
                    os.remove(save_path)
                except Exception:
                    pass
                return None

            img_db_id = db.insert_image_record(product_id, save_path, index, features)
            if img_db_id:
                logger.info(f"📸 [商品 {product_id}] 图片 {index} 处理完毕 (ID: {img_db_id})")
                return (img_db_id, features)

            return None

        except Exception as e:
            logger.error(f"处理图片异常: {e}")
            return None

    with concurrent.futures.ThreadPoolExecutor(max_workers=ai_max_workers) as ai_executor:
        future_to_img = {ai_executor.submit(process_image_task, item): item for item in downloaded_images}

        for future in concurrent.futures.as_completed(future_to_img):
            result = future.result()
            if result:
                db_id, feats = result
                vectors_to_add.append((db_id, feats))
                processed_count += 1

    # --- 阶段 3: 批量写入 FAISS (内存/磁盘操作) ---
    if vectors_to_add:
        try:
            from vector_engine import get_vector_engine
            engine = get_vector_engine()

            with faiss_lock:
                for img_id, feats in vectors_to_add:
                    engine.add_vector(img_id, feats)
                engine.save()

            logger.info(f"💾 [商品 {product_id}] FAISS 索引已更新，新增 {len(vectors_to_add)} 个向量")

        except Exception as e:
            logger.error(f"FAISS 批量写入失败: {e}")

    logger.info(f"商品 {product_id} 成功处理 {processed_count}/{len(image_urls)} 张图片")
    return processed_count

def save_product_images_multithreaded(product_id, image_urls):
    """向后兼容的别名"""
    return save_product_images_unified(product_id, image_urls)

def run_cleanup_task():
    """后台清理任务，定期清理数据库和内存中的过期记录"""
    while True:
        try:
            # 每小时执行一次
            time.sleep(3600)
            logger.info("⚙️ 开始执行后台清理任务...")

            # 1. 清理已处理的消息ID表
            db.cleanup_processed_messages()
            logger.info("✅ 已清理过期的消息ID记录")

            # 2. 清理内存中的冷却记录
            try:
                from bot import cleanup_expired_cooldowns
                cleanup_expired_cooldowns()
                logger.info("✅ 已清理内存中过期的冷却状态")
            except ImportError:
                logger.warning("无法导入bot模块进行冷却清理，跳过")

        except Exception as e:
            logger.error(f"后台清理任务异常: {e}")

if __name__ == '__main__':
    # 【Windows兼容性修复】必须在最开始调用
    multiprocessing.freeze_support()

    import atexit
    import signal
    import time

    # 【核心修复】只在主进程执行初始化
    initialize_runtime()

    # 全局变量用于控制优雅关闭
    import threading
    shutdown_event = threading.Event()

    def signal_handler(signum, frame):
        """处理中断信号，优雅关闭"""
        print(f"\n🛑 Received signal {signum}, initiating graceful shutdown...")
        shutdown_event.set()

        # 设置抓取状态为停止
        current_status = db.get_scrape_status()
        if current_status.get('is_scraping', False):
            db.update_scrape_status(
                stop_signal=True,
                message='系统正在关闭，已停止抓取任务'
            )
            print("⏹️  已停止所有抓取任务")

        # 等待抓取线程结束（最多等待10秒）
        global current_scrape_thread, scrape_thread_lock
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                print("⏳ 等待抓取线程结束...")
                current_scrape_thread.join(timeout=10.0)
                if current_scrape_thread.is_alive():
                    print("⚠️ 抓取线程未能在10秒内结束")
                else:
                    print("✅ 抓取线程已结束")

        # 立即停止Discord机器人
        stop_discord_bot()

        # 短暂等待让其他线程有机会清理
        time.sleep(0.2)
        print("💥 Force exiting...")
        import os
        os._exit(0)

    # 注册信号处理器
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # 注册退出时停止机器人的函数
    atexit.register(stop_discord_bot)

    # 启动 Flask 服务
    print("🚀 服务启动中...")
    try:
        # 关闭 debug 模式，避免 Flask 重载器导致双重初始化
        # 【关键修改】添加 use_reloader=False 禁用Flask重载器，避免双重进程
        app.run(host='0.0.0.0', port=5001, debug=False, threaded=True, use_reloader=False)
    except KeyboardInterrupt:
        print("\n🛑 Received KeyboardInterrupt, shutting down...")
        signal_handler(signal.SIGINT, None)
    except Exception as e:
        print(f"\n💥 Unexpected error: {e}")
        signal_handler(signal.SIGINT, None)
    finally:
        print("👋 Flask API shutdown complete")

