--- File: ./validate_fixes.py ---
#!/usr/bin/env python3
"""
ç³»ç»Ÿä¿®å¤éªŒè¯è„šæœ¬
æµ‹è¯•æ‰€æœ‰å…³é”®ä¿®å¤æ˜¯å¦ç”Ÿæ•ˆ
"""

import os
import sys
import time

def test_config():
    """æµ‹è¯•é…ç½®ç³»ç»Ÿ"""
    print("ğŸ”§ 1. æµ‹è¯•é…ç½®ç³»ç»Ÿ...")
    try:
        sys.path.insert(0, 'backend')
        from config import config
        
        checks = [
            ('SECRET_KEY', hasattr(config, 'SECRET_KEY') and config.SECRET_KEY),
            ('HOST', config.HOST == '0.0.0.0'),
            ('PORT', config.PORT == 5001),
            ('DEBUG', config.DEBUG == False),
            ('SCRAPE_THREADS', config.SCRAPE_THREADS == 2),
            ('CORS_ORIGINS', config.CORS_ORIGINS == ["*"]),
        ]
        
        for name, passed in checks:
            status = "âœ…" if passed else "âŒ"
            print(f"  {status} {name}: {'é€šè¿‡' if passed else 'å¤±è´¥'}")
        
        return all(passed for _, passed in checks)
    except Exception as e:
        print(f"  âŒ é…ç½®æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_database_reset():
    """æµ‹è¯•æ•°æ®åº“çŠ¶æ€é‡ç½®"""
    print("\nğŸ’¾ 2. æµ‹è¯•æ•°æ®åº“çŠ¶æ€é‡ç½®...")
    try:
        from backend.database import db
        
        # è®¾ç½®ä¸ºè¿è¡ŒçŠ¶æ€
        db.update_scrape_status(is_scraping=True, message='æµ‹è¯•')
        status1 = db.get_scrape_status()
        
        # é‡ç½®çŠ¶æ€
        db.update_scrape_status(is_scraping=False, stop_signal=False, message='é‡ç½®æµ‹è¯•')
        status2 = db.get_scrape_status()
        
        reset_worked = not status2.get('is_scraping', True)
        
        print(f"  âœ… è®¾ç½®è¿è¡ŒçŠ¶æ€: {status1.get('is_scraping', False)}")
        print(f"  âœ… é‡ç½®åçŠ¶æ€: {status2.get('is_scraping', True)}")
        print(f"  âœ… é‡ç½®åŠŸèƒ½: {'æ­£å¸¸' if reset_worked else 'å¼‚å¸¸'}")
        
        return reset_worked
    except Exception as e:
        print(f"  âŒ æ•°æ®åº“æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_singleton_pattern():
    """æµ‹è¯•å•ä¾‹æ¨¡å¼"""
    print("\nğŸ”„ 3. æµ‹è¯•å•ä¾‹æ¨¡å¼...")
    try:
        import threading
        
        class TestSingleton:
            _instance = None
            _lock = threading.Lock()
            _init_count = 0
            
            @classmethod
            def get_instance(cls):
                if cls._instance is not None:
                    return cls._instance
                    
                with cls._lock:
                    if cls._instance is None:
                        time.sleep(0.01)  # æ¨¡æ‹Ÿåˆå§‹åŒ–è€—æ—¶
                        cls._instance = object()
                        cls._init_count += 1
                return cls._instance
        
        def worker():
            return TestSingleton.get_instance()
        
        # å¯åŠ¨10ä¸ªçº¿ç¨‹
        threads = []
        for i in range(10):
            t = threading.Thread(target=worker)
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        
        singleton_worked = TestSingleton._init_count == 1
        print(f"  âœ… åˆå§‹åŒ–æ¬¡æ•°: {TestSingleton._init_count} (åº”ä¸º1)")
        print(f"  âœ… å•ä¾‹æ¨¡å¼: {'æ­£å¸¸' if singleton_worked else 'å¼‚å¸¸'}")
        
        return singleton_worked
    except Exception as e:
        print(f"  âŒ å•ä¾‹æµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸ¯ ç³»ç»Ÿä¿®å¤éªŒè¯")
    print("=" * 50)
    
    tests = [
        ("é…ç½®ç³»ç»Ÿ", test_config),
        ("æ•°æ®åº“é‡ç½®", test_database_reset), 
        ("å•ä¾‹æ¨¡å¼", test_singleton_pattern),
    ]
    
    results = []
    for name, test_func in tests:
        try:
            result = test_func()
            results.append(result)
        except Exception as e:
            print(f"âŒ {name} æµ‹è¯•å¼‚å¸¸: {e}")
            results.append(False)
    
    print("\n" + "=" * 50)
    print("ğŸ“Š æµ‹è¯•ç»“æœ:")
    
    all_passed = all(results)
    for i, (name, _) in enumerate(tests):
        status = "âœ… é€šè¿‡" if results[i] else "âŒ å¤±è´¥"
        print(f"  {status} - {name}")
    
    print(f"\nğŸ‰ æ€»ä½“ç»“æœ: {'æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ç³»ç»Ÿä¿®å¤æˆåŠŸ' if all_passed else 'éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦æ£€æŸ¥'}")
    
    if all_passed:
        print("\nğŸš€ ç°åœ¨å¯ä»¥å®‰å…¨å¯åŠ¨ç³»ç»Ÿ:")
        print("  cd backend && python app.py")
        print("  # å‰ç«¯: npm run dev")
    
    return 0 if all_passed else 1

if __name__ == '__main__':
    sys.exit(main())

--- File: ./frontend/app/layout.tsx ---
import type React from "react"
import type { Metadata } from "next"
import { Geist, Geist_Mono } from "next/font/google"
import { Analytics } from "@vercel/analytics/next"
import "./globals.css"

const _geist = Geist({ subsets: ["latin"] })
const _geistMono = Geist_Mono({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Discord è‡ªåŠ¨è¥é”€ç®¡ç†ç³»ç»Ÿ",
  description: "æ™ºèƒ½ Discord è´¦å·è¥é”€ç®¡ç†å¹³å°ï¼Œé›†æˆå¾®åº—æŠ“å–ã€å›¾åƒè¯†åˆ«ã€CNFans é“¾æ¥ç”Ÿæˆ",
  generator: "v0.app",
  icons: {
    icon: [
      {
        url: "/icon-light-32x32.png",
        media: "(prefers-color-scheme: light)",
      },
      {
        url: "/icon-dark-32x32.png",
        media: "(prefers-color-scheme: dark)",
      },
      {
        url: "/icon.svg",
        type: "image/svg+xml",
      },
    ],
    apple: "/apple-icon.png",
  },
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="zh-CN">
      <body className={`font-sans antialiased`}>
        {children}
        <Analytics />
      </body>
    </html>
  )
}

--- File: ./frontend/app/api/products/count/route.ts ---
import { NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/products/count`)

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Failed to fetch count' }))
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/products/count failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/route.ts ---
// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001'

export async function GET(request: Request) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'GET',
      headers: {
        'Cookie': request.headers.get('cookie') || ''
      }
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to fetch products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error fetching products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function PUT(request: Request) {
  try {
    const contentType = request.headers.get('content-type') || ''

    let response;
    if (contentType.includes('multipart/form-data')) {
      // å¤„ç†FormDataè¯·æ±‚ï¼ˆåŒ…å«æ–‡ä»¶ä¸Šä¼ ï¼‰
      const formData = await request.formData()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Cookie': request.headers.get('cookie') || ''
        },
        body: formData
      })
    } else {
      // å¤„ç†JSONè¯·æ±‚
      const body = await request.json()

      response = await fetch(`${BACKEND_URL}/api/products`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': request.headers.get('cookie') || ''
        },
        body: JSON.stringify(body)
      })
    }

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to update product' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error updating product:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

export async function DELETE(request: Request) {
  try {
    const url = new URL(request.url)
    const ids = url.searchParams.get('ids')

    if (!ids) {
      return new Response(JSON.stringify({ error: 'Missing ids parameter' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const response = await fetch(`${BACKEND_URL}/api/products/batch`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': request.headers.get('cookie') || ''
      },
      body: JSON.stringify({ ids: ids.split(',').map(id => parseInt(id)) })
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ error: 'Failed to delete products' }), {
        status: response.status,
        headers: { 'Content-Type': 'application/json' }
      })
    }

    const data = await response.json()
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    console.error('Error deleting products:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

--- File: ./frontend/app/api/products/[id]/images/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { id, imageIndex } = resolvedParams
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id]/images/[imageIndex] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/images/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params
    const id = resolvedParams.id
    const formData = await request.formData()
    const cookieHeader = request.headers.get('cookie') || '';

    // FormDataä¸Šä¼ æ—¶ï¼Œä¸è¦è®¾ç½®Content-Typeï¼Œè®©æµè§ˆå™¨è‡ªåŠ¨å¤„ç†multipart/form-data
    // åªä¼ é€’Cookieå¤´
    const response = await fetch(`${BACKEND_URL}/api/products/${id}/images`, {
      method: 'POST',
      body: formData,
      headers: cookieHeader ? {
        'Cookie': cookieHeader
      } : undefined
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/products/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/products/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/custom-replies failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/custom-replies/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/custom-replies/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/custom-replies/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/config/discord-threshold/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/discord-threshold`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/discord-threshold failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/global-reply-delay/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/config/global-reply-delay`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/config/global-reply-delay failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/config/discord-channel/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to fetch discord channel config' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    const response = await fetch(`${BACKEND_URL}/api/config/discord-channel`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Discord channel config API error:', error)
    return NextResponse.json({ error: 'Failed to update discord channel config' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/auth/logout/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function POST(request: NextRequest) {
  try {
    // è·å–å‰ç«¯çš„session cookieå¹¶ä¼ é€’ç»™åç«¯
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // è°ƒç”¨åç«¯ç™»å‡ºAPI
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/logout`, {
      method: 'POST',
      headers: headers
    });

    // æ¸…é™¤å‰ç«¯session cookie
    const response = NextResponse.json({ message: 'å·²ç™»å‡º' });
    response.cookies.set('user_session', '', {
      maxAge: 0
    });

    return response;
  } catch (error: any) {
    console.error('Logout API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/me/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function GET(request: NextRequest) {
  try {
    // è·å–æµè§ˆå™¨ä¼ æ¥çš„æ‰€æœ‰ Cookie
    const cookies = request.headers.get('cookie') || '';

    // è°ƒç”¨åç«¯éªŒè¯ Session æœ‰æ•ˆæ€§
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/me`, {
      headers: {
        'Cookie': cookies // å…³é”®ï¼šè½¬å‘ Cookie ç»™åç«¯
      }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // å¦‚æœåç«¯éªŒè¯å¤±è´¥ (401)ï¼Œå‰ç«¯ä¹Ÿè¦æ¸…é™¤ user_session
      const errorData = await backendResponse.json().catch(() => ({ error: 'Not authenticated' }));
      const response = NextResponse.json(errorData, { status: backendResponse.status });

      if (backendResponse.status === 401) {
      response.cookies.set('user_session', '', { maxAge: 0 });
      }
      return response;
    }
  } catch (error: any) {
    console.error('Auth me API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/auth/login/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // è°ƒç”¨åç«¯ç™»å½•API
    const backendResponse = await fetch(`${BACKEND_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      const response = NextResponse.json(data);

      // --- å…³é”®ä¿®å¤å¼€å§‹ ---
      // 1. è·å–åç«¯è¿”å›çš„åŸå§‹ Set-Cookie å­—ç¬¦ä¸²
      // Flask é€šå¸¸è¿”å›ç±»ä¼¼: "session=eyJ...; HttpOnly; Path=/; SameSite=Lax"
      const setCookieHeader = backendResponse.headers.get('set-cookie');

      if (setCookieHeader) {
        // ç®€å•è§£æ Cookie åç§°å’Œå€¼
        // æ³¨æ„ï¼šå¦‚æœåç«¯è¿”å›å¤šä¸ª Cookieï¼Œè¿™é‡Œå¯èƒ½éœ€è¦æ›´å¤æ‚çš„è§£æï¼Œä½† Flask é»˜è®¤é€šå¸¸åªè¿”å› session
        const firstPart = setCookieHeader.split(';')[0]; // è·å– "name=value"
        const [name, ...valueParts] = firstPart.split('=');
        const value = valueParts.join('='); // é˜²æ­¢å€¼ä¸­åŒ…å« =

        if (name && value) {
          // ä½¿ç”¨ Next.js API è®¾ç½® Cookieï¼Œé¿å…ä¸ header æ“ä½œå†²çª
          response.cookies.set({
            name: name.trim(),
            value: value.trim(),
            httpOnly: true, // ä¿æŒ HttpOnly å¢å¼ºå®‰å…¨æ€§
            path: '/',
            sameSite: 'lax',
            secure: false, // ã€å…³é”®ä¿®æ”¹ã€‘å¼ºåˆ¶ä¸º falseï¼Œå…è®¸HTTPè®¿é—®
            maxAge: 60 * 60 * 24 * 30 // 30å¤©ä¸è¿‡æœŸ
          });
        }
      }
      // --- å…³é”®ä¿®å¤ç»“æŸ ---

      // 2. è®¾ç½®å‰ç«¯ä¸“ç”¨çš„ user_session (ç”¨äºUIå±•ç¤º)
      response.cookies.set('user_session', JSON.stringify({
        user: data.user,
        timestamp: Date.now()
      }), {
        httpOnly: false, // å…è®¸å‰ç«¯ JS è¯»å–
        secure: false, // ã€å…³é”®ä¿®æ”¹ã€‘å¼ºåˆ¶ä¸º falseï¼Œå…è®¸HTTPè®¿é—®
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 * 30 // 30å¤©ä¸è¿‡æœŸ
      });

      return response;
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Login API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/message-filters/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/message-filters failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/message-filters/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/message-filters/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/message-filters/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/test-similarity/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/api/test_similarity`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend test_similarity error:', errorText);
      return NextResponse.json({ error: errorText }, { status: response.status });
    }

    const result = await response.json();
    return NextResponse.json(result);
  } catch (error: any) {
    console.error('POST /api/test-similarity failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const limit = url.searchParams.get('limit') || '50';

    const response = await fetch(`${BACKEND_URL}/api/search_history?limit=${limit}`);
    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('GET /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const response = await fetch(`${BACKEND_URL}/api/search_history`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/search_history/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const historyId = resolvedParams.id;

    const response = await fetch(`${BACKEND_URL}/api/search_history/${historyId}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const errorData = await response.json();
      return NextResponse.json(errorData, { status: response.status });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('DELETE /api/search_history/[id] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/announcements/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    // ä¿®å¤ï¼šæ‰‹åŠ¨è·å–å¹¶è½¬å‘ Cookie
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      headers: {
        'Cookie': cookieHeader
      }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/announcements failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/announcements/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/announcements/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/announcements/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/user/settings/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
        headers: {
            'Cookie': cookies
        }
    });

    if (backendResponse.ok) {
      const data = await backendResponse.json();
      return NextResponse.json(data);
    } else {
      // æ•è·é”™è¯¯å¹¶è¿”å›çŠ¶æ€ç ï¼Œå‰ç«¯æ”¶åˆ° 401 å¯å¤„ç†è·³è½¬
      const errorData = await backendResponse.json().catch(() => ({ error: 'Failed to fetch settings' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('User settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';

    const backendResponse = await fetch(`${BACKEND_URL}/api/user/settings`, {
      method: 'PUT',
      headers: {
          'Content-Type': 'application/json',
          'Cookie': cookies
      },
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user settings API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/status/route.ts ---
import { NextResponse } from 'next/server';

// åç«¯ API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(request: Request) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';

    // è°ƒç”¨åç«¯ API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/status`, {
      method: 'GET',
      headers: {
        'Cookie': cookieHeader
      }
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/route.ts ---
import { NextResponse } from 'next/server';

// åç«¯ API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // è°ƒç”¨åç«¯ API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/shop/control/route.ts ---
import { NextResponse } from 'next/server';

// åç«¯ API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    // è°ƒç”¨åç«¯ API
    const backendResponse = await fetch(`${BACKEND_URL}/api/scrape/shop/control`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend error' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/scrape/route.ts ---
import { NextResponse } from 'next/server';

// åç«¯ API URL
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: Request) {
  try {
    const data = await request.json();
    const { url, weidianId } = data;
    const cookieHeader = request.headers.get('cookie') || '';

    // æ”¯æŒä¸¤ç§è¾“å…¥æ–¹å¼ï¼šå®Œæ•´URLæˆ–å•†å“ID
    if (!url && !weidianId) {
      return NextResponse.json({ error: 'URL or weidianId is required' }, { status: 400 });
    }

    // å¦‚æœæä¾›äº†weidianIdï¼Œæ„é€ URL
    const finalUrl = url || `https://weidian.com/item.html?itemID=${weidianId}`;

    // è°ƒç”¨åç«¯ API
    const backendResponse = await fetch(`${BACKEND_URL}/scrape`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify({ url: finalUrl })
    });

    // ä¿®å¤ï¼šå¤„ç† 409 Conflictï¼Œä¸è¦æŠ›å‡ºé€šç”¨é”™è¯¯ï¼Œè€Œæ˜¯ä¼ é€’ç»™å‰ç«¯å¤„ç†
    if (backendResponse.status === 409) {
        const errorData = await backendResponse.json();
        return NextResponse.json(errorData, { status: 409 });
    }

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({ error: 'Backend scrape failed' }));
      return NextResponse.json(errorData, { status: backendResponse.status });
    }

    const result = await backendResponse.json();
    return NextResponse.json(result);

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const type = url.searchParams.get('type');

    if (type === 'indexed') {
      // è·å–å·²å»ºç«‹å‘é‡ç´¢å¼•çš„å•†å“URLåˆ—è¡¨
      const response = await fetch(`${BACKEND_URL}/api/get_indexed_ids`);
      if (response.ok) {
        const data = await response.json();
        return NextResponse.json(data);
      }
      return NextResponse.json({ indexedIds: [] });
    }

    // è·å–å‰ç«¯çš„session cookieå¹¶ä¼ é€’ç»™åç«¯
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // è°ƒç”¨åç«¯ API è·å–å•†å“åˆ—è¡¨
    const response = await fetch(`${BACKEND_URL}/api/products`, { headers });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    } else if (response.status === 401) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    return NextResponse.json([]);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const { id } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });
    if (response.ok) {
      return NextResponse.json({ success: true });
    } else {
      const err = await response.json().catch(() => ({ error: 'Delete failed' }));
      return NextResponse.json(err, { status: response.status });
    }
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PUTæ–¹æ³•ç”¨äºæ›´æ–°å•†å“ä¿¡æ¯
export async function PUT(request: Request) {
  try {
    const body = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Update failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// PATCHæ–¹æ³•ç”¨äºåˆ é™¤å•ä¸ªå›¾ç‰‡
export async function PATCH(request: Request) {
  try {
    const { productId, imageIndex } = await request.json();
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/products/${productId}/images/${imageIndex}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    });

    if (response.ok) {
      const data = await response.json();
      return NextResponse.json(data);
    }
    return NextResponse.json({ error: 'Delete image failed' }, { status: response.status });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/image/[productId]/[imageIndex]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ productId: string; imageIndex: string }> }
) {
  try {
    const resolvedParams = await params
    const { productId, imageIndex } = resolvedParams;

    const response = await fetch(`${BACKEND_URL}/api/image/${productId}/${imageIndex}`);

    if (!response.ok) {
      return NextResponse.json({ error: 'Image not found' }, { status: response.status });
    }

    const imageBuffer = await response.arrayBuffer();
    const contentType = response.headers.get('content-type') || 'image/jpeg';

    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600',
      },
    });
  } catch (error: any) {
    console.error('GET /api/image/[productId]/[imageIndex] failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch shops' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shops/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/shops/${resolvedParams.id}`, {
      method: 'DELETE',
      headers: headers
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// è·å–åç«¯ URL
const getBackendUrl = () => {
  return process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const imageFile = formData.get('image') as File
    const threshold = parseFloat(formData.get('threshold') as string) || 0.1

    if (!imageFile) {
      return NextResponse.json({ error: 'No image provided' }, { status: 400 })
    }

    console.log('æ”¶åˆ°å›¾ç‰‡æœç´¢è¯·æ±‚ï¼Œæ–‡ä»¶å¤§å°:', imageFile.size, 'bytes')

    // åˆ›å»ºæ–°çš„ FormData ä¼ é€’ç»™åç«¯
    const backendFormData = new FormData()
    const buffer = Buffer.from(await imageFile.arrayBuffer())
    const blob = new Blob([buffer], { type: imageFile.type })
    backendFormData.append('image', blob, imageFile.name || 'search.jpg')

    const backendUrl = getBackendUrl()
    console.log('è°ƒç”¨åç«¯æœç´¢ API:', `${backendUrl}/search_similar`)

    // ç›´æ¥è°ƒç”¨åç«¯çš„å‘é‡æœç´¢ API (ä½¿ç”¨ Faiss)
    const response = await fetch(`${backendUrl}/search_similar`, {
      method: 'POST',
      body: backendFormData
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('åç«¯æœç´¢å¤±è´¥:', response.status, errorText)
      return NextResponse.json({
        error: `åç«¯æœç´¢å¤±è´¥: ${response.status}`,
        details: errorText
      }, { status: response.status })
    }

    const result = await response.json()
    console.log('åç«¯æœç´¢ç»“æœ:', result)

    if (result.success && result.product) {
      // åç«¯è¿”å›æˆåŠŸï¼Œæ ¼å¼åŒ–å“åº”
      return NextResponse.json({
        success: true,
        similarity: result.similarity,
        product: {
          id: result.product.id,
          title: result.product.title,
          englishTitle: result.product.englishTitle,
          weidianId: result.skuId,
          weidianUrl: result.skuId, // ç›´æ¥ä½¿ç”¨ product_url
          cnfansUrl: result.skuId, // ç®€åŒ–å¤„ç†
          ruleEnabled: result.product.ruleEnabled,
          matchKeywords: result.product.matchKeywords,
          matchType: result.product.matchType,
          images: [] // å¯ä»¥ä»æ•°æ®åº“åŠ è½½
        },
        skuId: result.skuId,
        imageIndex: result.imageIndex,
        matchedImage: `/scraped_images/${result.skuId}/${result.imageIndex}.jpg`,
        searchTime: new Date().toISOString()
      })
    } else {
      // æœªæ‰¾åˆ°åŒ¹é…
      return NextResponse.json({
        success: false,
        message: result.message || `æœªæ‰¾åˆ°ç›¸ä¼¼åº¦è¶…è¿‡ ${(threshold * 100).toFixed(0)}% çš„å•†å“`
      })
    }

  } catch (error: any) {
    console.error('æœç´¢é”™è¯¯:', error)
    return NextResponse.json({
      error: error.message,
      stack: error.stack
    }, { status: 500 })
  }
}

--- File: ./frontend/app/api/system/stats/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/system/stats`)
    if (!response.ok) {
      const errorData = await response.json()
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/system/stats failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/shop-info/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const shopId = searchParams.get('shopId')

    if (!shopId) {
      return NextResponse.json({ error: 'ç¼ºå°‘shopIdå‚æ•°' }, { status: 400 })
    }

    // ä»£ç†è¯·æ±‚åˆ°åç«¯ï¼Œä½¿ç”¨127.0.0.1é¿å…ä»£ç†é—®é¢˜
    const backendUrl = `http://localhost:5001/api/shop-info?shopId=${shopId}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      return NextResponse.json({ error: 'åç«¯è¯·æ±‚å¤±è´¥' }, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)

  } catch (error) {
    console.error('Shop info API error:', error)
    return NextResponse.json({ error: 'è·å–åº—é“ºä¿¡æ¯å¤±è´¥' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/stream/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const backendUrl = `${BACKEND_URL}/api/logs/stream`

    // åˆ›å»ºåˆ°åç«¯çš„SSEè¿æ¥
    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Cookie': cookieHeader
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    // åˆ›å»ºå¯è¯»æµ
    const stream = new ReadableStream({
      start(controller) {
        const reader = response.body?.getReader()
        let isControllerClosed = false

        function push() {
          // å¦‚æœcontrollerå·²å…³é—­ï¼Œç›´æ¥è¿”å›
          if (isControllerClosed) return

          reader?.read().then(({ done, value }) => {
            // å¦‚æœcontrollerå·²å…³é—­ï¼Œåœæ­¢å¤„ç†
            if (isControllerClosed) return

            if (done) {
              // æµç»“æŸï¼Œå…³é—­controller
              if (!isControllerClosed) {
                isControllerClosed = true
                try {
                  controller.close()
                } catch (closeError) {
                  console.warn('Controller close error (already closed):', closeError.message)
                }
              }
              return
            }

            // ç¡®ä¿controlleræ²¡æœ‰è¢«å…³é—­å†enqueue
            if (!isControllerClosed) {
              try {
                controller.enqueue(value)
                // åªæœ‰åœ¨æˆåŠŸenqueueåæ‰ç»§ç»­è¯»å–ä¸‹ä¸€å—æ•°æ®
                push()
              } catch (enqueueError) {
                // enqueueå¤±è´¥ï¼Œå¯èƒ½æ˜¯controllerå·²å…³é—­
                console.error('Stream enqueue error:', enqueueError)
                if (!isControllerClosed) {
                  isControllerClosed = true
                  try {
                    controller.close()
                  } catch (closeError) {
                    console.warn('Controller close error after enqueue failure:', closeError.message)
                  }
                }
              }
            }
          }).catch((error) => {
            console.error('Stream read error:', error)
            // å‘ç”Ÿè¯»å–é”™è¯¯æ—¶ä¹Ÿè¦å…³é—­controller
            if (!isControllerClosed) {
              isControllerClosed = true
              try {
                controller.close()
              } catch (closeError) {
                console.warn('Controller close error after read failure:', closeError.message)
              }
            }
          })
        }

        push()
      }
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control',
      },
    })
  } catch (error) {
    console.error('Logs stream API error:', error)
    return NextResponse.json({ error: 'Failed to connect to log stream' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/logs/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

// å¼ºåˆ¶ä½¿ç”¨å†…ç½‘å›ç¯åœ°å€ï¼Œé€Ÿåº¦æœ€å¿«ä¸”æœ€ç¨³å®š
const BACKEND_URL = 'http://127.0.0.1:5001'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const endpoint = searchParams.get('endpoint') || 'recent'

    const backendUrl = `${BACKEND_URL}/api/logs/${endpoint}`

    const response = await fetch(backendUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Backend API error: ${response.status}`)
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error) {
    console.error('Logs API error:', error)
    return NextResponse.json({ error: 'Failed to fetch logs' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, { headers })
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to fetch accounts' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      const error = await response.json()
      return NextResponse.json(error, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/rotation/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`)
    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ enabled: false, rotationInterval: 10 })
    }
  } catch (error) {
    return NextResponse.json({ enabled: false, rotationInterval: 10 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const response = await fetch(`${BACKEND_URL}/api/accounts/rotation`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update rotation config' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/user/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// åˆ†é…Discordè´¦å·ç»™ç”¨æˆ·
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const accountId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/accounts/${accountId}/user`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Assign account to user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/accounts/[id]/status/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const body = await request.json()
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}/status`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    })

    if (response.ok) {
      const data = await response.json()
      return NextResponse.json(data)
    } else {
      return NextResponse.json({ error: 'Failed to update status' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/accounts/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params;
    const response = await fetch(`${BACKEND_URL}/api/accounts/${resolvedParams.id}`, {
      method: 'DELETE'
    })

    if (response.ok) {
      return NextResponse.json({ success: true })
    } else {
      return NextResponse.json({ error: 'Failed to delete account' }, { status: response.status })
    }
  } catch (error) {
    return NextResponse.json({ error: 'Backend connection failed' }, { status: 500 })
  }
}

--- File: ./frontend/app/api/search_similar/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();

    const response = await fetch(`${BACKEND_URL}/search_similar`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend search_similar error:', errorText);
      return NextResponse.json({ error: 'Search failed' }, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('POST /api/search_similar failed:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰
export async function GET(request: NextRequest) {
  try {
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, { headers });
    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Users API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// åˆ›å»ºæ–°ç”¨æˆ·ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Create user API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/password/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function PUT(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const body = await request.json();

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}/password`, {

      method: 'PUT',

      headers: {

        'Content-Type': 'application/json',

        'Cookie': cookieHeader

      },

      body: JSON.stringify(body)

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    const data = await response.json();

    return NextResponse.json(data);

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/users/[id]/shops/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

// æ›´æ–°ç”¨æˆ·åº—é“ºæƒé™
export async function PUT(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const resolvedParams = await params;
    const userId = resolvedParams.id;
    const body = await request.json();
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    const backendResponse = await fetch(`${BACKEND_URL}/api/users/${userId}/shops`, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify(body)
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Update user shops API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/users/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function DELETE(

  request: NextRequest,

  { params }: { params: Promise<{ id: string }> }

) {

  try {

    const { id } = await params;

    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/users/${id}`, {

      method: 'DELETE',

      headers: { 'Cookie': cookieHeader }

    });

    if (!response.ok) {

      const errorData = await response.json().catch(() => ({}));

      return NextResponse.json(errorData, { status: response.status });

    }

    return NextResponse.json({ success: true });

  } catch (error: any) {

    return NextResponse.json({ error: error.message }, { status: 500 });

  }

}

--- File: ./frontend/app/api/bot/start/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId } = body;

    if (!userId) {
      return NextResponse.json({ error: 'éœ€è¦ç”¨æˆ·ID' }, { status: 400 });
    }

    // è·å–å‰ç«¯çš„session cookieå¹¶ä¼ é€’ç»™åç«¯
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // è°ƒç”¨åç«¯å¯åŠ¨æœºå™¨äººAPI
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/start`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify({ userId })
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Start bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/bot/stop/route.ts ---
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001';

export async function POST(request: NextRequest) {
  try {
    // è·å–å‰ç«¯çš„session cookieå¹¶ä¼ é€’ç»™åç«¯
    const cookies = request.headers.get('cookie') || '';
    const headers: Record<string, string> = {};
    if (cookies) {
      headers['Cookie'] = cookies;
    }

    // è°ƒç”¨åç«¯åœæ­¢æœºå™¨äººAPI
    const backendResponse = await fetch(`${BACKEND_URL}/api/bot/stop`, {
      method: 'POST',
      headers: headers
    });

    const data = await backendResponse.json();

    if (backendResponse.ok) {
      return NextResponse.json(data);
    } else {
      return NextResponse.json(data, { status: backendResponse.status });
    }
  } catch (error: any) {
    console.error('Stop bot API error:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

--- File: ./frontend/app/api/websites/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(request: NextRequest) {
  try {
    const cookieHeader = request.headers.get('cookie') || '';
    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      // 404 handling specifically
      if (response.status === 404) {
          return NextResponse.json({ websites: [] });
      }
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('PUT /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/[channelId]/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; channelId: string }> }
) {
  try {
    const { id, channelId } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels/${channelId}`, {
      method: 'DELETE',
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('DELETE /api/websites/[id]/channels/[channelId] failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/api/websites/[id]/channels/route.ts ---
import { NextRequest, NextResponse } from 'next/server'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5001'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      headers: { 'Cookie': cookieHeader }
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('GET /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const body = await request.json()
    const cookieHeader = request.headers.get('cookie') || '';

    const response = await fetch(`${BACKEND_URL}/api/websites/${id}/channels`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookieHeader
      },
      body: JSON.stringify(body)
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status })
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (error: any) {
    console.error('POST /api/websites/[id]/channels failed:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

--- File: ./frontend/app/page.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { DashboardView } from "@/components/dashboard-view"
import { AccountsView } from "@/components/accounts-view"
import { ScraperView } from "@/components/scraper-view"
import { ShopsView } from "@/components/shops-view"
import { ImageSearchView } from "@/components/image-search-view"
import { UsersView } from "@/components/users-view"
import { RulesView } from "@/components/rules-view"
import { LogsView } from "@/components/logs-view"
import { LoginView } from "@/components/login-view"
import { AppSidebar } from "@/components/app-sidebar"
import { SidebarProvider, SidebarInset, SidebarTrigger } from "@/components/ui/sidebar"
import { Separator } from "@/components/ui/separator"
import { Button } from "@/components/ui/button"
import { LogOut, User, Play, Square } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export default function Page() {
  const [currentView, setCurrentView] = useState("dashboard")
  const [currentUser, setCurrentUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [botStatus, setBotStatus] = useState<'stopped' | 'starting' | 'running' | 'stopping'>('stopped')

  // ä½¿ç”¨useRefé˜²æ­¢é‡å¤è¯·æ±‚
  const hasFetchedUser = useRef(false)

  useEffect(() => {
    // æ£€æŸ¥é”ï¼Œé˜²æ­¢é‡å¤è¯·æ±‚
    if (!hasFetchedUser.current) {
      hasFetchedUser.current = true // ç«‹å³ä¸Šé”
    checkLoginStatus()
    }
  }, [])

  const checkLoginStatus = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setCurrentUser(data.user)
        // ç§»é™¤é¢„åŠ è½½ï¼Œé¿å…é‡å¤APIè°ƒç”¨
      }
    } catch (error) {
      // æœªç™»å½•æˆ–ç½‘ç»œé”™è¯¯
    } finally {
      setLoading(false)
    }
  }

  // ç§»é™¤é¢„åŠ è½½é€»è¾‘ï¼Œé¿å…é‡å¤APIè°ƒç”¨
  // const preloadCommonData = async (user: User) => {
  //   console.log('é¢„åŠ è½½å·²ç¦ç”¨ï¼Œé¿å…é‡å¤APIè°ƒç”¨')
  // }

  const handleLogin = (user: User) => {
    setCurrentUser(user)
  }

  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      })
      setCurrentUser(null)
      setCurrentView("accounts")
      setBotStatus('stopped')
      toast.success("å·²ç™»å‡º")
    } catch (error) {
      toast.error("ç™»å‡ºå¤±è´¥")
    }
  }

  const handleStartBot = async () => {
    if (!currentUser) {
      toast.error("è¯·å…ˆç™»å½•")
      return
    }

    setBotStatus('starting')
    try {
      // è°ƒç”¨åç«¯å¯åŠ¨è´¦å·çš„API
      const response = await fetch('/api/bot/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ userId: currentUser.id })
      })

      if (response.ok) {
        setBotStatus('running')
        toast.success("Discordè´¦å·å·²å¯åŠ¨")
      } else {
        const error = await response.json()
        setBotStatus('stopped')
        toast.error(error.error || "å¯åŠ¨è´¦å·å¤±è´¥")
      }
    } catch (error) {
      setBotStatus('stopped')
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•å¯åŠ¨è´¦å·")
    }
  }

  const handleStopBot = async () => {
    setBotStatus('stopping')
    try {
      const response = await fetch('/api/bot/stop', {
        method: 'POST',
        credentials: 'include'
      })

      if (response.ok) {
        setBotStatus('stopped')
        toast.success("Discordè´¦å·å·²åœæ­¢")
      } else {
        setBotStatus('running')
        toast.error("åœæ­¢è´¦å·å¤±è´¥")
      }
    } catch (error) {
      setBotStatus('running')
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•åœæ­¢è´¦å·")
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    )
  }

  if (!currentUser) {
    return <LoginView onLogin={handleLogin} />
  }

  return (
    <SidebarProvider defaultOpen={true}>
      <AppSidebar
        currentView={currentView}
        setCurrentView={setCurrentView}
        currentUser={currentUser}
      />
      <SidebarInset>
        <header className="flex h-14 shrink-0 items-center gap-2 border-b px-4">
          <SidebarTrigger />
          <Separator orientation="vertical" className="h-6" />
          <h1 className="text-lg font-semibold">Discord è‡ªåŠ¨è¥é”€ç³»ç»Ÿ</h1>
          <div className="flex-1" />
          <div className="flex items-center gap-3">
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <User className="size-4" />
              <span>{currentUser.username}</span>
              {currentUser.role === 'admin' && (
                <span className="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">ç®¡ç†å‘˜</span>
              )}
            </div>

            {/* æœºå™¨äººæ§åˆ¶ */}
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1 text-xs text-muted-foreground">
                <div className={`w-2 h-2 rounded-full ${
                  botStatus === 'running' ? 'bg-green-500' :
                  botStatus === 'starting' ? 'bg-yellow-500 animate-pulse' :
                  botStatus === 'stopping' ? 'bg-orange-500 animate-pulse' :
                  'bg-gray-400'
                }`} />
                <span>
                  {botStatus === 'running' ? 'è¿è¡Œä¸­' :
                   botStatus === 'starting' ? 'å¯åŠ¨ä¸­' :
                   botStatus === 'stopping' ? 'åœæ­¢ä¸­' :
                   'å·²åœæ­¢'}
                </span>
              </div>

              {botStatus === 'running' ? (
                <Button variant="outline" size="sm" onClick={handleStopBot} disabled={botStatus !== 'running'}>
                  <Square className="size-4 mr-1" />
                  åœæ­¢è´¦å·
                </Button>
              ) : (
                <Button
                  variant="default"
                  size="sm"
                  onClick={handleStartBot}
                  disabled={botStatus === 'starting'}
                  className="bg-green-600 hover:bg-green-700"
                >
                  <Play className="size-4 mr-1" />
                  å¯åŠ¨è´¦å·
                </Button>
              )}
            </div>

            <Button variant="outline" size="sm" onClick={handleLogout}>
              <LogOut className="size-4 mr-1" />
              ç™»å‡º
            </Button>
          </div>
        </header>
        <main className="flex-1 overflow-auto p-6">
          {/*

            æ ¸å¿ƒä¿®æ”¹ï¼š

            ä¸å†ä½¿ç”¨æ¡ä»¶æ¸²æŸ“ (&&)ï¼Œè€Œæ˜¯å…¨éƒ¨æ¸²æŸ“ä½†é€šè¿‡ CSS æ§åˆ¶æ˜¾ç¤ºéšè—ã€‚

            è¿™æ ·åˆ‡æ¢ Tab æ—¶ç»„ä»¶ä¸ä¼šå¸è½½ï¼Œæ•°æ®å’Œæ»šåŠ¨ä½ç½®å¾—ä»¥ä¿ç•™ã€‚

          */}
          <div style={{ display: currentView === "dashboard" ? 'block' : 'none', height: '100%' }}>
            <DashboardView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "accounts" ? 'block' : 'none', height: '100%' }}>
            <AccountsView />
          </div>

          {(currentUser.role === 'admin' || (currentUser.shops && currentUser.shops.length > 0)) && (
            <div style={{ display: currentView === "shops" ? 'block' : 'none', height: '100%' }}>
              <ShopsView currentUser={currentUser} />
            </div>
          )}

          <div style={{ display: currentView === "scraper" ? 'block' : 'none', height: '100%' }}>
            {/* ScraperView å†…éƒ¨å»ºè®®å®ç°è½®è¯¢æœºåˆ¶æ¥è·å–æœ€æ–°æŠ“å–ç»“æœ */}
            <ScraperView currentUser={currentUser} />
          </div>

          <div style={{ display: currentView === "image-search" ? 'block' : 'none', height: '100%' }}>
            <ImageSearchView />
          </div>

          {currentUser.role === 'admin' && (
            <>
              <div style={{ display: currentView === "users" ? 'block' : 'none', height: '100%' }}>
                <UsersView />
              </div>
              <div style={{ display: currentView === "logs" ? 'block' : 'none', height: '100%' }}>
                <LogsView />
              </div>
            </>
          )}
        </main>
      </SidebarInset>
    </SidebarProvider>
  )
}

--- File: ./frontend/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- File: ./frontend/components/theme-provider.tsx ---
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

--- File: ./frontend/components/accounts-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Textarea } from "@/components/ui/textarea"
import { toast } from "sonner"
import { Plus, Settings, Save, Trash2, Globe, Link, Hash, X, Edit } from "lucide-react"

export function AccountsView() {
  const [accounts, setAccounts] = useState<any[]>([])
  const [users, setUsers] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [showAddDialog, setShowAddDialog] = useState(false)
  const [newAccount, setNewAccount] = useState({
    token: ""
  })
  const [settings, setSettings] = useState({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
  })
  const [settingsLoading, setSettingsLoading] = useState(false)

  // æ–°å¢ï¼šå½“å‰ç”¨æˆ·ä¿¡æ¯çŠ¶æ€
  const [currentUser, setCurrentUser] = useState<any>(null)
  const [deleteAccountConfirm, setDeleteAccountConfirm] = useState<any>(null)

  // ä½¿ç”¨APIç¼“å­˜hook
  const { cachedFetch } = useApiCache()

  // ç½‘ç«™é…ç½®ç›¸å…³çŠ¶æ€
  const [websites, setWebsites] = useState<any[]>([])
  const [showAddWebsite, setShowAddWebsite] = useState(false)
  const [editingWebsite, setEditingWebsite] = useState<any>(null)
  const [newWebsite, setNewWebsite] = useState({
    name: '',
    display_name: '',
    url_template: '',
    id_pattern: '',
    badge_color: 'blue'
  })
  const [websiteChannels, setWebsiteChannels] = useState<{[key: number]: string[]}>({})

  // æ¶ˆæ¯è¿‡æ»¤ç›¸å…³çŠ¶æ€
  const [messageFilters, setMessageFilters] = useState<any[]>([])
  const [showAddFilter, setShowAddFilter] = useState(false)
  const [editingFilter, setEditingFilter] = useState<any>(null)
  const [newFilter, setNewFilter] = useState({
    filter_type: 'contains',
    filter_value: ''
  })


  const fetchWebsites = async () => {
    try {
      const data = await cachedFetch('/api/websites', { credentials: 'include' })
      const websites = data.websites || []

      // åç«¯å·²åŒ…å«channelsä¿¡æ¯ï¼Œæ— éœ€é¢å¤–è¯·æ±‚
        const channels: {[key: number]: string[]} = {}
      websites.forEach((website: any) => {
        channels[website.id] = website.channels || []
      })

      setWebsites(websites)
        setWebsiteChannels(channels)
    } catch (e) {
      console.error('è·å–ç½‘ç«™é…ç½®å¤±è´¥:', e)
    }
  }

  const fetchMessageFilters = async () => {
    try {
      const res = await fetch('/api/message-filters', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setMessageFilters(data.filters || [])
      }
    } catch (e) {
      console.error('è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥:', e)
    }
  }


  useEffect(() => {
    // å…ˆè·å–å½“å‰ç”¨æˆ·ï¼Œå†å†³å®šæ˜¯å¦è·å–ç”¨æˆ·åˆ—è¡¨
    const init = async () => {
        const userRes = await fetch('/api/auth/me', { credentials: 'include' });
        if (userRes.ok) {
            const userData = await userRes.json();
            setCurrentUser(userData.user);

            // å¹¶è¡Œè·å–æ•°æ®
            fetchAccounts(); // æ‰€æœ‰äººéƒ½èƒ½è·å–è´¦å·(è‡ªå·±çš„)

            // åªæœ‰ç®¡ç†å‘˜æ‰è·å–ç”¨æˆ·åˆ—è¡¨
            if (userData.user.role === 'admin') {
                fetchUsers();
            }
        }
    };
    init();
    fetchSettings();
    fetchWebsites();
    fetchMessageFilters();
  }, [])

  const fetchSettings = async (usePreload: boolean = true) => {
    try {
      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰é¢„åŠ è½½æ•°æ®
      if (usePreload) {
        const preloadData = sessionStorage.getItem('preload_settings')
        if (preloadData) {
          try {
            console.log('ä½¿ç”¨é¢„åŠ è½½è®¾ç½®æ•°æ®')
            const data = JSON.parse(preloadData)
            setSettings({
              discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
              global_reply_min_delay: data.global_reply_min_delay || 3.0,
              global_reply_max_delay: data.global_reply_max_delay || 8.0,
            })

            // æ¸…é™¤é¢„åŠ è½½æ•°æ®ï¼Œé¿å…é‡å¤ä½¿ç”¨
            sessionStorage.removeItem('preload_settings')

            // åœ¨åå°è·å–æœ€æ–°æ•°æ®ï¼Œä½†ä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            setTimeout(() => fetchSettings(false), 500)
            return
          } catch (e) {
            console.error('é¢„åŠ è½½è®¾ç½®æ•°æ®è§£æå¤±è´¥:', e)
            // é¢„åŠ è½½æ•°æ®æŸåï¼Œæ¸…é™¤å¹¶é‡æ–°è·å–
            sessionStorage.removeItem('preload_settings')
          }
        } else {
          // å¦‚æœæ²¡æœ‰é¢„åŠ è½½æ•°æ®ï¼Œç­‰å¾…ä¸€ä¸‹å†è¯•
          setTimeout(() => {
            const retryPreload = sessionStorage.getItem('preload_settings')
            if (retryPreload) {
              fetchSettings(true)
            } else {
              fetchSettings(false)
            }
          }, 200)
          return
        }
      }

      console.log('ä»APIè·å–è®¾ç½®æ•°æ®')
      const response = await fetch('/api/user/settings', {
        credentials: 'include'
      })
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold || 0.6,
          global_reply_min_delay: data.global_reply_min_delay || 3.0,
          global_reply_max_delay: data.global_reply_max_delay || 8.0,
        })
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
    }
  }

  const handleSaveSettings = async () => {
    setSettingsLoading(true)
    try {
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("è®¾ç½®å·²ä¿å­˜")
      } else {
        toast.error("ä¿å­˜è®¾ç½®å¤±è´¥")
      }
    } catch (error) {
      toast.error("ä¿å­˜è®¾ç½®å¤±è´¥")
    } finally {
      setSettingsLoading(false)
    }
  }

  const fetchAccounts = async () => {
          try {
      console.log('è·å–è´¦å·åˆ—è¡¨...')
      const data = await cachedFetch('/api/accounts', { credentials: 'include' })
            setAccounts(data.accounts || [])
    } catch (error) {
      console.error('è·å–è´¦å·åˆ—è¡¨å‡ºé”™:', error)
      setAccounts([])
    } finally {
      setLoading(false)
    }
  }

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users') // Next.js ä¼šè‡ªåŠ¨å¸¦ä¸Šæµè§ˆå™¨ Cookie
      if (response.ok) {
        const data = await response.json()
        setUsers(data.users || [])
      } else {
        // ä¸å†æŠ›å‡º toast é”™è¯¯ï¼Œè€Œæ˜¯é™é»˜å¤±è´¥æˆ–ä»…è®°å½•æ—¥å¿—
        // å› ä¸ºå¦‚æœæ˜¯æƒé™ä¸è¶³ï¼Œä¸Šé¢çš„é€»è¾‘åº”è¯¥å·²ç»æ‹¦æˆªäº†ï¼Œè¿™é‡Œæ˜¯å…œåº•
        console.log('User fetch skipped or failed', response.status)
        setUsers([])
      }
    } catch (error) {
      setUsers([])
    }
  }

  const getUserDisplayName = (userId: number) => {
    const user = users.find(u => u.id === userId)
    return user ? user.username : `ç”¨æˆ·${userId}`
  }

  const handleAddAccount = async () => {
    if (!newAccount.token) {
      toast.error("è¯·è¾“å…¥ Discord Token")
      return
    }

    try {
      const response = await fetch('/api/accounts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ token: newAccount.token })
      })

      if (response.ok) {
        toast.success("è´¦å·æ·»åŠ æˆåŠŸ")
        setNewAccount({ token: "" })
        setShowAddDialog(false)
        fetchAccounts()
      } else {
        const error = await response.json()
        toast.error(error.error || "æ·»åŠ è´¦å·å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    }
  }

  const handleDeleteAccount = (account: any) => {
    setDeleteAccountConfirm(account)
  }

  const confirmDeleteAccount = async () => {
    if (!deleteAccountConfirm) return

    try {
      const response = await fetch(`/api/accounts/${deleteAccountConfirm.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        toast.success("è´¦å·åˆ é™¤æˆåŠŸ")
        fetchAccounts()
        setDeleteAccountConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "åˆ é™¤è´¦å·å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    }
  }

  // ç½‘ç«™é…ç½®å¤„ç†å‡½æ•°
  const handleAddWebsite = async () => {
    try {
      const res = await fetch('/api/websites', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newWebsite)
      })
      if (res.ok) {
        toast.success('ç½‘ç«™é…ç½®å·²æ·»åŠ ')
        setShowAddWebsite(false)
        setNewWebsite({ name: '', display_name: '', url_template: '', id_pattern: '', badge_color: 'blue' })
        fetchWebsites()
      } else {
        toast.error('æ·»åŠ å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleUpdateWebsite = async () => {
    if (!editingWebsite) return
    try {
      const res = await fetch(`/api/websites/${editingWebsite.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(editingWebsite)
      })
      if (res.ok) {
        toast.success('ç½‘ç«™é…ç½®å·²æ›´æ–°')
        setEditingWebsite(null)
        fetchWebsites()
      } else {
        toast.error('æ›´æ–°å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleDeleteWebsite = async (website: any) => {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤ç½‘ç«™é…ç½® "${website.display_name}" å—ï¼Ÿ`)) return
    try {
      const res = await fetch(`/api/websites/${website.id}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('ç½‘ç«™é…ç½®å·²åˆ é™¤')
        fetchWebsites()
      } else {
        toast.error('åˆ é™¤å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleAddChannel = async (websiteId: number, channelId: string) => {
    if (!channelId.trim()) return
    try {
      const res = await fetch(`/api/websites/${websiteId}/channels`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ channel_id: channelId.trim() })
      })
      if (res.ok) {
        toast.success('é¢‘é“ç»‘å®šå·²æ·»åŠ ')
        fetchWebsites()
      } else {
        toast.error('æ·»åŠ å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleRemoveChannel = async (websiteId: number, channelId: string) => {
    try {
      const res = await fetch(`/api/websites/${websiteId}/channels/${channelId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('é¢‘é“ç»‘å®šå·²ç§»é™¤')
        fetchWebsites()
      } else {
        toast.error('ç§»é™¤å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  // æ¶ˆæ¯è¿‡æ»¤å¤„ç†å‡½æ•°
  const handleAddMessageFilter = async () => {
    try {
      const res = await fetch('/api/message-filters', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newFilter)
      })
      if (res.ok) {
        toast.success('è¿‡æ»¤è§„åˆ™æ·»åŠ æˆåŠŸ')
        setShowAddFilter(false)
        setNewFilter({ filter_type: 'contains', filter_value: '' })
        fetchMessageFilters()
      } else {
        toast.error('æ·»åŠ å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleUpdateMessageFilter = async () => {
    if (!editingFilter) return
    try {
      const res = await fetch(`/api/message-filters/${editingFilter.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          filter_type: editingFilter.filter_type,
          filter_value: editingFilter.filter_value,
          is_active: editingFilter.is_active
        })
      })
      if (res.ok) {
        toast.success('è¿‡æ»¤è§„åˆ™æ›´æ–°æˆåŠŸ')
        setEditingFilter(null)
        fetchMessageFilters()
      } else {
        toast.error('æ›´æ–°å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleDeleteMessageFilter = async (filterId: number) => {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè¿‡æ»¤è§„åˆ™å—ï¼Ÿ')) return
    try {
      const res = await fetch(`/api/message-filters/${filterId}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success('è¿‡æ»¤è§„åˆ™åˆ é™¤æˆåŠŸ')
        fetchMessageFilters()
      } else {
        toast.error('åˆ é™¤å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }


  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-extrabold tracking-tight">è´¦å·ç®¡ç†</h2>
        <p className="text-sm text-muted-foreground mt-1">ç®¡ç† Discord è´¦å·</p>
      </div>

      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h3 className="text-xl font-bold">è´¦å·åˆ—è¡¨</h3>
            <p className="text-sm text-gray-600 mt-1">
              å…± {accounts.length} ä¸ªè´¦å·
            </p>
          </div>
          <Dialog open={showAddDialog} onOpenChange={setShowAddDialog}>
            <DialogTrigger asChild>
              <Button>
                <Plus className="w-4 h-4 mr-2" />
                æ·»åŠ è´¦å·
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>æ·»åŠ  Discord è´¦å·</DialogTitle>
                <DialogDescription>
                  è¾“å…¥ Discord Tokenï¼Œç³»ç»Ÿå°†è‡ªåŠ¨éªŒè¯å¹¶è·å–ç”¨æˆ·å
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label htmlFor="token">Discord Token</Label>
                  <Input
                    id="token"
                    type="password"
                    value={newAccount.token}
                    onChange={(e) => setNewAccount(prev => ({ ...prev, token: e.target.value }))}
                    placeholder="è¾“å…¥ Discord Token"
                  />
                  <p className="text-xs text-muted-foreground mt-1">
                    Token å°†è¢«å®‰å…¨å­˜å‚¨ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨éªŒè¯æœ‰æ•ˆæ€§
                  </p>
                </div>
              </div>
              <DialogFooter>
                <Button onClick={handleAddAccount}>æ·»åŠ è´¦å·</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>

        <div className="space-y-2">
          {accounts.map((account) => (
            <div key={account.id} className="flex justify-between items-center p-4 border rounded">
              <div className="flex-1">
                <div className="font-semibold">{account.username}</div>
                <div className="text-sm text-gray-500">
                  {account.user_id ? `æ‰€å±ç”¨æˆ·: ${getUserDisplayName(account.user_id)}` : 'æœªåˆ†é…ç”¨æˆ·'}
                </div>
                <div className="text-xs text-gray-400 font-mono">
                  {account.token && typeof account.token === 'string' ? `${account.token.substring(0, 20)}...` : 'Token æ— æ•ˆ'}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <div className={`px-2 py-1 rounded text-sm ${
                  account.status === 'online' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
                }`}>
                  {account.status === 'online' ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleDeleteAccount(account)}
                  className="text-red-600 hover:text-red-700 hover:bg-red-50"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            </div>
          ))}
        </div>
      </div>


      {/* è®¾ç½®åŒºåŸŸ */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h3 className="text-xl font-bold flex items-center">
              <Settings className="w-5 h-5 mr-2" />
              ä¸ªäººè®¾ç½®
            </h3>
            <p className="text-sm text-gray-600 mt-1">é…ç½®æ‚¨çš„ä¸ªæ€§åŒ–è¿è¡Œå‚æ•°</p>
          </div>
          <Button onClick={handleSaveSettings} disabled={settingsLoading}>
            <Save className="w-4 h-4 mr-2" />
            {settingsLoading ? "ä¿å­˜ä¸­..." : "ä¿å­˜è®¾ç½®"}
          </Button>
        </div>

        {/* ç³»ç»Ÿå‚æ•°è®¾ç½® - åˆå¹¶ç›¸ä¼¼åº¦å’Œå»¶è¿Ÿè®¾ç½® */}
        <Card>
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">ç³»ç»Ÿå‚æ•°</CardTitle>
            <CardDescription>é…ç½®å›¾ç‰‡åŒ¹é…å’Œå›å¤å»¶è¿Ÿå‚æ•°</CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* ç›¸ä¼¼åº¦å’Œå»¶è¿Ÿè®¾ç½® - ç´§å‡‘å¸ƒå±€ */}
            <div className="flex flex-col sm:flex-row gap-6">
              {/* ç›¸ä¼¼åº¦è®¾ç½® */}
              <div className="flex-1 space-y-2">
                <div className="flex items-center justify-between">
                  <Label htmlFor="similarity-threshold" className="text-sm font-medium">ç›¸ä¼¼åº¦é˜ˆå€¼</Label>
                  <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                    {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                  </span>
                </div>
                <div className="space-y-1">
                  <Input
                    id="similarity-threshold"
                    type="number"
                    step="0.1"
                    min="0.1"
                    max="1.0"
                    value={settings.discord_similarity_threshold}
                    onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                    className="h-9"
                  />
                  <p className="text-xs text-muted-foreground">
                    é˜ˆå€¼è¶Šä½åŒ¹é…è¶Šå®½æ¾ï¼Œå»ºè®®èŒƒå›´ 0.3-0.8
                  </p>
                </div>
              </div>

              {/* å›å¤å»¶è¿Ÿè®¾ç½® */}
              <div className="flex-1 space-y-2">
                <Label className="text-sm font-medium">å›å¤å»¶è¿Ÿ</Label>
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="flex items-center gap-1">
                      <Input
                        id="min-delay"
                        type="number"
                        step="0.1"
                        min="0.1"
                        max="30"
                        value={settings.global_reply_min_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_min_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                      <span className="text-sm text-muted-foreground">-</span>
                      <Input
                        id="max-delay"
                        type="number"
                        step="0.5"
                        min="1"
                        max="60"
                        value={settings.global_reply_max_delay}
                        onChange={(e) => setSettings(prev => ({ ...prev, global_reply_max_delay: parseFloat(e.target.value) }))}
                        className="w-16 h-9 text-center"
                      />
                    </div>
                    <span className="text-xs text-muted-foreground">ç§’</span>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    æ¯æ¬¡å›å¤éšæœºå»¶è¿Ÿ {settings.global_reply_min_delay}-{settings.global_reply_max_delay} ç§’
                  </p>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>


        {/* ç¼–è¾‘ç½‘ç«™å¯¹è¯æ¡† */}
        {editingWebsite && (
          <Dialog open={!!editingWebsite} onOpenChange={() => setEditingWebsite(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>ç¼–è¾‘ç½‘ç«™é…ç½®</DialogTitle>
                <DialogDescription>ä¿®æ”¹ç½‘ç«™é…ç½®ä¿¡æ¯</DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>ç½‘ç«™æ ‡è¯†</Label>
                  <Input
                    value={editingWebsite.name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>æ˜¾ç¤ºåç§°</Label>
                  <Input
                    value={editingWebsite.display_name}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>URLæ¨¡æ¿</Label>
                  <Input
                    value={editingWebsite.url_template}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>IDæå–æ¨¡å¼</Label>
                  <Input
                    value={editingWebsite.id_pattern}
                    onChange={e => setEditingWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                  />
                </div>
                <div>
                  <Label>å¾½ç« é¢œè‰²</Label>
                  <Select value={editingWebsite?.badge_color || 'blue'} onValueChange={value => setEditingWebsite(prev => ({ ...prev, badge_color: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="blue">è“è‰²</SelectItem>
                      <SelectItem value="green">ç»¿è‰²</SelectItem>
                      <SelectItem value="orange">æ©™è‰²</SelectItem>
                      <SelectItem value="red">çº¢è‰²</SelectItem>
                      <SelectItem value="purple">ç´«è‰²</SelectItem>
                      <SelectItem value="gray">ç°è‰²</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingWebsite(null)}>å–æ¶ˆ</Button>
                <Button onClick={handleUpdateWebsite}>ä¿å­˜</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}

        {/* æ¶ˆæ¯è¿‡æ»¤è®¾ç½® */}
        {currentUser?.role === 'admin' && (
          <Card className="mt-6">
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg">æ¶ˆæ¯è¿‡æ»¤</CardTitle>
                  <CardDescription>è®¾ç½®è´¦å·ä¸å›å¤çš„æ¶ˆæ¯å†…å®¹è§„åˆ™</CardDescription>
                </div>
                <Dialog open={showAddFilter} onOpenChange={setShowAddFilter}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      æ·»åŠ è¿‡æ»¤è§„åˆ™
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™</DialogTitle>
                      <DialogDescription>è®¾ç½®è´¦å·å¿½ç•¥çš„æ¶ˆæ¯ç±»å‹</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>è¿‡æ»¤ç±»å‹</Label>
                        <Select value={newFilter.filter_type} onValueChange={value => setNewFilter(prev => ({ ...prev, filter_type: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="contains">åŒ…å«æ–‡æœ¬</SelectItem>
                            <SelectItem value="starts_with">å¼€å¤´æ˜¯</SelectItem>
                            <SelectItem value="ends_with">ç»“å°¾æ˜¯</SelectItem>
                            <SelectItem value="regex">æ­£åˆ™è¡¨è¾¾å¼</SelectItem>
                            <SelectItem value="user_id">ç”¨æˆ·ID</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                      <div>
                        <Label>è¿‡æ»¤å€¼</Label>
                        <Input
                          value={newFilter.filter_value}
                          onChange={e => setNewFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                          placeholder={
                            newFilter.filter_type === 'user_id'
                              ? "è¾“å…¥ç”¨æˆ·IDï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”"
                              : "è¾“å…¥è¦è¿‡æ»¤çš„å†…å®¹"
                          }
                        />
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddFilter(false)}>å–æ¶ˆ</Button>
                      <Button onClick={handleAddMessageFilter}>æ·»åŠ è§„åˆ™</Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                {messageFilters.map((filter: any) => (
                  <div key={filter.id} className="flex items-center justify-between p-3 border rounded">
                    <div>
                      <div className="font-medium">{filter.filter_type} "{filter.filter_value}"</div>
                      <div className="text-sm text-muted-foreground">
                        åˆ›å»ºæ—¶é—´: {new Date(filter.created_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingFilter(filter)}
                      >
                        <Edit className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteMessageFilter(filter.id)}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ))}
                {messageFilters.length === 0 && (
                  <div className="text-center py-4 text-muted-foreground">
                    æš‚æ— è¿‡æ»¤è§„åˆ™
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* ç½‘ç«™é…ç½®åŒºåŸŸ */}
        {currentUser?.role === 'admin' && (
          <Card className="mt-6">
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg flex items-center">
                    <Globe className="w-5 h-5 mr-2" />
                    ç½‘ç«™é…ç½®
                  </CardTitle>
                  <CardDescription>ç®¡ç†æ”¯æŒçš„è´­ç‰©ç½‘ç«™å’Œé¢‘é“ç»‘å®š</CardDescription>
                </div>
                <Dialog open={showAddWebsite} onOpenChange={setShowAddWebsite}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="w-4 h-4 mr-2" />
                      æ·»åŠ ç½‘ç«™
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>æ·»åŠ ç½‘ç«™é…ç½®</DialogTitle>
                      <DialogDescription>é…ç½®æ–°çš„è´­ç‰©ç½‘ç«™æ”¯æŒ</DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div>
                        <Label>ç½‘ç«™æ ‡è¯†</Label>
                        <Input
                          value={newWebsite.name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, name: e.target.value }))}
                          placeholder="ä¾‹å¦‚: kakobuy"
                        />
                      </div>
                      <div>
                        <Label>æ˜¾ç¤ºåç§°</Label>
                        <Input
                          value={newWebsite.display_name}
                          onChange={e => setNewWebsite(prev => ({ ...prev, display_name: e.target.value }))}
                          placeholder="ä¾‹å¦‚: Kakobuy"
                        />
                      </div>
                      <div>
                        <Label>URLæ¨¡æ¿</Label>
                        <Input
                          value={newWebsite.url_template}
                          onChange={e => setNewWebsite(prev => ({ ...prev, url_template: e.target.value }))}
                          placeholder="https://www.kakobuy.com/item/details?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD"
                        />
                      </div>
                      <div>
                        <Label>IDæå–æ¨¡å¼</Label>
                        <Input
                          value={newWebsite.id_pattern}
                          onChange={e => setNewWebsite(prev => ({ ...prev, id_pattern: e.target.value }))}
                          placeholder="{id}"
                        />
                      </div>
                      <div>
                        <Label>å¾½ç« é¢œè‰²</Label>
                        <Select value={newWebsite.badge_color} onValueChange={value => setNewWebsite(prev => ({ ...prev, badge_color: value }))}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="blue">è“è‰²</SelectItem>
                            <SelectItem value="green">ç»¿è‰²</SelectItem>
                            <SelectItem value="orange">æ©™è‰²</SelectItem>
                            <SelectItem value="red">çº¢è‰²</SelectItem>
                            <SelectItem value="purple">ç´«è‰²</SelectItem>
                            <SelectItem value="gray">ç°è‰²</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setShowAddWebsite(false)}>å–æ¶ˆ</Button>
                      <Button onClick={handleAddWebsite}>æ·»åŠ </Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {websites.map((website: any) => (
                  <div key={website.id} className="border rounded-lg p-4">
                    <div className="flex justify-between items-start mb-3">
                      <div className="flex items-center gap-2">
                        <span className={`inline-flex items-center rounded-md border font-medium w-fit whitespace-nowrap text-[9px] px-1 py-0 h-4 border-none shrink-0 text-white ${
                          website.badge_color === 'blue' ? 'bg-blue-600' :
                          website.badge_color === 'green' ? 'bg-green-600' :
                          website.badge_color === 'orange' ? 'bg-orange-600' :
                          website.badge_color === 'red' ? 'bg-red-600' :
                          website.badge_color === 'purple' ? 'bg-purple-600' :
                          'bg-gray-600'
                        }`}>
                          {website.display_name}
                        </span>
                        <span className="text-sm font-medium">{website.name}</span>
                      </div>
                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingWebsite(website)}
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteWebsite(website)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    </div>

                    <div className="text-xs text-muted-foreground mb-3">
                      <div>URLæ¨¡æ¿: {website.url_template}</div>
                      <div>IDæ¨¡å¼: {website.id_pattern}</div>
                    </div>

                    {/* é¢‘é“ç»‘å®š */}
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Hash className="w-4 h-4" />
                        <span className="text-sm font-medium">ç»‘å®šé¢‘é“</span>
                        <Dialog>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Plus className="w-3 h-3 mr-1" />
                              æ·»åŠ é¢‘é“
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>æ·»åŠ é¢‘é“ç»‘å®š</DialogTitle>
                              <DialogDescription>è¾“å…¥Discordé¢‘é“ID</DialogDescription>
                            </DialogHeader>
                            <div className="space-y-4">
                              <div>
                                <Label>é¢‘é“ID</Label>
                                <Input
                                  placeholder="ä¾‹å¦‚: 1234567890123456789"
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                      handleAddChannel(website.id, (e.target as HTMLInputElement).value)
                                      ;(e.target as HTMLInputElement).value = ''
                                    }
                                  }}
                                />
                              </div>
                            </div>
                            <DialogFooter>
                              <Button variant="outline" onClick={() => {}}>å–æ¶ˆ</Button>
                              <Button onClick={() => {
                                const input = document.querySelector('input[placeholder*="é¢‘é“ID"]') as HTMLInputElement
                                if (input?.value) {
                                  handleAddChannel(website.id, input.value)
                                  input.value = ''
                                }
                              }}>æ·»åŠ </Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </div>

                      <div className="flex flex-wrap gap-2">
                        {(websiteChannels[website.id] || []).map((channelId: string) => (
                          <div key={channelId} className="flex items-center gap-1 bg-muted rounded px-2 py-1">
                            <Hash className="w-3 h-3" />
                            <span className="text-xs font-mono">{channelId}</span>
                            <Button
                              variant="ghost"
                              size="sm"
                              className="h-4 w-4 p-0"
                              onClick={() => handleRemoveChannel(website.id, channelId)}
                            >
                              <X className="w-3 h-3" />
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* ç¼–è¾‘æ¶ˆæ¯è¿‡æ»¤å¯¹è¯æ¡† */}
        {editingFilter && (
          <Dialog open={!!editingFilter} onOpenChange={() => setEditingFilter(null)}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>ç¼–è¾‘è¿‡æ»¤è§„åˆ™</DialogTitle>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label>è¿‡æ»¤ç±»å‹</Label>
                  <Select value={editingFilter.filter_type} onValueChange={value => setEditingFilter(prev => ({ ...prev, filter_type: value }))}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="contains">åŒ…å«æ–‡æœ¬</SelectItem>
                      <SelectItem value="starts_with">å¼€å¤´æ˜¯</SelectItem>
                      <SelectItem value="ends_with">ç»“å°¾æ˜¯</SelectItem>
                      <SelectItem value="regex">æ­£åˆ™è¡¨è¾¾å¼</SelectItem>
                      <SelectItem value="user_id">ç”¨æˆ·ID</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label>è¿‡æ»¤å€¼</Label>
                  <Input
                    value={editingFilter.filter_value}
                    onChange={e => setEditingFilter(prev => ({ ...prev, filter_value: e.target.value }))}
                  />
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setEditingFilter(null)}>å–æ¶ˆ</Button>
                <Button onClick={handleUpdateMessageFilter}>ä¿å­˜ä¿®æ”¹</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}


        {/* åˆ é™¤è´¦å·ç¡®è®¤å¯¹è¯æ¡† */}
        <Dialog open={!!deleteAccountConfirm} onOpenChange={() => setDeleteAccountConfirm(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>ç¡®è®¤åˆ é™¤è´¦å·</DialogTitle>
              <DialogDescription>
                ç¡®å®šè¦åˆ é™¤Discordè´¦å· "{deleteAccountConfirm?.username}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setDeleteAccountConfirm(null)}>
                å–æ¶ˆ
              </Button>
              <Button variant="destructive" onClick={confirmDeleteAccount}>
                ç¡®è®¤åˆ é™¤
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/image-search-view.tsx ---
"use client"

import type React from "react"
import { useState, useCallback, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Upload, Search, ExternalLink, Settings, X, Clock, Trash2, Copy } from "lucide-react"
import { toast } from "sonner"

export function ImageSearchView() {
  const [uploadedImage, setUploadedImage] = useState<string | null>(null)
  const [imageUrl, setImageUrl] = useState<string>("")
  const [isSearching, setIsSearching] = useState(false)
  const [searchResults, setSearchResults] = useState<any[]>([])
  const [threshold, setThreshold] = useState(30) // 0-100ï¼Œé»˜è®¤30% (é™ä½é˜ˆå€¼ä»¥æé«˜åŒ¹é…æˆåŠŸç‡)
  const [maxResults, setMaxResults] = useState(5) // è¿”å›æœ€ç›¸ä¼¼çš„å‰Nä¸ªç»“æœ

  // æœç´¢å†å²ç›¸å…³çŠ¶æ€
  const [searchHistory, setSearchHistory] = useState<any[]>([])
  const [currentPage, setCurrentPage] = useState(1)
  const [totalHistory, setTotalHistory] = useState(0)
  const [hasMoreHistory, setHasMoreHistory] = useState(false)
  const [showClearConfirm, setShowClearConfirm] = useState(false)

  // åŠ è½½æœç´¢å†å²
  useEffect(() => {
    fetchSearchHistory()
  }, [])

  const fetchSearchHistory = async (page: number = 1) => {
    try {
      const limit = 10 // æ¯é¡µæ˜¾ç¤º10æ¡è®°å½•
      const offset = (page - 1) * limit
      const response = await fetch(`/api/search_history?limit=${limit}&offset=${offset}`)
      if (response.ok) {
        const result = await response.json()
        setSearchHistory(result.history || [])
        setTotalHistory(result.total || 0)
        setHasMoreHistory(result.has_more || false)
        setCurrentPage(page)
      }
    } catch (error) {
      console.error('Failed to fetch search history:', error)
    }
  }

  // åˆ é™¤å•æ¡æœç´¢å†å²
  const handleDeleteHistory = async (historyId: number) => {
    try {
      const response = await fetch(`/api/search_history/${historyId}`, {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory(prev => prev.filter(h => h.id !== historyId))
        setTotalHistory(prev => prev - 1)
        toast.success('æœç´¢è®°å½•å·²åˆ é™¤')
      } else {
        toast.error('åˆ é™¤å¤±è´¥')
      }
    } catch (error) {
      console.error('Failed to delete history:', error)
      toast.error('åˆ é™¤å¤±è´¥')
    }
  }

  // æ¸…ç©ºæ‰€æœ‰æœç´¢å†å²
  const handleClearAllHistory = () => {
    setShowClearConfirm(true)
  }

  const confirmClearAllHistory = async () => {
    setShowClearConfirm(false)
    try {
      const response = await fetch('/api/search_history', {
        method: 'DELETE',
      })
      if (response.ok) {
        setSearchHistory([])
        setTotalHistory(0)
        toast.success('æ‰€æœ‰æœç´¢è®°å½•å·²æ¸…ç©º')
      } else {
        toast.error('æ¸…ç©ºå¤±è´¥')
      }
    } catch (error) {
      console.error('Failed to clear history:', error)
      toast.error('æ¸…ç©ºå¤±è´¥')
    }
  }

  const handleFileUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      setUploadedImage(event.target?.result as string)
      // æ¸…ç©ºé“¾æ¥è¾“å…¥
      setImageUrl("")
      toast.success("å›¾ç‰‡å·²ä¸Šä¼ ")
    }
    reader.readAsDataURL(file)
  }, [])

  const handleClearImage = () => {
    setUploadedImage(null)
  }

  const handleSearch = async () => {
    if (!uploadedImage && !imageUrl.trim()) {
      toast.error("è¯·ä¸Šä¼ å›¾ç‰‡æˆ–è¾“å…¥å›¾ç‰‡é“¾æ¥")
      return
    }

    setIsSearching(true)

    try {
      // åˆ›å»ºFormData
      const formData = new FormData();

      if (uploadedImage) {
        // å°†base64å›¾ç‰‡è½¬æ¢ä¸ºblob
        try {
          const base64Data = uploadedImage.split(',')[1]; // å»æ‰data:image/jpeg;base64,å‰ç¼€
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: 'image/jpeg' });
        formData.append('image', blob, 'search.jpg');
        console.log('ä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡è¿›è¡Œæœç´¢');
        } catch (error) {
          console.error('å›¾ç‰‡è½¬æ¢å¤±è´¥:', error);
          toast.error('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
          setIsSearching(false);
          return;
        }
      } else if (imageUrl.trim()) {
        // å‘é€å›¾ç‰‡URL
        formData.append('image_url', imageUrl.trim());
        console.log('ä½¿ç”¨å›¾ç‰‡é“¾æ¥è¿›è¡Œæœç´¢:', imageUrl.trim());
      }

      formData.append('threshold', (threshold / 100).toString()); // è½¬æ¢ä¸º0-1
      formData.append('limit', maxResults.toString()); // è¿”å›ç»“æœæ•°é‡

      // å‘é€åˆ°åç«¯è¿›è¡Œå‘é‡æœç´¢
      const searchRes = await fetch('/api/search_similar', {
        method: 'POST',
        body: formData
      });

      if (searchRes.ok) {
        const result = await searchRes.json();
        if (result.success && result.results && result.results.length > 0) {
          // è®¾ç½®æœç´¢ç»“æœ
          setSearchResults(result.results)
          // é‡æ–°åŠ è½½æœç´¢å†å²ï¼ˆæ–°è®°å½•å·²ä¿å­˜åˆ°æ•°æ®åº“ï¼‰
          await fetchSearchHistory()
          toast.success(`æ‰¾åˆ° ${result.results.length} ä¸ªç›¸ä¼¼å•†å“ï¼Œæœ€ä½³ç›¸ä¼¼åº¦ ${(result.results[0].similarity * 100).toFixed(1)}%`);
        } else {
          setSearchResults([])
          toast.info(result.message || "æœªæ‰¾åˆ°ç›¸ä¼¼å•†å“");
        }
      } else {
        const errorText = await searchRes.text();
        console.error('Search failed:', errorText);
        toast.error("æœç´¢å¤±è´¥");
      }
    } catch (error) {
      console.error('Search error:', error);
      toast.error("æœç´¢è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯");
    } finally {
      setIsSearching(false);
    }
  }




  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">ä»¥å›¾æœå›¾</h2>
        <p className="text-muted-foreground">ä¸Šä¼ å›¾ç‰‡ï¼Œæµ‹è¯•å‘é‡æœç´¢åŠŸèƒ½å¹¶è·å– CNFans é“¾æ¥</p>
      </div>

      <div className="grid gap-6 lg:grid-cols-1">
        <Card>
          <CardHeader>
            <CardTitle>ä¸Šä¼ å›¾ç‰‡æˆ–è¾“å…¥é“¾æ¥è¿›è¡Œæœç´¢</CardTitle>
            <CardDescription>æ”¯æŒ JPGã€PNGã€WebP æ ¼å¼ï¼Œå¯ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶æˆ–è¾“å…¥å›¾ç‰‡é“¾æ¥è¿›è¡Œå‘é‡æœç´¢</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex gap-6">
              {/* å·¦ä¾§ï¼šå›¾ç‰‡è¾“å…¥åŒºåŸŸ */}
              <div className="flex-1 space-y-4">
                {/* å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">ä¸Šä¼ å›¾ç‰‡</label>
                  <div className="space-y-3">
                    {!uploadedImage ? (
                      <label
                        htmlFor="image-upload"
                        className={`flex flex-col items-center justify-center h-48 border-2 border-dashed rounded-lg cursor-pointer transition-colors ${
                          imageUrl.trim()
                            ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50'
                            : 'border-muted-foreground/25 hover:border-muted-foreground/50'
                        }`}
                      >
                        <Upload className="size-12 text-muted-foreground mb-2" />
                        <input
                          id="image-upload"
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={handleFileUpload}
                          disabled={!!imageUrl.trim()}
                        />
                      </label>
                    ) : (
                      <div className="relative">
                        <img
                          src={uploadedImage || "/placeholder.svg"}
                          alt="Uploaded"
                          className="w-full h-48 object-contain rounded-lg border"
                        />
                        <Button
                          variant="destructive"
                          size="icon"
                          className="absolute top-2 right-2 w-8 h-8"
                          onClick={handleClearImage}
                        >
                          <X className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>

                {/* å›¾ç‰‡é“¾æ¥è¾“å…¥ */}
                <div className="space-y-2">
                  <label className="text-sm font-medium">å›¾ç‰‡é“¾æ¥</label>
                  <input
                    type="url"
                    value={imageUrl}
                    onChange={(e) => {
                      setImageUrl(e.target.value)
                      // å½“è¾“å…¥é“¾æ¥æ—¶ï¼Œæ¸…ç©ºå·²ä¸Šä¼ çš„å›¾ç‰‡
                      if (e.target.value.trim()) {
                        setUploadedImage(null)
                      }
                    }}
                    placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥ (https://...)"
                    className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                      uploadedImage ? 'border-gray-200 bg-gray-50 cursor-not-allowed opacity-50' : 'border-gray-300'
                    }`}
                    disabled={!!uploadedImage}
                  />
                  {imageUrl && !uploadedImage && (
                    <div className="flex items-center gap-2">
                      <img
                        src={imageUrl}
                        alt="Preview"
                        className="w-16 h-16 object-cover rounded border"
                        onError={(e) => {
                          e.currentTarget.style.display = 'none';
                        }}
                      />
                      <span className="text-sm text-muted-foreground">å›¾ç‰‡é¢„è§ˆ</span>
                    </div>
                  )}
                  {uploadedImage && (
                    <p className="text-xs text-muted-foreground">å·²ä¸Šä¼ å›¾ç‰‡ï¼Œæ— æ³•è¾“å…¥é“¾æ¥</p>
                  )}
                </div>
              </div>

              {/* å³ä¾§ï¼šæœç´¢è®¾ç½® */}
              <div className="w-80 space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">ç›¸ä¼¼åº¦é˜ˆå€¼</label>
                    <span className="text-sm text-muted-foreground">{threshold}%</span>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="1"
                    value={threshold}
                    onChange={(e) => setThreshold(Number.parseInt(e.target.value))}
                    className="w-full"
                  />
                  <p className="text-xs text-muted-foreground">åªæ˜¾ç¤ºç›¸ä¼¼åº¦è¶…è¿‡æ­¤é˜ˆå€¼çš„å•†å“ (0-100%)</p>
                </div>

                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <label className="text-sm font-medium">è¿”å›ç»“æœæ•°é‡</label>
                    <span className="text-sm text-muted-foreground">{maxResults}ä¸ª</span>
                  </div>
                  <select
                    value={maxResults}
                    onChange={(e) => setMaxResults(Number.parseInt(e.target.value))}
                    className="w-full px-3 py-2 border border-input rounded-md bg-background text-sm"
                  >
                    <option value={1}>1ä¸ª</option>
                    <option value={3}>3ä¸ª</option>
                    <option value={5}>5ä¸ª</option>
                    <option value={10}>10ä¸ª</option>
                    <option value={20}>20ä¸ª</option>
                  </select>
                  <p className="text-xs text-muted-foreground">è¿”å›æœ€ç›¸ä¼¼çš„å‰Nä¸ªç»“æœè¿›è¡Œç­›é€‰</p>
                </div>

                <Button
                  className="w-full"
                  onClick={handleSearch}
                  disabled={(!uploadedImage && !imageUrl.trim()) || isSearching}
                >
                  <Search className="w-4 h-4 mr-2" />
                  {isSearching ? "æœç´¢ä¸­..." : "å¼€å§‹æœç´¢"}
                </Button>

                {isSearching && (
                  <div className="flex items-center justify-center py-4">
                    <div className="text-center space-y-2">
                      <div className="animate-spin size-6 border-4 border-primary border-t-transparent rounded-full mx-auto" />
                      <p className="text-xs text-muted-foreground">æ­£åœ¨åŒ¹é…å‘é‡...</p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </CardContent>
        </Card>

        {/* æœç´¢ç»“æœ */}
        {searchResults && searchResults.length > 0 && (
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-lg flex items-center gap-2">
                    <Search className="w-5 h-5" />
                    æœç´¢ç»“æœ
                  </CardTitle>
                  <CardDescription>
                    æ‰¾åˆ° {searchResults.length} ä¸ªç›¸ä¼¼å•†å“ï¼ŒæŒ‰ç›¸ä¼¼åº¦æ’åº
                  </CardDescription>
                </div>
                <div className="flex items-center gap-3">
                </div>
              </div>
            </CardHeader>
            <CardContent className="pt-0">
              <div className="space-y-4">
                {searchResults.map((result, index) => (
                  <div key={index} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* åŒ¹é…å›¾ç‰‡å’ŒåŸºæœ¬ä¿¡æ¯ */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* åŒ¹é…çš„å•†å“å›¾ç‰‡ */}
                      <div className="flex-shrink-0">
                        <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                          <img
                            src={result.matchedImage}
                            alt={result.product.title}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              e.currentTarget.src = '/placeholder.jpg'
                            }}
                          />
                        </div>
                      </div>

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{result.product.title}</h4>
                          <Badge
                            className={
                              result.similarity >= 0.95
                                ? "bg-green-600 hover:bg-green-700"
                                : result.similarity >= 0.85
                                ? "bg-blue-600 hover:bg-blue-700"
                                : "bg-yellow-600 hover:bg-yellow-700"
                            }
                          >
                            {(result.similarity * 100).toFixed(1)}% ç›¸ä¼¼åº¦
                          </Badge>
                        </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{result.product.englishTitle || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {result.product.weidianUrl?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>æ’å: #{result.rank}</span>
                          <span>|</span>
                          <span>æœç´¢æ—¶é—´: {new Date().toLocaleString('zh-CN')}</span>
                        </div>
                      </div>
                    </div>

                    {/* é“¾æ¥æ˜¾ç¤ºåŒºåŸŸ */}
                    <div className="flex items-center gap-4">
                      <div className="flex flex-col gap-1 min-w-[300px]">
                        <div className="flex items-center gap-1.5">
                          <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-gray-600">
                            å¾®åº—
                          </Badge>
                          <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                            <a href={result.product.weidianUrl} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">
                              {result.product.weidianUrl}
                            </a>
                            <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.weidianUrl); toast.success("Copied")}}>
                              <Copy className="h-2.5 w-2.5"/>
                            </Button>
                          </div>
                        </div>
                        {result.product.cnfansUrl && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-blue-600">
                              CNFans
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={result.product.cnfansUrl} target="_blank" className="font-mono truncate hover:underline text-blue-500">
                                {result.product.cnfansUrl}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.cnfansUrl); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                              </Button>
                            </div>
                          </div>
                        )}
                        {result.product.acbuyUrl && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-purple-600">
                              ACBuy
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={result.product.acbuyUrl} target="_blank" className="font-mono truncate hover:underline text-purple-500">
                                {result.product.acbuyUrl}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(result.product.acbuyUrl); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                              </Button>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* æœç´¢å†å² - åˆ—è¡¨å½¢å¼ */}
        <Card>
          <CardHeader className="pb-4">
            <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
              <div>
                <CardTitle className="text-lg">æœç´¢è®°å½•</CardTitle>
                <CardDescription>å†å²æœç´¢ç»“æœï¼ŒæŒ‰æ—¶é—´å€’åºæ’åˆ—</CardDescription>
              </div>
              {searchHistory.length > 0 && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleClearAllHistory}
                  className="shrink-0"
                >
                  <Trash2 className="w-4 h-4 mr-1" />
                  æ¸…ç©ºå†å²
                </Button>
              )}
            </div>
          </CardHeader>
          <CardContent className="pt-0">
            {searchHistory.length === 0 ? (
              <div className="text-center py-12 text-muted-foreground">
                <Search className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>æš‚æ— æœç´¢è®°å½•</p>
                <p className="text-sm">ä¸Šä¼ å›¾ç‰‡å¹¶æœç´¢åï¼Œç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
              </div>
            ) : (
              <div className="space-y-3">
                {searchHistory.map((history) => (
                  <div key={history.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                    {/* åŒ¹é…å›¾ç‰‡å’ŒåŸºæœ¬ä¿¡æ¯ */}
                    <div className="flex gap-3 items-center flex-1">
                      {/* åŒ¹é…çš„å•†å“å›¾ç‰‡ */}
                      {history.matched_product_id && (
                        <div className="flex-shrink-0">
                          <div className="w-16 h-16 bg-muted rounded-lg overflow-hidden">
                            <img
                              src={`/api/image/${history.matched_product_id}/${history.matched_image_index}`}
                              alt="åŒ¹é…çš„å•†å“å›¾ç‰‡"
                              className="w-full h-full object-cover"
                              onError={(e) => {
                                e.currentTarget.src = '/placeholder.jpg'
                              }}
                            />
                          </div>
                        </div>
                      )}

                      <div className="space-y-0.5 min-w-0 flex-1">
                        <div className="flex items-center gap-2">
                          <h4 className="font-bold text-base truncate">{history.title}</h4>
                            <Badge
                              className={
                                history.similarity >= 0.95
                                  ? "bg-green-600 hover:bg-green-700"
                                  : history.similarity >= 0.85
                                  ? "bg-blue-600 hover:bg-blue-700"
                                  : "bg-yellow-600 hover:bg-yellow-700"
                              }
                            >
                              {(history.similarity * 100).toFixed(1)}% ç›¸ä¼¼åº¦
                            </Badge>
                          </div>
                        <div className="flex items-center gap-2 mt-1">
                          <p className="text-sm font-bold text-blue-600 truncate">{history.english_title || "No English Title"}</p>
                        </div>
                        <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                          <span className="font-mono">ID: {history.weidian_url?.split('itemID=')?.[1] || 'N/A'}</span>
                          <span>|</span>
                          <span>åŒ¹é…å›¾ç‰‡: #{history.matched_image_index}</span>
                          <span>|</span>
                          <span>é˜ˆå€¼: {history.threshold * 100}%</span>
                          <span>|</span>
                          <span>æœç´¢æ—¶é—´: {new Date(history.search_time).toLocaleString('zh-CN')}</span>
                        </div>
                              </div>
                            </div>

                    {/* é“¾æ¥æ˜¾ç¤ºåŒºåŸŸ */}
                    <div className="flex items-center gap-4">
                      <div className="flex flex-col gap-1 min-w-[300px]">
                        <div className="flex items-center gap-1.5">
                          <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-gray-600">
                            å¾®åº—
                          </Badge>
                          <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                            <a href={history.weidian_url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">
                              {history.weidian_url}
                            </a>
                            <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.weidian_url); toast.success("Copied")}}>
                              <Copy className="h-2.5 w-2.5"/>
                            </Button>
                          </div>
                        </div>
                        {history.cnfans_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-blue-600">
                              CNFans
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.cnfans_url} target="_blank" className="font-mono truncate hover:underline text-blue-500">
                                {history.cnfans_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.cnfans_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                        {history.acbuy_url && (
                          <div className="flex items-center gap-1.5">
                            <Badge className="text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white bg-purple-600">
                              ACBuy
                            </Badge>
                            <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                              <a href={history.acbuy_url} target="_blank" className="font-mono truncate hover:underline text-purple-500">
                                {history.acbuy_url}
                              </a>
                              <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(history.acbuy_url); toast.success("Copied")}}>
                                <Copy className="h-2.5 w-2.5"/>
                            </Button>
                            </div>
                          </div>
                        )}
                      </div>

                      {/* åˆ é™¤æŒ‰é’® */}
                        <Button
                        variant="outline"
                          size="icon"
                        className="h-8 w-8 hover:bg-red-50 hover:text-red-600"
                          onClick={() => handleDeleteHistory(history.id)}
                        >
                        <X className="size-3.5" />
                        </Button>
                    </div>
                  </div>
                ))}

                {/* åˆ†é¡µæ§ä»¶ */}
                {searchHistory.length > 0 && (
                  <div className="flex flex-col sm:flex-row justify-between items-center gap-4 pt-4 border-t mt-4">
                    <div className="text-sm text-muted-foreground font-medium">
                      æ˜¾ç¤ºç¬¬ {((currentPage - 1) * 10) + 1} - {Math.min(currentPage * 10, totalHistory)} æ¡ï¼Œå…± {totalHistory} æ¡è®°å½•
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage - 1)}
                        disabled={currentPage <= 1}
                        className="h-8 px-3"
                      >
                        ä¸Šä¸€é¡µ
                      </Button>
                      <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                        {currentPage}
                      </div>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fetchSearchHistory(currentPage + 1)}
                        disabled={!hasMoreHistory || searchHistory.length === 0}
                        className="h-8 px-3"
                      >
                        ä¸‹ä¸€é¡µ
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* æ¸…ç©ºå†å²ç¡®è®¤å¯¹è¯æ¡† */}
        <Dialog open={showClearConfirm} onOpenChange={setShowClearConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>ç¡®è®¤æ¸…ç©ºå†å²</DialogTitle>
              <DialogDescription>
                ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æœç´¢è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowClearConfirm(false)}>
                å–æ¶ˆ
              </Button>
              <Button variant="destructive" onClick={confirmClearAllHistory}>
                ç¡®è®¤æ¸…ç©º
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  )
}

--- File: ./frontend/components/scraper-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { useApiCache } from "@/hooks/use-api-cache"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Copy, ChevronLeft, ChevronRight, Trash2, ImageIcon, Edit, X, Download, Loader2, List, Upload, Store, CheckSquare, Square, Search, ChevronDown, ChevronUp, Pause, Play, StopCircle } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { Checkbox } from "@/components/ui/checkbox"

export function ScraperView({ currentUser }: { currentUser: any }) {
  const [batchIds, setBatchIds] = useState('')
  const [isBatchScraping, setIsBatchScraping] = useState(false)
  const [batchProgress, setBatchProgress] = useState(0)
  const [products, setProducts] = useState<any[]>([])
  const [totalProducts, setTotalProducts] = useState(0)
  const [currentPage, setCurrentPage] = useState(1)
  const [jumpPage, setJumpPage] = useState("")
  const [itemsPerPage, setItemsPerPage] = useState(50)
  const [editingProduct, setEditingProduct] = useState<any>(null)
  const [selectedProducts, setSelectedProducts] = useState<number[]>([])
  const [selectAll, setSelectAll] = useState(false)
  const [indexedIds, setIndexedIds] = useState<string[]>([])
  const [shopFilter, setShopFilter] = useState('__ALL__')
  const [keywordSearch, setKeywordSearch] = useState('')
  const [isDeleting, setIsDeleting] = useState(false)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const [deletingProductId, setDeletingProductId] = useState<number | null>(null)
  // å›¾ç‰‡ä¸Šä¼  ref
  const uploadInputRef = useRef<HTMLInputElement>(null)
  const [isUploadingImg, setIsUploadingImg] = useState(false)
  const [productUrls, setProductUrls] = useState<{[key: number]: any[]}>({})
  const [expandedProducts, setExpandedProducts] = useState<Set<number>>(new Set())
  const [selectedFiles, setSelectedFiles] = useState<FileList | null>(null)
  const [batchUploading, setBatchUploading] = useState(false)

  // ä½¿ç”¨APIç¼“å­˜hook
  const { cachedFetch } = useApiCache()

  // æŠ“å–ç›¸å…³çŠ¶æ€
  const [shopId, setShopId] = useState('')
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [shopScrapeProgress, setShopScrapeProgress] = useState(0)
  const [scrapeStatus, setScrapeStatus] = useState<any>(null)
  const [availableShops, setAvailableShops] = useState<any[]>([])
  const [selectedShopId, setSelectedShopId] = useState('')
  const [totalProductsCount, setTotalProductsCount] = useState(0)
  // æœç´¢ç±»å‹çŠ¶æ€
  const [searchType, setSearchType] = useState<'all' | 'id' | 'keyword' | 'chinese'>('all')

  // ä¼˜åŒ–ï¼šåˆ†ç¦»ä¸åŒç±»å‹çš„åŠ è½½é€»è¾‘
  useEffect(() => {
    fetchIndexedIds()
    fetchAvailableShops()
    fetchProductsCount()
  }, []) // é™æ€æ•°æ®åªåŠ è½½ä¸€æ¬¡

  useEffect(() => {
    fetchProducts(currentPage)
  }, [currentPage, itemsPerPage, keywordSearch, shopFilter]) // åªåœ¨ç›¸å…³å‚æ•°æ”¹å˜æ—¶é‡æ–°åŠ è½½å•†å“

  useEffect(() => {
    // å½“æœç´¢æ¡ä»¶æ”¹å˜æ—¶ï¼Œé‡ç½®åˆ°ç¬¬ä¸€é¡µ
    if (keywordSearch || shopFilter) {
      setCurrentPage(1)
    }
  }, [keywordSearch, shopFilter])

  // ä¼˜åŒ–è½®è¯¢æœºåˆ¶ï¼šä½¿ç”¨æ™ºèƒ½è½®è¯¢ï¼Œé¿å…é‡å¤è¯·æ±‚
  useEffect(() => {
    let statusInterval: NodeJS.Timeout | null = null

    // å¦‚æœæ²¡æœ‰æŠ“å–ä»»åŠ¡ï¼Œå‡å°‘è½®è¯¢é¢‘ç‡åˆ°60ç§’ä¸€æ¬¡
    if (!isShopScraping && !isBatchScraping) {
      statusInterval = setInterval(() => {
        fetchScrapeStatus()
      }, 60000) // 60ç§’æ£€æŸ¥ä¸€æ¬¡çŠ¶æ€

      return () => {
        if (statusInterval) clearInterval(statusInterval)
      }
    }

    // å¦‚æœæœ‰æŠ“å–ä»»åŠ¡ï¼Œä½¿ç”¨æ›´æ™ºèƒ½çš„è½®è¯¢ç­–ç•¥
    let pollCount = 0
    statusInterval = setInterval(() => {
      pollCount++

      // æ€»æ˜¯æ£€æŸ¥æŠ“å–çŠ¶æ€
      fetchScrapeStatus()

      // åªæœ‰åœ¨æŠ“å–è¿›è¡Œä¸­æ—¶æ‰æ£€æŸ¥å•†å“æ•°é‡å’Œåˆ—è¡¨
      // å‰30ç§’ï¼ˆ15æ¬¡ï¼‰æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œåç»­æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
      if ((isShopScraping || isBatchScraping)) {
        if (pollCount <= 15) {
          fetchProductsCount()
          fetchProducts(currentPage)
        } else if (pollCount % 5 === 0) {
          // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡å•†å“æ•°é‡å’Œåˆ—è¡¨
          fetchProductsCount()
          fetchProducts(currentPage)
        }
      }
    }, 2000) // åŸºç¡€é—´éš”2ç§’

    return () => {
      if (statusInterval) {
        clearInterval(statusInterval)
      }
    }
  }, [isShopScraping, isBatchScraping])

  const fetchProducts = async (page: number = 1, append: boolean = false, usePreload: boolean = true) => {
    try {
      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰é¢„åŠ è½½æ•°æ®ï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡åŠ è½½ä¸”æœªè¿½åŠ æ—¶ï¼‰
      if (page === 1 && !append && usePreload) {
        const preloadData = sessionStorage.getItem('preload_products')
        if (preloadData) {
          try {
            console.log('ä½¿ç”¨é¢„åŠ è½½å•†å“æ•°æ®')
            const data = JSON.parse(preloadData)
            // ä½¿ç”¨é¢„åŠ è½½æ•°æ®
            const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
              ...product,
              id: product.id,
              shopName: product.shopName || product.shop_name || 'æœªçŸ¥åº—é“º',
              title: product.title || '',
              englishTitle: product.englishTitle || product.english_title || '',
              weidianUrl: product.weidianUrl || product.product_url || '',
              cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
              acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
              weidianId: product.weidianId || '',
              ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
              customReplyText: product.customReplyText || product.custom_reply_text || '',
              customReplyImages: product.customReplyImages || product.custom_reply_images || [],
              selectedImageIndexes: product.selectedImageIndexes || [],
              customImageUrls: product.customImageUrls || product.custom_image_urls || [],
              imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload')
            }))

            setProducts(processedProducts)
            setTotalProducts(data.total || 0)

            // æ¸…é™¤é¢„åŠ è½½æ•°æ®ï¼Œé¿å…é‡å¤ä½¿ç”¨
            sessionStorage.removeItem('preload_products')

            // åœ¨åå°è·å–æœ€æ–°æ•°æ®ï¼Œä½†ä¸æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            setTimeout(() => fetchProducts(1, false, false), 500)
            return
          } catch (e) {
            console.error('é¢„åŠ è½½æ•°æ®è§£æå¤±è´¥:', e)
            // é¢„åŠ è½½æ•°æ®æŸåï¼Œæ¸…é™¤å¹¶é‡æ–°è·å–
            sessionStorage.removeItem('preload_products')
          }
        } else {
          // å¦‚æœæ²¡æœ‰é¢„åŠ è½½æ•°æ®ï¼Œç­‰å¾…ä¸€ä¸‹å†è¯•ï¼ˆç»™é¢„åŠ è½½ä¸€ç‚¹æ—¶é—´ï¼‰
          if (page === 1 && !append) {
            setTimeout(() => {
              const retryPreload = sessionStorage.getItem('preload_products')
              if (retryPreload) {
                fetchProducts(1, false, true)
              } else {
                fetchProducts(1, false, false)
              }
            }, 200)
            return
          }
        }
      }

      console.log('ä»APIè·å–å•†å“æ•°æ®')
      const res = await fetch(`/api/products?page=${page}&limit=${itemsPerPage}`)
      const data = await res.json()

      // è°ƒè¯•ä¿¡æ¯
      console.log('å•†å“åˆ—è¡¨APIå“åº”:', {
        page,
        total: data.total,
        productsCount: data.products?.length || 0,
        debug: data.debug,
        firstProduct: data.products?.[0] ? {
          id: data.products[0].id,
          shopName: data.products[0].shopName || data.products[0].shop_name,
          title: data.products[0].title
        } : null
      })

      const processedProducts = (Array.isArray(data.products) ? data.products : []).map((product: any) => ({
        ...product,
        id: product.id,
        shopName: product.shopName || product.shop_name || 'æœªçŸ¥åº—é“º',
        title: product.title || '',
        englishTitle: product.englishTitle || product.english_title || '',
        weidianUrl: product.weidianUrl || product.product_url || '',
        cnfansUrl: product.cnfansUrl || product.cnfans_url || '',
        acbuyUrl: product.acbuyUrl || product.acbuy_url || '',
        weidianId: product.weidianId || '',
        ruleEnabled: product.ruleEnabled !== undefined ? product.ruleEnabled : true,
        customReplyText: product.customReplyText || product.custom_reply_text || '',
        customReplyImages: product.customReplyImages || product.custom_reply_images || [],
        selectedImageIndexes: product.selectedImageIndexes || [],
        customImageUrls: product.customImageUrls || product.custom_image_urls || [],
        imageSource: product.imageSource || product.image_source || (product.custom_image_urls ? 'custom' : 'upload'),
        uploadedImages: product.uploadedImages || []
      }))

      if (append) {
        // åˆ†é¡µåŠ è½½æ›´å¤š
        setProducts(prev => [...prev, ...processedProducts])
      } else {
        // é‡æ–°åŠ è½½ç¬¬ä¸€é¡µ
        setProducts(processedProducts)
      }

      setTotalProducts(data.total || 0)
    } catch (e) {
      toast.error("åŠ è½½å•†å“åº“å¤±è´¥")
    }
  }

  const fetchIndexedIds = async () => {
    try {
      const data = await cachedFetch('/api/scrape?type=indexed', { credentials: 'include' })
      setIndexedIds(data.indexedIds || [])
    } catch (e) {
      console.error('è·å–å·²ç´¢å¼•IDå¤±è´¥:', e)
    }
  }

  const fetchAvailableShops = async () => {
    try {
      const data = await cachedFetch('/api/shops')
      setAvailableShops(data.shops || [])
    } catch (e) {
      console.error('è·å–åº—é“ºåˆ—è¡¨å¤±è´¥:', e)
    }
  }

  const fetchProductsCount = async () => {
    try {
      const data = await cachedFetch('/api/products/count')
      setTotalProductsCount(data.count || 0)
    } catch (e) {
      console.error('è·å–å•†å“æ•°é‡å¤±è´¥:', e)
    }
  }

  const fetchScrapeStatus = async () => {
    try {
      const res = await fetch('/api/scrape/shop/status')
      if (res.ok) {
        const text = await res.text()
        if (text.trim()) {
          const status = JSON.parse(text)
          console.log('åº—é“ºæŠ“å–çŠ¶æ€æ›´æ–°:', status)
          setScrapeStatus(status)
          setIsShopScraping(status.is_scraping)
          setShopScrapeProgress(status.progress || 0)
          // å¦‚æœæŠ“å–å®Œæˆï¼Œåˆ·æ–°å•†å“åˆ—è¡¨
          if (!status.is_scraping && status.completed) {
            fetchProducts()
            fetchProductsCount()
          }
        }
      }
    } catch (e) {
      console.error('è·å–æŠ“å–çŠ¶æ€å¤±è´¥:', e)
      // é™é»˜å¤±è´¥
    }
  }

  // === é“¾æ¥ç”Ÿæˆé€»è¾‘ ===

  const getProductLinks = (product: any) => {
    const links = [
        { name: 'cnfans', display_name: 'CNFans', url: product.cnfansUrl, badge_color: 'blue' },
        { name: 'weidian', display_name: 'å¾®åº—', url: product.weidianUrl, badge_color: 'gray' },
        { name: 'acbuy', display_name: 'AcBuy', url: product.acbuyUrl, badge_color: 'orange' }
    ].filter(link => link.url && link.url.trim() !== '');

    // å¦‚æœæœ‰ä»åç«¯è·å–çš„é¢å¤–é“¾æ¥ï¼Œå¯ä»¥åˆå¹¶ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªç”¨ä¸Šé¢çš„ï¼‰
    return links;
  }

  // ... (ä¿ç•™ handleBatchDelete, confirmBatchDelete, handleUploadImage, handleBatchUploadImages) ...

  const handleBatchDelete = async () => {
    console.log('æ‰¹é‡åˆ é™¤æŒ‰é’®è¢«ç‚¹å‡»ï¼Œé€‰ä¸­å•†å“æ•°é‡:', selectedProducts.length)
    if (selectedProducts.length === 0) {
      console.log('æ²¡æœ‰é€‰ä¸­å•†å“ï¼Œè¿”å›')
      return
    }
    console.log('è®¾ç½®æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†')
    setShowDeleteConfirm(true)
  }

  const confirmBatchDelete = async () => {
    setShowDeleteConfirm(false)
    setIsDeleting(true)
    try {
      const res = await fetch(`/api/products?ids=${selectedProducts.join(',')}`, {
        method: 'DELETE',
        credentials: 'include'
      })
      if (res.ok) {
        toast.success("æ‰¹é‡åˆ é™¤æˆåŠŸ")
        setProducts(products.filter(p => !selectedProducts.includes(p.id)))
        setSelectedProducts([])
      } else {
        toast.error("æ‰¹é‡åˆ é™¤å¤±è´¥")
      }
    } catch (e) {
      toast.error("ç½‘ç»œé”™è¯¯")
    } finally {
      setIsDeleting(false)
    }
  }

  const handleUploadImage = async (productId: number, file: File) => {
    if (!file) return
    setIsUploadingImg(true)
    const formData = new FormData()
    formData.append('image', file)
    try {
      const res = await fetch(`/api/products/${productId}/images`, {
        method: 'POST',
        body: formData
      })
      if (res.ok) {
        const data = await res.json()
        setProducts(products.map(p => p.id === productId ? data.product : p))
        toast.success("å›¾ç‰‡ä¸Šä¼ æˆåŠŸ")
      } else {
        toast.error("ä¸Šä¼ å¤±è´¥")
      }
    } catch (e) {
      toast.error("ä¸Šä¼ å‡ºé”™")
    } finally {
      setIsUploadingImg(false)
    }
  }

  const handleBatchUploadImages = async (productId: number, files?: FileList | null) => {
    const filesToUpload = files || selectedFiles
    if (!filesToUpload || filesToUpload.length === 0) return
    setBatchUploading(true)
    let successCount = 0
    try {
      for (let i = 0; i < filesToUpload.length; i++) {
        const file = filesToUpload[i]
        const formData = new FormData()
        formData.append('image', file)
          const res = await fetch(`/api/products/${productId}/images`, {
            method: 'POST',
          body: formData
          })
        if (res.ok) successCount++
      }
      if (successCount > 0) {
        const productRes = await fetch(`/api/products/${productId}`) // Fix: fetch specific product if endpoint exists, else refresh all or return from API
        // Refresh products for simplicity
        fetchProducts();
      }
      toast.success(`ä¸Šä¼ å®Œæˆï¼š${successCount}å¼ å›¾ç‰‡`)
      setSelectedFiles(null)
    } catch (e) {
      toast.error('æ‰¹é‡ä¸Šä¼ é”™è¯¯')
    } finally {
      setBatchUploading(false)
    }
  }

  const handleSelectAll = () => {
    if (selectedProducts.length === currentProducts.length && currentProducts.length > 0) {
      setSelectedProducts([])
    } else {
      setSelectedProducts(currentProducts.map(p => p.id))
    }
  }

  const toggleProductExpansion = (productId: number) => {
    setExpandedProducts(prev => {
      const newSet = new Set(prev)
      if (newSet.has(productId)) newSet.delete(productId)
      else newSet.add(productId)
      return newSet
    })
  }

  const handleDeleteProduct = async (id: number) => {
    setDeletingProductId(id)
    setShowDeleteConfirm(true)
  }

  const confirmDeleteProduct = async () => {
    if (!deletingProductId) return

    setShowDeleteConfirm(false)

    // æ˜¾ç¤ºåˆ é™¤è¿›åº¦æç¤º
    toast.loading("æ­£åœ¨åˆ é™¤å•†å“...", { id: `delete-${deletingProductId}` })

    try {
      const response = await fetch(`/api/products/${deletingProductId}`, {
        method: 'DELETE',
        credentials: 'include'
      })

      if (response.ok) {
        setProducts(products.filter(p => p.id !== deletingProductId))
        setTotalProducts(totalProducts - 1)
        setSelectedProducts(selectedProducts.filter(pid => pid !== deletingProductId))
        toast.success("åˆ é™¤æˆåŠŸ", { id: `delete-${deletingProductId}` })
      } else {
        toast.error("åˆ é™¤å¤±è´¥", { id: `delete-${deletingProductId}` })
      }
    } catch (e) {
      toast.error("åˆ é™¤å¤±è´¥", { id: `delete-${deletingProductId}` })
    } finally {
      setDeletingProductId(null)
    }
  }

  const handleUpdateProduct = async (updatedProduct: any) => {
    try {
      let res;

      // æ£€æŸ¥æ˜¯å¦æœ‰ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶
      if (updatedProduct.uploadedImages && updatedProduct.uploadedImages.length > 0) {
        // ä½¿ç”¨FormDataå‘é€æ–‡ä»¶
        const formData = new FormData();

        // æ·»åŠ åŸºæœ¬æ•°æ®
        formData.append('id', updatedProduct.id.toString());
        if (updatedProduct.title) formData.append('title', updatedProduct.title);
        if (updatedProduct.englishTitle) formData.append('englishTitle', updatedProduct.englishTitle);
        if (updatedProduct.ruleEnabled !== undefined) formData.append('ruleEnabled', updatedProduct.ruleEnabled.toString());
        if (updatedProduct.customReplyText) formData.append('customReplyText', updatedProduct.customReplyText);
        if (updatedProduct.imageSource) formData.append('imageSource', updatedProduct.imageSource);

        // æ·»åŠ æ•°ç»„æ•°æ®ï¼ˆåºåˆ—åŒ–ä¸ºJSONï¼‰
        if (updatedProduct.selectedImageIndexes) {
          formData.append('selectedImageIndexes', JSON.stringify(updatedProduct.selectedImageIndexes));
        }
        if (updatedProduct.customImageUrls) {
          formData.append('customImageUrls', JSON.stringify(updatedProduct.customImageUrls));
        }

        // æ·»åŠ ä¸Šä¼ çš„æ–‡ä»¶
        updatedProduct.uploadedImages.forEach((file: File, index: number) => {
          formData.append('uploadedImages', file);
        });

        res = await fetch('/api/products', {
          method: 'PUT',
          credentials: 'include',
          body: formData
        });
      } else {
        // ä½¿ç”¨JSONå‘é€æ™®é€šæ•°æ®
        res = await fetch('/api/products', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(updatedProduct)
        });
      }

      if (res.ok) {
        const data = await res.json()
        setProducts(products.map(p => p.id === data.product.id ? data.product : p))
        setEditingProduct(null)
        toast.success("æ›´æ–°æˆåŠŸ")
      } else {
        const errorData = await res.json().catch(() => ({}));
        toast.error(errorData.error || "æ›´æ–°å¤±è´¥")
      }
    } catch (e) {
      console.error('Update error:', e);
      toast.error("æ›´æ–°å¤±è´¥")
    }
  }


  // ... (ä¿ç•™ handleScrapeShop, handleBatchScrape, handleJumpPage) ...

  const handleScrapeControl = async (action: 'stop') => {
    try {
      console.log(`ğŸ® å‘é€æŠ“å–æ§åˆ¶è¯·æ±‚: action=${action}`)
      const response = await fetch('/api/scrape/shop/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action
        })
      })

      if (response.ok) {
        const result = await response.json()
        console.log(`ğŸ® æ§åˆ¶APIå“åº”å†…å®¹:`, result)

        if (action === 'stop') {
          // ç«‹å³æ›´æ–°æœ¬åœ°çŠ¶æ€
          setIsShopScraping(false)
          setShopScrapeProgress(100)
          toast.success('æŠ“å–å·²åœæ­¢')

          // é‡æ–°è·å–çŠ¶æ€ç¡®è®¤
          setTimeout(() => {
            fetchScrapeStatus()
            fetchProductsCount()
            fetchProducts(currentPage)
          }, 1000)
        }
      } else {
        const errorText = await response.text()
        console.error(`æ§åˆ¶APIé”™è¯¯å“åº”:`, errorText)
        try {
          const errorData = JSON.parse(errorText)
          toast.error(errorData.error || `æ“ä½œå¤±è´¥: ${action}`)
        } catch {
          toast.error(`æ“ä½œå¤±è´¥: ${action}`)
        }
      }
    } catch (error) {
      console.error(`æ§åˆ¶è¯·æ±‚å¼‚å¸¸:`, error)
      toast.error(`æ“ä½œå¤±è´¥: ${action}`)
    }
  }

  const handleScrapeShop = async () => {
    if (!selectedShopId) {
      toast.error("è¯·é€‰æ‹©è¦æŠ“å–çš„åº—é“º")
      return
    }

    // ==========================================
    // ä¿®å¤ï¼šç«‹å³è®¾ç½®åŠ è½½çŠ¶æ€ï¼Œé˜²æ­¢UIé—ªçƒ
    // ==========================================
    setIsShopScraping(true)
    setShopScrapeProgress(0)
    setScrapeStatus(prev => ({
       ...prev,
       message: 'æ­£åœ¨å‘é€æŠ“å–è¯·æ±‚...'
    }))

    try {
      const response = await fetch('/api/scrape/shop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shopId: selectedShopId })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success(`æŠ“å–æŒ‡ä»¤å·²å‘é€`)
        // ä¸éœ€è¦åœ¨è¿™é‡Œ setProductsï¼Œå› ä¸ºè½®è¯¢ä¼šè‡ªåŠ¨æ›´æ–°
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || "è¯·æ±‚è¢«æ‹’ç»")

        // åªæœ‰è¯·æ±‚å¤±è´¥æ—¶ï¼Œæ‰æŠŠçŠ¶æ€æ”¹å›å»
        setIsShopScraping(false)
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•è¿æ¥æœåŠ¡å™¨")
      setIsShopScraping(false)
    }
    // æ³¨æ„ï¼šè¿™é‡Œä¸è¦åŠ  finally { setIsShopScraping(false) }
    // å› ä¸ºæŠ“å–æ˜¯å¼‚æ­¥çš„é•¿ä»»åŠ¡ï¼Œè¯·æ±‚ç»“æŸä¸ä»£è¡¨æŠ“å–ç»“æŸã€‚
    // çŠ¶æ€åº”è¯¥ç”± useEffect é‡Œçš„è½®è¯¢æ¥å†³å®šä½•æ—¶å˜å› falseã€‚
  }

  const handleBatchScrape = async () => {
    const ids = batchIds.split('\n').map(id => id.trim()).filter(id => id && id.match(/^\d+$/))
    if (ids.length === 0) {
      toast.error("è¯·è¾“å…¥æœ‰æ•ˆçš„å•†å“ID")
      return
    }

    console.log('å¼€å§‹æ‰¹é‡ä¸Šä¼ ï¼Œå•†å“æ•°é‡:', ids.length)
    setIsBatchScraping(true)
    setBatchProgress(0)

    try {
      console.log(`å‘é€æ‰¹é‡è¯·æ±‚åˆ° /api/scrape/batchï¼Œå•†å“æ•°é‡: ${ids.length}`)

      // è°ƒç”¨æ–°çš„æ‰¹é‡API
      const res = await fetch('/api/scrape/batch', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ productIds: ids }),
        signal: AbortSignal.timeout(300000) // 5åˆ†é’Ÿè¶…æ—¶ï¼ˆæ‰¹é‡å¤„ç†éœ€è¦æ›´é•¿æ—¶é—´ï¼‰
      })

      console.log(`æ”¶åˆ°æ‰¹é‡å“åº”ï¼ŒçŠ¶æ€ç : ${res.status}`)

      if(res.ok) {
        const result = await res.json()
        console.log('æ‰¹é‡å¤„ç†ç»“æœ:', result)

        // ä»ç»“æœä¸­æå–ç»Ÿè®¡ä¿¡æ¯
        const results = result.results || {}
        const successCount = results.success || 0
        const skipCount = results.skipped || 0
        const cancelledCount = results.cancelled || 0
        const partialCount = results.partial || 0
        const errorCount = results.errors || 0

        // æ„å»ºç»“æœæ¶ˆæ¯
        let messageParts = []
        if (successCount > 0) messageParts.push(`æˆåŠŸ ${successCount}`)
        if (skipCount > 0) messageParts.push(`è·³è¿‡ ${skipCount}`)
        if (cancelledCount > 0) messageParts.push(`å–æ¶ˆ ${cancelledCount}`)
        if (partialCount > 0) messageParts.push(`éƒ¨åˆ†å®Œæˆ ${partialCount}`)
        if (errorCount > 0) messageParts.push(`å¤±è´¥ ${errorCount}`)

        const message = messageParts.length > 0 ? messageParts.join(', ') : 'æ— ç»“æœ'

        toast.success(`æ‰¹é‡ä¸Šä¼ å®Œæˆ: ${message}`)
        console.log('æ‰¹é‡ä¸Šä¼ å®Œæˆ')

        // æ˜¾ç¤ºå¤„ç†æ—¶é—´
        if (results.duration) {
          console.log(`å¤„ç†æ—¶é—´: ${results.duration.toFixed(2)} ç§’`)
        }
      } else {
        const errorText = await res.text()
        console.error('æ‰¹é‡ä¸Šä¼ å¤±è´¥:', res.status, errorText)
        toast.error(`æ‰¹é‡ä¸Šä¼ å¤±è´¥: ${errorText}`)
      }

      setBatchProgress(100)

      // å¼ºåˆ¶åˆ·æ–°æ•°æ®
      fetchProducts()
      fetchProductsCount()

      // å¼ºåˆ¶åˆ·æ–°æŠ“å–çŠ¶æ€ï¼Œç¡®ä¿UIæ­£ç¡®æ›´æ–°
      setTimeout(() => fetchScrapeStatus(), 100)

      setBatchIds('')
    } catch(e) {
      console.error('æ‰¹é‡ä¸Šä¼ å‡ºç°é”™è¯¯:', e)
      if (e.name === 'TimeoutError') {
        toast.error("æ‰¹é‡ä¸Šä¼ è¶…æ—¶ï¼Œè¯·å‡å°‘å•†å“æ•°é‡æˆ–ç¨åé‡è¯•")
      } else {
        toast.error("æ‰¹é‡ä¸Šä¼ å¤±è´¥")
      }
    } finally {
      console.log('è®¾ç½® isBatchScraping ä¸º false')
      setIsBatchScraping(false)
    }
  }

  const handleJumpPage = () => { /* ... */ }

  // ç­›é€‰å’Œåˆ†é¡µé€»è¾‘ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½è¿‡å¤šæ•°æ®ï¼‰
  const uniqueShops = Array.from(new Set(products.map(p => p?.shopName || '').filter(name => name && name.trim()))).sort()

  // ç®€åŒ–åˆ†é¡µï¼šç›´æ¥ä½¿ç”¨å½“å‰é¡µçš„äº§å“æ•°æ®ï¼Œä¸å†è¿›è¡Œå¤æ‚çš„å†…å­˜ç­›é€‰
  // è¿™æ ·å¯ä»¥æ˜¾è‘—æå‡åŠ è½½é€Ÿåº¦ï¼Œä½†æš‚æ—¶ä¸æ”¯æŒè·¨é¡µæœç´¢
  const currentProducts = products.filter(p => {
    // åªæœ‰åœ¨æ²¡æœ‰æœç´¢æ¡ä»¶æ—¶æ‰æ˜¾ç¤ºå½“å‰é¡µæ•°æ®
    if (!keywordSearch && !shopFilter) {
      return true
    }

    // æœ‰æœç´¢æ¡ä»¶æ—¶ï¼Œå¯¹å½“å‰åŠ è½½çš„æ•°æ®è¿›è¡Œç­›é€‰
    let matchesSearch = true
    if (keywordSearch) {
      if (searchType === 'id') {
        matchesSearch = p.weidianId?.includes(keywordSearch)
      } else if (searchType === 'keyword') {
        matchesSearch = p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else if (searchType === 'chinese') {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase())
      } else {
        matchesSearch = p.title?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.englishTitle?.toLowerCase().includes(keywordSearch.toLowerCase()) ||
        p.weidianId?.includes(keywordSearch)
      }
    }
    const matchesShop = !shopFilter || shopFilter === "__ALL__" || p.shopName === shopFilter
    return matchesSearch && matchesShop
  })

  // è®¡ç®—æ€»é¡µæ•°ï¼ˆåŸºäºæ€»æ•°ï¼‰
  const totalPages = Math.ceil(totalProducts / itemsPerPage)

  return (
    <div className="space-y-8">
      {/* ... é¡¶éƒ¨æ ‡é¢˜å’Œç®¡ç†å‘˜/æ™®é€šç”¨æˆ·ä¸Šä¼ åŒºåŸŸ (ä¿æŒä¸å˜) ... */}

      <div>
        <h2 className="text-3xl font-bold tracking-tight">å¾®åº—æŠ“å–</h2>
        <p className="text-muted-foreground">å•†å“ç®¡ç†ä¸æŠ“å–</p>
      </div>

      {(currentUser?.role === 'admin' || (currentUser?.shops && currentUser.shops.length > 0)) ? (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
             {/* Shop Scrape Card */}
        <Card className="border-2 border-dashed border-purple-300/50 hover:border-purple-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-purple-100 rounded-xl"><Store className="h-6 w-6 text-purple-600"/></div>
                            <div><h4 className="text-xl font-bold">åº—é“ºå•†å“æŠ“å–</h4><p className="text-sm text-muted-foreground">è¾“å…¥åº—é“ºID</p></div>
                </div>
                        <div className="space-y-3">
                <div>
                                <Label className="text-sm">é€‰æ‹©åº—é“º</Label>
                                <Select value={selectedShopId} onValueChange={setSelectedShopId} disabled={isShopScraping}>
                                    <SelectTrigger className="w-full">
                                        <SelectValue placeholder="è¯·é€‰æ‹©è¦æŠ“å–çš„åº—é“º" />
                                    </SelectTrigger>
                                    <SelectContent>
                                        {availableShops.map((shop) => (
                                            <SelectItem key={shop.shop_id} value={shop.shop_id}>
                                                {shop.name} (ID: {shop.shop_id})
                                            </SelectItem>
                                        ))}
                                    </SelectContent>
                                </Select>
                </div>
                            {!isShopScraping ? (
                              <Button onClick={handleScrapeShop} disabled={!selectedShopId} className="w-full">
                                æŠ“å–åº—é“º
                              </Button>
                            ) : (
                              <Button
                                variant="destructive"
                                size="sm"
                                onClick={() => handleScrapeControl('stop')}
                                className="w-full"
                              >
                                <StopCircle className="w-4 h-4 mr-2" />
                                å–æ¶ˆæŠ“å–
                              </Button>
                            )}
              </div>
            </div>
          </CardContent>
        </Card>
             {/* Batch Scrape Card */}
        <Card className="border-2 border-dashed border-green-300/50 hover:border-green-400 transition-colors">
          <CardContent className="p-6">
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                            <div className="p-3 bg-green-100 rounded-xl"><List className="h-6 w-6 text-green-600"/></div>
                            <div><h4 className="text-xl font-bold">æ‰¹é‡ä¸Šä¼ </h4><p className="text-sm text-muted-foreground">è¾“å…¥å•†å“ID</p></div>
                </div>
              <div className="space-y-3">
                            <textarea placeholder="æ¯è¡Œä¸€ä¸ªID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-32 p-4 text-sm border-2 rounded-lg resize-none"/>
                            <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">
                                {isBatchScraping ? "ä¸Šä¼ ä¸­..." : `æ‰¹é‡ä¸Šä¼ `}
                  </Button>
              </div>
            </div>
          </CardContent>
        </Card>
        </div>
      ) : (
          /* User View - æ™®é€šç”¨æˆ·åªèƒ½çœ‹åˆ°æ‰¹é‡ä¸Šä¼  */
        <div className="max-w-2xl mx-auto">
             <Card className="border-2 border-dashed border-green-300/50">
            <CardContent className="p-8">
                    <div className="space-y-4">
                  <h4 className="text-2xl font-bold mb-2">æ‰¹é‡å•†å“ä¸Šä¼ </h4>
                        <textarea id="batch-ids" placeholder="æ¯è¡Œä¸€ä¸ªID" value={batchIds} onChange={e=>setBatchIds(e.target.value)} className="w-full h-40 p-4 border-2 rounded-lg"/>
                        <Button onClick={handleBatchScrape} disabled={!batchIds.trim() || isBatchScraping} className="w-full">æ‰¹é‡ä¸Šä¼ </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Progress Bar - åªæ˜¾ç¤ºæ‰¹é‡æŠ“å–è¿›åº¦ */}
      {isBatchScraping && (
        <div className="space-y-3">
          <Progress value={batchProgress} className="h-3" />
          <p className="text-center text-sm text-muted-foreground">{batchProgress.toFixed(1)}%</p>
        </div>
      )}

      {/* Product List */}
      <div className="space-y-4">
        <Card className="shadow-sm">
            <CardHeader className="py-4 border-b">
                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div className="flex flex-col gap-1">
                        <CardTitle className="text-xl font-bold">
                          å•†å“åº“{isShopScraping ? ' - æŠ“å–ä¸­...' : ''}
                        </CardTitle>
            </div>
                    <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center w-full sm:w-auto">
                        {/* æœç´¢æ§ä»¶ */}
                        <div className="flex gap-2 flex-1 sm:flex-initial">
                <div className="relative">
                                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                                    placeholder={
                                        searchType === 'id' ? 'è¾“å…¥å•†å“ID...' :
                                        searchType === 'keyword' ? 'è¾“å…¥è‹±æ–‡å…³é”®è¯...' :
                                        searchType === 'chinese' ? 'è¾“å…¥ä¸­æ–‡å…³é”®è¯...' :
                                        'è¾“å…¥å•†å“æ ‡é¢˜ã€ä¸­æ–‡å…³é”®è¯ã€è‹±æ–‡å…³é”®è¯æˆ–ID...'
                                    }
                    value={keywordSearch}
                                    onChange={e=>setKeywordSearch(e.target.value)}
                                    className="pl-10 h-9 w-full sm:w-[400px]"
                  />
                </div>
                            <Select value={searchType} onValueChange={(value: 'all' | 'id' | 'keyword' | 'chinese') => setSearchType(value)}>
                                <SelectTrigger className="h-9 w-28">
                                    <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="all">å…¨éƒ¨</SelectItem>
                                    <SelectItem value="id">æŒ‰ID</SelectItem>
                                    <SelectItem value="keyword">è‹±æ–‡å…³é”®è¯</SelectItem>
                                    <SelectItem value="chinese">ä¸­æ–‡å…³é”®è¯</SelectItem>
                                </SelectContent>
                            </Select>
                  <Select value={shopFilter} onValueChange={setShopFilter}>
                                <SelectTrigger className="h-9 w-32">
                                    <SelectValue placeholder="å…¨éƒ¨åº—é“º" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__ALL__">å…¨éƒ¨åº—é“º</SelectItem>
                                    {uniqueShops.map(s=><SelectItem key={s} value={s}>{s}</SelectItem>)}
                    </SelectContent>
                  </Select>
              <Select value={itemsPerPage.toString()} onValueChange={(v) => {
                setItemsPerPage(parseInt(v))
                setCurrentPage(1)
              }}>
                                <SelectTrigger className="h-9 w-24">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                                    <SelectItem value="20">20ä¸ª/é¡µ</SelectItem>
                                    <SelectItem value="50">50ä¸ª/é¡µ</SelectItem>
                                    <SelectItem value="100">100ä¸ª/é¡µ</SelectItem>
                                    <SelectItem value="200">200ä¸ª/é¡µ</SelectItem>
                </SelectContent>
              </Select>
            </div>
                        {/* æ“ä½œæŒ‰é’® */}
                        <div className="flex items-center gap-3">
                            <Button variant={selectedProducts.length===currentProducts.length && currentProducts.length>0?"secondary":"outline"} size="sm" onClick={handleSelectAll}>
                                {selectedProducts.length===currentProducts.length && currentProducts.length>0 ? <CheckSquare className="mr-2 h-4 w-4"/> : <Square className="mr-2 h-4 w-4"/>} å…¨é€‰ ({currentProducts.length})
            </Button>
                            {selectedProducts.length > 0 && (
                                <Button variant="destructive" size="sm" onClick={handleBatchDelete} disabled={isDeleting}>
                                    <Trash2 className="mr-2 h-4 w-4" /> åˆ é™¤ ({selectedProducts.length})
                                </Button>
                            )}
          </div>
              </div>
            </div>
            </CardHeader>
            <CardContent className="p-0">
                {/* åˆ—è¡¨ */}
          <div className="divide-y">
                    {currentProducts.map((product) => {
                        const links = getProductLinks(product);
                        const showAllLinks = expandedProducts.has(product.id);
                        const displayedLinks = showAllLinks ? links : links.slice(0, 3);
                        return (
              <div key={product.id} className="flex flex-col lg:flex-row lg:items-center justify-between p-2 hover:bg-muted/20 transition-colors gap-3">
                <div className="flex gap-3 items-center">
                                <Checkbox checked={selectedProducts.includes(product.id)} onCheckedChange={(checked)=>{
                                    if(checked) setSelectedProducts([...selectedProducts, product.id])
                                    else setSelectedProducts(selectedProducts.filter(id=>id!==product.id))
                                }}/>
                </div>

                            {/* å›¾ç‰‡ä¸åŸºæœ¬ä¿¡æ¯ */}
                <div className="flex gap-3 items-center flex-1">
                                {/* å›¾ç‰‡å¼¹çª— (ä¿æŒåŸé€»è¾‘) */}
                  <Dialog>
                    <DialogTrigger asChild>
                                        <Button variant="ghost" className="size-10 p-0 rounded bg-muted flex items-center justify-center flex-shrink-0 border shadow-sm">
                        {product.images && product.images.length > 0 ? (
                                                <img src={product.images[0]} alt="thumb" className="object-cover w-12 h-12 rounded-md" />
                                            ) : <ImageIcon className="size-4 text-muted-foreground" />}
                      </Button>
                    </DialogTrigger>
                    <DialogContent className="max-w-4xl">
                      <DialogHeader>
                        <DialogTitle className="text-xl">å•†å“å›¾é›† - {product.weidianId}</DialogTitle>
                        <div className="flex gap-2 mt-2">
                          <input
                            type="file"
                            accept="image/*"
                            multiple
                            className="hidden"
                            id={`upload-${product.id}`}
                            onChange={(e) => {
                              const files = (e.target as HTMLInputElement).files
                              if (files && files.length > 0) {
                                handleBatchUploadImages(product.id, files)
                              }
                            }}
                          />
                          <label htmlFor={`upload-${product.id}`}>
                            <Button size="sm" disabled={isUploadingImg || batchUploading} asChild>
                              <span className="cursor-pointer">
                                <Upload className="mr-2 h-4 w-4" />
                                {isUploadingImg || batchUploading ? "ä¸Šä¼ ä¸­..." : "æ·»åŠ å›¾ç‰‡"}
                              </span>
                            </Button>
                          </label>
                        </div>
                      </DialogHeader>
                      <ScrollArea className="max-h-[70vh] mt-4">
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-1">
                          {product.images?.map((img: string, idx: number) => (
                            <div key={img} className="aspect-square rounded-xl border-2 bg-muted overflow-hidden group relative">
                              <img src={img} alt={`Img ${idx}`} className="object-cover w-full h-full transition-transform group-hover:scale-110" />
                              <button
                                                            onClick={async (e) => {
                                                                e.preventDefault()
                                                                e.stopPropagation()
                                                                try {
                                                                    // ä»å›¾ç‰‡URLä¸­æå–image_index
                                                                    // URLæ ¼å¼: /api/image/{product_id}/{image_index}
                                                                    const urlParts = img.split('/')
                                                                    const imageIndex = urlParts[urlParts.length - 1] // è·å–æœ€åä¸€ä¸ªéƒ¨åˆ†

                                                                    // éªŒè¯imageIndexæ˜¯å¦ä¸ºæœ‰æ•ˆæ•°å­—
                                                                    if (!imageIndex || isNaN(Number(imageIndex))) {
                                                                        toast.error("æ— æ³•ç¡®å®šè¦åˆ é™¤çš„å›¾ç‰‡")
                                                                        return
                                                                    }

                                                                    const res = await fetch(`/api/products/${product.id}/images/${imageIndex}`, {
                                                                        method: 'DELETE'
                                  })
                                  if (res.ok) {
                                    const data = await res.json()
                                                                        // æ›´æ–°äº§å“çŠ¶æ€ï¼Œæ›¿æ¢æ•´ä¸ªäº§å“å¯¹è±¡
                                                                        setProducts(prevProducts =>
                                                                            prevProducts.map(p =>
                                                                                p.id === product.id ? { ...data.product } : p
                                                                            )
                                                                        )
                                                                        toast.success("å›¾ç‰‡å·²åˆ é™¤")
                                  } else {
                                                                        const errorData = await res.json().catch(() => ({ error: 'Delete failed' }))
                                                                        toast.error(errorData.error || "åˆ é™¤å¤±è´¥")
                                                                        console.error('Delete failed:', errorData)
                                                                    }
                                                                } catch (error) {
                                                                    console.error('Delete image error:', error)
                                                                    toast.error("ç½‘ç»œé”™è¯¯ï¼Œåˆ é™¤å¤±è´¥")
                                  }
                                }}
                                                            className="absolute top-1 right-1 p-1 bg-red-500 rounded-full text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 shadow-lg z-10"
                              >
                                <X className="size-3" />
                              </button>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </DialogContent>
                  </Dialog>
                  <div className="space-y-0.5 min-w-0 flex-1">
                    <div className="flex items-center gap-2">
                                        <h4 className="font-bold text-base truncate">{product.title}</h4>
                                        {/* å·²åˆ é™¤è¿™é‡ŒåŸæœ¬çš„å°ç¼–è¾‘æŒ‰é’® */}
                                        {indexedIds.includes(product.weidianId) && <Badge className="bg-blue-600 text-[10px] h-4 px-2">å·²ç´¢å¼•</Badge>}
                                        {product.ruleEnabled && <Badge className="bg-purple-600 text-[10px] h-4 px-2">è§„åˆ™å¯ç”¨</Badge>}
                    </div>
                    <div className="flex items-center gap-2 mt-1">
                                        <p className="text-sm font-bold text-blue-600 truncate">{product.englishTitle || "No English Title"}</p>
                    </div>
                                    <div className="flex items-center gap-2 mt-1 text-[11px] text-muted-foreground">
                                        <span className="font-mono">ID: {product.weidianId}</span>
                                        <span>|</span>
                                        <span>åº—é“º: {product.shopName}</span>
                                        <span>|</span>
                                        <span>{product.images?.length || 0}å¼ å›¾ç‰‡</span>
                      {((product.createdAt) || (product.created_at)) && (
                                            <>
                                                <span>|</span>
                                                <span>åˆ›å»º: {(() => {
                          try {
                            const date = new Date(product.createdAt || product.created_at);
                            return isNaN(date.getTime()) ? 'æœªçŸ¥æ—¶é—´' : date.toLocaleString('zh-CN');
                          } catch {
                            return 'æœªçŸ¥æ—¶é—´';
                          }
                        })()}</span>
                                            </>
                      )}
                    </div>
                  </div>
                </div>
                            {/* é“¾æ¥æ˜¾ç¤ºåŒºåŸŸ */}
                <div className="flex items-center gap-4">
                                <div className="flex flex-col gap-1 min-w-0 flex-1 max-w-md">
                                    {displayedLinks.map((link) => (
                      <div key={link.name} className="flex items-center gap-1.5">
                                            <Badge className={`text-[9px] px-1 py-0 h-4 border-none w-12 justify-center shrink-0 text-white ${
                          link.badge_color === 'blue' ? 'bg-blue-600' :
                          link.badge_color === 'green' ? 'bg-green-600' :
                                                link.badge_color === 'orange' ? 'bg-orange-600' : 'bg-gray-600'
                                            }`}>{link.display_name}</Badge>
                        <div className="flex-1 bg-muted/30 p-0.5 px-2 rounded border text-[10px] flex items-center justify-between overflow-hidden">
                                                <a href={link.url} target="_blank" className="font-mono truncate hover:underline text-muted-foreground">{link.url}</a>
                                                <Button variant="ghost" size="icon" className="h-4 w-4" onClick={()=>{navigator.clipboard.writeText(link.url); toast.success("Copied")}}><Copy className="h-2.5 w-2.5"/></Button>
                        </div>
                      </div>
                    ))}
                                    {links.length > 3 && (
                                        <Button variant="ghost" size="sm" className="h-5 text-xs w-full" onClick={()=>toggleProductExpansion(product.id)}>
                                            {showAllLinks ? <ChevronUp className="h-3 w-3"/> : <ChevronDown className="h-3 w-3"/>}
                                            {showAllLinks ? "æ”¶èµ·" : `æ˜¾ç¤ºæ›´å¤š (${links.length - 3})`}
                      </Button>
                    )}
                  </div>
                                {/* æ“ä½œæŒ‰é’®ç»„ */}
                                <div className="flex items-center gap-1">
                                    {/* ç¼–è¾‘æŒ‰é’® */}
                                    <Dialog open={editingProduct?.id === product.id} onOpenChange={(open)=>!open && setEditingProduct(null)}>
                      <DialogTrigger asChild>
                                            <Button variant="outline" size="icon" className="h-8 w-8" onClick={()=>setEditingProduct(product)}>
                                                <Edit className="size-3.5"/>
                        </Button>
                      </DialogTrigger>
                                        <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
                        <DialogHeader>
                                                <DialogTitle>ç¼–è¾‘å•†å“ä¸è§„åˆ™ - {product.weidianId}</DialogTitle>
                          <DialogDescription>é…ç½®å•†å“ä¿¡æ¯å’Œè‡ªåŠ¨å›å¤è§„åˆ™</DialogDescription>
                        </DialogHeader>

                                            <div className="space-y-6 py-4">
                          <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                              <Label>å•†å“åç§° (ä¸­æ–‡)</Label>
                              <Input value={editingProduct?.title || ""} onChange={(e) => setEditingProduct({...editingProduct, title: e.target.value})} />
                            </div>
                            <div className="space-y-2">
                              <Label>è‹±æ–‡å…³é”®è¯</Label>
                              <Input value={editingProduct?.englishTitle || ""} onChange={(e) => setEditingProduct({...editingProduct, englishTitle: e.target.value})} />
                            </div>
                          </div>
                          <div className="flex items-center justify-between p-4 border rounded-lg bg-muted/30">
                            <div className="space-y-1">
                              <Label className="text-sm font-bold">å¯ç”¨è‡ªåŠ¨å›å¤è§„åˆ™</Label>
                                                        <p className="text-xs text-muted-foreground">å½“æ£€æµ‹åˆ°å…³é”®è¯æ—¶è‡ªåŠ¨å‘é€é“¾æ¥</p>
                            </div>
                                                    <Switch checked={editingProduct?.ruleEnabled || false} onCheckedChange={(c) => setEditingProduct({...editingProduct, ruleEnabled: c})} />
                          </div>

                          {/* è‡ªå®šä¹‰å›å¤è®¾ç½® - å½“è‡ªåŠ¨å›å¤è§„åˆ™å…³é—­æ—¶æ˜¾ç¤º */}
                          {!editingProduct?.ruleEnabled && (
                            <div className="space-y-4 p-4 border rounded-lg bg-blue-50/30">
                              <div className="space-y-2">
                                <Label className="text-sm font-medium">è‡ªå®šä¹‰å›å¤æ¶ˆæ¯</Label>
                                <Textarea
                                  value={editingProduct?.customReplyText || ""}
                                  onChange={(e) => setEditingProduct({...editingProduct, customReplyText: e.target.value})}
                                  placeholder="è¾“å…¥è‡ªå®šä¹‰å›å¤æ¶ˆæ¯å†…å®¹..."
                                  rows={3}
                                />
                                <p className="text-xs text-muted-foreground">ç•™ç©ºåˆ™ä¸å‘é€æ–‡æœ¬æ¶ˆæ¯</p>
                              </div>

                              <div className="space-y-2">
                                <Label className="text-sm font-medium">é€‰æ‹©å›å¤å›¾ç‰‡æ¥æº</Label>
                                <div className="flex flex-wrap gap-4">
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'product'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'product'})}
                                    />
                                    <span className="text-sm">é€‰æ‹©ç°æœ‰å›¾ç‰‡</span>
                                  </label>
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'upload'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'upload'})}
                                    />
                                    <span className="text-sm">æœ¬åœ°ä¸Šä¼ æ–°å›¾ç‰‡</span>
                                  </label>
                                  <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                      type="radio"
                                      name="imageSource"
                                      checked={editingProduct?.imageSource === 'custom'}
                                      onChange={() => setEditingProduct({...editingProduct, imageSource: 'custom'})}
                                    />
                                    <span className="text-sm">ä½¿ç”¨å›¾ç‰‡é“¾æ¥</span>
                                  </label>
                                </div>
                              </div>

                              {editingProduct?.imageSource === 'product' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">é€‰æ‹©ç°æœ‰å›¾ç‰‡ (å¤šé€‰)</Label>
                                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3 max-h-60 overflow-y-auto">
                                    {editingProduct?.images?.map((image: any, index: number) => (
                                      <div
                                        key={index}
                                        className={`relative border-2 rounded-lg overflow-hidden cursor-pointer transition-all ${
                                          editingProduct?.selectedImageIndexes?.includes(index)
                                            ? 'border-blue-500 bg-blue-50'
                                            : 'border-gray-200 hover:border-gray-300'
                                        }`}
                                        onClick={() => {
                                          const selectedIndexes = editingProduct?.selectedImageIndexes || [];
                                          const newIndexes = selectedIndexes.includes(index)
                                            ? selectedIndexes.filter((i: number) => i !== index)
                                            : [...selectedIndexes, index];
                                          setEditingProduct({...editingProduct, selectedImageIndexes: newIndexes});
                                        }}
                                      >
                                        <img
                                          src={`/api/products/${editingProduct.id}/images/${index}`}
                                          alt={`å›¾ç‰‡ ${index + 1}`}
                                          className="w-full h-20 object-cover"
                                        />
                                        {editingProduct?.selectedImageIndexes?.includes(index) && (
                                          <div className="absolute inset-0 bg-blue-500/20 flex items-center justify-center">
                                            <div className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold">
                                              âœ“
                                            </div>
                                          </div>
                                        )}
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                          å›¾ç‰‡ {index + 1}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                  {(!editingProduct?.images || editingProduct.images.length === 0) && (
                                    <div className="text-center py-8 text-muted-foreground text-sm border-2 border-dashed border-gray-200 rounded-lg">
                                      æ­¤å•†å“æš‚æ— å›¾ç‰‡
                                    </div>
                                  )}
                                  <p className="text-xs text-muted-foreground">
                                    å·²é€‰æ‹© {editingProduct?.selectedImageIndexes?.length || 0} å¼ å›¾ç‰‡ç”¨äºå›å¤
                                  </p>
                                </div>
                              ) : editingProduct?.imageSource === 'upload' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">æœ¬åœ°ä¸Šä¼ å›¾ç‰‡</Label>
                                  <div className="space-y-3">
                                    <input
                                      type="file"
                                      multiple
                                      accept="image/*"
                                      onChange={(e) => {
                                        const files = Array.from(e.target.files || []);
                                        setEditingProduct({...editingProduct, uploadedImages: files});
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    />
                                    {editingProduct?.uploadedImages && editingProduct.uploadedImages.length > 0 && (
                                      <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                                        {editingProduct.uploadedImages.map((file: File, index: number) => (
                                          <div key={index} className="relative border rounded-lg overflow-hidden">
                                            <img
                                              src={URL.createObjectURL(file)}
                                              alt={`ä¸Šä¼ å›¾ç‰‡ ${index + 1}`}
                                              className="w-full h-20 object-cover"
                                            />
                                            <button
                                              type="button"
                                              onClick={() => {
                                                const newFiles = editingProduct.uploadedImages.filter((_: File, i: number) => i !== index);
                                                setEditingProduct({...editingProduct, uploadedImages: newFiles});
                                              }}
                                              className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs"
                                            >
                                              Ã—
                                            </button>
                                            <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                              {file.name}
                                            </div>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                  <p className="text-xs text-muted-foreground">
                                    é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ åˆ°å•†å“ä¸­ï¼Œæ”¯æŒå¤šé€‰
                                  </p>
                                </div>
                              ) : editingProduct?.imageSource === 'custom' ? (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥</Label>
                                  <Input
                                    value={editingProduct?.customImageUrls?.join('\n') || ""}
                                    onChange={(e) => {
                                      const urls = e.target.value.split('\n').filter(url => url.trim());
                                      setEditingProduct({...editingProduct, customImageUrls: urls});
                                    }}
                                    placeholder="æ¯è¡Œä¸€ä¸ªå›¾ç‰‡é“¾æ¥&#10;https://example.com/image1.jpg&#10;https://example.com/image2.jpg"
                                    className="min-h-20"
                                  />
                                  <p className="text-xs text-muted-foreground">
                                    æ¯è¡Œä¸€ä¸ªå›¾ç‰‡é“¾æ¥ï¼Œæœ€å¤šæ”¯æŒ10ä¸ªé“¾æ¥
                                  </p>
                                </div>
                              ) : (
                                <div className="space-y-2">
                                  <Label className="text-sm font-medium">é€‰æ‹©å•†å“å›¾ç‰‡ (å¤šé€‰)</Label>
                                  <div className="grid grid-cols-2 md:grid-cols-3 gap-3 max-h-60 overflow-y-auto">
                                    {editingProduct?.images?.map((image: any, index: number) => (
                                      <div
                                        key={index}
                                        className={`relative border-2 rounded-lg overflow-hidden cursor-pointer transition-all ${
                                          editingProduct?.selectedImageIndexes?.includes(index)
                                            ? 'border-blue-500 bg-blue-50'
                                            : 'border-gray-200 hover:border-gray-300'
                                        }`}
                                        onClick={() => {
                                          const selectedIndexes = editingProduct?.selectedImageIndexes || [];
                                          const newIndexes = selectedIndexes.includes(index)
                                            ? selectedIndexes.filter((i: number) => i !== index)
                                            : [...selectedIndexes, index];
                                          setEditingProduct({...editingProduct, selectedImageIndexes: newIndexes});
                                        }}
                                      >
                                        <img
                                          src={`/api/products/${editingProduct.id}/images/${index}`}
                                          alt={`å›¾ç‰‡ ${index + 1}`}
                                          className="w-full h-20 object-cover"
                                        />
                                        {editingProduct?.selectedImageIndexes?.includes(index) && (
                                          <div className="absolute inset-0 bg-blue-500/20 flex items-center justify-center">
                                            <div className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold">
                                              âœ“
                                            </div>
                                          </div>
                                        )}
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1">
                                          å›¾ç‰‡ {index + 1}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                  {(!editingProduct?.images || editingProduct.images.length === 0) && (
                                    <div className="text-center py-8 text-muted-foreground text-sm border-2 border-dashed border-gray-200 rounded-lg">
                                      æ­¤å•†å“æš‚æ— å›¾ç‰‡
                                    </div>
                                  )}
                                  <p className="text-xs text-muted-foreground">
                                    å·²é€‰æ‹© {editingProduct?.selectedImageIndexes?.length || 0} å¼ å›¾ç‰‡
                                  </p>
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                        <DialogFooter>
                                                <Button variant="outline" onClick={()=>setEditingProduct(null)}>å–æ¶ˆ</Button>
                                                <Button onClick={()=>handleUpdateProduct(editingProduct)}>ä¿å­˜ä¿®æ”¹</Button>
                        </DialogFooter>
                      </DialogContent>
                    </Dialog>

                                    {/* åˆ é™¤æŒ‰é’® */}
                                    <Button variant="outline" size="icon" className="h-8 w-8 hover:bg-red-50 hover:text-red-600" onClick={()=>handleDeleteProduct(product.id)}>
                                        <Trash2 className="size-3.5"/>
                    </Button>
                  </div>
                </div>
              </div>
                        )
                    })}
          </div>
          
                {/* åˆ†é¡µç»„ä»¶ */}
                {currentProducts.length > 0 && (
                    <div className="flex flex-col sm:flex-row justify-between items-center gap-4 p-6 border-t bg-muted/5">
              <div className="text-sm text-muted-foreground font-medium">
                            æ˜¾ç¤ºç¬¬ {(currentPage-1)*itemsPerPage + 1} - {Math.min(currentPage*itemsPerPage, currentProducts.length)} æ¡ï¼Œå…± {currentProducts.length} æ¡è®°å½•
                            <span className="ml-2">({currentPage}/{totalPages}é¡µ)</span>
              </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.max(1, p-1))}
                                disabled={currentPage===1}
                                className="h-8 px-3"
                  >
                                <ChevronLeft className="h-4 w-4 mr-1"/> ä¸Šä¸€é¡µ
                  </Button>
                            <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                    {currentPage} / {totalPages}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                                onClick={()=>setCurrentPage(p=>Math.min(totalPages, p+1))}
                                disabled={currentPage===totalPages}
                                className="h-8 px-3"
                  >
                                ä¸‹ä¸€é¡µ <ChevronRight className="h-4 w-4 ml-1"/>
                  </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

        {/* å•ä¸ªå•†å“åˆ é™¤ç¡®è®¤å¯¹è¯æ¡† */}
        <Dialog open={showDeleteConfirm && deletingProductId !== null} onOpenChange={(open) => {
          if (!open) {
            setShowDeleteConfirm(false)
            setDeletingProductId(null)
          }
        }}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>ç¡®è®¤åˆ é™¤å•†å“</DialogTitle>
              <DialogDescription>
                ç¡®å®šè¦åˆ é™¤å•†å“ {deletingProductId} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => {
                setShowDeleteConfirm(false)
                setDeletingProductId(null)
              }}>
                å–æ¶ˆ
              </Button>
              <Button
                variant="destructive"
                onClick={confirmDeleteProduct}
              >
                ç¡®è®¤åˆ é™¤
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

      {/* æ‰¹é‡åˆ é™¤ç¡®è®¤å¯¹è¯æ¡† */}
        <Dialog open={showDeleteConfirm && deletingProductId === null} onOpenChange={setShowDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
              <DialogTitle>ç¡®è®¤æ‰¹é‡åˆ é™¤</DialogTitle>
            <DialogDescription>
              ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ {selectedProducts.length} ä¸ªå•†å“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteConfirm(false)}>
              å–æ¶ˆ
            </Button>
              <Button
                variant="destructive"
                onClick={confirmBatchDelete}
                disabled={isDeleting}
              >
              {isDeleting ? "åˆ é™¤ä¸­..." : "ç¡®è®¤åˆ é™¤"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      </div>
    </div>
  )
}
--- File: ./frontend/components/logs-view.tsx ---
"use client"

import { useState, useEffect, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Pause, Play, Trash2, RefreshCw } from "lucide-react"

type LogEntry = {
  timestamp: string
  level: string
  message: string
  module?: string
  func?: string
  type?: string // ç”¨äºå¿ƒè·³åŒ…
}

export function LogsView() {
  const [logs, setLogs] = useState<LogEntry[]>([])
  const [isConnected, setIsConnected] = useState(false)
  const [isPaused, setIsPaused] = useState(false)
  const scrollRef = useRef<HTMLDivElement>(null)
  const eventSourceRef = useRef<EventSource | null>(null)

  // åŠ è½½å†å²æ—¥å¿—
  const loadRecentLogs = async () => {
    try {
      const response = await fetch('/api/logs?endpoint=recent')
      if (response.ok) {
        const data = await response.json()
        setLogs(data.logs || [])
      }
    } catch (error) {
      console.error('åŠ è½½å†å²æ—¥å¿—å¤±è´¥:', error)
    }
  }

  // è¿æ¥åˆ°æ—¥å¿—æµ
  const connectToLogStream = () => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
    }

    const eventSource = new EventSource('/api/logs/stream')
    eventSourceRef.current = eventSource

    eventSource.onopen = () => {
      console.log('æ—¥å¿—æµè¿æ¥å·²å»ºç«‹')
      setIsConnected(true)
    }

    eventSource.onmessage = (event) => {
      try {
        const logEntry: LogEntry = JSON.parse(event.data)

        // è¿‡æ»¤å¿ƒè·³åŒ…
        if (logEntry.type === 'heartbeat') {
          return
        }

        setLogs((prev) => [...prev, logEntry].slice(-200)) // ä¿æŒæœ€è¿‘200æ¡æ—¥å¿—
      } catch (error) {
        console.error('è§£ææ—¥å¿—æ•°æ®å¤±è´¥:', error, event.data)
      }
    }

    eventSource.onerror = (error) => {
      console.error('æ—¥å¿—æµè¿æ¥é”™è¯¯:', error)
      setIsConnected(false)

      // è‡ªåŠ¨é‡è¿
      setTimeout(() => {
        if (!isPaused) {
          connectToLogStream()
        }
      }, 5000)
    }
  }

  useEffect(() => {
    // åŠ è½½å†å²æ—¥å¿—
    loadRecentLogs()

    // è¿æ¥åˆ°æ—¥å¿—æµ
    if (!isPaused) {
      connectToLogStream()
    }

    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
      }
    }
  }, [isPaused])

  useEffect(() => {
    if (scrollRef.current && !isPaused) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" })
    }
  }, [logs, isPaused])

  const handleTogglePause = () => {
    setIsPaused(!isPaused)
    if (!isPaused) {
      // æš‚åœæ—¶æ–­å¼€è¿æ¥
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
        setIsConnected(false)
      }
    } else {
      // æ¢å¤æ—¶é‡æ–°è¿æ¥
      connectToLogStream()
    }
  }

  const handleClearLogs = () => {
    setLogs([])
  }

  const handleRefresh = () => {
    loadRecentLogs()
  }

  const getLevelColor = (level: string) => {
    switch (level) {
      case "INFO":
        return "bg-blue-600 hover:bg-blue-700"
      case "WARNING":
        return "bg-yellow-600 hover:bg-yellow-700"
      case "ERROR":
        return "bg-red-600 hover:bg-red-700"
      case "CRITICAL":
        return "bg-red-800 hover:bg-red-900"
      default:
        return "bg-gray-600 hover:bg-gray-700"
    }
  }

  const formatTimestamp = (timestamp: string) => {
    try {
      const date = new Date(timestamp)
      return date.toLocaleTimeString("zh-CN", { hour12: false })
    } catch {
      return timestamp
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">å®æ—¶æ—¥å¿—</h2>
          <p className="text-muted-foreground">ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€å’Œäº‹ä»¶æµ</p>
        </div>
        <div className="flex items-center gap-2">
          <div className="flex items-center gap-1 text-sm">
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
            <span className="text-muted-foreground">
              {isConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥'}
            </span>
          </div>
          <Button variant="outline" size="sm" onClick={handleTogglePause}>
            {isPaused ? <Play className="size-4" /> : <Pause className="size-4" />}
            {isPaused ? 'æ¢å¤' : 'æš‚åœ'}
          </Button>
          <Button variant="outline" size="sm" onClick={handleRefresh}>
            <RefreshCw className="size-4" />
            åˆ·æ–°
          </Button>
          <Button variant="outline" size="sm" onClick={handleClearLogs}>
            <Trash2 className="size-4" />
            æ¸…ç©º
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ç³»ç»Ÿæ—¥å¿—æµ</CardTitle>
          <CardDescription>
            å…± {logs.length} æ¡è®°å½• â€¢ {isPaused ? 'å·²æš‚åœ' : 'å®æ—¶ç›‘æ§ä¸­'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ScrollArea className="h-[600px] w-full rounded-md border bg-black/90 p-4">
            <div className="space-y-3 font-mono text-[11px] leading-relaxed">
              {logs.map((log, index) => (
                <div
                  key={`${log.timestamp}-${index}`}
                  className="flex items-start gap-3 text-green-400 hover:bg-white/5 p-2 rounded transition-colors border-b border-white/5 last:border-0"
                >
                  <span className="text-gray-500 shrink-0 font-bold">
                    {formatTimestamp(log.timestamp)}
                  </span>
                  <Badge className={`${getLevelColor(log.level)} shrink-0 text-[9px] h-4 px-1`}>
                    {log.level}
                  </Badge>
                  <span className="text-cyan-400 shrink-0 font-semibold">
                    [{log.module || 'system'}]
                  </span>
                  <span className="text-gray-200 break-words">{log.message}</span>
                </div>
              ))}
              <div ref={scrollRef} />
            </div>
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}


--- File: ./frontend/components/similarity-test-view.tsx ---
"use client"

import type React from "react"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Upload, TestTube, AlertCircle, CheckCircle } from "lucide-react"
import { toast } from "sonner"
import { Alert, AlertDescription } from "@/components/ui/alert"

export function SimilarityTestView() {
  const [image1, setImage1] = useState<string | null>(null)
  const [image2, setImage2] = useState<string | null>(null)
  const [isTesting, setIsTesting] = useState(false)
  const [result, setResult] = useState<any>(null)

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>, imageNumber: 1 | 2) => {
    const file = e.target.files?.[0]
    if (!file) return

    if (!file.type.startsWith("image/")) {
      toast.error("è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶")
      return
    }

    const reader = new FileReader()
    reader.onload = (event) => {
      if (imageNumber === 1) {
        setImage1(event.target?.result as string)
      } else {
        setImage2(event.target?.result as string)
      }
      toast.success(`å›¾ç‰‡${imageNumber}å·²ä¸Šä¼ `)
    }
    reader.readAsDataURL(file)
  }

  const handleTest = async () => {
    if (!image1 || !image2) {
      toast.error("è¯·ä¸Šä¼ ä¸¤å¼ å›¾ç‰‡")
      return
    }

    setIsTesting(true)
    setResult(null)

    try {
      // å°†base64å›¾ç‰‡è½¬æ¢ä¸ºblob
      const response1 = await fetch(image1)
      const blob1 = await response1.blob()

      const response2 = await fetch(image2)
      const blob2 = await response2.blob()

      // åˆ›å»ºFormData
      const formData = new FormData()
      formData.append('image1', blob1, 'image1.jpg')
      formData.append('image2', blob2, 'image2.jpg')

      // å‘é€åˆ°APIè¿›è¡Œç›¸ä¼¼åº¦æµ‹è¯•
      const testRes = await fetch('/api/test-similarity', {
        method: 'POST',
        body: formData
      })

      if (testRes.ok) {
        const data = await testRes.json()
        setResult(data)
        toast.success(`ç›¸ä¼¼åº¦æµ‹è¯•å®Œæˆ: ${(data.similarity * 100).toFixed(2)}%`)
      } else {
        const errorText = await testRes.text()
        console.error('Test failed:', errorText)
        toast.error("æµ‹è¯•å¤±è´¥: " + errorText)
      }
    } catch (error) {
      console.error('Test error:', error)
      toast.error("æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯")
    } finally {
      setIsTesting(false)
    }
  }

  const clearImages = () => {
    setImage1(null)
    setImage2(null)
    setResult(null)
  }

  return (
    <div className="space-y-6">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <h2 className="text-3xl font-bold tracking-tight">ç›¸ä¼¼åº¦æµ‹è¯•</h2>
          <p className="text-muted-foreground">æµ‹è¯•PP-ShiTuV2æ¨¡å‹å¯¹ä¸¤å¼ å›¾ç‰‡çš„ç›¸ä¼¼åº¦è®¡ç®—</p>
        </div>
      </div>

      <div className="grid gap-6 lg:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>å›¾ç‰‡1</CardTitle>
            <CardDescription>é€‰æ‹©ç¬¬ä¸€å¼ å›¾ç‰‡</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image1 ? (
              <label
                htmlFor="image1-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">ç‚¹å‡»ä¸Šä¼ ç¬¬ä¸€å¼ å›¾ç‰‡</p>
                <input id="image1-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 1)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image1}
                  alt="Image 1"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage1(null)}
                >
                  Ã—
                </Button>
              </div>
            )}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>å›¾ç‰‡2</CardTitle>
            <CardDescription>é€‰æ‹©ç¬¬äºŒå¼ å›¾ç‰‡</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {!image2 ? (
              <label
                htmlFor="image2-upload"
                className="flex flex-col items-center justify-center h-48 border-2 border-dashed border-muted-foreground/25 rounded-lg cursor-pointer hover:border-muted-foreground/50 transition-colors"
              >
                <Upload className="size-12 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground">ç‚¹å‡»ä¸Šä¼ ç¬¬äºŒå¼ å›¾ç‰‡</p>
                <input id="image2-upload" type="file" accept="image/*" className="hidden" onChange={(e) => handleFileUpload(e, 2)} />
              </label>
            ) : (
              <div className="relative">
                <img
                  src={image2}
                  alt="Image 2"
                  className="w-full h-48 object-contain rounded-lg border"
                />
                <Button
                  variant="destructive"
                  size="icon-sm"
                  className="absolute top-2 right-2"
                  onClick={() => setImage2(null)}
                >
                  Ã—
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TestTube className="size-5" />
            æµ‹è¯•æ§åˆ¶
          </CardTitle>
          <CardDescription>æ‰§è¡Œç›¸ä¼¼åº¦æµ‹è¯•</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-3">
            <Button
              onClick={handleTest}
              disabled={!image1 || !image2 || isTesting}
              className="flex-1"
            >
              <TestTube className="mr-2 size-4" />
              {isTesting ? "æµ‹è¯•ä¸­..." : "å¼€å§‹ç›¸ä¼¼åº¦æµ‹è¯•"}
            </Button>
            <Button
              variant="outline"
              onClick={clearImages}
              disabled={isTesting}
            >
              æ¸…ç©ºå›¾ç‰‡
            </Button>
          </div>

          {isTesting && (
            <div className="space-y-2">
              <Progress value={50} className="h-2" />
              <p className="text-[10px] text-blue-500 animate-pulse font-medium">æ­£åœ¨æå–ç‰¹å¾å‘é‡å¹¶è®¡ç®—ç›¸ä¼¼åº¦...</p>
            </div>
          )}
        </CardContent>
      </Card>

      {result && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              {result.similarity > 0.9 ? (
                <CheckCircle className="size-5 text-green-500" />
              ) : (
                <AlertCircle className="size-5 text-orange-500" />
              )}
              æµ‹è¯•ç»“æœ
            </CardTitle>
            <CardDescription>PP-ShiTuV2æ¨¡å‹ç›¸ä¼¼åº¦åˆ†æ</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">ç›¸ä¼¼åº¦åˆ†æ•°</span>
                  <Badge
                    className={
                      result.similarity > 0.9
                        ? "bg-green-600 hover:bg-green-700"
                        : result.similarity > 0.7
                        ? "bg-blue-600 hover:bg-blue-700"
                        : "bg-orange-600 hover:bg-orange-700"
                    }
                  >
                    {(result.similarity * 100).toFixed(2)}%
                  </Badge>
                </div>
                <Progress value={result.similarity * 100} className="h-3" />
              </div>

              <div className="space-y-2">
                <div className="text-sm">
                  <span className="font-medium">æ¨¡å‹åç§°:</span> {result.model}
                </div>
                <div className="text-sm">
                  <span className="font-medium">å‘é‡ç»´åº¦:</span> {result.vector_dimension}
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
              <div>
                <span className="font-medium">å›¾ç‰‡1ç‰¹å¾èŒƒæ•°:</span> {result.features1_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">å›¾ç‰‡2ç‰¹å¾èŒƒæ•°:</span> {result.features2_norm?.toFixed(4)}
              </div>
              <div>
                <span className="font-medium">ç‚¹ç§¯:</span> {result.dot_product?.toFixed(4)}
              </div>
            </div>

            {result.similarity < 0.95 && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  ç›¸ä¼¼åº¦ä½äº95%ï¼Œå¯èƒ½çš„åŸå› ï¼š
                  1. å›¾ç‰‡å†…å®¹ä¸åŒ
                  2. å›¾ç‰‡åœ¨å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿå˜åŒ–ï¼ˆå‹ç¼©ã€å°ºå¯¸è°ƒæ•´ç­‰ï¼‰
                  3. æ¨¡å‹ç‰¹å¾æå–çš„å±€é™æ€§
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  )
}

--- File: ./frontend/components/dashboard-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
      fetchAnnouncements()
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('ç»Ÿè®¡æ•°æ®:', data)
        setStats(data)
      } else {
        console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements', { credentials: 'include' })
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('è·å–å…¬å‘Šå¤±è´¥:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('å…¬å‘Šæ·»åŠ æˆåŠŸ')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('æ·»åŠ å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('å…¬å‘Šæ›´æ–°æˆåŠŸ')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('æ›´æ–°å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤å…¬å‘Š "${announcement.title}" å—ï¼Ÿ`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('å…¬å‘Šåˆ é™¤æˆåŠŸ')
        fetchAnnouncements()
      } else {
        toast.error('åˆ é™¤å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">ä»ªè¡¨ç›˜</h2>
        <p className="text-muted-foreground mt-2">ç³»ç»Ÿæ¦‚è§ˆå’Œå…¬å‘Šç®¡ç†</p>
      </div>

      {/* ç»Ÿè®¡ä¿¡æ¯ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 lg:gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">åº—é“ºæ•°é‡</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²æ”¶å½•çš„åº—é“º</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">å•†å“æ•°é‡</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²æŠ“å–çš„å•†å“</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">å›¾ç‰‡æ•°é‡</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²ç´¢å¼•çš„å›¾ç‰‡</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">ç”¨æˆ·æ•°é‡</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">æ´»è·ƒç”¨æˆ·</p>
          </CardContent>
        </Card>
      </div>

      {/* å…¬å‘Šç®¡ç† - æ‰€æœ‰ç”¨æˆ·å¯è§ï¼Œä½†åªæœ‰ç®¡ç†å‘˜å¯ä¿®æ”¹ */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                ç³»ç»Ÿå…¬å‘Š
              </CardTitle>
              <CardDescription>æŸ¥çœ‹æœ€æ–°ç³»ç»Ÿé€šçŸ¥å’Œé‡è¦æ›´æ–°</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm" className="shrink-0">
                    <Plus className="w-4 h-4 mr-2" />
                    æ·»åŠ å…¬å‘Š
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>æ·»åŠ ç³»ç»Ÿå…¬å‘Š</DialogTitle>
                    <DialogDescription>åˆ›å»ºæ–°çš„ç³»ç»Ÿå…¬å‘Š</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>å…¬å‘Šæ ‡é¢˜</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="è¯·è¾“å…¥å…¬å‘Šæ ‡é¢˜"
                      />
                    </div>
                    <div>
                      <Label>å…¬å‘Šå†…å®¹</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="è¯·è¾“å…¥å…¬å‘Šå†…å®¹"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>å–æ¶ˆ</Button>
                    <Button onClick={handleAddAnnouncement}>æ·»åŠ å…¬å‘Š</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                æš‚æ— å…¬å‘Š
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4 hover:bg-muted/30 transition-colors">
                  <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3">
                    <div className="flex-1 min-w-0">
                      <h4 className="font-semibold text-base mb-2">{announcement.title}</h4>
                      <p className="text-sm text-muted-foreground mb-3 leading-relaxed">{announcement.content}</p>
                      <div className="text-xs text-muted-foreground">
                        æ›´æ–°æ—¶é—´: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                      </div>
                    </div>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2 shrink-0">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                          className="h-8 w-8 p-0"
                          title="ç¼–è¾‘å…¬å‘Š"
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                          className="h-8 w-8 p-0 hover:bg-red-50 hover:text-red-600 hover:border-red-200"
                          title="åˆ é™¤å…¬å‘Š"
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* ç¼–è¾‘å…¬å‘Šå¯¹è¯æ¡† */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>ç¼–è¾‘å…¬å‘Š</DialogTitle>
              <DialogDescription>ä¿®æ”¹å…¬å‘Šå†…å®¹</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>å…¬å‘Šæ ‡é¢˜</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>å…¬å‘Šå†…å®¹</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>å–æ¶ˆ</Button>
              <Button onClick={handleUpdateAnnouncement}>ä¿å­˜ä¿®æ”¹</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/settings-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { toast } from "sonner"
import { Settings, Save } from "lucide-react"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

interface UserSettings {
  discord_similarity_threshold: number
  global_reply_min_delay: number
  global_reply_max_delay: number
  user_blacklist: string
  keyword_filters: string
}

interface SystemSettings {
  scrape_threads: number
  download_threads: number
  feature_extract_threads: number
}

export function SettingsView() {
  const [settings, setSettings] = useState<UserSettings>({
    discord_similarity_threshold: 0.6,
    global_reply_min_delay: 3.0,
    global_reply_max_delay: 8.0,
    user_blacklist: '',
    keyword_filters: '',
  })
  const [systemSettings, setSystemSettings] = useState<SystemSettings>({
    scrape_threads: 2,
    download_threads: 4,
    feature_extract_threads: 4,
  })
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [savingSystem, setSavingSystem] = useState(false)
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  })
  const [changingPassword, setChangingPassword] = useState(false)

  useEffect(() => {
    fetchSettings()
    fetchSystemSettings()
  }, [])

  const fetchSettings = async () => {
    try {
      // è·å–ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®
      const response = await fetch('/api/user/settings')
      if (response.ok) {
        const data = await response.json()
        setSettings({
          discord_similarity_threshold: data.discord_similarity_threshold ?? 0.6,
          global_reply_min_delay: data.global_reply_min_delay ?? 3.0,
          global_reply_max_delay: data.global_reply_max_delay ?? 8.0,
          user_blacklist: data.user_blacklist ?? '',
          keyword_filters: data.keyword_filters ?? '',
        })
      } else {
        toast.error("è·å–è®¾ç½®å¤±è´¥")
      }
    } catch (error) {
      console.error('Failed to fetch settings:', error)
      toast.error("è·å–è®¾ç½®å¤±è´¥")
    } finally {
      setLoading(false)
    }
  }

  const handleSaveSystemSettings = async () => {
    setSavingSystem(true)
    try {
      const response = await fetch('/api/config/scrape-threads', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          scrape_threads: systemSettings.scrape_threads
        })
      })

      if (response.ok) {
        toast.success("ç³»ç»Ÿè®¾ç½®å·²ä¿å­˜")
      } else {
        const errorData = await response.json()
        toast.error(errorData.error || "ä¿å­˜ç³»ç»Ÿè®¾ç½®å¤±è´¥")
      }
    } catch (error) {
      console.error('Failed to save system settings:', error)
      toast.error("ä¿å­˜ç³»ç»Ÿè®¾ç½®å¤±è´¥")
    } finally {
      setSavingSystem(false)
    }
  }

  const fetchSystemSettings = async () => {
    try {
      // è·å–æŠ“å–çº¿ç¨‹é…ç½®
      const scrapeResponse = await fetch('/api/config/scrape-threads')
      let scrape_threads = 2
      if (scrapeResponse.ok) {
        const data = await scrapeResponse.json()
        scrape_threads = data.scrape_threads ?? 2
      }

      // æ³¨æ„ï¼šå…¶ä»–çº¿ç¨‹é…ç½®ç›®å‰åœ¨åç«¯æ²¡æœ‰å•ç‹¬çš„APIï¼Œè¿™é‡Œå…ˆä½¿ç”¨é»˜è®¤å€¼
      // åç»­å¯ä»¥æ·»åŠ æ›´å¤šçš„APIæ¥è·å–è¿™äº›é…ç½®
      setSystemSettings({
        scrape_threads: scrape_threads,
        download_threads: 4,  // é»˜è®¤å€¼
        feature_extract_threads: 4,  // é»˜è®¤å€¼
      })
    } catch (error) {
      console.error('Failed to fetch system settings:', error)
    }
  }

  const handleSave = async () => {
    setSaving(true)
    try {
      // éªŒè¯å›å¤å»¶è¿Ÿè®¾ç½®
      if (settings.global_reply_min_delay >= settings.global_reply_max_delay) {
        toast.error("æœ€å°å»¶è¿Ÿå¿…é¡»å°äºæœ€å¤§å»¶è¿Ÿ")
        setSaving(false)
        return
      }

      if (settings.global_reply_min_delay < 0 || settings.global_reply_max_delay < 0) {
        toast.error("å»¶è¿Ÿæ—¶é—´ä¸èƒ½ä¸ºè´Ÿæ•°")
        setSaving(false)
        return
      }

      // ä¿å­˜ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®
      const response = await fetch('/api/user/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings)
      })

      if (response.ok) {
        toast.success("è®¾ç½®å·²ä¿å­˜")
      } else {
        toast.error("ä¿å­˜è®¾ç½®å¤±è´¥")
      }
    } catch (error) {
      toast.error("ä¿å­˜è®¾ç½®å¤±è´¥")
    } finally {
      setSaving(false)
    }
  }

  const handleChangePassword = async () => {
    if (!passwordData.currentPassword || !passwordData.newPassword || !passwordData.confirmPassword) {
      toast.error("è¯·å¡«å†™æ‰€æœ‰å¯†ç å­—æ®µ")
      return
    }

    if (passwordData.newPassword !== passwordData.confirmPassword) {
      toast.error("æ–°å¯†ç å’Œç¡®è®¤å¯†ç ä¸ä¸€è‡´")
      return
    }

    if (passwordData.newPassword.length < 6) {
      toast.error("æ–°å¯†ç é•¿åº¦è‡³å°‘6ä½")
      return
    }

    setChangingPassword(true)
    try {
      const response = await fetch('/api/user/change-password', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          current_password: passwordData.currentPassword,
          new_password: passwordData.newPassword
        })
      })

      if (response.ok) {
        toast.success("å¯†ç ä¿®æ”¹æˆåŠŸ")
        setPasswordData({
          currentPassword: '',
          newPassword: '',
          confirmPassword: ''
        })
      } else {
        const error = await response.json()
        toast.error(error.error || "å¯†ç ä¿®æ”¹å¤±è´¥")
      }
    } catch (error) {
      toast.error("å¯†ç ä¿®æ”¹å¤±è´¥")
    } finally {
      setChangingPassword(false)
    }
  }

  if (loading) {
    return (
      <div className="space-y-8">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">ç³»ç»Ÿè®¾ç½®</h2>
          <p className="text-sm text-muted-foreground mt-1">æ­£åœ¨åŠ è½½è®¾ç½®...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">ä¸ªäººè®¾ç½®</h2>
          <p className="text-sm text-muted-foreground mt-1">é…ç½®æ‚¨çš„ä¸ªæ€§åŒ–è¿è¡Œå‚æ•°</p>
        </div>
        <div className="flex gap-2">
          <Button onClick={handleSave} disabled={saving} variant="outline">
            <Save className="w-4 h-4 mr-2" />
            {saving ? "ä¿å­˜ç”¨æˆ·è®¾ç½®..." : "ä¿å­˜ç”¨æˆ·è®¾ç½®"}
          </Button>
          <Button onClick={handleSaveSystemSettings} disabled={savingSystem}>
            <Settings className="w-4 h-4 mr-2" />
            {savingSystem ? "ä¿å­˜ç³»ç»Ÿè®¾ç½®..." : "ä¿å­˜ç³»ç»Ÿè®¾ç½®"}
          </Button>
        </div>
      </div>

      {/* å¯†ç ä¿®æ”¹ */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">ä¿®æ”¹å¯†ç </CardTitle>
          <CardDescription>ä¿®æ”¹æ‚¨çš„è´¦å·å¯†ç </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="current-password">å½“å‰å¯†ç </Label>
            <Input
              id="current-password"
              type="password"
              value={passwordData.currentPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, currentPassword: e.target.value }))}
              placeholder="è¯·è¾“å…¥å½“å‰å¯†ç "
            />
          </div>
          <div>
            <Label htmlFor="new-password">æ–°å¯†ç </Label>
            <Input
              id="new-password"
              type="password"
              value={passwordData.newPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
              placeholder="è¯·è¾“å…¥æ–°å¯†ç "
            />
          </div>
          <div>
            <Label htmlFor="confirm-password">ç¡®è®¤æ–°å¯†ç </Label>
            <Input
              id="confirm-password"
              type="password"
              value={passwordData.confirmPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
              placeholder="è¯·å†æ¬¡è¾“å…¥æ–°å¯†ç "
            />
          </div>
          <Button
            onClick={handleChangePassword}
            disabled={changingPassword}
            className="w-full"
          >
            {changingPassword ? "ä¿®æ”¹ä¸­..." : "ä¿®æ”¹å¯†ç "}
          </Button>
        </CardContent>
      </Card>

      {/* ç³»ç»Ÿå‚æ•°è®¾ç½® */}
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="text-lg">ç³»ç»Ÿå‚æ•°</CardTitle>
          <CardDescription>é…ç½®å›¾ç‰‡åŒ¹é…ã€å›å¤å»¶è¿Ÿå’ŒæŠ“å–å¤šçº¿ç¨‹å‚æ•°</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* ç³»ç»Ÿè®¾ç½® - å¤šåˆ—ç½‘æ ¼å¸ƒå±€ */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            {/* ç›¸ä¼¼åº¦è®¾ç½® */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="similarity-threshold" className="text-sm font-medium">ç›¸ä¼¼åº¦é˜ˆå€¼</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {(settings.discord_similarity_threshold * 100).toFixed(0)}%
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="similarity-threshold"
                  type="number"
                  step="0.1"
                  min="0.1"
                  max="1.0"
                  value={settings.discord_similarity_threshold}
                  onChange={(e) => setSettings(prev => ({ ...prev, discord_similarity_threshold: parseFloat(e.target.value) }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  åŒ¹é…é˜ˆå€¼ï¼ŒèŒƒå›´ 0.1-1.0
                </p>
              </div>
            </div>

            {/* å•†å“æŠ“å–çº¿ç¨‹æ•° */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="scrape-threads" className="text-sm font-medium">å•†å“æŠ“å–çº¿ç¨‹</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.scrape_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="scrape-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="10"
                  value={systemSettings.scrape_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, scrape_threads: parseInt(e.target.value) || 2 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  æ‰¹é‡å•†å“å¤„ç†å¹¶å‘æ•°
                </p>
              </div>
            </div>

            {/* å›¾ç‰‡ä¸‹è½½çº¿ç¨‹æ•° */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="download-threads" className="text-sm font-medium">å›¾ç‰‡ä¸‹è½½çº¿ç¨‹</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.download_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="download-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="20"
                  value={systemSettings.download_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, download_threads: parseInt(e.target.value) || 4 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  æ¯ä¸ªå•†å“çš„å›¾ç‰‡ä¸‹è½½æ•°
                </p>
              </div>
            </div>

            {/* ç‰¹å¾æå–çº¿ç¨‹æ•° */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="feature-extract-threads" className="text-sm font-medium">ç‰¹å¾æå–çº¿ç¨‹</Label>
                <span className="text-sm font-mono text-muted-foreground bg-muted px-2 py-0.5 rounded">
                  {systemSettings.feature_extract_threads}
                </span>
              </div>
              <div className="space-y-1">
                <Input
                  id="feature-extract-threads"
                  type="number"
                  step="1"
                  min="1"
                  max="10"
                  value={systemSettings.feature_extract_threads}
                  onChange={(e) => setSystemSettings(prev => ({ ...prev, feature_extract_threads: parseInt(e.target.value) || 4 }))}
                  className="h-9"
                />
                <p className="text-xs text-muted-foreground">
                  AIç‰¹å¾æå–å¹¶å‘æ•°
                </p>
              </div>
            </div>
          </div>

            {/* å›å¤å»¶è¿Ÿè®¾ç½® */}
            <div className="flex-1 space-y-2">
              <Label className="text-sm font-medium">å›å¤å»¶è¿Ÿ</Label>
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <div className="flex items-center gap-1">
                    <Input
                      id="min-delay"
                      type="number"
                      step="0.1"
                      min="0.1"
                      max="30"
                      value={settings.global_reply_min_delay}
                      onChange={(e) => setSettings(prev => ({ ...prev, global_reply_min_delay: parseFloat(e.target.value) }))}
                      className="w-16 h-9 text-center"
                    />
                    <span className="text-sm text-muted-foreground">-</span>
                    <Input
                      id="max-delay"
                      type="number"
                      step="0.5"
                      min="1"
                      max="60"
                      value={settings.global_reply_max_delay}
                      onChange={(e) => setSettings(prev => ({ ...prev, global_reply_max_delay: parseFloat(e.target.value) }))}
                      className="w-16 h-9 text-center"
                    />
                  </div>
                  <span className="text-xs text-muted-foreground">ç§’</span>
                </div>
                <p className="text-xs text-muted-foreground">
                  æ¯æ¬¡å›å¤éšæœºå»¶è¿Ÿ {settings.global_reply_min_delay}-{settings.global_reply_max_delay} ç§’
                </p>
              </div>
            </div>
          </div>

          {/* ç”¨æˆ·é»‘åå•è®¾ç½® */}
          <div className="space-y-2">
            <Label htmlFor="user-blacklist" className="text-sm font-medium">ç”¨æˆ·é»‘åå•</Label>
            <div className="space-y-1">
              <Input
                id="user-blacklist"
                type="text"
                value={settings.user_blacklist}
                onChange={(e) => setSettings(prev => ({ ...prev, user_blacklist: e.target.value }))}
                placeholder="è¾“å…¥ä¸å›å¤çš„ç”¨æˆ·IDï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                ä¸ä¼šå›å¤è¿™äº›ç”¨æˆ·å‘é€çš„æ¶ˆæ¯ï¼Œæ ¼å¼ï¼šuser123,user456,user789
              </p>
            </div>
          </div>

          {/* å…³é”®è¯è¿‡æ»¤è®¾ç½® */}
          <div className="space-y-2">
            <Label htmlFor="keyword-filters" className="text-sm font-medium">å…³é”®è¯è¿‡æ»¤</Label>
            <div className="space-y-1">
              <Input
                id="keyword-filters"
                type="text"
                value={settings.keyword_filters}
                onChange={(e) => setSettings(prev => ({ ...prev, keyword_filters: e.target.value }))}
                placeholder="è¾“å…¥ä¸å›å¤çš„å…³é”®è¯ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”"
                className="h-9"
              />
              <p className="text-xs text-muted-foreground">
                æ¶ˆæ¯åŒ…å«è¿™äº›å…³é”®è¯æ—¶ä¸ä¼šå›å¤ï¼Œæ ¼å¼ï¼šå¹¿å‘Š,åˆ·å±,æµ‹è¯•,åƒåœ¾
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

        {/* ç³»ç»Ÿä¿¡æ¯ */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">ç³»ç»Ÿä¿¡æ¯</CardTitle>
            <CardDescription>å½“å‰ç³»ç»ŸçŠ¶æ€</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-muted-foreground">çŠ¶æ€:</span>
                <span className="text-green-600">è¿è¡Œæ­£å¸¸</span>
              </div>
              <div className="flex justify-between">
                <span className="text-muted-foreground">ç‰ˆæœ¬:</span>
                <span>v1.0.0</span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

--- File: ./frontend/components/app-sidebar.tsx ---
"use client"

import { LayoutDashboard, Users, Search, ImageIcon, ListTree, ScrollText, Bot, Settings, TestTube, Store, Shield, Cog, BarChart3 } from "lucide-react"
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuItem,
  SidebarMenuButton,
  SidebarHeader,
  SidebarFooter,
} from "@/components/ui/sidebar"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

const baseMenuItems = [
  { id: "dashboard", icon: BarChart3, label: "ä»ªè¡¨ç›˜" },
  { id: "accounts", icon: Users, label: "è´¦å·ä¸è§„åˆ™" },
  { id: "scraper", icon: Search, label: "å¾®åº—æŠ“å–" },
  { id: "image-search", icon: ImageIcon, label: "ä»¥å›¾æœå›¾" },
  { id: "shops", icon: Store, label: "åº—é“ºç®¡ç†" },
]

// åªæœ‰ç®¡ç†å‘˜æ‰èƒ½è®¿é—®çš„åŠŸèƒ½
const adminOnlyMenuItems = [
  { id: "users", icon: Shield, label: "ç”¨æˆ·ç®¡ç†" },
  { id: "logs", icon: ScrollText, label: "å®æ—¶æ—¥å¿—" },
]

export function AppSidebar({
  currentView,
  setCurrentView,
  currentUser,
}: {
  currentView: string
  setCurrentView: (view: string) => void
  currentUser: User | null
}) {
  return (
    <Sidebar>
      <SidebarHeader className="border-b p-4">
        <div className="flex items-center gap-2">
          <Bot className="size-6 text-primary" />
          <div>
            <h2 className="text-lg font-bold">Discord è¥é”€</h2>
            <p className="text-xs text-muted-foreground">æ™ºèƒ½è‡ªåŠ¨å›å¤ç³»ç»Ÿ</p>
          </div>
        </div>
      </SidebarHeader>
      <SidebarContent>
        <SidebarGroup>
          <SidebarGroupLabel>ä¸»è¦åŠŸèƒ½</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {baseMenuItems
                .filter(item => item.id !== 'shops' || currentUser?.role === 'admin' || (currentUser?.shops && currentUser.shops.length > 0))
                .map((item) => (
                <SidebarMenuItem key={item.id}>
                  <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                    <item.icon />
                    <span>{item.label}</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>


        {currentUser?.role === 'admin' && (
          <SidebarGroup>
            <SidebarGroupLabel>ç®¡ç†å‘˜åŠŸèƒ½</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {adminOnlyMenuItems.map((item) => (
                  <SidebarMenuItem key={item.id}>
                    <SidebarMenuButton onClick={() => setCurrentView(item.id)} isActive={currentView === item.id}>
                      <item.icon />
                      <span>{item.label}</span>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        )}
      </SidebarContent>
      <SidebarFooter className="border-t p-4">
        <p className="text-xs text-muted-foreground text-center">v1.0.0 â€¢ æŠ€æœ¯æ”¯æŒ</p>
        <p className="text-xs text-muted-foreground text-center mt-1">å¾®ä¿¡: OceanSeaWang</p>
        <p className="text-xs text-muted-foreground text-center mt-1">Discord: zrnown</p>
      </SidebarFooter>
    </Sidebar>
  )
}

--- File: ./frontend/components/dashboard-view-new.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Store, Package, ImageIcon, Users, Megaphone, Plus, Edit, Trash2 } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"

interface SystemStats {
  shop_count: number
  product_count: number
  image_count: number
  user_count: number
}

interface Announcement {
  id: number
  title: string
  content: string
  created_at: string
  updated_at: string
}

export function DashboardView({ currentUser }: { currentUser: any }) {
  const [stats, setStats] = useState<SystemStats | null>(null)
  const [announcements, setAnnouncements] = useState<Announcement[]>([])
  const [showAddAnnouncement, setShowAddAnnouncement] = useState(false)
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null)
  const [newAnnouncement, setNewAnnouncement] = useState({
    title: '',
    content: ''
  })

  useEffect(() => {
    fetchStats()
    if (currentUser?.role === 'admin') {
      fetchAnnouncements()
    }
  }, [currentUser])

  const fetchStats = async () => {
    try {
      const res = await fetch('/api/system/stats')
      if (res.ok) {
        const data = await res.json()
        console.log('ç»Ÿè®¡æ•°æ®:', data)
        setStats(data)
      } else {
        console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', res.status, res.statusText)
      }
    } catch (e) {
      console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', e)
    }
  }

  const fetchAnnouncements = async () => {
    try {
      const res = await fetch('/api/announcements')
      if (res.ok) {
        const data = await res.json()
        setAnnouncements(data.announcements || [])
      }
    } catch (e) {
      console.error('è·å–å…¬å‘Šå¤±è´¥:', e)
    }
  }

  const handleAddAnnouncement = async () => {
    try {
      const res = await fetch('/api/announcements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newAnnouncement)
      })
      if (res.ok) {
        toast.success('å…¬å‘Šæ·»åŠ æˆåŠŸ')
        setShowAddAnnouncement(false)
        setNewAnnouncement({ title: '', content: '' })
        fetchAnnouncements()
      } else {
        toast.error('æ·»åŠ å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleUpdateAnnouncement = async () => {
    if (!editingAnnouncement) return
    try {
      const res = await fetch(`/api/announcements/${editingAnnouncement.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: editingAnnouncement.title,
          content: editingAnnouncement.content,
          is_active: true
        })
      })
      if (res.ok) {
        toast.success('å…¬å‘Šæ›´æ–°æˆåŠŸ')
        setEditingAnnouncement(null)
        fetchAnnouncements()
      } else {
        toast.error('æ›´æ–°å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  const handleDeleteAnnouncement = async (announcement: Announcement) => {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤å…¬å‘Š "${announcement.title}" å—ï¼Ÿ`)) return
    try {
      const res = await fetch(`/api/announcements/${announcement.id}`, { method: 'DELETE' })
      if (res.ok) {
        toast.success('å…¬å‘Šåˆ é™¤æˆåŠŸ')
        fetchAnnouncements()
      } else {
        toast.error('åˆ é™¤å¤±è´¥')
      }
    } catch (e) {
      toast.error('ç½‘ç»œé”™è¯¯')
    }
  }

  return (
    <div className="space-y-8">
      <div>
        <h2 className="text-4xl font-bold tracking-tight">ä»ªè¡¨ç›˜</h2>
        <p className="text-muted-foreground mt-2">ç³»ç»Ÿæ¦‚è§ˆå’Œå…¬å‘Šç®¡ç†</p>
      </div>

      {/* ç»Ÿè®¡ä¿¡æ¯ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">åº—é“ºæ•°é‡</CardTitle>
            <Store className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.shop_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²æ”¶å½•çš„åº—é“º</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">å•†å“æ•°é‡</CardTitle>
            <Package className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.product_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²æŠ“å–çš„å•†å“</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">å›¾ç‰‡æ•°é‡</CardTitle>
            <ImageIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.image_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">å·²ç´¢å¼•çš„å›¾ç‰‡</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">ç”¨æˆ·æ•°é‡</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats?.user_count ?? 0}</div>
            <p className="text-xs text-muted-foreground">æ´»è·ƒç”¨æˆ·</p>
          </CardContent>
        </Card>
      </div>

      {/* å…¬å‘Šç®¡ç† - æ‰€æœ‰ç”¨æˆ·å¯è§ï¼Œä½†åªæœ‰ç®¡ç†å‘˜å¯ä¿®æ”¹ */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle className="flex items-center">
                <Megaphone className="w-5 h-5 mr-2" />
                ç³»ç»Ÿå…¬å‘Š
              </CardTitle>
              <CardDescription>æŸ¥çœ‹æœ€æ–°ç³»ç»Ÿé€šçŸ¥</CardDescription>
            </div>
            {currentUser?.role === 'admin' && (
              <Dialog open={showAddAnnouncement} onOpenChange={setShowAddAnnouncement}>
                <DialogTrigger asChild>
                  <Button size="sm">
                    <Plus className="w-4 h-4 mr-2" />
                    æ·»åŠ å…¬å‘Š
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>æ·»åŠ ç³»ç»Ÿå…¬å‘Š</DialogTitle>
                    <DialogDescription>åˆ›å»ºæ–°çš„ç³»ç»Ÿå…¬å‘Š</DialogDescription>
                  </DialogHeader>
                  <div className="space-y-4">
                    <div>
                      <Label>å…¬å‘Šæ ‡é¢˜</Label>
                      <Input
                        value={newAnnouncement.title}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                        placeholder="è¯·è¾“å…¥å…¬å‘Šæ ‡é¢˜"
                      />
                    </div>
                    <div>
                      <Label>å…¬å‘Šå†…å®¹</Label>
                      <Textarea
                        value={newAnnouncement.content}
                        onChange={e => setNewAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                        placeholder="è¯·è¾“å…¥å…¬å‘Šå†…å®¹"
                        rows={4}
                      />
                    </div>
                  </div>
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setShowAddAnnouncement(false)}>å–æ¶ˆ</Button>
                    <Button onClick={handleAddAnnouncement}>æ·»åŠ å…¬å‘Š</Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            )}
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {announcements.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                æš‚æ— å…¬å‘Š
              </div>
            ) : (
              announcements.map((announcement) => (
                <div key={announcement.id} className="border rounded-lg p-4">
                  <div className="flex justify-between items-start mb-2">
                    <h4 className="font-semibold">{announcement.title}</h4>
                    {currentUser?.role === 'admin' && (
                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => setEditingAnnouncement(announcement)}
                        >
                          <Edit className="w-4 h-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleDeleteAnnouncement(announcement)}
                        >
                          <Trash2 className="w-4 h-4" />
                        </Button>
                      </div>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground mb-2">{announcement.content}</p>
                  <div className="text-xs text-muted-foreground">
                    æ›´æ–°æ—¶é—´: {new Date(announcement.updated_at).toLocaleString('zh-CN')}
                  </div>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* ç¼–è¾‘å…¬å‘Šå¯¹è¯æ¡† */}
      {editingAnnouncement && (
        <Dialog open={!!editingAnnouncement} onOpenChange={() => setEditingAnnouncement(null)}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>ç¼–è¾‘å…¬å‘Š</DialogTitle>
              <DialogDescription>ä¿®æ”¹å…¬å‘Šå†…å®¹</DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label>å…¬å‘Šæ ‡é¢˜</Label>
                <Input
                  value={editingAnnouncement.title}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>
              <div>
                <Label>å…¬å‘Šå†…å®¹</Label>
                <Textarea
                  value={editingAnnouncement.content}
                  onChange={e => setEditingAnnouncement(prev => ({ ...prev, content: e.target.value }))}
                  rows={4}
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingAnnouncement(null)}>å–æ¶ˆ</Button>
              <Button onClick={handleUpdateAnnouncement}>ä¿å­˜ä¿®æ”¹</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  )
}

--- File: ./frontend/components/login-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Bot, LogIn, User, Shield } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
}

export function LoginView({ onLogin }: { onLogin: (user: User) => void }) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [loading, setLoading] = useState(false)

  const handleLogin = async () => {
    if (!username || !password) {
      toast.error("è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ")
      return
    }

    setLoading(true)
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      })

      if (response.ok) {
        const data = await response.json()
        toast.success("ç™»å½•æˆåŠŸ")
        onLogin(data.user)
      } else {
        const error = await response.json()
        toast.error(error.error || "ç™»å½•å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    } finally {
      setLoading(false)
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleLogin()
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
      <Card className="w-full max-w-md shadow-2xl">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <div className="p-3 bg-primary rounded-full">
              <Bot className="h-8 w-8 text-primary-foreground" />
            </div>
          </div>
          <CardTitle className="text-2xl font-bold">Discord è¥é”€ç³»ç»Ÿ</CardTitle>
          <CardDescription>æ™ºèƒ½ Discord è´¦å·è¥é”€ç®¡ç†å¹³å°</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username" className="text-sm font-medium">
                ç”¨æˆ·å
              </Label>
              <div className="relative">
                <User className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="username"
                  type="text"
                  placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="password" className="text-sm font-medium">
                å¯†ç 
              </Label>
              <div className="relative">
                <Shield className="absolute left-3 top-2.5 h-5 w-5 text-muted-foreground" />
                <Input
                  id="password"
                  type="password"
                  placeholder="è¯·è¾“å…¥å¯†ç "
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="pl-10 h-11"
                />
              </div>
            </div>
          </div>

          <Button
            onClick={handleLogin}
            disabled={loading}
            className="w-full h-11 text-base font-semibold"
          >
            {loading ? (
              <>
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                ç™»å½•ä¸­...
              </>
            ) : (
              <>
                <LogIn className="mr-2 h-5 w-5" />
                ç™»å½•
              </>
            )}
          </Button>

        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/rules-view.tsx ---
"use client"

import { useState, useRef } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Trash2, Edit, Image as ImageIcon, Search, Upload, X } from "lucide-react"
import { toast } from "sonner"
import { Checkbox } from "@/components/ui/checkbox"

const mockRules: any[] = []

const availableAccounts = ["Sisyphus_Bot_01", "Marketing_Manager", "Auto_Responder_X", "Discord_Helper_04"]

export function RulesView() {
  const [rules, setRules] = useState(mockRules)
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingRule, setEditingRule] = useState<any>(null)
  const [ruleSearch, setRuleSearch] = useState("")
  const [selectedAccountMode, setSelectedAccountMode] = useState("random")
  const [selectedSpecificAccounts, setSelectedSpecificAccounts] = useState<string[]>([])
  const [matchType, setMatchType] = useState("keyword")
  
  const [replyImage, setReplyImage] = useState<string | null>(null)
  const [triggerImage, setTriggerImage] = useState<string | null>(null)
  
  const replyImageInputRef = useRef<HTMLInputElement>(null)
  const triggerImageInputRef = useRef<HTMLInputElement>(null)

  const handleDeleteRule = (id: number) => {
    setRules((prev) => prev.filter((rule) => rule.id !== id))
    toast.success("è§„åˆ™å·²åˆ é™¤")
  }

  const handleEditRule = (rule: any) => {
    setEditingRule(rule)
    setSelectedAccountMode(rule.accountMode)
    setMatchType(rule.matchType)
    setSelectedSpecificAccounts(rule.assignedAccounts.includes("all") ? [] : rule.assignedAccounts)
    setReplyImage(rule.replyImage || null)
    setTriggerImage(rule.triggerImage || null)
    setIsDialogOpen(true)
  }

  const filteredRules = rules.filter((r: any) =>
    r.keywords.some((k: string) => k.toLowerCase().includes(ruleSearch.toLowerCase())) ||
    r.replyText.toLowerCase().includes(ruleSearch.toLowerCase())
  )

  const toggleAccountSelection = (acc: string) => {
    setSelectedSpecificAccounts(prev => 
      prev.includes(acc) ? prev.filter(a => a !== acc) : [...prev, acc]
    )
  }

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>, type: 'reply' | 'trigger') => {
    const file = e.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        if (type === 'reply') setReplyImage(reader.result as string)
        else setTriggerImage(reader.result as string)
        toast.success("å›¾ç‰‡å·²å°±ç»ª")
      }
      reader.readAsDataURL(file)
    }
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">è§„åˆ™é…ç½®</h2>
          <p className="text-sm text-muted-foreground">é…ç½®è‡ªåŠ¨å›å¤è§¦å‘è§„åˆ™ã€å“åº”å†…å®¹ä»¥åŠå‘é€è´¦å·æ¨¡å¼</p>
        </div>
        <div className="flex items-center gap-4">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="æœç´¢è§„åˆ™å…³é”®è¯..."
              className="pl-9 w-[250px] h-10"
              value={ruleSearch}
              onChange={(e) => setRuleSearch(e.target.value)}
            />
          </div>
          <Dialog open={isDialogOpen} onOpenChange={(open) => {
            setIsDialogOpen(open)
            if (!open) {
              setEditingRule(null)
              setSelectedSpecificAccounts([])
              setReplyImage(null)
              setTriggerImage(null)
              setMatchType("keyword")
            }
          }}>
            <DialogTrigger asChild>
              <Button className="h-10 px-6 font-bold">
                <Plus className="mr-2 h-5 w-5" />
                æ·»åŠ æ–°è§„åˆ™
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle className="text-2xl">{editingRule ? "ç¼–è¾‘è§„åˆ™" : "åˆ›å»ºæ–°è§„åˆ™"}</DialogTitle>
                <DialogDescription>è®¾ç½®è§¦å‘æ¡ä»¶ã€å›å¤å†…å®¹åŠè´¦å·åˆ†é…ç­–ç•¥</DialogDescription>
              </DialogHeader>
              <div className="space-y-6 py-6">
                <div className="grid grid-cols-2 gap-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">åŒ¹é…æ¨¡å¼</Label>
                    <Select value={matchType} onValueChange={setMatchType}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="keyword">å…³é”®è¯åŒ¹é… (Partial)</SelectItem>
                        <SelectItem value="exact">ç²¾ç¡®åŒ¹é… (Exact)</SelectItem>
                        <SelectItem value="regex">æ­£åˆ™è¡¨è¾¾å¼ (Regex)</SelectItem>
                        <SelectItem value="image">å›¾ç‰‡è¯†åˆ« (è¯†åˆ«ç‰¹å®šç…§ç‰‡)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">å›å¤é™„ä»¶ (å›¾ç‰‡)</Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={replyImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'reply')}
                    />
                    <div className="flex items-center gap-2">
                      {replyImage ? (
                        <div className="relative size-10 border rounded overflow-hidden group">
                          <img src={replyImage} className="object-cover w-full h-full" alt="Reply" />
                          <button 
                            onClick={() => setReplyImage(null)}
                            className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity"
                          >
                            <X className="size-4 text-white" />
                          </button>
                        </div>
                      ) : (
                        <Button 
                          variant="outline" 
                          className="w-full h-10 border-dashed justify-start text-muted-foreground"
                          onClick={() => replyImageInputRef.current?.click()}
                        >
                          <Upload className="mr-2 h-4 w-4" />
                          ä¸Šä¼ å›å¤å›¾ç‰‡
                        </Button>
                      )}
                    </div>
                  </div>
                </div>

                {matchType === 'image' ? (
                  <div className="space-y-2 bg-primary/5 p-4 rounded-lg border-2 border-dashed border-primary/20">
                    <Label className="font-bold text-sm text-primary flex items-center gap-2">
                      <ImageIcon className="size-4" /> è¯†åˆ«ç›®æ ‡ (è§¦å‘ç…§ç‰‡)
                    </Label>
                    <input 
                      type="file" 
                      className="hidden" 
                      ref={triggerImageInputRef} 
                      accept="image/*" 
                      onChange={(e) => handleImageUpload(e, 'trigger')}
                    />
                    <p className="text-[11px] text-muted-foreground mb-3">å½“ç”¨æˆ·åœ¨ Discord å‘é€ä¸æ­¤ç…§ç‰‡é«˜åº¦ç›¸ä¼¼çš„å›¾ç‰‡æ—¶ï¼Œå°†è§¦å‘å›å¤ã€‚</p>
                    {triggerImage ? (
                      <div className="relative w-full aspect-video border rounded-xl overflow-hidden group max-h-[200px]">
                        <img src={triggerImage} className="object-contain w-full h-full bg-black/10" alt="Trigger" />
                        <button 
                          onClick={() => setTriggerImage(null)}
                          className="absolute top-2 right-2 p-1 bg-red-500 rounded-full text-white shadow-lg"
                        >
                          <X className="size-4" />
                        </button>
                      </div>
                    ) : (
                      <Button 
                        variant="secondary" 
                        className="w-full h-24 flex-col gap-2"
                        onClick={() => triggerImageInputRef.current?.click()}
                      >
                        <Upload className="size-6" />
                        <span>ç‚¹å‡»ä¸Šä¼ è¯†åˆ«æ¨¡æ¿å›¾</span>
                      </Button>
                    )}
                  </div>
                ) : (
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">è§¦å‘æ¡ä»¶ (å…³é”®è¯)</Label>
                    <Input 
                      id="keywords" 
                      defaultValue={editingRule ? editingRule.keywords.join(", ") : ""} 
                      placeholder="å¤šä¸ªå…³é”®è¯ç”¨é€—å·åˆ†éš”..." 
                      className="h-10" 
                    />
                  </div>
                )}

                <div className="space-y-2">
                  <Label className="font-bold text-sm">å›å¤æ–‡å­—å†…å®¹</Label>
                  <Textarea 
                    id="reply-text" 
                    defaultValue={editingRule ? editingRule.replyText : ""} 
                    placeholder="è¾“å…¥è‡ªåŠ¨å›å¤çš„æ–‡å­—ï¼ˆå¦‚æœä¸ºç©ºåˆ™åªå‘å›¾ç‰‡ï¼‰..." 
                    rows={4} 
                    className="text-base" 
                  />
                </div>

                <div className="grid grid-cols-2 gap-6 border-t pt-6">
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">è´¦å·åˆ†é…æ¨¡å¼</Label>
                    <Select value={selectedAccountMode} onValueChange={setSelectedAccountMode}>
                      <SelectTrigger className="h-10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="random">éšæœºä½¿ç”¨ (Random)</SelectItem>
                        <SelectItem value="rotation">é¡ºåºè½®æ¢ (Rotation)</SelectItem>
                        <SelectItem value="fixed">æ‰‹åŠ¨æŒ‡å®š (Specific)</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label className="font-bold text-sm">é€‰æ‹©æ‰§è¡Œè´¦å·</Label>
                    <div className="border rounded-md p-3 space-y-2 bg-muted/20 max-h-[150px] overflow-y-auto">
                      {availableAccounts.map(acc => (
                        <div key={acc} className="flex items-center space-x-2">
                          <Checkbox 
                            id={`acc-${acc}`} 
                            checked={selectedSpecificAccounts.includes(acc)}
                            onCheckedChange={() => toggleAccountSelection(acc)}
                          />
                          <label htmlFor={`acc-${acc}`} className="text-xs font-medium cursor-pointer">{acc}</label>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
              <DialogFooter className="border-t pt-6">
                <Button variant="outline" onClick={() => setIsDialogOpen(false)} className="h-10">
                  å–æ¶ˆ
                </Button>
                <Button
                  className="h-10 px-8 font-bold"
                  onClick={() => {
                    setIsDialogOpen(false)
                    toast.success("è§„åˆ™ä¿å­˜æˆåŠŸ")
                  }}
                >
                  {editingRule ? "ä¿å­˜ä¿®æ”¹" : "ç¡®è®¤æ·»åŠ è§„åˆ™"}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </div>
      </div>

      <Card className="shadow-sm">
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold pl-6">è§¦å‘è§„åˆ™</TableHead>
                <TableHead className="text-sm font-bold">æ¨¡å¼</TableHead>
                <TableHead className="text-sm font-bold">è´¦å·æ¨¡å¼</TableHead>
                <TableHead className="text-sm font-bold">å›å¤å†…å®¹</TableHead>
                <TableHead className="text-sm font-bold">å»¶è¿Ÿ</TableHead>
                <TableHead className="text-sm font-bold text-right pr-6">æ“ä½œ</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredRules.map((rule) => (
                <TableRow key={rule.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="pl-6">
                    {rule.matchType === 'image' ? (
                      <div className="flex items-center gap-2">
                        <div className="size-8 rounded border bg-muted overflow-hidden">
                          {rule.triggerImage ? <img src={rule.triggerImage} className="object-cover w-full h-full" alt="Trigger" /> : <ImageIcon className="size-4 m-2 text-muted-foreground" />}
                        </div>
                        <Badge variant="outline" className="text-[10px] bg-blue-50 text-blue-700">å›¾ç‰‡åŒ¹é…</Badge>
                      </div>
                    ) : (
                      <div className="flex flex-wrap gap-1.5">
                        {rule.keywords.map((keyword: string, i: number) => (
                          <Badge key={i} variant="secondary" className="text-[11px] font-medium h-5 bg-orange-50 text-orange-700 border-orange-200">
                            {keyword}
                          </Badge>
                        ))}
                      </div>
                    )}
                  </TableCell>
                  <TableCell>
                    <Badge variant="outline" className="text-[11px] font-medium h-5 border-primary/20 text-primary">
                      {rule.matchType === "keyword" && "å…³é”®è¯"}
                      {rule.matchType === "exact" && "ç²¾ç¡®åŒ¹é…"}
                      {rule.matchType === "regex" && "æ­£åˆ™"}
                      {rule.matchType === "image" && "å›¾ç‰‡è¯†åˆ«"}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge className={`${rule.accountMode === 'rotation' ? "bg-purple-600" : "bg-blue-600"} text-[11px] h-5`}>
                      {rule.accountMode === "random" ? "éšæœºä½¿ç”¨" : rule.accountMode === "rotation" ? "è‡ªåŠ¨è½®æ¢" : "å›ºå®šè´¦å·"}
                    </Badge>
                  </TableCell>
                  <TableCell className="max-w-[200px]">
                    <div className="flex flex-col gap-1">
                      <span className="text-[11px] truncate font-medium">{rule.replyText || "(ä»…å›å¤å›¾ç‰‡)"}</span>
                      {rule.replyImage && <span className="text-[9px] text-blue-500 flex items-center font-bold"><ImageIcon className="size-3 mr-1" /> [é™„å¸¦å›¾ç‰‡å›å¤]</span>}
                    </div>
                  </TableCell>
                  <TableCell className="text-xs font-mono font-bold">{rule.min_delay}-{rule.max_delay}s</TableCell>
                  <TableCell className="text-right pr-6">
                    <div className="flex items-center justify-end gap-2">
                      <Button variant="ghost" size="icon" className="h-9 w-9" onClick={() => handleEditRule(rule)}>
                        <Edit className="size-4" />
                      </Button>
                      <Button variant="ghost" size="icon" className="h-9 w-9 hover:bg-red-50 hover:text-red-600" onClick={() => handleDeleteRule(rule.id)}>
                        <Trash2 className="size-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
              {filteredRules.length === 0 && (
                <TableRow>
                  <TableCell colSpan={6} className="h-24 text-center text-muted-foreground italic">æœªæ‰¾åˆ°ç¬¦åˆæœç´¢æ¡ä»¶çš„è§„åˆ™</TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}

--- File: ./frontend/components/shops-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Plus, Trash2, Store, Loader2, RefreshCw, Search, CheckSquare, Square } from "lucide-react"
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

export function ShopsView({ currentUser }: { currentUser: any }) {

  const [shops, setShops] = useState<any[]>([])
  const [newShopId, setNewShopId] = useState('')
  const [isAddingShop, setIsAddingShop] = useState(false)
  const [selectedShopIds, setSelectedShopIds] = useState<string[]>([])
  const [isShopScraping, setIsShopScraping] = useState(false)
  const [searchKeyword, setSearchKeyword] = useState('')
  const [isBatchDeleting, setIsBatchDeleting] = useState(false)
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false)

  useEffect(() => {
    fetchShops()
  }, [])

  const fetchShops = async () => {
    try {
      const res = await fetch('/api/shops')
      const data = await res.json()
      let allShops = data.shops || []

      // æ ¹æ®ç”¨æˆ·æƒé™è¿‡æ»¤åº—é“º
      if (currentUser?.role !== 'admin' && currentUser?.shops) {
        // æ™®é€šç”¨æˆ·åªçœ‹åˆ°åˆ†é…ç»™ä»–ä»¬çš„åº—é“º
        allShops = allShops.filter((shop: any) => currentUser.shops.includes(shop.shop_id))
      }

      setShops(allShops)
    } catch (e) {
      toast.error("åŠ è½½åº—é“ºåˆ—è¡¨å¤±è´¥")
    }
  }

  const fetchShopInfo = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shop-info?shopId=${shopId}`)
      const data = await res.json()
      return data.shopName || `åº—é“º ${shopId}`
    } catch (e) {
      console.error("è·å–åº—é“ºä¿¡æ¯å¤±è´¥:", e)
      return `åº—é“º ${shopId}`
    }
  }

  const handleAddShop = async () => {
    if (!newShopId.trim()) {
      toast.error("è¯·è¾“å…¥åº—é“ºID")
      return
    }

    if (!/^\d+$/.test(newShopId.trim())) {
      toast.error("åº—é“ºIDå¿…é¡»æ˜¯æ•°å­—")
      return
    }

    setIsAddingShop(true)
    try {
      // å…ˆè·å–åº—é“ºåç§°
      const shopName = await fetchShopInfo(newShopId.trim())

      const res = await fetch('/api/shops', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopId: newShopId.trim(),
          name: shopName
        })
      })

      const data = await res.json()

      if (res.ok) {
        toast.success("åº—é“ºæ·»åŠ æˆåŠŸ")
        setNewShopId('')
        fetchShops()
      } else {
        toast.error(data.error || "æ·»åŠ åº—é“ºå¤±è´¥")
      }
    } catch (e) {
      toast.error("æ·»åŠ åº—é“ºå¤±è´¥")
    } finally {
      setIsAddingShop(false)
    }
  }

  const handleDeleteShop = async (shopId: string) => {
    try {
      const res = await fetch(`/api/shops/${shopId}`, {
        method: 'DELETE'
      })

      if (res.ok) {
        toast.success("åº—é“ºåˆ é™¤æˆåŠŸ")
        fetchShops()
        // ç§»é™¤é€‰ä¸­çŠ¶æ€
        setSelectedShopIds(prev => prev.filter(id => id !== shopId))
      } else {
        toast.error("åˆ é™¤åº—é“ºå¤±è´¥")
      }
    } catch (e) {
      toast.error("åˆ é™¤åº—é“ºå¤±è´¥")
    }
  }


  const handleSelectShop = (shopId: string) => {
    setSelectedShopIds(prev =>
      prev.includes(shopId)
        ? prev.filter(id => id !== shopId)
        : [...prev, shopId]
    )
  }

  const handleSelectAllShops = () => {
    if (selectedShopIds.length === filteredShops.length) {
      setSelectedShopIds([])
    } else {
      setSelectedShopIds(filteredShops.map(shop => shop.shop_id))
    }
  }

  const handleBatchDeleteShops = () => {
    if (selectedShopIds.length === 0) return
    setShowBatchDeleteConfirm(true)
  }

  const confirmBatchDeleteShops = async () => {
    setShowBatchDeleteConfirm(false)
    setIsBatchDeleting(true)

    let successCount = 0
    let failCount = 0

    try {
      for (const shopId of selectedShopIds) {
        try {
          const res = await fetch(`/api/shops/${shopId}`, {
            method: 'DELETE'
          })

          if (res.ok) {
            successCount++
          } else {
            failCount++
          }
        } catch (e) {
          failCount++
        }
      }

      if (successCount > 0) {
        toast.success(`æ‰¹é‡åˆ é™¤å®Œæˆï¼šæˆåŠŸ ${successCount} ä¸ª${failCount > 0 ? `ï¼Œå¤±è´¥ ${failCount} ä¸ª` : ''}`)
        setSelectedShopIds([])
        fetchShops()
      } else {
        toast.error("æ‰¹é‡åˆ é™¤å¤±è´¥")
      }
    } catch (e) {
      toast.error("æ‰¹é‡åˆ é™¤è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯")
    } finally {
      setIsBatchDeleting(false)
    }
  }

  // è¿‡æ»¤åº—é“ºåˆ—è¡¨
  const filteredShops = shops.filter(shop =>
    shop.name?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    shop.shop_id?.includes(searchKeyword)
  )

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-3xl font-bold tracking-tight">åº—é“ºç®¡ç†</h2>
        <p className="text-muted-foreground">ç®¡ç†å¾®åº—åº—é“ºï¼Œæ·»åŠ æ–°åº—é“ºå¹¶è¿›è¡Œå…¨é‡æŠ“å–</p>
        <div className="flex items-center gap-2 mt-2">
          <span className="text-sm text-muted-foreground">å½“å‰ç”¨æˆ·:</span>
          <span className="font-medium">{currentUser?.username}</span>
          <span className={`text-xs px-2 py-1 rounded ${
            currentUser?.role === 'admin'
              ? 'bg-blue-100 text-blue-700'
              : 'bg-gray-100 text-gray-700'
          }`}>
            {currentUser?.role === 'admin' ? 'ç®¡ç†å‘˜' : 'æ™®é€šç”¨æˆ·'}
          </span>
        </div>
      </div>

      {/* æ·»åŠ æ–°åº—é“º - ä»…ç®¡ç†å‘˜å¯è§ */}
      {currentUser?.role === 'admin' && (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Plus className="h-5 w-5" />
            æ·»åŠ æ–°åº—é“º
          </CardTitle>
          <CardDescription>
            è¾“å…¥å¾®åº—åº—é“ºIDï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è·å–åº—é“ºåç§°
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex gap-3">
            <div className="flex-1">
              <Input
                placeholder="è¾“å…¥åº—é“ºID (ä¾‹å¦‚: 1713062461)"
                value={newShopId}
                onChange={(e) => setNewShopId(e.target.value)}
                disabled={isAddingShop}
                onKeyPress={(e) => e.key === 'Enter' && handleAddShop()}
              />
            </div>
            <Button
              onClick={handleAddShop}
              disabled={!newShopId.trim() || isAddingShop}
            >
              {isAddingShop ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  æ·»åŠ ä¸­...
                </>
              ) : (
                <>
                  <Plus className="mr-2 h-4 w-4" />
                  æ·»åŠ åº—é“º
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
      )}


      {/* åº—é“ºåˆ—è¡¨ */}
      <Card>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <Store className="h-5 w-5" />
                åº—é“ºåˆ—è¡¨ ({shops.length})
              </CardTitle>
              <CardDescription>
                å·²æ·»åŠ çš„åº—é“ºï¼Œæ”¯æŒæ‰¹é‡å…¨é‡æŠ“å–å’Œåˆ é™¤
              </CardDescription>
            </div>
            {selectedShopIds.length > 0 && currentUser?.role === 'admin' && (
              <Button
                variant="destructive"
                size="sm"
                onClick={handleBatchDeleteShops}
                disabled={isBatchDeleting}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                åˆ é™¤é€‰ä¸­ ({selectedShopIds.length})
              </Button>
            )}
          </div>
        </CardHeader>

        {/* æœç´¢å’Œæ“ä½œå·¥å…·æ  */}
        {shops.length > 0 && (
          <div className="px-6 pb-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="æœç´¢åº—é“ºåç§°æˆ–ID..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                    disabled={isShopScraping}
                  />
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Button
                  variant={selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "secondary" : "outline"}
                  size="sm"
                  onClick={handleSelectAllShops}
                  disabled={isShopScraping || filteredShops.length === 0}
                >
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length
                    ? <CheckSquare className="mr-2 h-4 w-4" />
                    : <Square className="mr-2 h-4 w-4" />
                  }
                  {selectedShopIds.length > 0 && selectedShopIds.length === filteredShops.length ? "å–æ¶ˆå…¨é€‰" : "å…¨é€‰"}
                </Button>
              </div>
            </div>

            {/* æœç´¢ç»“æœçŠ¶æ€ */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                æœç´¢ç»“æœ: <span className="font-medium">{filteredShops.length}</span> ä¸ªåº—é“º
                <span className="ml-2">å…³é”®è¯: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}

            {/* é€‰ä¸­çŠ¶æ€ */}
            {selectedShopIds.length > 0 && (
              <div className="mt-2 text-sm text-blue-700 bg-blue-50 px-3 py-2 rounded-md border border-blue-200">
                å·²é€‰æ‹© <span className="font-medium">{selectedShopIds.length}</span> ä¸ªåº—é“º
              </div>
            )}
          </div>
        )}
        <CardContent>
          {shops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Store className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">æš‚æ— åº—é“º</p>
              <p className="text-sm">è¯·å…ˆæ·»åŠ åº—é“ºID</p>
            </div>
          ) : filteredShops.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium">æœªæ‰¾åˆ°åŒ¹é…çš„åº—é“º</p>
              <p className="text-sm">å°è¯•è°ƒæ•´æœç´¢å…³é”®è¯</p>
            </div>
          ) : (
            <div className="space-y-3">
              {filteredShops.map((shop) => (
                <div
                  key={shop.shop_id}
                  className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50 transition-colors"
                >
                  <div className="flex items-center gap-3 flex-1">
                    <input
                      type="checkbox"
                      checked={selectedShopIds.includes(shop.shop_id)}
                      onChange={() => handleSelectShop(shop.shop_id)}
                      disabled={isShopScraping}
                      className="rounded border-gray-300"
                    />
                    <div className="flex-1">
                      <div className="font-medium">{shop.name}</div>
                      <div className="text-sm text-muted-foreground">
                        ID: {shop.shop_id}{shop.product_count > 0 ? ` â€¢ å•†å“æ•°: ${shop.product_count}` : ''}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        æ·»åŠ æ—¶é—´: {(() => {
                          try {
                            const date = new Date(shop.created_at);
                            return isNaN(date.getTime()) ? 'æœªçŸ¥æ—¶é—´' : date.toLocaleString('zh-CN');
                          } catch {
                            return 'æœªçŸ¥æ—¶é—´';
                          }
                        })()}
                      </div>
                    </div>
                  </div>
                  {(currentUser?.role === 'admin' || currentUser?.shops?.includes(shop.shop_id)) && (
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => handleDeleteShop(shop.shop_id)}
                    disabled={isShopScraping}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                  )}
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* æ‰¹é‡åˆ é™¤ç¡®è®¤å¯¹è¯æ¡† */}
      <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>ç¡®è®¤æ‰¹é‡åˆ é™¤</DialogTitle>
            <DialogDescription>
              ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ {selectedShopIds.length} ä¸ªåº—é“ºå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
              å–æ¶ˆ
              </Button>
            <Button variant="destructive" onClick={confirmBatchDeleteShops} disabled={isBatchDeleting}>
              {isBatchDeleting ? "åˆ é™¤ä¸­..." : "ç¡®è®¤åˆ é™¤"}
              </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
--- File: ./frontend/components/users-view.tsx ---
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Badge } from "@/components/ui/badge"
import { Checkbox } from "@/components/ui/checkbox"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Plus, Shield, User, Users, Edit, Trash2, Save, Search } from "lucide-react"
import { toast } from "sonner"

interface User {
  id: number
  username: string
  role: string
  shops: string[]
  is_active: boolean
  created_at: string
}

export function UsersView() {
  const [users, setUsers] = useState<User[]>([])
  const [shops, setShops] = useState<any[]>([])
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [editingUser, setEditingUser] = useState<User | null>(null)
  const [newUser, setNewUser] = useState({
    username: "",
    password: "",
    role: "user",
    shops: [] as string[]
  })
  const [loading, setLoading] = useState(true)

  const [resetPasswordUser, setResetPasswordUser] = useState<User | null>(null)
  const [newPassword, setNewPassword] = useState("")
  const [deleteUserConfirm, setDeleteUserConfirm] = useState<User | null>(null)

  // Pagination State
  const [page, setPage] = useState(1)
  const itemsPerPage = 10
  const [searchKeyword, setSearchKeyword] = useState('')

  // è¿‡æ»¤ç”¨æˆ·åˆ—è¡¨
  const filteredUsers = users.filter(user =>
    user.username?.toLowerCase().includes(searchKeyword.toLowerCase()) ||
    user.role?.toLowerCase().includes(searchKeyword.toLowerCase())
  )

  // è®¡ç®—åˆ†é¡µæ•°æ®
  const paginatedUsers = filteredUsers.slice((page-1)*itemsPerPage, page*itemsPerPage)
  const totalPages = Math.ceil(filteredUsers.length / itemsPerPage)

  useEffect(() => {
    fetchUsers()
    fetchShops()
  }, [])

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users')
      if (response.ok) {
        const data = await response.json()
        setUsers(data.users || [])
      }
    } catch (error) {
      console.error('Failed to fetch users:', error)
    } finally {
      setLoading(false)
    }
  }

  const fetchShops = async () => {
    try {
      const response = await fetch('/api/shops')
      if (response.ok) {
        const data = await response.json()
        setShops(data.shops || [])
      }
    } catch (error) {
      console.error('Failed to fetch shops:', error)
    }
  }

  const handleCreateUser = async () => {
    if (!newUser.username || !newUser.password) {
      toast.error("è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ")
      return
    }

    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      })

      if (response.ok) {
        const data = await response.json()
        setUsers([...users, data.user])
        toast.success("ç”¨æˆ·åˆ›å»ºæˆåŠŸ")
        setIsDialogOpen(false)
        setNewUser({ username: "", password: "", role: "user", shops: [] })
      } else {
        const error = await response.json()
        toast.error(error.error || "åˆ›å»ºç”¨æˆ·å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    }
  }

  const handleDeleteUser = (user: User) => {
    setDeleteUserConfirm(user)
  }

  const confirmDeleteUser = async () => {
    if (!deleteUserConfirm) return

    try {
      const response = await fetch(`/api/users/${deleteUserConfirm.id}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        setUsers(users.filter(u => u.id !== deleteUserConfirm.id))
        toast.success("ç”¨æˆ·åˆ é™¤æˆåŠŸ")
        setDeleteUserConfirm(null)
      } else {
        const error = await response.json()
        toast.error(error.error || "åˆ é™¤ç”¨æˆ·å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    }
  }

  const handleResetPassword = async () => {
      if (!resetPasswordUser || !newPassword) return
      try {
          const res = await fetch(`/api/users/${resetPasswordUser.id}/password`, {
              method: 'PUT',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ password: newPassword })
          })
          if (res.ok) {
              toast.success("å¯†ç ä¿®æ”¹æˆåŠŸ")
              setResetPasswordUser(null)
              setNewPassword("")
          } else {
              toast.error("ä¿®æ”¹å¤±è´¥")
          }
      } catch(e) { toast.error("ç½‘ç»œé”™è¯¯") }
  }

  const handleUpdateUserShops = async (userId: number, shopIds: string[]) => {
    try {
      const response = await fetch(`/api/users/${userId}/shops`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ shops: shopIds })
      })

      if (response.ok) {
        setUsers(users.map(u => u.id === userId ? { ...u, shops: shopIds } : u))
        toast.success("æƒé™æ›´æ–°æˆåŠŸ")
        setEditingUser(null)
      } else {
        toast.error("æƒé™æ›´æ–°å¤±è´¥")
      }
    } catch (error) {
      toast.error("ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•")
    }
  }

  const getShopNames = (shopIds: string[]) => {
    return shopIds.map(id => {
      const shop = shops.find(s => s.shop_id === id)
      return shop ? shop.name : id
    }).join(', ')
  }

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-4xl font-extrabold tracking-tight">ç”¨æˆ·æƒé™ç®¡ç†</h2>
          <p className="text-sm text-muted-foreground mt-1">åˆ›å»ºç”¨æˆ·å¹¶åˆ†é…åº—é“ºç®¡ç†æƒé™</p>
        </div>
        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 size-5" />
              åˆ›å»ºç”¨æˆ·
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle className="text-xl">åˆ›å»ºæ–°ç”¨æˆ·</DialogTitle>
              <DialogDescription>è®¾ç½®ç”¨æˆ·åã€å¯†ç å’Œæƒé™</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>ç”¨æˆ·å</Label>
                <Input
                  value={newUser.username}
                  onChange={(e) => setNewUser({...newUser, username: e.target.value})}
                  placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
                />
              </div>
              <div className="space-y-2">
                <Label>å¯†ç </Label>
                <Input
                  type="password"
                  value={newUser.password}
                  onChange={(e) => setNewUser({...newUser, password: e.target.value})}
                  placeholder="è¯·è¾“å…¥å¯†ç "
                />
              </div>
              <div className="space-y-2">
                <Label>è§’è‰²</Label>
                <Select value={newUser.role} onValueChange={(value) => setNewUser({...newUser, role: value})}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="user">æ™®é€šç”¨æˆ·</SelectItem>
                    <SelectItem value="admin">ç®¡ç†å‘˜</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label>ç®¡ç†çš„åº—é“º</Label>
                <div className="max-h-32 overflow-y-auto border rounded p-2 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={shop.shop_id}
                        checked={newUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          if (checked) {
                            setNewUser({...newUser, shops: [...newUser.shops, shop.shop_id]})
                          } else {
                            setNewUser({...newUser, shops: newUser.shops.filter(id => id !== shop.shop_id)})
                          }
                        }}
                      />
                      <Label htmlFor={shop.shop_id} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>å–æ¶ˆ</Button>
              <Button onClick={handleCreateUser}>åˆ›å»ºç”¨æˆ·</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>

      <Card className="shadow-sm">
        <CardHeader className="py-5 border-b">
          <CardTitle className="text-2xl font-bold">ç”¨æˆ·åˆ—è¡¨</CardTitle>
          <CardDescription className="text-sm">
            å…± {users.length} ä¸ªç”¨æˆ·
          </CardDescription>
        </CardHeader>

        {/* æœç´¢å·¥å…·æ  */}
        {users.length > 0 && (
          <div className="px-6 py-4 border-b bg-muted/10">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="æœç´¢ç”¨æˆ·åæˆ–è§’è‰²..."
                    value={searchKeyword}
                    onChange={(e) => setSearchKeyword(e.target.value)}
                    className="pl-10 h-9 w-full sm:w-[300px]"
                  />
                </div>
              </div>
            </div>

            {/* æœç´¢ç»“æœçŠ¶æ€ */}
            {searchKeyword && (
              <div className="mt-3 text-sm text-muted-foreground">
                æœç´¢ç»“æœ: <span className="font-medium">{filteredUsers.length}</span> ä¸ªç”¨æˆ·
                <span className="ml-2">å…³é”®è¯: <span className="font-medium">"{searchKeyword}"</span></span>
              </div>
            )}
          </div>
        )}
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow className="bg-muted/50 h-12">
                <TableHead className="text-sm font-bold text-foreground pl-6">ç”¨æˆ·å</TableHead>
                <TableHead className="text-sm font-bold text-foreground">è§’è‰²</TableHead>
                <TableHead className="text-sm font-bold text-foreground">ç®¡ç†åº—é“º</TableHead>
                <TableHead className="text-sm font-bold text-foreground">çŠ¶æ€</TableHead>
                <TableHead className="text-sm font-bold text-foreground text-right pr-6">æ“ä½œ</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {paginatedUsers.map((user) => (
                <TableRow key={user.id} className="h-16 hover:bg-muted/30 transition-colors">
                  <TableCell className="font-medium py-3 pl-6">
                    <div className="flex items-center gap-2">
                      {user.role === 'admin' ? (
                        <Shield className="size-4 text-blue-600" />
                      ) : (
                        <User className="size-4 text-gray-600" />
                      )}
                      <span className="text-base font-semibold">{user.username}</span>
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.role === 'admin' ? (
                      <Badge className="bg-blue-600">ç®¡ç†å‘˜</Badge>
                    ) : (
                      <Badge variant="secondary">æ™®é€šç”¨æˆ·</Badge>
                    )}
                  </TableCell>
                  <TableCell className="py-3">
                    <div className="text-sm max-w-xs truncate" title={getShopNames(user.shops)}>
                      {user.shops.length > 0 ? getShopNames(user.shops) : "æ— "}
                    </div>
                  </TableCell>
                  <TableCell className="py-3">
                    {user.is_active ? (
                      <Badge className="bg-green-600">æ´»è·ƒ</Badge>
                    ) : (
                      <Badge variant="secondary">ç¦ç”¨</Badge>
                    )}
                  </TableCell>
                  <TableCell className="text-right pr-6 py-3">
                    <div className="flex items-center justify-end gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setResetPasswordUser(user)}
                      >
                        ä¿®æ”¹å¯†ç 
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setEditingUser(user)}
                      >
                        <Edit className="size-4 mr-1" />
                        æƒé™
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDeleteUser(user)}
                        className="text-red-600 hover:text-red-700 hover:bg-red-50"
                      >
                        <Trash2 className="size-4 mr-1" />
                        åˆ é™¤
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* ç¼–è¾‘ç”¨æˆ·æƒé™å¯¹è¯æ¡† */}
      {editingUser && (
        <Dialog open={!!editingUser} onOpenChange={() => setEditingUser(null)}>
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle>ç¼–è¾‘ç”¨æˆ·æƒé™ - {editingUser.username}</DialogTitle>
              <DialogDescription>ä¿®æ”¹ç”¨æˆ·ç®¡ç†çš„åº—é“ºæƒé™</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label>ç®¡ç†çš„åº—é“º</Label>
                <div className="max-h-48 overflow-y-auto border rounded p-3 space-y-2">
                  {shops.map(shop => (
                    <div key={shop.shop_id} className="flex items-center space-x-2">
                      <Checkbox
                        id={`edit-${shop.shop_id}`}
                        checked={editingUser.shops.includes(shop.shop_id)}
                        onCheckedChange={(checked) => {
                          const newShops = checked
                            ? [...editingUser.shops, shop.shop_id]
                            : editingUser.shops.filter(id => id !== shop.shop_id)
                          setEditingUser({...editingUser, shops: newShops})
                        }}
                      />
                      <Label htmlFor={`edit-${shop.shop_id}`} className="text-sm">{shop.name}</Label>
                    </div>
                  ))}
                </div>
                {shops.length === 0 && (
                  <p className="text-sm text-muted-foreground">æš‚æ— åº—é“ºï¼Œè¯·å…ˆæ·»åŠ åº—é“º</p>
                )}
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditingUser(null)}>å–æ¶ˆ</Button>
              <Button onClick={() => handleUpdateUserShops(editingUser.id, editingUser.shops)}>
                <Save className="size-4 mr-1" />
                ä¿å­˜æƒé™
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}

      {/* åˆ†é¡µæ§ä»¶ */}
      {totalPages > 1 && (
        <div className="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6 px-6 py-4 border-t bg-muted/5">
          <div className="text-sm text-muted-foreground font-medium">
            æ˜¾ç¤ºç¬¬ {(page-1)*itemsPerPage + 1} - {Math.min(page*itemsPerPage, filteredUsers.length)} æ¡ï¼Œå…± {filteredUsers.length} æ¡è®°å½•
          </div>
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                disabled={page===1}
                onClick={()=>setPage(p=>p-1)}
                className="h-8 px-3"
              >
                ä¸Šä¸€é¡µ
              </Button>
              <div className="text-sm font-medium bg-primary text-primary-foreground px-3 py-1 rounded">
                {page} / {totalPages}
              </div>
              <Button
                variant="outline"
                size="sm"
                disabled={page===totalPages}
                onClick={()=>setPage(p=>p+1)}
                className="h-8 px-3"
              >
                ä¸‹ä¸€é¡µ
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Reset Password Dialog */}
      <Dialog open={!!resetPasswordUser} onOpenChange={()=>setResetPasswordUser(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>é‡ç½®å¯†ç  - {resetPasswordUser?.username}</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <Label>æ–°å¯†ç </Label>
            <Input type="password" value={newPassword} onChange={e=>setNewPassword(e.target.value)} />
          </div>
          <DialogFooter>
            <Button onClick={handleResetPassword}>ç¡®è®¤ä¿®æ”¹</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* åˆ é™¤ç”¨æˆ·ç¡®è®¤å¯¹è¯æ¡† */}
      <Dialog open={!!deleteUserConfirm} onOpenChange={() => setDeleteUserConfirm(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>ç¡®è®¤åˆ é™¤ç”¨æˆ·</DialogTitle>
            <DialogDescription>
              ç¡®å®šè¦åˆ é™¤ç”¨æˆ· "{deleteUserConfirm?.username}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteUserConfirm(null)}>
              å–æ¶ˆ
            </Button>
            <Button variant="destructive" onClick={confirmDeleteUser}>
              ç¡®è®¤åˆ é™¤
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}

--- File: ./frontend/hooks/use-api-cache.ts ---
import { useState, useCallback } from 'react'

interface CacheEntry {
  data: any
  timestamp: number
}

export function useApiCache(cacheDuration: number = 30000) {
  const [cache, setCache] = useState<{[key: string]: CacheEntry}>({})

  const cachedFetch = useCallback(async (url: string, options?: RequestInit): Promise<any> => {
    const cacheKey = `${options?.method || 'GET'}:${url}`
    const now = Date.now()

    // æ£€æŸ¥ç¼“å­˜
    const cached = cache[cacheKey]
    if (cached && (now - cached.timestamp) < cacheDuration) {
      console.log(`ä½¿ç”¨ç¼“å­˜æ•°æ®: ${cacheKey}`)
      return cached.data
    }

    // å‘èµ·æ–°è¯·æ±‚
    console.log(`å‘èµ·APIè¯·æ±‚: ${cacheKey}`)
    const response = await fetch(url, options)
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`)
    }
    const data = await response.json()

    // æ›´æ–°ç¼“å­˜
    setCache(prev => ({
      ...prev,
      [cacheKey]: { data, timestamp: now }
    }))

    return data
  }, [cache, cacheDuration])

  const clearCache = useCallback(() => {
    setCache({})
  }, [])

  const invalidateCache = useCallback((url: string, method: string = 'GET') => {
    const cacheKey = `${method}:${url}`
    setCache(prev => {
      const newCache = { ...prev }
      delete newCache[cacheKey]
      return newCache
    })
  }, [])

  return { cachedFetch, clearCache, invalidateCache }
}

--- File: ./frontend/hooks/use-mobile.ts ---
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener('change', onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener('change', onChange)
  }, [])

  return !!isMobile
}

--- File: ./frontend/hooks/use-toast.ts ---
'use client'

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '@/components/ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }

--- File: ./frontend/lib/utils.ts ---
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- File: ./backend/config.py ---
import os
from dotenv import load_dotenv

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

class Config:
    # === åŸºç¡€é…ç½® ===
    HOST = '0.0.0.0'
    PORT = 5001
    DEBUG = False  # ç”Ÿäº§ç¯å¢ƒå»ºè®®å…³é—­è°ƒè¯•æ¨¡å¼ä»¥å‡å°‘æ—¥å¿—

    # === å…³é”®ä¿®å¤ï¼šSECRET_KEY å¿…é¡»åœ¨ç±»é‡Œé¢ ===
    SECRET_KEY = 'my-fixed-secret-key-888888'

    # === Sessioné…ç½® ===
    SESSION_COOKIE_SECURE = False
    SESSION_COOKIE_SAMESITE = 'Lax'
    SESSION_LIFETIME = 86400 * 30

    # === CORS ===
    CORS_ORIGINS = ["*"]

    # === è®¾å¤‡é…ç½® ===
    DEVICE = os.getenv('DEVICE', 'cpu')

    # === Discord é…ç½® ===
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = 0.6

    # === å»¶è¿Ÿé…ç½® ===
    GLOBAL_REPLY_MIN_DELAY = 3.0
    GLOBAL_REPLY_MAX_DELAY = 8.0

    # === é¢‘é“é…ç½® ===
    CNFANS_CHANNEL_ID = 0
    ACBUY_CHANNEL_ID = 0
    FORWARD_KEYWORDS = []
    FORWARD_TARGET_CHANNEL_ID = 0

    # === API åœ°å€ ===
    BACKEND_API_URL = 'http://127.0.0.1:5001'
    NEXTJS_API_URL = f'{BACKEND_API_URL}/api'

    # === æœºå™¨äºº ===
    COMMAND_PREFIX = '!'

    # === AI æ¨¡å‹ ===
    DINO_MODEL_NAME = 'facebook/dinov2-small'
    VECTOR_DIMENSION = 384
    YOLO_MODEL_PATH = 'yolov8s-world.pt'
    USE_YOLO_CROP = True

    # === å¤šçº¿ç¨‹ ===
    SCRAPE_THREADS = 10  # æé«˜å¹¶å‘æ•°
    DOWNLOAD_THREADS = 8  # å›¾ç‰‡ä¸‹è½½çº¿ç¨‹
    FEATURE_EXTRACT_THREADS = 4  # AI çº¿ç¨‹ (ä¸è¦å¤ªå¤§ï¼Œå¦åˆ™ CPU çˆ†æ»¡)

    # === FAISS ===
    FAISS_HNSW_M = 64
    FAISS_EF_CONSTRUCTION = 80
    FAISS_EF_SEARCH = 64

    # === è·¯å¾„ ===
    BASE_DIR = os.path.dirname(os.path.dirname(__file__))
    DATA_DIR = os.path.join(BASE_DIR, 'backend', 'data')
    # ç¡®ä¿è¿™äº›è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„
    IMAGE_SAVE_DIR = os.path.join(DATA_DIR, 'scraped_images')
    LOG_DIR = os.path.join(DATA_DIR, 'logs')
    DATABASE_PATH = os.path.join(DATA_DIR, 'metadata.db')

    FAISS_INDEX_FILE = os.path.join(DATA_DIR, 'faiss_index.bin')
    FAISS_ID_MAP_FILE = os.path.join(DATA_DIR, 'faiss_id_map.pkl')

    # === ç½‘ç»œ ===
    REQUEST_TIMEOUT = 30
    MAX_RETRIES = 3

    @classmethod
    def init_dirs(cls):
        for dir_path in [cls.DATA_DIR, cls.IMAGE_SAVE_DIR, cls.LOG_DIR]:
            os.makedirs(dir_path, exist_ok=True)

# åˆå§‹åŒ–
config = Config()
config.init_dirs()
--- File: ./backend/database.py ---
import sqlite3
import numpy as np
import os
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from contextlib import contextmanager
try:
    from config import config
except ImportError:
    from .config import config

logger = logging.getLogger(__name__)

class Database:
    def __init__(self):
        # SQLite æ•°æ®åº“è·¯å¾„ (ç”¨äºå­˜å‚¨å•†å“å…ƒæ•°æ®å’ŒDiscordè´¦å·ä¿¡æ¯)
        self.db_path = os.path.join(os.path.dirname(__file__), 'data', 'metadata.db')

        # ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        # åˆå§‹åŒ– SQLite æ•°æ®åº“
        self.init_sqlite_database()

    def init_sqlite_database(self):
        """åˆå§‹åŒ– SQLite æ•°æ®åº“ (ç”¨äºå…ƒæ•°æ®å­˜å‚¨)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # åˆ›å»ºå•†å“è¡¨ï¼ˆç§»é™¤å•†å“çº§åˆ«å»¶è¿Ÿï¼Œä½¿ç”¨å…¨å±€å»¶è¿Ÿï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_url TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    english_title TEXT,
                    cnfans_url TEXT,
                    acbuy_url TEXT,
                    shop_name TEXT,
                    ruleEnabled BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
            try:
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_shop_name ON products(shop_name)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_products_rule_enabled ON products(ruleEnabled)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON product_images(product_id)')
                cursor.execute('CREATE INDEX IF NOT EXISTS idx_product_images_image_index ON product_images(image_index)')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºåº—é“ºè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS shops (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    shop_id TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    product_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # ä¸ºç°æœ‰è¡¨æ·»åŠ æ–°å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN ruleEnabled BOOLEAN DEFAULT 1')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN min_delay INTEGER DEFAULT 3')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN max_delay INTEGER DEFAULT 8')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # æ–°å¢è‹±æ–‡æ ‡é¢˜ä¸ cnfans é“¾æ¥å­—æ®µï¼ˆå…¼å®¹å·²æœ‰æ•°æ®åº“ï¼‰
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN english_title TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN cnfans_url TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN acbuy_url TEXT')
            except sqlite3.OperationalError:
                pass

            # æ·»åŠ è‡ªå®šä¹‰å›å¤å­—æ®µ
            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_text TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_reply_images TEXT')  # JSONæ ¼å¼å­˜å‚¨å›¾ç‰‡ç´¢å¼•æ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN custom_image_urls TEXT')  # JSONæ ¼å¼å­˜å‚¨è‡ªå®šä¹‰å›¾ç‰‡URLæ•°ç»„
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN image_source TEXT DEFAULT \'product\'')  # å›¾ç‰‡æ¥æºï¼š'product'(å•†å“å›¾ç‰‡), 'upload'(æœ¬åœ°ä¸Šä¼ ), 'custom'(URL)
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE products ADD COLUMN shop_name TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN cnfans_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN acbuy_channel_id TEXT')
            except sqlite3.OperationalError:
                pass

            # åˆ›å»ºå›¾ç‰‡è¡¨ (milvus_id æ›¿ä»£ faiss_id)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS product_images (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    image_path TEXT NOT NULL,
                    image_index INTEGER NOT NULL,
                    features TEXT,  -- å­˜å‚¨åºåˆ—åŒ–çš„ç‰¹å¾å‘é‡
                    milvus_id INTEGER UNIQUE,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE,
                    UNIQUE(product_id, image_index)
                )
            ''')

            # åˆ›å»ºç”¨æˆ·è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    role TEXT DEFAULT 'user',  -- admin, user
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç”¨æˆ·-åº—é“ºæƒé™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_shop_permissions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    shop_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id, shop_id)
                )
            ''')

            # åˆ›å»º Discord è´¦å·è¡¨ï¼ˆå…³è”åˆ°ç”¨æˆ·ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS discord_accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT,
                    token TEXT UNIQUE NOT NULL,
                    user_id INTEGER,
                    status TEXT DEFAULT 'offline',
                    last_active TIMESTAMP,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL
                )
            ''')

            # æ’å…¥é»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO users (id, username, password_hash, role, is_active)
                    VALUES (1, 'admin', 'hashed_admin123', 'admin', 1)
                ''')  # å¯†ç : admin123
            except sqlite3.Error as e:
                logger.warning(f"åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜å¤±è´¥: {e}")

            # åˆ›å»ºè´¦å·è½®æ¢é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS account_rotation_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    enabled BOOLEAN DEFAULT 0,
                    rotation_interval INTEGER DEFAULT 10,
                    current_account_id INTEGER,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤è½®æ¢é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO account_rotation_config (id, enabled, rotation_interval)
                VALUES (1, 0, 10)
            ''')

            # åˆ›å»ºæœç´¢å†å²è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS search_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    query_image_path TEXT NOT NULL,
                    matched_product_id INTEGER,
                    matched_image_index INTEGER,
                    similarity REAL NOT NULL,
                    threshold REAL NOT NULL,
                    search_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (matched_product_id) REFERENCES products (id) ON DELETE SET NULL
                )
            ''')

            # åˆ›å»ºå…¨å±€å»¶è¿Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS global_reply_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    min_delay REAL DEFAULT 3.0,
                    max_delay REAL DEFAULT 8.0,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿé…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_config (
                    id INTEGER PRIMARY KEY CHECK (id = 1),
                    discord_channel_id TEXT DEFAULT '',
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    cnfans_channel_id TEXT DEFAULT '',
                    acbuy_channel_id TEXT DEFAULT '',
                    scrape_threads INTEGER DEFAULT 2,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç³»ç»Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                VALUES (1, '', 4, 4, 0.6, '', '')
            ''')

            # ä¸ºç°æœ‰è®°å½•æ·»åŠ scrape_threadså­—æ®µ
            try:
                cursor.execute('ALTER TABLE system_config ADD COLUMN scrape_threads INTEGER DEFAULT 2')
            except sqlite3.OperationalError:
                pass  # å­—æ®µå·²å­˜åœ¨

            # åˆ›å»ºç½‘ç«™é…ç½®è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_configs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    display_name TEXT NOT NULL,
                    url_template TEXT NOT NULL,
                    id_pattern TEXT NOT NULL,
                    badge_color TEXT DEFAULT 'blue',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºç½‘ç«™é¢‘é“ç»‘å®šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS website_channel_bindings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    website_id INTEGER NOT NULL,
                    channel_id TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (website_id) REFERENCES website_configs (id) ON DELETE CASCADE,
                    UNIQUE(website_id, channel_id)
                )
            ''')

            # åˆ›å»ºç³»ç»Ÿå…¬å‘Šè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS system_announcements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºæ¶ˆæ¯è¿‡æ»¤è§„åˆ™è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS message_filters (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filter_type TEXT NOT NULL, -- 'contains', 'starts_with', 'ends_with', 'regex'
                    filter_value TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # åˆ›å»ºè‡ªå®šä¹‰å›å¤å†…å®¹è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS custom_replies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    reply_type TEXT NOT NULL, -- 'text', 'image', 'text_and_link', 'custom_only'
                    content TEXT, -- æ–‡å­—å†…å®¹æˆ–å›¾ç‰‡URL
                    image_url TEXT, -- å¦‚æœæ˜¯å›¾ç‰‡å›å¤
                    is_active BOOLEAN DEFAULT 1,
                    priority INTEGER DEFAULT 0, -- ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤ç½‘ç«™é…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                VALUES
                    ('cnfans', 'CNFans', 'https://cnfans.com/product?id={id}&platform=WEIDIAN', '{id}', 'blue'),
                    ('acbuy', 'AcBuy', 'https://www.acbuy.com/product?url=https%3A%2F%2Fweidian.com%2Fitem.html%3FitemID%3D{id}&id={id}&source=WD', '{id}', 'orange'),
                    ('weidian', 'å¾®åº—', 'https://weidian.com/item.html?itemID={id}', '{id}', 'gray')
            ''')

            # åˆ›å»ºç”¨æˆ·è®¾ç½®è¡¨ï¼ˆæ¯ä¸ªç”¨æˆ·çš„ä¸ªæ€§åŒ–è®¾ç½®ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS user_settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    download_threads INTEGER DEFAULT 4,
                    feature_extract_threads INTEGER DEFAULT 4,
                    discord_similarity_threshold REAL DEFAULT 0.6,
                    global_reply_min_delay REAL DEFAULT 3.0,
                    global_reply_max_delay REAL DEFAULT 8.0,
                    user_blacklist TEXT DEFAULT '',  -- ç”¨æˆ·é»‘åå•ï¼Œé€—å·åˆ†éš”
                    keyword_filters TEXT DEFAULT '',  -- å…³é”®è¯è¿‡æ»¤ï¼Œé€—å·åˆ†éš”
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE(user_id)
                )
            ''')

            # åˆ›å»ºæŠ“å–çŠ¶æ€è¡¨ï¼ˆæŒä¹…åŒ–å­˜å‚¨æŠ“å–çŠ¶æ€ï¼‰
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scrape_status (
                    id INTEGER PRIMARY KEY CHECK (id = 1),  -- åªå…è®¸ä¸€æ¡è®°å½•
                    is_scraping BOOLEAN DEFAULT 0,
                    stop_signal BOOLEAN DEFAULT 0,
                    current_shop_id TEXT,
                    total INTEGER DEFAULT 0,
                    processed INTEGER DEFAULT 0,
                    success INTEGER DEFAULT 0,
                    progress REAL DEFAULT 0,
                    message TEXT DEFAULT 'ç­‰å¾…å¼€å§‹...',
                    completed BOOLEAN DEFAULT 0,
                    thread_id TEXT,  -- è®°å½•å½“å‰çº¿ç¨‹ID
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # æ’å…¥é»˜è®¤çŠ¶æ€è®°å½•
            cursor.execute('''
                INSERT OR IGNORE INTO scrape_status (id, is_scraping, stop_signal, message)
                VALUES (1, 0, 0, 'ç­‰å¾…å¼€å§‹...')
            ''')

            # æ’å…¥é»˜è®¤å…¨å±€å»¶è¿Ÿé…ç½®
            cursor.execute('''
                INSERT OR IGNORE INTO global_reply_config (id, min_delay, max_delay)
                VALUES (1, 3.0, 8.0)
            ''')

            # ä¸ºç°æœ‰å•†å“è®¾ç½®é»˜è®¤åº—é“ºåç§°
            try:
                cursor.execute('UPDATE products SET shop_name = ? WHERE shop_name IS NULL OR shop_name = ?', ('æœªçŸ¥åº—é“º', ''))
                logger.info("å·²ä¸ºç¼ºå°‘åº—é“ºåç§°çš„å•†å“è®¾ç½®é»˜è®¤å€¼")
            except Exception as e:
                logger.warning(f"è®¾ç½®é»˜è®¤åº—é“ºåç§°å¤±è´¥: {e}")

            conn.commit()


    @contextmanager
    def get_connection(self):
        """è·å– SQLite æ•°æ®åº“è¿æ¥çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # å¯ç”¨è¡Œå·¥å‚
            yield conn
        except Exception as e:
            logger.error("æ•°æ®åº“è¿æ¥å¤±è´¥: %s", str(e))
            raise
        finally:
            if conn:
                conn.close()

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> List[Dict]:
        """æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›ç»“æœ"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            if fetch:
                results = [dict(row) for row in cursor.fetchall()]
                conn.commit()
                return results
            conn.commit()
            return []

    def insert_product(self, product_data: Dict) -> int:
        """æ’å…¥å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO products
                (product_url, title, description, english_title, cnfans_url, acbuy_url, shop_name, ruleEnabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                product_data['product_url'],
                product_data.get('title', ''),
                product_data.get('description', ''),
                product_data.get('english_title', ''),
                product_data.get('cnfans_url', ''),
                product_data.get('acbuy_url', ''),
                product_data.get('shop_name', ''),
                product_data.get('ruleEnabled', True)
            ))
            product_id = cursor.lastrowid
            conn.commit()
            return product_id

    def insert_image_record(self, product_id: int, image_path: str, image_index: int, features: np.ndarray = None) -> int:
        """æ’å…¥å›¾åƒè®°å½•åˆ°æ•°æ®åº“ï¼Œè¿”å›è®°å½•IDä¾›FAISSä½¿ç”¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # å°†ç‰¹å¾å‘é‡åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²å­˜å‚¨
                features_str = None
                if features is not None:
                    import json
                    features_str = json.dumps(features.tolist())

                cursor.execute('''
                    INSERT INTO product_images
                    (product_id, image_path, image_index, features)
                    VALUES (?, ?, ?, ?)
                ''', (product_id, image_path, image_index, features_str))
                conn.commit()
                record_id = cursor.lastrowid
                logger.info(f"å›¾åƒè®°å½•æ’å…¥æˆåŠŸ: product_id={product_id}, image_index={image_index}, record_id={record_id}")
                return record_id

        except Exception as e:
            logger.error(f"æ’å…¥å›¾åƒè®°å½•å¤±è´¥: {e}")
            raise e

    def search_similar_images(self, query_vector: np.ndarray, limit: int = 1,
                             threshold: float = 0.6, user_shops: Optional[List[str]] = None) -> List[Dict]:
        """ä½¿ç”¨FAISSæœç´¢ç›¸ä¼¼å›¾åƒ"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()

            print(f"DEBUG DB: Starting FAISS search, threshold: {threshold}, limit: {limit}")
            print(f"DEBUG DB: Query vector length: {len(query_vector) if hasattr(query_vector, '__len__') else 'unknown'}")

            # æ‰§è¡ŒFAISSæœç´¢ - è¯·æ±‚æ›´å¤šç»“æœä»¥åº”å¯¹è¢«åˆ é™¤çš„å‘é‡
            faiss_results = engine.search(query_vector, top_k=min(limit * 3, 50))  # è¯·æ±‚æ›´å¤šå€™é€‰ç»“æœ
            print(f"DEBUG DB: FAISS search returned {len(faiss_results)} results")

            matched_results = []

            for result in faiss_results:
                score = result['score']
                db_id = result['db_id']

                print(f"DEBUG DB: Processing result - db_id: {db_id}, score: {score}, threshold: {threshold}")

                # é€šè¿‡image_db_idè·å–äº§å“ä¿¡æ¯
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    print(f"DEBUG DB: Found image info for db_id {db_id}: product_id={image_info['product_id']}")
                    product_info = self._get_product_info_by_id(image_info['product_id'])

                    if product_info:
                        # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œè¿›è¡Œè¿‡æ»¤
                        if user_shops and product_info.get('shop_name') not in user_shops:
                            print(f"DEBUG DB: Skipping product from shop {product_info.get('shop_name')} - not in user shops {user_shops}")
                            continue

                        print(f"DEBUG DB: Found product info for product_id {image_info['product_id']}: ruleEnabled={product_info.get('ruleEnabled', True)}")
                        result_dict = {
                            **product_info,
                            'similarity': score,
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added result with similarity {score}")

                        # å¦‚æœæ‰¾åˆ°äº†è¶³å¤Ÿçš„ç»“æœï¼Œå°±åœæ­¢
                        if len(matched_results) >= limit:
                            break
                    else:
                        print(f"DEBUG DB: Product info not found for product_id {image_info['product_id']}")
                else:
                    print(f"DEBUG DB: Image info not found for db_id {db_id}")

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç»“æœï¼Œè¿”å›æœ€ä½³åŒ¹é…ï¼ˆå³ä½¿ä½äºé˜ˆå€¼ï¼‰
            if not matched_results and faiss_results:
                print(f"DEBUG DB: No results above threshold {threshold}, returning best match")
                best_result = faiss_results[0]
                db_id = best_result['db_id']
                image_info = self.get_image_info_by_id(db_id)
                if image_info:
                    product_info = self._get_product_info_by_id(image_info['product_id'])
                    if product_info:
                        result_dict = {
                            **product_info,
                            'similarity': best_result['score'],
                            'image_index': image_info['image_index'],
                            'image_path': image_info['image_path']
                        }
                        matched_results.append(result_dict)
                        print(f"DEBUG DB: Added best match with similarity {best_result['score']}")

            return matched_results

        except Exception as e:
            logger.error(f"FAISSæœç´¢å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _get_product_url_by_id(self, product_id: int) -> Optional[str]:
        """æ ¹æ®äº§å“IDè·å–äº§å“URL"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT product_url FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return row['product_url'] if row else None

    def get_image_info_by_id(self, image_id: int) -> Optional[Dict]:
        """æ ¹æ®å›¾åƒè®°å½•IDè·å–å›¾åƒä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM product_images WHERE id = ?", (image_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def _get_product_info_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®äº§å“IDè·å–å®Œæ•´çš„äº§å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE id = ?", (product_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_indexed_product_ids(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT p.product_url
                FROM products p
                JOIN product_images pi ON p.id = pi.product_id
            ''')
            return [row['product_url'] for row in cursor.fetchall()]

    def get_product_images(self, product_id: int) -> List[Dict]:
        """è·å–å•†å“çš„æ‰€æœ‰å›¾ç‰‡åŠå…¶ç‰¹å¾å‘é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, image_path, image_index, features
                    FROM product_images
                    WHERE product_id = ?
                    ORDER BY image_index
                ''', (product_id,))

                images = []
                for row in cursor.fetchall():
                    image_data = dict(row)
                    # ååºåˆ—åŒ–ç‰¹å¾å‘é‡
                    if image_data.get('features'):
                        import json
                        try:
                            features_list = json.loads(image_data['features'])
                            image_data['features'] = np.array(features_list, dtype='float32')
                        except Exception as e:
                            logger.warning(f"ååºåˆ—åŒ–ç‰¹å¾å‘é‡å¤±è´¥: {e}")
                            image_data['features'] = None
                    else:
                        image_data['features'] = None
                    images.append(image_data)

                return images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def delete_product_images(self, product_id: int) -> bool:
        """åˆ é™¤å•†å“çš„æ‰€æœ‰å›¾åƒå’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾åƒè®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_records = []
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ?", (product_id,))
                image_records = [{'id': row['id'], 'path': row['image_path']} for row in cursor.fetchall()]

            if image_records:
                # ä»FAISSä¸­åˆ é™¤å‘é‡
                try:
                    # ä¼˜å…ˆå°è¯•ç»å¯¹å¯¼å…¥
                    from vector_engine import get_vector_engine
                except ImportError:
                    try:
                        # å°è¯•ç›¸å¯¹å¯¼å…¥
                        from .vector_engine import get_vector_engine
                    except ImportError:
                        # å¦‚æœéƒ½å¤±è´¥ï¼Œè·³è¿‡FAISSæ“ä½œ
                        logger.warning("æ— æ³•å¯¼å…¥vector_engineï¼Œè·³è¿‡FAISSå‘é‡åˆ é™¤")
                        engine = None
                    else:
                        engine = get_vector_engine()
                else:
                    engine = get_vector_engine()

                # å¦‚æœæˆåŠŸè·å–åˆ°å¼•æ“ï¼Œåˆ é™¤å‘é‡
                if engine:
                    for record in image_records:
                        try:
                            engine.remove_vector_by_db_id(record['id'])
                        except Exception as e:
                            logger.warning(f"åˆ é™¤FAISSå‘é‡å¤±è´¥ {record['id']}: {e}")

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            for record in image_records:
                if record['path'] and os.path.exists(record['path']):
                    try:
                        os.remove(record['path'])
                        logger.info(f"å·²åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶: {record['path']}")
                    except Exception as e:
                        logger.warning(f"åˆ é™¤å•†å“å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ?", (product_id,))
                cursor.execute("DELETE FROM products WHERE id = ?", (product_id,))
                conn.commit()

            # ä¿å­˜FAISSç´¢å¼•
            if image_records and engine:
                try:
                    engine.save()
                    logger.info("FAISSç´¢å¼•å·²ä¿å­˜")
                except Exception as e:
                    logger.warning(f"ä¿å­˜FAISSç´¢å¼•å¤±è´¥: {e}")

            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å•†å“å›¾åƒå¤±è´¥: {e}")
            return False

    def delete_image_record(self, image_id: int) -> bool:
        """æ ¹æ®å›¾ç‰‡IDåˆ é™¤å›¾ç‰‡è®°å½•ï¼ˆç”¨äºå›æ»šæ“ä½œï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE id = ?", (image_id,))
                deleted = cursor.rowcount > 0
                if deleted:
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡è®°å½•: id={image_id}")
                return deleted
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾ç‰‡è®°å½•å¤±è´¥: {e}")
            return False

    def delete_image_vector(self, product_id: int, image_index: int) -> bool:
        """åˆ é™¤ç‰¹å®šçš„å›¾åƒå‘é‡å’Œç‰©ç†æ–‡ä»¶"""
        try:
            # è·å–è¯¥å›¾åƒçš„è®°å½•IDå’Œæ–‡ä»¶è·¯å¾„
            image_path = None
            image_id = None
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))
                row = cursor.fetchone()
                if row:
                    image_id = row['id']
                    image_path = row['image_path']

            if not image_id:
                logger.warning(f"å›¾ç‰‡ä¸å­˜åœ¨: product_id={product_id}, image_index={image_index}")
                return False

            # ä»FAISSä¸­åˆ é™¤å‘é‡å¹¶é‡å»ºç´¢å¼•
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            success = engine.remove_vector_by_db_id(image_id)
            if not success:
                logger.error(f"FAISSåˆ é™¤å‘é‡å¤±è´¥: db_id={image_id}")
                return False

            # åˆ é™¤ç‰©ç†æ–‡ä»¶
            if image_path and os.path.exists(image_path):
                try:
                    os.remove(image_path)
                    logger.info(f"å·²åˆ é™¤å›¾ç‰‡æ–‡ä»¶: {image_path}")
                except Exception as e:
                    logger.warning(f"åˆ é™¤å›¾ç‰‡æ–‡ä»¶å¤±è´¥: {e}")

            # ä» SQLite åˆ é™¤è®°å½•
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("DELETE FROM product_images WHERE product_id = ? AND image_index = ?",
                             (product_id, image_index))

                # --- åˆ é™¤é‡æ–°æ’åºçš„ä»£ç  ---
                # é‡æ–°æ’åºä¼šå¯¼è‡´å‰ç«¯ React key å†²çªå’Œæµè§ˆå™¨ç¼“å­˜é—®é¢˜
                # è®©å›¾ç‰‡ç´¢å¼•ä¿æŒå›ºå®šï¼Œåˆ é™¤ä¸­é—´å›¾ç‰‡åç´¢å¼•ä¸å˜
                # cursor.execute("SELECT id, image_index FROM product_images WHERE product_id = ? ORDER BY image_index",
                #              (product_id,))
                # remaining_images = cursor.fetchall()
                #
                # # æ›´æ–°ç´¢å¼•ï¼Œä»0å¼€å§‹é‡æ–°ç¼–å·
                # for new_index, (img_id, old_index) in enumerate(remaining_images):
                #     if new_index != old_index:
                #         cursor.execute("UPDATE product_images SET image_index = ? WHERE id = ?",
                #                      (new_index, img_id))

                conn.commit()

            logger.info(f"å›¾ç‰‡åˆ é™¤æˆåŠŸ: product_id={product_id}, image_index={image_index}")
            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å›¾åƒå‘é‡å¤±è´¥: {e}")
            return False

    def get_product_by_url(self, product_url: str) -> Optional[Dict]:
        """æ ¹æ®å•†å“URLè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def get_product_by_item_id(self, item_id: str) -> Optional[Dict]:
        """æ ¹æ®å¾®åº—å•†å“IDè·å–å•†å“ä¿¡æ¯"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM products WHERE item_id = ?", (item_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

    def cleanup_unused_images(self, days_old: int = 30) -> int:
        """
        æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶
        åˆ é™¤é‚£äº›åœ¨æ•°æ®åº“ä¸­ä¸å­˜åœ¨è®°å½•çš„å›¾ç‰‡æ–‡ä»¶ï¼Œæˆ–è€…åˆ é™¤è¶…è¿‡æŒ‡å®šå¤©æ•°çš„æ—§å›¾ç‰‡

        Args:
            days_old: åˆ é™¤å¤šå°‘å¤©å‰çš„å›¾ç‰‡ï¼ˆé»˜è®¤30å¤©ï¼‰

        Returns:
            åˆ é™¤çš„æ–‡ä»¶æ•°é‡
        """
        try:
            import os
            import time

            # è·å–æ‰€æœ‰æ•°æ®åº“ä¸­å­˜åœ¨çš„å›¾ç‰‡è·¯å¾„
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT image_path FROM product_images")
                db_image_paths = set(row['image_path'] for row in cursor.fetchall())

            # è·å–data/imagesç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
            images_dir = os.path.join('data', 'images')
            if not os.path.exists(images_dir):
                return 0

            deleted_count = 0
            cutoff_time = time.time() - (days_old * 24 * 60 * 60)

            for filename in os.listdir(images_dir):
                filepath = os.path.join(images_dir, filename)

                # åªå¤„ç†jpgæ–‡ä»¶
                if not filename.endswith('.jpg'):
                    continue

                # æ£€æŸ¥æ˜¯å¦åœ¨æ•°æ®åº“ä¸­å­˜åœ¨
                if filepath not in db_image_paths:
                    try:
                        os.remove(filepath)
                        logger.info(f"æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶: {filepath}")
                        deleted_count += 1
                    except Exception as e:
                        logger.warning(f"åˆ é™¤æ–‡ä»¶å¤±è´¥ {filepath}: {e}")
                # æˆ–è€…æ£€æŸ¥æ˜¯å¦å¤ªæ—§ï¼ˆå³ä½¿åœ¨æ•°æ®åº“ä¸­ï¼‰
                elif os.path.getmtime(filepath) < cutoff_time:
                    # è¿™é‡Œå¯ä»¥é€‰æ‹©æ˜¯å¦åˆ é™¤æ—§æ–‡ä»¶
                    # æš‚æ—¶ä¿ç•™ï¼Œé¿å…è¯¯åˆ 
                    pass

            if deleted_count > 0:
                logger.info(f"å›¾ç‰‡æ¸…ç†å®Œæˆï¼Œå…±åˆ é™¤ {deleted_count} ä¸ªæœªä½¿ç”¨çš„æ–‡ä»¶")

            return deleted_count

        except Exception as e:
            logger.error(f"å›¾ç‰‡æ¸…ç†å¤±è´¥: {e}")
            return 0

    def get_product_id_by_url(self, product_url: str) -> Optional[int]:
        """æ ¹æ®å•†å“URLè·å–å•†å“å†…éƒ¨ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products WHERE product_url = ?", (product_url,))
            row = cursor.fetchone()
            return row['id'] if row else None

    def get_total_indexed_images(self) -> int:
        """è·å–å·²ç´¢å¼•çš„æ€»å›¾ç‰‡æ•°é‡"""
        try:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            return engine.count()
        except Exception as e:
            logger.error(f"è·å–ç´¢å¼•å›¾ç‰‡æ•°é‡å¤±è´¥: {e}")
            return 0

    def get_indexed_product_urls(self) -> List[str]:
        """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT DISTINCT p.product_url
                    FROM products p
                    JOIN product_images pi ON p.id = pi.product_id
                ''')
                return [row['product_url'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–å·²ç´¢å¼•å•†å“URLå¤±è´¥: {e}")
            return []

    def add_search_history(self, query_image_path: str, matched_product_id: int,
                          matched_image_index: int, similarity: float, threshold: float) -> bool:
        """æ·»åŠ æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO search_history
                    (query_image_path, matched_product_id, matched_image_index, similarity, threshold)
                    VALUES (?, ?, ?, ?, ?)
                ''', (query_image_path, matched_product_id, matched_image_index, similarity, threshold))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def get_search_history(self, limit: int = 50, offset: int = 0) -> Dict:
        """è·å–æœç´¢å†å²è®°å½•ï¼ˆæ”¯æŒåˆ†é¡µï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–æ€»æ•°
                cursor.execute('SELECT COUNT(*) FROM search_history')
                total = cursor.fetchone()[0]

                # è·å–åˆ†é¡µæ•°æ®
                cursor.execute('''
                    SELECT
                        sh.id,
                        sh.query_image_path,
                        sh.matched_product_id,
                        sh.matched_image_index,
                        sh.similarity,
                        sh.threshold,
                        sh.search_time,
                        p.title,
                        p.english_title,
                        p.product_url as weidian_url,
                        p.cnfans_url,
                        p.acbuy_url,
                        p.ruleEnabled,
                        pi.image_path as matched_image_path
                    FROM search_history sh
                    LEFT JOIN products p ON sh.matched_product_id = p.id
                    LEFT JOIN product_images pi ON sh.matched_product_id = pi.product_id AND sh.matched_image_index = pi.image_index
                    ORDER BY sh.search_time DESC
                    LIMIT ? OFFSET ?
                ''', (limit, offset))
                rows = cursor.fetchall()
                history = []
                for row in rows:
                    history.append({
                        'id': row['id'],
                        'query_image_path': row['query_image_path'],
                        'matched_product_id': row['matched_product_id'],
                        'matched_image_index': row['matched_image_index'],
                        'similarity': row['similarity'],
                        'threshold': row['threshold'],
                        'search_time': row['search_time'],
                        'title': row['title'],
                        'english_title': row['english_title'],
                        'weidian_url': row['weidian_url'],
                        'cnfans_url': row['cnfans_url'],
                        'acbuy_url': row['acbuy_url'],
                        'ruleEnabled': row['ruleEnabled'],
                        'matched_image_path': row['matched_image_path']
                    })

                return {
                    'history': history,
                    'total': total,
                    'limit': limit,
                    'offset': offset,
                    'has_more': offset + limit < total
                }
        except Exception as e:
            logger.error(f"è·å–æœç´¢å†å²å¤±è´¥: {e}")
            return []

    def delete_search_history(self, history_id: int) -> bool:
        """åˆ é™¤æœç´¢å†å²è®°å½•"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history WHERE id = ?', (history_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æœç´¢å†å²å¤±è´¥: {e}")
            return False

    def clear_search_history(self) -> bool:
        """æ¸…ç©ºæ‰€æœ‰æœç´¢å†å²"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM search_history')
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ¸…ç©ºæœç´¢å†å²å¤±è´¥: {e}")
            return False

    # ===== ç”¨æˆ·æƒé™ç®¡ç†æ–¹æ³• =====

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """ç”¨æˆ·è®¤è¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, password_hash, role, is_active, created_at
                    FROM users
                    WHERE username = ? AND is_active = 1
                ''', (username,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    stored_hash = user_dict.get('password_hash')

                    # éªŒè¯å¯†ç 
                    authenticated = False

                    if stored_hash:
                        # é¦–å…ˆå°è¯•Werkzeugå“ˆå¸ŒéªŒè¯ï¼ˆæ–°ç”¨æˆ·ï¼‰
                        from werkzeug.security import check_password_hash
                        if check_password_hash(stored_hash, password):
                            authenticated = True
                        # å¦‚æœå¤±è´¥ï¼Œå°è¯•æ—§çš„å“ˆå¸Œæ–¹å¼ï¼ˆå…¼å®¹æ—§ç”¨æˆ·ï¼‰
                        elif stored_hash == f"hashed_{password}":
                            authenticated = True

                    if authenticated:
                        # è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º
                        user_dict['shops'] = self.get_user_shops(user_dict['id'])
                        return user_dict
                return None
        except Exception as e:
            logger.error(f"ç”¨æˆ·è®¤è¯å¤±è´¥: {e}")
            return None

    def create_user(self, username: str, password: str, role: str = 'user') -> bool:
        """åˆ›å»ºæ–°ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # ç®€å•çš„å¯†ç å“ˆå¸Œï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨bcryptï¼‰
                import hashlib
                password_hash = f"hashed_{password}"  # ç®€åŒ–ç‰ˆï¼Œå®é™…åº”è¯¥ç”¨bcrypt

                cursor.execute('''
                    INSERT INTO users (username, password_hash, role, is_active)
                    VALUES (?, ?, ?, 1)
                ''', (username, password_hash, role))
                conn.commit()
                return True
        except sqlite3.IntegrityError:
            logger.warning(f"ç”¨æˆ·åå·²å­˜åœ¨: {username}")
            return False
        except Exception as e:
            logger.error(f"åˆ›å»ºç”¨æˆ·å¤±è´¥: {e}")
            return False

    def get_all_users(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    ORDER BY created_at DESC
                ''')
                users = []
                for row in cursor.fetchall():
                    user = dict(row)
                    user['shops'] = self.get_user_shops(user['id'])
                    users.append(user)
                return users
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_user_shops(self, user_id: int) -> List[str]:
        """è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT shop_id FROM user_shop_permissions
                    WHERE user_id = ?
                ''', (user_id,))
                return [row['shop_id'] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return []

    def update_user_shops(self, user_id: int, shop_ids: List[str]) -> bool:
        """æ›´æ–°ç”¨æˆ·çš„åº—é“ºæƒé™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # å…ˆåˆ é™¤æ—§çš„æƒé™
                cursor.execute('DELETE FROM user_shop_permissions WHERE user_id = ?', (user_id,))

                # æ·»åŠ æ–°çš„æƒé™
                for shop_id in shop_ids:
                    cursor.execute('''
                        INSERT INTO user_shop_permissions (user_id, shop_id)
                        VALUES (?, ?)
                    ''', (user_id, shop_id))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·åº—é“ºæƒé™å¤±è´¥: {e}")
            return False

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, username, role, is_active, created_at
                    FROM users
                    WHERE id = ?
                ''', (user_id,))
                user = cursor.fetchone()
                if user:
                    user_dict = dict(user)
                    user_dict['shops'] = self.get_user_shops(user_id)
                    return user_dict
                return None
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_discord_account_user(self, account_id: int, user_id: Optional[int]) -> bool:
        """æ›´æ–°Discordè´¦å·å…³è”çš„ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET user_id = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (user_id, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°Discordè´¦å·ç”¨æˆ·å…³è”å¤±è´¥: {e}")
            return False

    def get_discord_accounts_by_user(self, user_id: Optional[int]) -> List[Dict]:
        """è·å–ç”¨æˆ·å…³è”çš„Discordè´¦å·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                if user_id is None:
                    # ç®¡ç†å‘˜æŸ¥è¯¢æ‰€æœ‰è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                    FROM discord_accounts
                    ORDER BY created_at DESC
                    ''')
                else:
                    # æ™®é€šç”¨æˆ·æŸ¥è¯¢è‡ªå·±çš„è´¦å·
                    cursor.execute('''
                        SELECT id, username, token, status, last_active, created_at, user_id
                        FROM discord_accounts
                        WHERE user_id = ?
                        ORDER BY created_at DESC
                    ''', (user_id,))
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·Discordè´¦å·å¤±è´¥: {e}")
            return []

    def update_product_title(self, product_id: int, title: str) -> bool:
        """æ›´æ–°å•†å“æ ‡é¢˜"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE products
                    SET title = ?, updated_at = datetime('now')
                    WHERE id = ?
                ''', (title, product_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return False

    def update_product(self, product_id: int, updates: Dict) -> bool:
        """æ›´æ–°å•†å“ä¿¡æ¯ï¼ˆé€šç”¨æ–¹æ³•ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºåŠ¨æ€æ›´æ–°è¯­å¥
                set_parts = []
                params = []
                allowed_fields = [
                    'title', 'english_title', 'ruleEnabled',
                    'custom_reply_text', 'custom_reply_images', 'custom_image_urls'
                ]

                for field in allowed_fields:
                    if field in updates:
                        set_parts.append(f'{field} = ?')
                        if (field == 'custom_reply_images' or field == 'custom_image_urls') and isinstance(updates[field], list):
                            # å°†å›¾ç‰‡ç´¢å¼•æˆ–URLæ•°ç»„è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                            params.append(json.dumps(updates[field]))
                        else:
                            params.append(updates[field])

                if not set_parts:
                    return False

                set_parts.append('updated_at = datetime(\'now\')')

                query = f'''
                    UPDATE products
                    SET {', '.join(set_parts)}
                    WHERE id = ?
                '''
                params.append(product_id)

                cursor.execute(query, params)
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“å¤±è´¥: {e}")
            return False

    def get_product_by_id(self, product_id: int) -> Optional[Dict]:
        """æ ¹æ®IDè·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM products WHERE id = ?', (product_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            logger.error(f"è·å–å•†å“å¤±è´¥: {e}")
            return None

    def delete_user(self, user_id: int) -> bool:
        """åˆ é™¤ç”¨æˆ·"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                # é¦–å…ˆåˆ é™¤ç”¨æˆ·çš„æ‰€æœ‰ç›¸å…³æ•°æ®
                # åˆ é™¤ç”¨æˆ·çš„Discordè´¦å·
                cursor.execute('DELETE FROM discord_accounts WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·çš„è®¾ç½®
                cursor.execute('DELETE FROM user_settings WHERE user_id = ?', (user_id,))
                # åˆ é™¤ç”¨æˆ·
                cursor.execute('DELETE FROM users WHERE id = ?', (user_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç”¨æˆ·å¤±è´¥: {e}")
            return False

    def update_account_status(self, account_id: int, status: str) -> bool:
        """æ›´æ–°Discordè´¦å·çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE discord_accounts
                    SET status = ?, last_active = datetime('now')
                    WHERE id = ?
                ''', (status, account_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}")
            return False

    def get_website_configs(self) -> List[Dict]:
        """è·å–æ‰€æœ‰ç½‘ç«™é…ç½®åŠå…¶é¢‘é“ç»‘å®šï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œé¿å…N+1æŸ¥è¯¢ï¼‰"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # ä½¿ç”¨LEFT JOINä¸€æ¬¡æ€§è·å–æ‰€æœ‰ç½‘ç«™å’Œå…¶é¢‘é“ç»‘å®š
                cursor.execute('''
                    SELECT
                        wc.id, wc.name, wc.display_name, wc.url_template,
                        wc.id_pattern, wc.badge_color, wc.created_at,
                        GROUP_CONCAT(wcb.channel_id) as channels
                    FROM website_configs wc
                    LEFT JOIN website_channel_bindings wcb ON wc.id = wcb.website_id
                    GROUP BY wc.id, wc.name, wc.display_name, wc.url_template, wc.id_pattern, wc.badge_color, wc.created_at
                    ORDER BY wc.created_at
                ''')

                configs = []
                for row in cursor.fetchall():
                    config = dict(row)
                    # å°†channelså­—ç¬¦ä¸²è§£æä¸ºæ•°ç»„
                    if config.get('channels'):
                        config['channels'] = config['channels'].split(',') if config['channels'] else []
                    else:
                        config['channels'] = []
                    configs.append(config)

                return configs
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return []

    def add_website_config(self, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str = 'blue') -> bool:
        """æ·»åŠ ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO website_configs (name, display_name, url_template, id_pattern, badge_color)
                    VALUES (?, ?, ?, ?, ?)
                ''', (name, display_name, url_template, id_pattern, badge_color))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def update_website_config(self, config_id: int, name: str, display_name: str, url_template: str, id_pattern: str, badge_color: str) -> bool:
        """æ›´æ–°ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE website_configs
                    SET name = ?, display_name = ?, url_template = ?, id_pattern = ?, badge_color = ?
                    WHERE id = ?
                ''', (name, display_name, url_template, id_pattern, badge_color, config_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def delete_website_config(self, config_id: int) -> bool:
        """åˆ é™¤ç½‘ç«™é…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM website_configs WHERE id = ?', (config_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç½‘ç«™é…ç½®å¤±è´¥: {e}")
            return False

    def get_website_channel_bindings(self, website_id: int) -> List[str]:
        """è·å–ç½‘ç«™ç»‘å®šçš„é¢‘é“åˆ—è¡¨"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT channel_id FROM website_channel_bindings
                    WHERE website_id = ?
                    ORDER BY created_at
                ''', (website_id,))
                return [row[0] for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return []

    def add_website_channel_binding(self, website_id: int, channel_id: str) -> bool:
        """æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO website_channel_bindings (website_id, channel_id)
                    VALUES (?, ?)
                ''', (website_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def remove_website_channel_binding(self, website_id: int, channel_id: str) -> bool:
        """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    DELETE FROM website_channel_bindings
                    WHERE website_id = ? AND channel_id = ?
                ''', (website_id, channel_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
            return False

    def generate_website_urls(self, weidian_id: str) -> List[Dict]:
        """æ ¹æ®å¾®åº—IDç”Ÿæˆæ‰€æœ‰ç½‘ç«™çš„URL"""
        try:
            website_configs = self.get_website_configs()
            urls = []

            for config in website_configs:
                try:
                    # æ›¿æ¢URLæ¨¡æ¿ä¸­çš„{id}å ä½ç¬¦
                    url = config['url_template'].replace('{id}', weidian_id)
                    urls.append({
                        'name': config['name'],
                        'display_name': config['display_name'],
                        'url': url,
                        'badge_color': config['badge_color'],
                        'channels': self.get_website_channel_bindings(config['id'])
                    })
                except Exception as e:
                    logger.warning(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥ {config['name']}: {e}")

            return urls
        except Exception as e:
            logger.error(f"ç”Ÿæˆç½‘ç«™URLå¤±è´¥: {e}")
            return []

    def get_system_stats(self) -> Dict:
        """è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # è·å–åº—é“ºæ•°é‡ï¼ˆä»shopsè¡¨ç»Ÿè®¡ï¼‰
                cursor.execute("SELECT COUNT(*) FROM shops")
                shop_count = cursor.fetchone()[0] or 0

                # è·å–å•†å“æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM products")
                product_count = cursor.fetchone()[0] or 0

                # è·å–å›¾ç‰‡æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM product_images")
                image_count = cursor.fetchone()[0] or 0

                # è·å–ç”¨æˆ·æ•°é‡
                cursor.execute("SELECT COUNT(*) FROM users WHERE is_active = 1")
                user_count = cursor.fetchone()[0] or 0

                return {
                    'shop_count': shop_count,
                    'product_count': product_count,
                    'image_count': image_count,
                    'user_count': user_count
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {e}")
            return {'shop_count': 0, 'product_count': 0, 'image_count': 0, 'user_count': 0}

    def get_active_announcements(self) -> List[Dict]:
        """è·å–æ´»è·ƒçš„ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, title, content, created_at, updated_at
                    FROM system_announcements
                    WHERE is_active = 1
                    ORDER BY updated_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return []

    def create_announcement(self, title: str, content: str) -> bool:
        """åˆ›å»ºç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO system_announcements (title, content)
                    VALUES (?, ?)
                ''', (title, content))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"åˆ›å»ºç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def update_announcement(self, announcement_id: int, title: str, content: str, is_active: bool) -> bool:
        """æ›´æ–°ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE system_announcements
                    SET title = ?, content = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (title, content, is_active, announcement_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def delete_announcement(self, announcement_id: int) -> bool:
        """åˆ é™¤ç³»ç»Ÿå…¬å‘Š"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM system_announcements WHERE id = ?', (announcement_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤ç³»ç»Ÿå…¬å‘Šå¤±è´¥: {e}")
            return False

    def get_message_filters(self) -> List[Dict]:
        """è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, filter_type, filter_value, is_active, created_at
                    FROM message_filters
                    WHERE is_active = 1
                    ORDER BY created_at
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return []

    def add_message_filter(self, filter_type: str, filter_value: str) -> bool:
        """æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO message_filters (filter_type, filter_value)
                    VALUES (?, ?)
                ''', (filter_type, filter_value))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def update_message_filter(self, filter_id: int, filter_type: str, filter_value: str, is_active: bool) -> bool:
        """æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE message_filters
                    SET filter_type = ?, filter_value = ?, is_active = ?
                    WHERE id = ?
                ''', (filter_type, filter_value, is_active, filter_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def delete_message_filter(self, filter_id: int) -> bool:
        """åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM message_filters WHERE id = ?', (filter_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
            return False

    def get_custom_replies(self) -> List[Dict]:
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT id, reply_type, content, image_url, is_active, priority, created_at
                    FROM custom_replies
                    WHERE is_active = 1
                    ORDER BY priority DESC, created_at DESC
                ''')
                return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"è·å–è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return []

    def add_custom_reply(self, reply_type: str, content: str = None, image_url: str = None, priority: int = 0) -> bool:
        """æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO custom_replies (reply_type, content, image_url, priority)
                    VALUES (?, ?, ?, ?)
                ''', (reply_type, content, image_url, priority))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def update_custom_reply(self, reply_id: int, reply_type: str, content: str = None, image_url: str = None, priority: int = 0, is_active: bool = True) -> bool:
        """æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE custom_replies
                    SET reply_type = ?, content = ?, image_url = ?, priority = ?, is_active = ?
                    WHERE id = ?
                ''', (reply_type, content, image_url, priority, is_active, reply_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def delete_custom_reply(self, reply_id: int) -> bool:
        """åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM custom_replies WHERE id = ?', (reply_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
            return False

    def get_products_by_user_shops(self, user_shops: List[str], limit: int = None, offset: int = 0) -> Dict:
        """æ ¹æ®ç”¨æˆ·åº—é“ºæƒé™è·å–å•†å“"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor = conn.cursor()

                if user_shops is None:
                    # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°æ‰€æœ‰å•†å“ï¼ˆä¸é™åˆ¶åº—é“ºï¼‰- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
                    if limit is None or limit <= 0:
                        # ä¸€æ¬¡æ€§è·å–æ‰€æœ‰å•†å“å’Œå¯¹åº”çš„å›¾ç‰‡ç´¢å¼•
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                        '''
                        cursor.execute(query)
                        rows = cursor.fetchall()

                        # è·å–æ€»æ•°
                        cursor.execute('SELECT COUNT(*) FROM products')
                        total = cursor.fetchone()[0]
                    else:
                        # åˆ†é¡µæŸ¥è¯¢ - ä½¿ç”¨å­æŸ¥è¯¢ä¼˜åŒ–æ€§èƒ½
                        query = '''
                            SELECT p.*,
                                   GROUP_CONCAT(pi.image_index) as image_indices,
                                   COUNT(pi.id) as image_count,
                                   p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                            FROM products p
                            LEFT JOIN product_images pi ON p.id = pi.product_id
                            GROUP BY p.id
                            ORDER BY p.created_at DESC
                            LIMIT ? OFFSET ?
                        '''
                        cursor.execute(query, [limit, offset])
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    cursor.execute('SELECT COUNT(*) FROM products')
                    total = cursor.fetchone()[0]

                    products = []
                    for row in rows:
                        prod = dict(row)
                        # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                        if prod.get('image_indices'):
                            image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                            prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                        else:
                            prod['images'] = []

                        # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                        prod['weidianUrl'] = prod.get('product_url')
                        prod['englishTitle'] = prod.get('english_title') or ''
                        prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                        prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                        prod['createdAt'] = prod.get('created_at')
                        prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                        prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'

                        # æå–å¾®åº—ID
                        try:
                            import re
                            m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                            prod['weidianId'] = m.group(1) if m else ''
                        except:
                            prod['weidianId'] = ''

                        products.append(prod)

                    return {'products': products, 'total': total}

                elif not user_shops:
                    # å¦‚æœç”¨æˆ·æ²¡æœ‰åº—é“ºæƒé™ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # ç¡®ä¿user_shopsæ˜¯listç±»å‹
                if not isinstance(user_shops, list):
                    user_shops = []

                # æ ¹æ®shop_idæ‰¾åˆ°å¯¹åº”çš„shop_name
                shop_names = []
                for shop_id in user_shops:
                    cursor.execute("SELECT name FROM shops WHERE shop_id = ?", (shop_id,))
                    shop_row = cursor.fetchone()
                    if shop_row:
                        shop_names.append(shop_row[0])

                if not shop_names:
                    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åº—é“ºåç§°ï¼Œè¿”å›ç©ºç»“æœ
                    return {'products': [], 'total': 0}

                # æ„å»ºINæŸ¥è¯¢ - ä¼˜åŒ–æ€§èƒ½
                placeholders = ','.join('?' * len(shop_names))
                if limit is None or limit <= 0:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                    '''
                    cursor.execute(query, shop_names)
                    rows = cursor.fetchall()

                    # è·å–æ€»æ•°
                    count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                    cursor.execute(count_query, shop_names)
                    total = cursor.fetchone()[0]
                else:
                    query = f'''
                        SELECT p.*,
                               GROUP_CONCAT(pi.image_index) as image_indices,
                               COUNT(pi.id) as image_count,
                               p.custom_reply_text, p.custom_reply_images, p.custom_image_urls, p.image_source
                        FROM products p
                        LEFT JOIN product_images pi ON p.id = pi.product_id
                        WHERE p.shop_name IN ({placeholders})
                        GROUP BY p.id
                        ORDER BY p.created_at DESC
                        LIMIT ? OFFSET ?
                    '''
                    cursor.execute(query, shop_names + [limit, offset])
                rows = cursor.fetchall()

                # è·å–æ€»æ•°
                count_query = f'SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})'
                cursor.execute(count_query, shop_names)
                total = cursor.fetchone()[0]

                products = []
                for row in rows:
                    prod = dict(row)
                    # å¤„ç†å›¾ç‰‡è·¯å¾„ - ç›´æ¥ä½¿ç”¨é¢„æŸ¥è¯¢çš„image_indices
                    if prod.get('image_indices'):
                        image_indices = [int(idx) for idx in prod['image_indices'].split(',') if idx]
                        prod['images'] = [f"/api/image/{prod['id']}/{idx}" for idx in image_indices]
                    else:
                        prod['images'] = []

                    # æ ¼å¼åŒ–å­—æ®µåä»¥å…¼å®¹å‰ç«¯
                    prod['weidianUrl'] = prod.get('product_url')
                    prod['englishTitle'] = prod.get('english_title') or ''
                    prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                    prod['acbuyUrl'] = prod.get('acbuy_url') or ''
                    prod['createdAt'] = prod.get('created_at')
                    prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                    prod['shopName'] = prod.get('shop_name') or 'æœªçŸ¥åº—é“º'
                    prod['customReplyText'] = prod.get('custom_reply_text') or ''
                    # è§£æè‡ªå®šä¹‰å›å¤å›¾ç‰‡ç´¢å¼•
                    try:
                        custom_reply_images = prod.get('custom_reply_images')
                        if custom_reply_images:
                            prod['selectedImageIndexes'] = json.loads(custom_reply_images)
                        else:
                            prod['selectedImageIndexes'] = []
                    except:
                        prod['selectedImageIndexes'] = []

                    # æå–å¾®åº—ID
                    try:
                        import re
                        m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                        prod['weidianId'] = m.group(1) if m else ''
                    except:
                        prod['weidianId'] = ''

                    products.append(prod)

                return {'products': products, 'total': total}

        except Exception as e:
            print(f"DEBUG: Exception in get_products_by_user_shops: {type(e).__name__}: {e}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            logger.error("è·å–ç”¨æˆ·å•†å“å¤±è´¥: %s", str(e))
            return {'products': [], 'total': 0}

    def get_global_reply_config(self) -> Dict[str, float]:
        """è·å–å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT min_delay, max_delay FROM global_reply_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {'min_delay': row[0], 'max_delay': row[1]}
                return {'min_delay': 3.0, 'max_delay': 8.0}  # é»˜è®¤å€¼
        except Exception as e:
            logger.error(f"è·å–å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return {'min_delay': 3.0, 'max_delay': 8.0}

    def update_global_reply_config(self, min_delay: float, max_delay: float) -> bool:
        """æ›´æ–°å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE global_reply_config
                    SET min_delay = ?, max_delay = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''', (min_delay, max_delay))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°å…¨å±€å›å¤é…ç½®å¤±è´¥: {e}")
            return False

    def get_system_config(self) -> Dict[str, any]:
        """è·å–ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads FROM system_config WHERE id = 1')
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_channel_id': row[0] or '',
                        'download_threads': row[1] or 4,
                        'feature_extract_threads': row[2] or 4,
                        'discord_similarity_threshold': row[3] or 0.6,
                        'cnfans_channel_id': row[4] or '',
                        'acbuy_channel_id': row[5] or '',
                        'scrape_threads': row[6] or 2
                    }
                # å¦‚æœæ²¡æœ‰é…ç½®è®°å½•ï¼Œåˆ›å»ºé»˜è®¤é…ç½®
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, download_threads, feature_extract_threads, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id, scrape_threads)
                    VALUES (1, '', 4, 4, 0.6, '', '', 2)
                ''')
                conn.commit()
                return {
                    'discord_channel_id': '',
                    'download_threads': 4,
                    'feature_extract_threads': 4,
                    'discord_similarity_threshold': 0.6,
                    'cnfans_channel_id': '',
                    'acbuy_channel_id': '',
                    'scrape_threads': 2
                }
        except Exception as e:
            logger.error(f"è·å–ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return {
                'discord_channel_id': '',
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'cnfans_channel_id': '',
                'acbuy_channel_id': '',
                'scrape_threads': 2
            }

    def get_user_settings(self, user_id: int) -> Dict[str, any]:
        """è·å–ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT discord_similarity_threshold, global_reply_min_delay, global_reply_max_delay,
                           user_blacklist, keyword_filters
                    FROM user_settings WHERE user_id = ?
                ''', (user_id,))
                row = cursor.fetchone()
                if row:
                    return {
                        'discord_similarity_threshold': row[0] or 0.6,
                        'global_reply_min_delay': row[1] or 3.0,
                        'global_reply_max_delay': row[2] or 8.0,
                        'user_blacklist': row[3] or '',
                        'keyword_filters': row[4] or '',
                    }
                # å¦‚æœç”¨æˆ·æ²¡æœ‰è®¾ç½®ï¼Œè¿”å›é»˜è®¤å€¼
                return {
                    'discord_similarity_threshold': 0.6,
                    'global_reply_min_delay': 3.0,
                    'global_reply_max_delay': 8.0,
                    'user_blacklist': '',
                    'keyword_filters': '',
                }
        except Exception as e:
            logger.error(f"è·å–ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return {
                'download_threads': 4,
                'feature_extract_threads': 4,
                'discord_similarity_threshold': 0.6,
                'global_reply_min_delay': 3.0,
                'global_reply_max_delay': 8.0,
                'user_blacklist': '',
                'keyword_filters': '',
            }

    def update_user_settings(self, user_id: int, discord_similarity_threshold: float = None,
                           global_reply_min_delay: float = None, global_reply_max_delay: float = None,
                           user_blacklist: str = None, keyword_filters: str = None) -> bool:
        """æ›´æ–°ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰è®¾ç½®
                cursor.execute('SELECT id FROM user_settings WHERE user_id = ?', (user_id,))
                existing = cursor.fetchone()

                if existing:
                    # æ›´æ–°ç°æœ‰è®¾ç½®
                    update_fields = []
                    params = []


                    if discord_similarity_threshold is not None:
                        update_fields.append('discord_similarity_threshold = ?')
                        params.append(discord_similarity_threshold)

                    if global_reply_min_delay is not None:
                        update_fields.append('global_reply_min_delay = ?')
                        params.append(global_reply_min_delay)

                    if global_reply_max_delay is not None:
                        update_fields.append('global_reply_max_delay = ?')
                        params.append(global_reply_max_delay)

                    if user_blacklist is not None:
                        update_fields.append('user_blacklist = ?')
                        params.append(user_blacklist)

                    if keyword_filters is not None:
                        update_fields.append('keyword_filters = ?')
                        params.append(keyword_filters)

                    if update_fields:
                        update_fields.append('updated_at = CURRENT_TIMESTAMP')
                        sql = f'UPDATE user_settings SET {", ".join(update_fields)} WHERE user_id = ?'
                        params.append(user_id)
                        cursor.execute(sql, params)
                else:
                    # æ’å…¥æ–°è®¾ç½®
                    cursor.execute('''
                        INSERT INTO user_settings
                        (user_id, discord_similarity_threshold, global_reply_min_delay, global_reply_max_delay,
                         user_blacklist, keyword_filters)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (
                        user_id,
                        discord_similarity_threshold or 0.6,
                        global_reply_min_delay or 3.0,
                        global_reply_max_delay or 8.0,
                        user_blacklist or '',
                        keyword_filters or ''
                    ))

                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ›´æ–°ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
            return False

    def update_system_config(self, discord_channel_id: str = None, discord_similarity_threshold: float = None,
                           cnfans_channel_id: str = None, acbuy_channel_id: str = None) -> bool:
        """æ›´æ–°ç³»ç»Ÿé…ç½®"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # é¦–å…ˆç¡®ä¿é…ç½®è®°å½•å­˜åœ¨
                cursor.execute('''
                    INSERT OR IGNORE INTO system_config (id, discord_channel_id, discord_similarity_threshold, cnfans_channel_id, acbuy_channel_id)
                    VALUES (1, '', 0.6, '', '')
                ''')

                # æ„å»ºæ›´æ–°è¯­å¥
                update_fields = []
                params = []

                if discord_channel_id is not None:
                    update_fields.append('discord_channel_id = ?')
                    params.append(discord_channel_id)

                if discord_similarity_threshold is not None:
                    update_fields.append('discord_similarity_threshold = ?')
                    params.append(discord_similarity_threshold)

                if cnfans_channel_id is not None:
                    update_fields.append('cnfans_channel_id = ?')
                    params.append(cnfans_channel_id)

                if acbuy_channel_id is not None:
                    update_fields.append('acbuy_channel_id = ?')
                    params.append(acbuy_channel_id)

                if update_fields:
                    update_fields.append('updated_at = CURRENT_TIMESTAMP')
                    sql = f'UPDATE system_config SET {", ".join(update_fields)} WHERE id = 1'
                    cursor.execute(sql, params)
                    conn.commit()
                    return True
                return False
        except Exception as e:
            logger.error(f"æ›´æ–°ç³»ç»Ÿé…ç½®å¤±è´¥: {e}")
            return False

    # ===== åº—é“ºç®¡ç†æ–¹æ³• =====

    def add_shop(self, shop_id: str, name: str) -> bool:
        """æ·»åŠ æ–°åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ£€æŸ¥åº—é“ºæ˜¯å¦å·²å­˜åœ¨
                cursor.execute('SELECT id FROM shops WHERE shop_id = ?', (shop_id,))
                if cursor.fetchone():
                    logger.warning(f"åº—é“º {shop_id} å·²å­˜åœ¨")
                    return False

                cursor.execute('''
                    INSERT INTO shops (shop_id, name, product_count)
                    VALUES (?, ?, 0)
                ''', (shop_id, name))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"æ·»åŠ åº—é“ºå¤±è´¥: {e}")
            return False

    def get_all_shops(self) -> List[Dict]:
        """è·å–æ‰€æœ‰åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops ORDER BY created_at DESC')
                rows = cursor.fetchall()

                shops = []
                for row in rows:
                    shops.append({
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    })
                return shops
        except Exception as e:
            logger.error(f"è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}")
            return []

    def get_shop_by_id(self, shop_id: str) -> Optional[Dict]:
        """æ ¹æ®shop_idè·å–åº—é“ºä¿¡æ¯"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM shops WHERE shop_id = ?', (shop_id,))
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'shop_id': row[1],
                        'name': row[2],
                        'product_count': row[3],
                        'created_at': row[4],
                        'updated_at': row[5]
                    }
                return None
        except Exception as e:
            logger.error(f"è·å–åº—é“ºä¿¡æ¯å¤±è´¥: {e}")
            return None

    def update_shop_product_count(self, shop_id: str, product_count: int) -> bool:
        """æ›´æ–°åº—é“ºçš„å•†å“æ•°é‡"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE shops
                    SET product_count = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE shop_id = ?
                ''', (product_count, shop_id))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"æ›´æ–°åº—é“ºå•†å“æ•°é‡å¤±è´¥: {e}")
            return False

    def delete_shop(self, shop_id: str) -> bool:
        """åˆ é™¤åº—é“º"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM shops WHERE shop_id = ?', (shop_id,))
                conn.commit()
                return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"åˆ é™¤åº—é“ºå¤±è´¥: {e}")
            return False

    # ========== æŠ“å–çŠ¶æ€ç®¡ç†æ–¹æ³• ==========

    def get_scrape_status(self) -> Dict:
        """è·å–æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT * FROM scrape_status WHERE id = 1')
                row = cursor.fetchone()

                if row:
                    return {
                        'id': row[0],
                        'is_scraping': bool(row[1]),
                        'stop_signal': bool(row[2]),
                        'current_shop_id': row[3],
                        'total': row[4] or 0,
                        'processed': row[5] or 0,
                        'success': row[6] or 0,
                        'progress': row[7] or 0.0,
                        'message': row[8] or 'ç­‰å¾…å¼€å§‹...',
                        'completed': bool(row[9]),
                        'thread_id': row[10],
                        'updated_at': row[11]
                    }
                else:
                    # å¦‚æœæ²¡æœ‰è®°å½•ï¼Œåˆ›å»ºé»˜è®¤è®°å½•
                    return self.reset_scrape_status()

        except Exception as e:
            logger.error(f"è·å–æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'è·å–çŠ¶æ€å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

    def update_scrape_status(self, **kwargs) -> bool:
        """æ›´æ–°æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # æ„å»ºæ›´æ–°è¯­å¥
                fields = []
                values = []
                for key, value in kwargs.items():
                    if key in ['is_scraping', 'stop_signal', 'completed']:
                        fields.append(f'{key} = ?')
                        values.append(1 if value else 0)
                    elif key in ['total', 'processed', 'success']:
                        fields.append(f'{key} = ?')
                        values.append(int(value) if value is not None else 0)
                    elif key == 'progress':
                        fields.append(f'{key} = ?')
                        values.append(float(value) if value is not None else 0.0)
                    elif key in ['current_shop_id', 'message', 'thread_id']:
                        fields.append(f'{key} = ?')
                        values.append(str(value) if value is not None else None)

                if fields:
                    fields.append('updated_at = CURRENT_TIMESTAMP')
                    query = f'UPDATE scrape_status SET {", ".join(fields)} WHERE id = 1'
                    cursor.execute(query, values)
                    conn.commit()
                    return cursor.rowcount > 0

                return False

        except Exception as e:
            logger.error(f"æ›´æ–°æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return False

    def reset_scrape_status(self) -> Dict:
        """é‡ç½®æŠ“å–çŠ¶æ€"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scrape_status SET
                        is_scraping = 0,
                        stop_signal = 0,
                        current_shop_id = NULL,
                        total = 0,
                        processed = 0,
                        success = 0,
                        progress = 0,
                        message = 'ç­‰å¾…å¼€å§‹...',
                        completed = 0,
                        thread_id = NULL,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = 1
                ''')
                conn.commit()

                return {
                    'is_scraping': False,
                    'stop_signal': False,
                    'current_shop_id': None,
                    'total': 0,
                    'processed': 0,
                    'success': 0,
                    'progress': 0.0,
                    'message': 'ç­‰å¾…å¼€å§‹...',
                    'completed': False,
                    'thread_id': None,
                    'updated_at': None
                }

        except Exception as e:
            logger.error(f"é‡ç½®æŠ“å–çŠ¶æ€å¤±è´¥: {e}")
            return {
                'is_scraping': False,
                'stop_signal': False,
                'current_shop_id': None,
                'total': 0,
                'processed': 0,
                'success': 0,
                'progress': 0.0,
                'message': 'é‡ç½®å¤±è´¥',
                'completed': False,
                'thread_id': None,
                'updated_at': None
            }

# å…¨å±€æ•°æ®åº“å®ä¾‹
db = Database()

--- File: ./backend/weidian_scraper.py ---
import requests
import re
import json
import time
import logging
from urllib.parse import urlparse, parse_qs, quote
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class WeidianScraper:
    """å¾®åº—å•†å“ä¿¡æ¯çˆ¬è™« - ä½¿ç”¨å®˜æ–¹API"""

    def __init__(self):
        self.session = requests.Session()
        # ä¿®å¤ï¼šæ›´æ–° Headersï¼Œå®Œå…¨åŒ¹é…ä½ çš„ CURL è¯·æ±‚
        self.session.headers.update({
            'accept': 'application/json, */*',  # æ³¨æ„ï¼šcurlä¸­æ˜¯ application/json, / ä½†å®é™…åº”è¯¥æ˜¯ /*
            'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'origin': 'https://weidian.com',
            'priority': 'u=1, i',
            'referer': 'https://weidian.com/',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"macOS"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-site',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
        })

        # ä¿®å¤ï¼šæ›´æ–° Cookies
        self.session.cookies.update({
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '6',
            '__spider__sessionid': 'e0e858ac8efb20a2'
        })

    def extract_item_id(self, url: str) -> Optional[str]:
        """ä»å¾®åº—URLä¸­æå–å•†å“ID"""
        try:
            parsed_url = urlparse(url)
            if 'itemID' in parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                return query_params.get('itemID', [None])[0]
            else:
                # å°è¯•ä»è·¯å¾„ä¸­æå–
                path_match = re.search(r'/item/(\d+)', parsed_url.path)
                if path_match:
                    return path_match.group(1)

                # å°è¯•å…¶ä»–æ ¼å¼
                id_match = re.search(r'itemID[=/](\d+)', url)
                if id_match:
                    return id_match.group(1)

            return None
        except Exception as e:
            logger.error(f"æå–å•†å“IDå¤±è´¥: {e}")
            return None

    def scrape_product_info(self, url: str) -> Optional[Dict]:
        """
        æŠ“å–å¾®åº—å•†å“ä¿¡æ¯ - ä½¿ç”¨å®˜æ–¹API
        è¿”å›åŒ…å«æ ‡é¢˜ã€æè¿°ã€å›¾ç‰‡ç­‰ä¿¡æ¯çš„å­—å…¸
        """
        try:
            item_id = self.extract_item_id(url)
            if not item_id:
                logger.error(f"æ— æ³•ä»URLæå–å•†å“ID: {url}")
                return None

            logger.info(f"å¼€å§‹æŠ“å–å•†å“: {item_id}")

            # è·å–åº—é“ºä¿¡æ¯
            shop_name = self._get_shop_name(url)
            if shop_name == "æœªçŸ¥åº—é“º":
                logger.info("åº—é“ºåç§°è·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°
                        shop_name_pattern = r'"shopName"[^:]*:[^"]*"([^"]+)"'
                        match = re.search(shop_name_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            shop_name = match.group(1).strip()
                            logger.info(f"âœ… ä»JavaScriptæ•°æ®è·å–åˆ°åº—é“ºåç§°: {shop_name}")
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢æå–åº—é“ºåç§°å¤±è´¥: {e}")

            # ä½¿ç”¨å®˜æ–¹APIè·å–å•†å“ä¿¡æ¯
            product_info = self._scrape_by_api(item_id, url, shop_name)
            if product_info:
                logger.info(f"âœ… å•†å“ä¿¡æ¯æŠ“å–æˆåŠŸ: {product_info.get('title', 'Unknown')}")
                return product_info

            # å¦‚æœAPIå¤±è´¥ï¼Œè¿”å›None
            logger.error("APIæŠ“å–å¤±è´¥ï¼Œæ²¡æœ‰å¤‡ç”¨æ–¹æ³•")
            return None

        except Exception as e:
            logger.error(f"å•†å“ä¿¡æ¯æŠ“å–å¤±è´¥: {e}")
            return None

    def _scrape_by_api(self, item_id: str, url: str, shop_name: str = '') -> Optional[Dict]:
        """ä½¿ç”¨å¾®åº—å®˜æ–¹APIæŠ“å–å•†å“ä¿¡æ¯"""
        try:
            # è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯
            title_info = self._get_item_title_and_sku(item_id)
            title = title_info.get('title', '') if title_info else ''

            # å¦‚æœAPIè·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
            if not title:
                logger.info("APIè·å–æ ‡é¢˜å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
                try:
                    page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                        'cache-control': 'max-age=0',
                        'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                        'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-platform': '"macOS"',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'same-origin',
                        'sec-fetch-user': '?1',
                        'upgrade-insecure-requests': '1',
                        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                    }, cookies={
                        'wdtoken': '8ea9315c',
                        '__spider__visitorid': '0dcf6a5b878847ec',
                        'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                        'v-components/cpn-coupon-dialog@nologinshop': '10',
                        '__spider__sessionid': 'e55c6458ac1fdba4'
                    })

                    if page_response.status_code == 200:
                        # ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
                        title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                        match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                        if match:
                            title = match.group(1).strip()
                            logger.info(f"âœ… ä»é¡µé¢HTMLè·å–åˆ°å•†å“æ ‡é¢˜: {title}")
                        else:
                            title = f'å¾®åº—å•†å“ {item_id}'
                except Exception as e:
                    logger.warning(f"ä»é¡µé¢HTMLæå–æ ‡é¢˜å¤±è´¥: {e}")
                    title = f'å¾®åº—å•†å“ {item_id}'
            else:
                title = title

            # è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ï¼ˆå³ä½¿æ ‡é¢˜è·å–å¤±è´¥ä¹Ÿè¦å°è¯•è·å–å›¾ç‰‡ï¼‰
            image_info = self._get_item_images(item_id)
            images = image_info if image_info else []

            # å¦‚æœæ—¢æ²¡æœ‰æ ‡é¢˜ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œè¿”å›None
            if not title and not images:
                logger.error("æ— æ³•è·å–å•†å“æ ‡é¢˜å’Œå›¾ç‰‡ä¿¡æ¯")
                return None

            # æ„å»ºå•†å“ä¿¡æ¯
            product_info = {
                'id': item_id,
                'weidian_url': url,
                'cnfans_url': f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN",
                'acbuy_url': f"https://www.acbuy.com/product?url=https%253A%252F%252Fweidian.com%252Fitem.html%253FitemID%253D{item_id}%2526spider_token%253D43fe&id={item_id}&source=WD",
                'images': images,
                'title': title,
                'english_title': self._generate_english_title(title),
                'description': f"å¾®åº—å•†å“ID: {item_id}",
                'shop_name': shop_name
            }

            return product_info

        except Exception as e:
            logger.error(f"APIæŠ“å–å¤±è´¥: {e}")
            return None

    def _get_item_title_and_sku(self, item_id: str) -> Optional[Dict]:
        """è·å–å•†å“æ ‡é¢˜å’ŒSKUä¿¡æ¯"""
        try:
            # æ„é€ API URL - ä½¿ç”¨æ›´æ–°çš„æ ¼å¼
            param = json.dumps({"itemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getItemSkuInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.info(f"è°ƒç”¨SKU API: {api_url}")  # ä¿®æ”¹æ—¥å¿—çº§åˆ«ä¸º INFO ä»¥ä¾¿è°ƒè¯•

            # ä½¿ç”¨ä¸å‰ç«¯ fetch å®Œå…¨ä¸€è‡´çš„ headers
            headers = {
                "accept": "application/json, */*",
                "accept-language": "en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"macOS"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "referrer": "https://weidian.com/",
                "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
            }

            # ä¸å¸¦ cookies å‘é€è¯·æ±‚ (æœ‰æ—¶å€™ cookies ä¼šå¯¼è‡´æ ¡éªŒå¤±è´¥)
            response = requests.get(api_url, headers=headers, timeout=15)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"æ ‡é¢˜APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                title = result.get('itemTitle', '')
                if title:
                    return {'title': title, 'sku_info': result}

            # å¦‚æœAPIè·å–å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
            logger.info("APIè·å–æ ‡é¢˜å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢HTMLæå–")
            try:
                page_response = requests.get(url, timeout=10, proxies={'http': None, 'https': None}, headers={
                    'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                    'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                    'cache-control': 'max-age=0',
                    'referer': 'https://weidian.com/?userid=1713062461&wfr=c&source=home_shop&ifr=itemdetail&sfr=app&tabType=all',
                    'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                    'sec-ch-ua-mobile': '?0',
                    'sec-ch-ua-platform': '"macOS"',
                    'sec-fetch-dest': 'document',
                    'sec-fetch-mode': 'navigate',
                    'sec-fetch-site': 'same-origin',
                    'sec-fetch-user': '?1',
                    'upgrade-insecure-requests': '1',
                    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
                }, cookies={
                    'wdtoken': '8ea9315c',
                    '__spider__visitorid': '0dcf6a5b878847ec',
                    'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                    'v-components/cpn-coupon-dialog@nologinshop': '10',
                    '__spider__sessionid': 'e55c6458ac1fdba4'
                })

                if page_response.status_code == 200:
                    # ä»é¡µé¢HTMLä¸­æå–å•†å“æ ‡é¢˜
                    title_pattern = r'<span[^>]*class="[^"]*item-name[^"]*"[^>]*>([^<]+)</span>'
                    match = re.search(title_pattern, page_response.text, re.DOTALL | re.IGNORECASE)
                    if match:
                        title = match.group(1).strip()
                        logger.info(f"âœ… ä»é¡µé¢HTMLè·å–åˆ°å•†å“æ ‡é¢˜: {title}")
                        return {'title': title, 'sku_info': {}}
            except Exception as e:
                logger.warning(f"ä»é¡µé¢HTMLæå–æ ‡é¢˜å¤±è´¥: {e}")

            return None

        except Exception as e:
            logger.error(f"è·å–å•†å“æ ‡é¢˜å¤±è´¥: {e}")
            return None

    def _get_item_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“å›¾ç‰‡ä¿¡æ¯ - åŒæ—¶è°ƒç”¨ä¸¤ä¸ªAPIå¹¶å»é‡"""
        try:
            all_images = []

            # 1. è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)
            detail_images = self._get_detail_images(item_id)
            all_images.extend(detail_images)

            # 2. è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API)
            sku_images = self._get_sku_images(item_id)
            all_images.extend(sku_images)

            # 3. ç®€å•URLå»é‡
            unique_images = []
            seen_urls = set()
            for img_url in all_images:
                if img_url and img_url not in seen_urls:
                    unique_images.append(img_url)
                    seen_urls.add(img_url)

            logger.info(f"âœ… å•†å“ {item_id} å›¾ç‰‡è·å–å®Œæˆ: å…± {len(unique_images)} å¼  (è¯¦æƒ…:{len(detail_images)}, SKU:{len(sku_images)})")
            if len(unique_images) > 0:
                logger.info(f"ğŸ“¸ å›¾ç‰‡URLæ ·ä¾‹: {unique_images[:3]}")
            return unique_images

        except Exception as e:
            logger.error(f"è·å–å•†å“å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_detail_images(self, item_id: str) -> List[str]:
        """è·å–å•†å“è¯¦æƒ…å›¾ç‰‡ (åŸæœ‰API)"""
        try:
            # æ„é€ API URL
            param = json.dumps({"vItemId": item_id})
            encoded_param = quote(param)
            timestamp = int(time.time() * 1000)

            api_url = f"https://thor.weidian.com/detail/getDetailDesc/1.0?param={encoded_param}&wdtoken=8ea9315c&_={timestamp}"

            logger.debug(f"è°ƒç”¨è¯¦æƒ…å›¾ç‰‡API: {api_url}")

            # ä½¿ç”¨æ›´ç¨³å®šçš„è¯·æ±‚å¤´ï¼Œæ¨¡æ‹Ÿæµè§ˆå™¨è¡Œä¸º
            import requests
            headers = {
                'accept': 'application/json, text/plain, */*',
                'accept-language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'origin': 'https://weidian.com',
                'priority': 'u=1, i',
                'referer': 'https://weidian.com/',
                'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-site',
                'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
            }

            # è®¾ç½®cookies
            cookies = {
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }

            response = requests.get(api_url, timeout=15, proxies={'http': None, 'https': None}, headers=headers, cookies=cookies)
            response.raise_for_status()

            data = response.json()
            logger.debug(f"è¯¦æƒ…å›¾ç‰‡APIè¿”å›çŠ¶æ€: {data.get('status', {}).get('code')}")

            images = []
            if data.get('status', {}).get('code') == 0:
                item_detail = data.get('result', {}).get('item_detail', {})
                desc_content = item_detail.get('desc_content', [])

                for item in desc_content:
                    if item.get('type') == 2 and item.get('url'):
                        images.append(item['url'])

            return images

        except Exception as e:
            logger.error(f"è·å–è¯¦æƒ…å›¾ç‰‡å¤±è´¥: {e}")
            return []

    def _get_sku_images(self, item_id: str) -> List[str]:
        """è·å–SKUå±æ€§å›¾ç‰‡ (æ–°API)"""
        try:
            logger.info(f"å¼€å§‹è·å–SKUå›¾ç‰‡ï¼Œå•†å“ID: {item_id}")
            # å¤ç”¨ _get_item_title_and_sku çš„é€»è¾‘
            title_info = self._get_item_title_and_sku(item_id)
            if not title_info or 'sku_info' not in title_info:
                logger.warning(f"æ— æ³•è·å–SKUä¿¡æ¯ï¼Œè·³è¿‡å›¾ç‰‡æå–: {item_id}")
                return []

            result = title_info['sku_info']
            attr_list = result.get('attrList', [])
            logger.info(f"æ‰¾åˆ° {len(attr_list)} ä¸ªå±æ€§ç»„")

            images = []
            for i, attr in enumerate(attr_list):
                attr_values = attr.get('attrValues', [])
                logger.info(f"å±æ€§ç»„ {i+1} æœ‰ {len(attr_values)} ä¸ªå±æ€§å€¼")
                for j, attr_value in enumerate(attr_values):
                    # === ä¿®å¤ï¼šä» attrValues ä¸­æå– img ===
                    img_url = attr_value.get('img')
                    if img_url:
                        logger.debug(f"æ‰¾åˆ°SKUå›¾ç‰‡: {img_url}")
                        # ç¡®ä¿URLæ ¼å¼æ­£ç¡®
                        if img_url.startswith('//'):
                            img_url = 'https:' + img_url
                        if img_url not in images:
                            images.append(img_url)

            logger.info(f"ä»SKUå±æ€§ä¸­æˆåŠŸæå– {len(images)} å¼ å›¾ç‰‡")
            return images
        except Exception as e:
            logger.error(f"è·å–SKUå›¾ç‰‡å¤±è´¥: {e}")
            return []


    def _generate_english_title(self, chinese_title: str) -> str:
        """æ ¹æ®ä¸­æ–‡æ ‡é¢˜ç”Ÿæˆè‹±æ–‡æ ‡é¢˜ - ä½¿ç”¨å…è´¹ç¿»è¯‘API"""
        if not chinese_title or len(chinese_title.strip()) == 0:
            return ""
        # ä¼˜å…ˆä½¿ç”¨ Google å…è´¹æ¥å£ï¼Œå¤±è´¥å†å›é€€åˆ°ç™¾åº¦ï¼Œå†å›é€€åˆ°ç®€å•æ˜ å°„
        try:
            return self._translate_with_google(chinese_title)
        except Exception as e:
            logger.debug(f"Google ç¿»è¯‘å¤±è´¥: {e}")
        try:
            res = self._translate_with_baidu(chinese_title)
            if res:
                return res
        except Exception as e:
            logger.debug(f"ç™¾åº¦ç¿»è¯‘å¤±è´¥: {e}")
        # æœ€åå¤‡ç”¨ï¼šç®€å•æ˜ å°„
        return self._simple_chinese_to_english(chinese_title)

    def _translate_with_baidu(self, text: str) -> str:
        """ä½¿ç”¨ç™¾åº¦ç¿»è¯‘API"""
        try:
            # ç™¾åº¦ç¿»è¯‘å…è´¹API
            url = "https://fanyi.baidu.com/transapi"

            params = {
                'from': 'zh',
                'to': 'en',
                'query': text[:200]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            data = response.json()
            # å°è¯•å¤šç§å¯èƒ½çš„è¿”å›ç»“æ„ï¼Œé¿å…ç›´æ¥æŠ›å‡ºå¼‚å¸¸
            translated = ""
            if isinstance(data, dict):
                try:
                    translated = data.get('data', {}).get('result', [{}])[0].get('dst', '') or ''
                except Exception:
                    translated = ''
                if not translated:
                    if 'trans_result' in data:
                        try:
                            translated = data.get('trans_result', [{}])[0].get('dst', '') or ''
                        except Exception:
                            translated = ''
            if translated:
                return translated.strip()
            logger.debug("ç™¾åº¦ç¿»è¯‘è¿”å›ç©ºç»“æœ")
            return ""
        except Exception as e:
            logger.warning(f"ç™¾åº¦ç¿»è¯‘APIè°ƒç”¨å¼‚å¸¸: {e}")
            return ""

    def _translate_with_google(self, text: str) -> str:
        """ä½¿ç”¨Google Translate APIçš„å…è´¹ç‰ˆæœ¬"""
        try:
            # ä½¿ç”¨Google Translateçš„å…è´¹API
            url = "https://translate.googleapis.com/translate_a/single"

            params = {
                'client': 'gtx',
                'sl': 'zh-CN',
                'tl': 'en',
                'dt': 't',
                'q': text[:500]  # é™åˆ¶é•¿åº¦
            }

            response = self.session.get(url, params=params, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # Googleè¿”å›çš„æ˜¯JSONæ•°ç»„
            data = response.json()
            if data and len(data) > 0 and len(data[0]) > 0:
                translated = data[0][0][0]
                if translated:
                    return translated.strip()

            raise Exception("Googleç¿»è¯‘è¿”å›ç©ºç»“æœ")

        except Exception as e:
            logger.error(f"Googleç¿»è¯‘APIè°ƒç”¨å¤±è´¥: {e}")
            raise e

    def _simple_chinese_to_english(self, text: str) -> str:
        """ç®€å•çš„ä¸­è‹±æ˜ å°„ - æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ"""
        # ç®€å•çš„å•†å“å…³é”®è¯æ˜ å°„
        mappings = {
            'é‹': 'shoes',
            'è¿åŠ¨é‹': 'sports shoes',
            'è¢œå­': 'socks',
            'é‹å­': 'shoes',
            'è¡£æœ': 'clothes',
            'ä¸Šè¡£': 'top',
            'è£¤å­': 'pants',
            'åŒ…': 'bag',
            'åŒ…åŒ…': 'bag',
            'æ‰‹æœº': 'phone',
            'ç”µè„‘': 'computer',
            'è€³æœº': 'headphones',
            'æ‰‹è¡¨': 'watch',
            'çœ¼é•œ': 'glasses',
            'å¸½å­': 'hat',
            'ä¹¦': 'book',
            'ç©å…·': 'toy',
            'æ¸¸æˆ': 'game'
        }

        result = text
        for cn, en in mappings.items():
            result = result.replace(cn, en)

        # å¦‚æœæœ‰æ˜æ˜¾çš„å˜åŒ–ï¼Œè¿”å›ç¿»è¯‘ç»“æœï¼Œå¦åˆ™è¿”å›ç©º
        if result != text:
            return result.strip()
        else:
            return ""


    def download_images(self, image_urls: List[str], save_dir: str, item_id: str) -> List[str]:
        """å¤šçº¿ç¨‹ä¸‹è½½å•†å“å›¾ç‰‡åˆ°æœ¬åœ°"""
        import os
        import concurrent.futures
        import threading

        saved_paths = []
        os.makedirs(save_dir, exist_ok=True)

        # ç§»é™¤å›¾ç‰‡æ•°é‡é™åˆ¶ï¼ŒæŠ“å–æ‰€æœ‰å¯ç”¨çš„å›¾ç‰‡
        # SKUå›¾ç‰‡é€šå¸¸æ’åœ¨è¯¦æƒ…å›¾ä¹‹åï¼Œç°åœ¨å¯ä»¥è·å–æ‰€æœ‰å›¾ç‰‡
        logger.info(f"å‡†å¤‡ä¸‹è½½ {len(image_urls)} å¼ å›¾ç‰‡ï¼ˆæ— æ•°é‡é™åˆ¶ï¼‰")

        def download_single_image(args):
            """ä¸‹è½½å•å¼ å›¾ç‰‡çš„å‡½æ•°"""
            i, img_url = args
            try:
                # ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºç‹¬ç«‹çš„session
                thread_session = requests.Session()
                thread_session.headers.update(self.session.headers)
                thread_session.cookies.update(self.session.cookies)

                response = thread_session.get(img_url, timeout=10, proxies={'http': None, 'https': None})
                response.raise_for_status()

                # ä¿å­˜å›¾ç‰‡
                img_path = os.path.join(save_dir, f"{item_id}_{i}.jpg")
                with open(img_path, 'wb') as f:
                    f.write(response.content)

                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸ: {img_path}")
                return img_path

            except Exception as e:
                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ {img_url}: {e}")
                return None

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘ä¸‹è½½å›¾ç‰‡
        try:
            from config import config
        except ImportError:
            from .config import config
        max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))  # ä½¿ç”¨é…ç½®çš„ä¸‹è½½çº¿ç¨‹æ•°

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æäº¤æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
            future_to_image = {
                executor.submit(download_single_image, (i, img_url)): (i, img_url)
                for i, img_url in enumerate(image_urls)
            }

            # æ”¶é›†ç»“æœ
            for future in concurrent.futures.as_completed(future_to_image):
                result = future.result()
                if result:
                    saved_paths.append(result)

        # æŒ‰ç´¢å¼•æ’åºç»“æœ
        saved_paths.sort(key=lambda x: int(x.split('_')[-1].split('.')[0]))

        return saved_paths

    def _get_shop_name(self, url: str) -> str:
        """ä»å•†å“é¡µé¢è·å–åº—é“ºåç§°"""
        try:
            logger.debug(f"å¼€å§‹è·å–åº—é“ºåç§°: {url}")

            # è¯·æ±‚å•†å“é¡µé¢
            response = self.session.get(url, timeout=10, proxies={'http': None, 'https': None})
            response.raise_for_status()

            # è§£ç HTMLå®ä½“ï¼ˆ&#34; -> " ç­‰ï¼‰
            html_content = response.text
            html_content = html_content.replace('&#34;', '"').replace('&#39;', "'").replace('&quot;', '"')

            # é¦–å…ˆå°è¯•æœ€ç²¾ç¡®çš„åŒ¹é…ï¼šemæ ‡ç­¾ä¸­çš„shop-name-strç±»ï¼ˆæ ¹æ®ç”¨æˆ·æä¾›çš„HTMLç»“æ„ï¼‰
            shop_name_pattern1 = r'<em[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</em>'
            match = re.search(shop_name_pattern1, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (em shop-name-str): {shop_name}")
                return shop_name

            # ç„¶åå°è¯•æ›´å®½æ³›çš„åŒ¹é…ï¼ŒæŸ¥æ‰¾åŒ…å«shop-name-strç±»çš„ä»»ä½•å…ƒç´ 
            shop_name_pattern2 = r'<[^>]*class="[^"]*\bshop-name-str\b[^"]*"[^>]*>([^<]+)</[^>]*>'
            match = re.search(shop_name_pattern2, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (é€šç”¨shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•åŒ¹é…class="shop-name-str"çš„å…ƒç´ ï¼ˆä¸é™å®šæ ‡ç­¾ç±»å‹ï¼‰
            shop_name_pattern3 = r'class="shop-name-str"[^>]*>([^<]+)</'
            match = re.search(shop_name_pattern3, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (shop-name-str): {shop_name}")
                return shop_name

            # å°è¯•ä»JavaScriptæ•°æ®ä¸­æå–åº—é“ºåç§°ï¼ˆå¤šç§æ ¼å¼ï¼‰
            # æ ¼å¼1: "shopName":"Aiseo"
            shop_name_pattern4 = r'"shopName"\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern4, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScript): {shop_name}")
                return shop_name

            # æ ¼å¼2: \"shopName\":\"Aiseo\" (åœ¨HTMLä¸­è¢«è½¬ä¹‰)
            shop_name_pattern5 = r'\\"shopName\\"\s*:\s*\\"([^\\"]+)\\"'
            match = re.search(shop_name_pattern5, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptè½¬ä¹‰): {shop_name}")
                return shop_name

            # æ ¼å¼3: shopName:"Aiseo" (æ— å¼•å·)
            shop_name_pattern6 = r'shopName\s*:\s*"([^"]+)"'
            match = re.search(shop_name_pattern6, html_content, re.DOTALL | re.IGNORECASE)
            if match:
                shop_name = match.group(1).strip()
                logger.info(f"âœ… è·å–åˆ°åº—é“ºåç§° (JavaScriptæ— å¼•å·): {shop_name}")
                return shop_name

            logger.warning("æœªæ‰¾åˆ°åº—é“ºåç§°ï¼Œä½¿ç”¨é»˜è®¤åç§°")
            return "æœªçŸ¥åº—é“º"

        except Exception as e:
            logger.error(f"è·å–åº—é“ºåç§°å¤±è´¥: {e}")
            return "æœªçŸ¥åº—é“º"

    def close(self):
        """å…³é—­èµ„æº - å ä½æ–¹æ³•"""
        pass

# å…¨å±€çˆ¬è™«å®ä¾‹
_scraper = None

def get_weidian_scraper() -> WeidianScraper:
    """è·å–å¾®åº—çˆ¬è™«å®ä¾‹"""
    global _scraper
    if _scraper is None:
        _scraper = WeidianScraper()
    return _scraper

--- File: ./backend/bot_config.py ---
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    DISCORD_CHANNEL_ID = int(os.getenv('DISCORD_CHANNEL_ID', 0)) if os.getenv('DISCORD_CHANNEL_ID') else 0
    DISCORD_SIMILARITY_THRESHOLD = float(os.getenv('DISCORD_SIMILARITY_THRESHOLD', '0.6'))  # Discordæœºå™¨äººç›¸ä¼¼åº¦é˜ˆå€¼

    # å…¨å±€å›å¤å»¶è¿Ÿé…ç½®
    GLOBAL_REPLY_MIN_DELAY = int(os.getenv('GLOBAL_REPLY_MIN_DELAY', '3'))  # å…¨å±€æœ€å°å»¶è¿Ÿç§’æ•°
    GLOBAL_REPLY_MAX_DELAY = int(os.getenv('GLOBAL_REPLY_MAX_DELAY', '8'))  # å…¨å±€æœ€å¤§å»¶è¿Ÿç§’æ•°

    # å…³é”®è¯è½¬å‘é…ç½®
    FORWARD_KEYWORDS = os.getenv('FORWARD_KEYWORDS', 'å•†å“,è´§æº,è¿›è´§,æ‰¹å‘,ä»£ç†').split(',')  # è§¦å‘è½¬å‘çš„å…³é”®è¯
    FORWARD_TARGET_CHANNEL_ID = int(os.getenv('FORWARD_TARGET_CHANNEL_ID', 0)) if os.getenv('FORWARD_TARGET_CHANNEL_ID') else 0  # è½¬å‘ç›®æ ‡é¢‘é“ID

    # APIæœåŠ¡åœ°å€ï¼ˆæœ¬åœ°æœåŠ¡ï¼‰
    NEXTJS_API_URL = 'http://localhost:5001/api'
    PADDLE_SERVICE_URL = 'http://localhost:5001'

    # æœºå™¨äººé…ç½®
    COMMAND_PREFIX = '!'

config = Config()

--- File: ./backend/bot.py ---
import discord
import aiohttp
import logging
import time
import asyncio
import random
import os
import json
import io
from datetime import datetime
try:
    from config import config
except ImportError:
    from .config import config

# å…¨å±€å˜é‡ç”¨äºå¤šè´¦å·æœºå™¨äººç®¡ç†
bot_clients = []
bot_tasks = []

def get_response_url_for_channel(product, channel_id):
    """æ ¹æ®é¢‘é“IDå†³å®šå‘é€å“ªä¸ªé“¾æ¥"""
    channel_id_str = str(channel_id)

    # å¦‚æœæ˜¯CNFansé¢‘é“ï¼Œä¼˜å…ˆå‘é€CNFansé“¾æ¥
    if config.CNFANS_CHANNEL_ID and channel_id_str == config.CNFANS_CHANNEL_ID:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        elif product.get('acbuyUrl'):
            return product['acbuyUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    # å¦‚æœæ˜¯AcBuyé¢‘é“ï¼Œä¼˜å…ˆå‘é€AcBuyé“¾æ¥
    elif config.ACBUY_CHANNEL_ID and channel_id_str == config.ACBUY_CHANNEL_ID:
        if product.get('acbuyUrl'):
            return product['acbuyUrl']
        elif product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

    # å…¶ä»–é¢‘é“é»˜è®¤å‘é€CNFansé“¾æ¥ï¼Œå¦‚æœæ²¡æœ‰åˆ™å‘é€å¾®åº—é“¾æ¥
    else:
        if product.get('cnfansUrl'):
            return product['cnfansUrl']
        else:
            return product.get('weidianUrl', 'æœªæ‰¾åˆ°ç›¸å…³å•†å“')

class HTTPLogHandler(logging.Handler):
    """é€šè¿‡HTTPå‘é€æ—¥å¿—åˆ°Flaskåº”ç”¨"""
    def __init__(self):
        super().__init__()
        self.pending_logs = []
        self.is_sending = False

    def emit(self, record):
        try:
            # åªå‘é€æˆ‘ä»¬å…³å¿ƒçš„æ—¥å¿—çº§åˆ«
            if record.levelno >= logging.INFO:
                log_data = {
                    'timestamp': datetime.now().isoformat(),
                    'level': record.levelname,
                    'message': self.format(record),
                    'module': record.module,
                    'func': record.funcName
                }

                # æ·»åŠ åˆ°å¾…å‘é€é˜Ÿåˆ—
                self.pending_logs.append(log_data)

                # å¦‚æœæ²¡æœ‰æ­£åœ¨å‘é€ï¼Œå¯åŠ¨å‘é€ä»»åŠ¡
                if not self.is_sending:
                    # åœ¨æœºå™¨äººçš„äº‹ä»¶å¾ªç¯ä¸­åˆ›å»ºä»»åŠ¡
                    try:
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            loop.create_task(self.send_pending_logs())
                        else:
                            # å¦‚æœå¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥å‘é€ï¼ˆåŒæ­¥æ–¹å¼ï¼‰
                            self.send_sync(log_data)
                    except RuntimeError:
                        # æ²¡æœ‰äº‹ä»¶å¾ªç¯ï¼Œç›´æ¥åŒæ­¥å‘é€
                        self.send_sync(log_data)

        except Exception as e:
            print(f"HTTPæ—¥å¿—å¤„ç†å™¨é”™è¯¯: {e}")

    def send_sync(self, log_data):
        """åŒæ­¥å‘é€æ—¥å¿—ï¼ˆä½œä¸ºfallbackï¼‰"""
        try:
            import requests
            response = requests.post('http://localhost:5001/api/logs/add',
                                   json=log_data, timeout=2)
            if response.status_code != 200:
                print(f"åŒæ­¥å‘é€æ—¥å¿—å¤±è´¥: {response.status_code}")
        except Exception as e:
            print(f"åŒæ­¥å‘é€æ—¥å¿—å¼‚å¸¸: {e}")

    async def send_pending_logs(self):
        """å¼‚æ­¥å‘é€å¾…å¤„ç†çš„æ—¥å¿—"""
        if self.is_sending:
            return

        self.is_sending = True

        try:
            while self.pending_logs:
                log_data = self.pending_logs.pop(0)

                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.post('http://localhost:5001/api/logs/add',
                                              json=log_data, timeout=aiohttp.ClientTimeout(total=2)) as resp:
                            if resp.status != 200:
                                print(f"å‘é€æ—¥å¿—å¤±è´¥: {resp.status}")
                except Exception as e:
                    print(f"å‘é€æ—¥å¿—å¼‚å¸¸: {e}")
                    # é‡æ–°æ”¾å›é˜Ÿåˆ—
                    self.pending_logs.insert(0, log_data)
                    break

                # å°å»¶è¿Ÿé¿å…å‘é€å¤ªå¿«
                await asyncio.sleep(0.1)

        finally:
            self.is_sending = False

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)

# æ·»åŠ HTTPæ—¥å¿—å¤„ç†å™¨
http_handler = HTTPLogHandler()
http_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(http_handler)

logger = logging.getLogger(__name__)

# ç¡®ä¿discordåº“ä¹Ÿä½¿ç”¨æˆ‘ä»¬çš„æ—¥å¿—é…ç½®
logging.getLogger('discord').setLevel(logging.INFO)

class DiscordBotClient(discord.Client):
    def __init__(self, account_id=None, user_id=None, user_shops=None):
        # discord.py-self å¯èƒ½ä¸éœ€è¦ intentsï¼Œæˆ–è€…ä½¿ç”¨ä¸åŒçš„è¯­æ³•
        try:
            # å°è¯•ä½¿ç”¨æ ‡å‡†çš„ intents
            intents = discord.Intents.default()
            intents.message_content = True
            intents.messages = True
            intents.guilds = True
            super().__init__(intents=intents)
        except AttributeError:
            # å¦‚æœ Intents ä¸å­˜åœ¨ï¼Œç›´æ¥åˆå§‹åŒ–ï¼ˆdiscord.py-self å¯èƒ½ä¸éœ€è¦ï¼‰
            super().__init__()
        self.current_token = None
        self.running = False
        self.account_id = account_id
        self.user_id = user_id  # ç”¨æˆ·IDï¼Œç”¨äºè·å–ä¸ªæ€§åŒ–è®¾ç½®
        self.user_shops = user_shops  # ç”¨æˆ·ç®¡ç†çš„åº—é“ºåˆ—è¡¨

    def _should_filter_message(self, message):
        """æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åº”è¯¥è¢«è¿‡æ»¤"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db

            # 1. æ£€æŸ¥å…¨å±€æ¶ˆæ¯è¿‡æ»¤è§„åˆ™
            filters = db.get_message_filters()
            message_content = message.content.lower()

            for filter_rule in filters:
                filter_value = filter_rule['filter_value'].lower()
                filter_type = filter_rule['filter_type']

                if filter_type == 'contains':
                    if filter_value in message_content:
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å« "{filter_value}"')
                        return True
                elif filter_type == 'starts_with':
                    if message_content.startswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" å¼€å¤´')
                        return True
                elif filter_type == 'ends_with':
                    if message_content.endswith(filter_value):
                        logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ä»¥ "{filter_value}" ç»“å°¾')
                        return True
                elif filter_type == 'regex':
                    import re
                    try:
                        if re.search(filter_value, message_content, re.IGNORECASE):
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ¹é…æ­£åˆ™ "{filter_value}"')
                            return True
                    except re.error:
                        logger.warning(f'æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼: {filter_value}')
                elif filter_type == 'user_id':
                    # æ£€æŸ¥ç”¨æˆ·IDè¿‡æ»¤
                    filter_user_ids = [uid.strip() for uid in filter_value.split(',') if uid.strip()]
                    sender_id = str(message.author.id)
                    sender_name = str(message.author.name).lower()

                    for blocked_id in filter_user_ids:
                        blocked_id = blocked_id.strip()
                        if blocked_id == sender_id or blocked_id.lower() in sender_name:
                            logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} (ID: {sender_id}) åœ¨è¿‡æ»¤åˆ—è¡¨ä¸­')
                            return True

            # 2. æ£€æŸ¥ç”¨æˆ·ä¸ªæ€§åŒ–è®¾ç½®çš„è¿‡æ»¤è§„åˆ™
            if self.user_id:
                user_settings = db.get_user_settings(self.user_id)
                if user_settings:
                    # æ£€æŸ¥ç”¨æˆ·é»‘åå•
                    user_blacklist = user_settings.get('user_blacklist', '')
                    if user_blacklist:
                        blacklist_users = [u.strip().lower() for u in user_blacklist.split(',') if u.strip()]
                        sender_name = str(message.author.name).lower()
                        sender_id = str(message.author.id).lower()

                        for blocked_user in blacklist_users:
                            blocked_user = blocked_user.lower()
                            if blocked_user in sender_name or blocked_user == sender_id:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: ç”¨æˆ· {message.author.name} åœ¨é»‘åå•ä¸­')
                                return True

                    # æ£€æŸ¥å…³é”®è¯è¿‡æ»¤
                    keyword_filters = user_settings.get('keyword_filters', '')
                    if keyword_filters:
                        filter_keywords = [k.strip().lower() for k in keyword_filters.split(',') if k.strip()]

                        for keyword in filter_keywords:
                            if keyword in message_content:
                                logger.info(f'æ¶ˆæ¯è¢«è¿‡æ»¤: åŒ…å«å…³é”®è¯ "{keyword}"')
                                return True

        except Exception as e:
            logger.error(f'æ£€æŸ¥æ¶ˆæ¯è¿‡æ»¤å¤±è´¥: {e}')

        return False

    def _get_custom_reply(self):
        """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            replies = db.get_custom_replies()

            if replies:
                # è¿”å›ä¼˜å…ˆçº§æœ€é«˜çš„æ´»è·ƒå›å¤
                return replies[0]
        except Exception as e:
            logger.error(f'è·å–è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}')

        return None

    async def on_ready(self):
        logger.info(f'Discordæœºå™¨äººå·²ç™»å½•: {self.user} (ID: {self.user.id})')
        logger.info(f'æœºå™¨äººå·²å°±ç»ªï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯')
        logger.info(f'ç›‘å¬é¢‘é“: {config.DISCORD_CHANNEL_ID or "æ‰€æœ‰é¢‘é“"}')
        self.running = True

        # æ›´æ–°æ•°æ®åº“ä¸­çš„è´¦å·çŠ¶æ€ä¸ºåœ¨çº¿
        try:
            try:
                from database import db
            except ImportError:
                from .database import db
            if hasattr(self, 'account_id'):
                db.update_account_status(self.account_id, 'online')
                logger.info(f'è´¦å· {self.account_id} çŠ¶æ€å·²æ›´æ–°ä¸ºåœ¨çº¿')
        except Exception as e:
            logger.error(f'æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}')

    async def on_message(self, message):
        if not self.running:
            return

        # å¿½ç•¥è‡ªå·±çš„æ¶ˆæ¯
        if message.author == self.user:
            return

        # å¿½ç•¥æœºå™¨äººå’Œwebhookçš„æ¶ˆæ¯
        if message.author.bot or message.webhook_id:
            return

        # å¦‚æœé…ç½®äº†é¢‘é“IDï¼Œåªå¤„ç†ç‰¹å®šé¢‘é“çš„æ¶ˆæ¯ï¼›å¦åˆ™å¤„ç†æ‰€æœ‰é¢‘é“
        if config.DISCORD_CHANNEL_ID and str(message.channel.id) != str(config.DISCORD_CHANNEL_ID):
            return

        # æ£€æŸ¥æ¶ˆæ¯è¿‡æ»¤è§„åˆ™
        if self._should_filter_message(message):
            return

        logger.info(f'æ”¶åˆ°æ¶ˆæ¯: {message.author.name} åœ¨ #{message.channel.name}: "{message.content[:100]}{"..." if len(message.content) > 100 else ""}"')

        # å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘
        await self.handle_keyword_forward(message)

        # å¤„ç†å…³é”®è¯æœç´¢ï¼ˆæ–‡å­—æ¶ˆæ¯ï¼‰
        await self.handle_keyword_search(message)

        # æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åŒ…å«å›¾ç‰‡ï¼ˆåªå¤„ç†å›¾ç‰‡ï¼Œä¸å¤„ç†æ–‡å­—ï¼‰
        if message.attachments:
            for attachment in message.attachments:
                if attachment.content_type and attachment.content_type.startswith('image/'):
                    await self.handle_image(message, attachment)
                    # å¦‚æœæ¶ˆæ¯åŒ…å«å›¾ç‰‡ï¼Œä¸å†å¤„ç†æ–‡å­—å†…å®¹ï¼Œé¿å…é‡å¤å›å¤

    async def handle_image(self, message, attachment):
        try:
            # ä¸‹è½½å›¾ç‰‡ï¼Œè®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´å’Œé‡è¯•æœºåˆ¶
            timeout = aiohttp.ClientTimeout(total=10, connect=5)  # 10ç§’æ€»è¶…æ—¶ï¼Œ5ç§’è¿æ¥è¶…æ—¶
            image_data = None

            # é‡è¯•æœ€å¤š3æ¬¡
            for attempt in range(3):
                try:
                    logger.info(f"ä¸‹è½½Discordå›¾ç‰‡ (å°è¯• {attempt + 1}/3): {attachment.filename}")
                    async with aiohttp.ClientSession(timeout=timeout) as session:
                        async with session.get(attachment.url) as resp:
                            if resp.status == 200:
                                image_data = await resp.read()
                                logger.info(f"å›¾ç‰‡ä¸‹è½½æˆåŠŸï¼Œå¤§å°: {len(image_data)} bytes")
                                break
                            else:
                                logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : {resp.status}")
                except aiohttp.ClientError as e:
                    logger.warning(f"å›¾ç‰‡ä¸‹è½½å¤±è´¥ (å°è¯• {attempt + 1}/3): {e}")
                    if attempt < 2:  # ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•
                        await asyncio.sleep(1)  # ç­‰å¾…1ç§’åé‡è¯•
                except Exception as e:
                    logger.error(f"å›¾ç‰‡ä¸‹è½½æœªçŸ¥é”™è¯¯ (å°è¯• {attempt + 1}/3): {e}")
                    break

            if image_data is None:
                logger.error("å›¾ç‰‡ä¸‹è½½å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                return  # é™é»˜å¤±è´¥ï¼Œä¸å‘é€é”™è¯¯æ¶ˆæ¯

            # è°ƒç”¨ DINOv2 æœåŠ¡è¯†åˆ«å›¾ç‰‡ï¼Œæ ¹æ®ç”¨æˆ·æƒé™è¿‡æ»¤ç»“æœ
            result = await self.recognize_image(image_data, self.user_shops)

            logger.info(f'å›¾ç‰‡è¯†åˆ«ç»“æœ: success={result.get("success") if result else False}, results_count={len(result.get("results", [])) if result else 0}')

            if result and result.get('success') and result.get('results'):
                # è·å–æœ€ä½³åŒ¹é…ç»“æœ
                best_match = result['results'][0]
                similarity = best_match.get('similarity', 0)

                # è·å–ç”¨æˆ·ä¸ªæ€§åŒ–ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                user_threshold = config.DISCORD_SIMILARITY_THRESHOLD  # é»˜è®¤å€¼
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        user_settings = db.get_user_settings(self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            user_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                logger.info(f'æœ€ä½³åŒ¹é…ç›¸ä¼¼åº¦: {similarity:.4f}, ç”¨æˆ·é˜ˆå€¼: {user_threshold:.4f}')

                # æ£€æŸ¥ç›¸ä¼¼åº¦æ˜¯å¦è¶…è¿‡ç”¨æˆ·è®¾ç½®çš„é˜ˆå€¼ï¼Œæˆ–è€…æ˜¯å¦ä¸ºé«˜è´¨é‡åŒ¹é…ï¼ˆç›¸ä¼¼åº¦>0.8ï¼‰
                if similarity >= user_threshold or similarity > 0.8:
                    product = best_match.get('product', {})
                    logger.info(f'âœ… åŒ¹é…æˆåŠŸ! ç›¸ä¼¼åº¦: {similarity:.2f} | å•†å“: {product.get("id")} | é¢‘é“: {message.channel.name}')

                    # æ¨¡æ‹Ÿæ‰“å­—çŠ¶æ€å¹¶å»¶è¿Ÿå›å¤
                    async with message.channel.typing():
                        # === ä¿®å¤å»¶è¿Ÿé€»è¾‘ ===
                        # ç›´æ¥è¯»å–é…ç½®ï¼Œä¸è®¾ç¡¬æ€§ä¸‹é™ï¼Œå…è®¸ 0.1s
                        min_d = max(0.1, float(config.GLOBAL_REPLY_MIN_DELAY))
                        max_d = max(min_d, float(config.GLOBAL_REPLY_MAX_DELAY))

                        delay = random.uniform(min_d, max_d)
                        await asyncio.sleep(delay)

                    # æ£€æŸ¥å•†å“æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨å›å¤è§„åˆ™
                    product_rule_enabled = product.get('ruleEnabled', True)

                    if product_rule_enabled:
                        # ä½¿ç”¨å…¨å±€è‡ªå®šä¹‰å›å¤
                        custom_reply = self._get_custom_reply()

                        if custom_reply:
                            reply_type = custom_reply.get('reply_type')

                            if reply_type == 'custom_only':
                                # åªå‘é€è‡ªå®šä¹‰å†…å®¹ï¼Œä¸å‘é€é“¾æ¥
                                if custom_reply.get('content'):
                                    await message.reply(custom_reply['content'])
                                if custom_reply.get('image_url'):
                                    # è¿™é‡Œå¯ä»¥å®ç°å‘é€å›¾ç‰‡çš„é€»è¾‘
                                    pass

                            elif reply_type == 'text_and_link':
                                # å‘é€æ–‡å­— + é“¾æ¥
                                response = get_response_url_for_channel(product, message.channel.id)
                                full_reply = f"{custom_reply.get('content', '')}\n{response}".strip()
                                await message.reply(full_reply)

                            elif reply_type == 'text':
                                # åªå‘é€æ–‡å­—
                                if custom_reply.get('content'):
                                    await message.reply(custom_reply['content'])

                            elif reply_type == 'image':
                                # å‘é€å›¾ç‰‡ï¼ˆå¦‚æœè®¾ç½®äº†çš„è¯ï¼‰
                                if custom_reply.get('image_url'):
                                    # è¿™é‡Œå¯ä»¥å®ç°å‘é€å›¾ç‰‡çš„é€»è¾‘
                                    pass
                        else:
                            # é»˜è®¤è¡Œä¸ºï¼šå‘é€é“¾æ¥
                            response = get_response_url_for_channel(product, message.channel.id)
                            await message.reply(response)
                    else:
                        # å•†å“çº§è‡ªå®šä¹‰å›å¤
                        custom_text = product.get('custom_reply_text', '').strip()
                        custom_image_indexes = product.get('selectedImageIndexes', [])
                        custom_image_urls = product.get('customImageUrls', [])

                        # å‘é€è‡ªå®šä¹‰æ–‡æœ¬æ¶ˆæ¯
                        if custom_text:
                            await message.reply(custom_text)

                        # å‘é€å›¾ç‰‡ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼šæœ¬åœ°ä¸Šä¼  > è‡ªå®šä¹‰é“¾æ¥ > å•†å“å›¾ç‰‡ï¼‰
                        images_sent = False

                        # ä¼˜å…ˆæ£€æŸ¥å›¾ç‰‡æ¥æºç±»å‹
                        image_source = product.get('image_source', 'product')

                        if image_source == 'upload':
                            # å‘é€æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡
                            try:
                                from database import db
                                # è·å–è¯¥å•†å“çš„æ‰€æœ‰å›¾ç‰‡ï¼ˆåŒ…æ‹¬ä¸Šä¼ çš„ï¼‰
                                product_images = db.get_product_images(product['id'])
                                if product_images:
                                    for img_data in product_images[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                        try:
                                            image_path = img_data.get('image_path')
                                            # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ„å»ºå®Œæ•´è·¯å¾„
                                            if image_path and not os.path.isabs(image_path):
                                                image_path = os.path.join(os.path.dirname(__file__), image_path)
                                            if image_path and os.path.exists(image_path):
                                                await message.reply(file=discord.File(image_path, os.path.basename(image_path)))
                                                images_sent = True
                                        except Exception as e:
                                            logger.error(f'å‘é€æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†æœ¬åœ°ä¸Šä¼ å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif image_source == 'custom' and custom_image_urls and len(custom_image_urls) > 0:
                            # å‘é€è‡ªå®šä¹‰å›¾ç‰‡é“¾æ¥
                            try:
                                import aiohttp
                                for url in custom_image_urls[:10]:  # æœ€å¤šå‘é€10å¼ å›¾ç‰‡
                                    try:
                                        async with aiohttp.ClientSession() as session:
                                            async with session.get(url.strip()) as resp:
                                                if resp.status == 200:
                                                    image_data = await resp.read()
                                                    # ä»URLæå–æ–‡ä»¶å
                                                    filename = url.split('/')[-1].split('?')[0] or f"image_{custom_image_urls.index(url)}.jpg"
                                                    if not filename.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
                                                        filename += '.jpg'
                                                    await message.reply(file=discord.File(io.BytesIO(image_data), filename))
                                                    images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€è‡ªå®šä¹‰å›¾ç‰‡å¤±è´¥ {url}: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†è‡ªå®šä¹‰å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        elif custom_image_indexes and len(custom_image_indexes) > 0:
                            # å‘é€é€‰ä¸­çš„å•†å“å›¾ç‰‡
                            try:
                                import aiofiles
                                import os
                                from database import db

                                for image_index in custom_image_indexes:
                                    try:
                                        # è·å–å›¾ç‰‡è·¯å¾„
                                        image_path = db.get_product_image_path(product['id'], image_index)
                                        if image_path and os.path.exists(image_path):
                                            # å‘é€å›¾ç‰‡æ–‡ä»¶
                                            await message.reply(file=discord.File(image_path, f"image_{image_index}.jpg"))
                                            images_sent = True
                                    except Exception as e:
                                        logger.error(f'å‘é€å•†å“å›¾ç‰‡å¤±è´¥: {e}')
                            except Exception as e:
                                logger.error(f'å¤„ç†å•†å“å›¾ç‰‡å›å¤å¤±è´¥: {e}')

                        # å¦‚æœæ—¢æ²¡æœ‰æ–‡æœ¬ä¹Ÿæ²¡æœ‰å›¾ç‰‡ï¼Œåˆ™å‘é€é»˜è®¤é“¾æ¥
                        if not custom_text and not images_sent:
                            response = get_response_url_for_channel(product, message.channel.id)
                            await message.reply(response)

                    logger.info(f'å›¾ç‰‡è¯†åˆ«æˆåŠŸï¼Œç›¸ä¼¼åº¦: {similarity:.4f}')
                else:
                    # ç›¸ä¼¼åº¦ä½äºé˜ˆå€¼ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                    logger.info(f'å›¾ç‰‡è¯†åˆ«ç›¸ä¼¼åº¦ {similarity:.4f} ä½äºç”¨æˆ·é˜ˆå€¼ {user_threshold:.4f}ï¼Œä¸å›å¤')

        except Exception as e:
            logger.error(f'Error handling image: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def handle_keyword_forward(self, message):
        """å¤„ç†å…³é”®è¯æ¶ˆæ¯è½¬å‘"""
        try:
            # æ£€æŸ¥æ¶ˆæ¯å†…å®¹æ˜¯å¦åŒ…å«å…³é”®è¯
            message_content = message.content.lower() if message.content else ""
            has_keyword = any(keyword.strip().lower() in message_content for keyword in config.FORWARD_KEYWORDS)

            if has_keyword and config.FORWARD_TARGET_CHANNEL_ID:
                # è·å–ç›®æ ‡é¢‘é“
                target_channel = self.get_channel(config.FORWARD_TARGET_CHANNEL_ID)
                if target_channel:
                    # æ„å»ºè½¬å‘æ¶ˆæ¯
                    forward_embed = discord.Embed(
                        title="ğŸ“¢ å•†å“ç›¸å…³æ¶ˆæ¯è½¬å‘",
                        description=f"**åŸå§‹æ¶ˆæ¯:** {message.content[:500]}{'...' if len(message.content) > 500 else ''}",
                        color=0x00ff00,
                        timestamp=message.created_at
                    )

                    forward_embed.add_field(
                        name="å‘é€è€…",
                        value=f"{message.author.name}#{message.author.discriminator}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æ¥æºé¢‘é“",
                        value=f"#{message.channel.name}",
                        inline=True
                    )

                    forward_embed.add_field(
                        name="æœåŠ¡å™¨",
                        value=message.guild.name if message.guild else "DM",
                        inline=True
                    )

                    # å¦‚æœæœ‰é™„ä»¶ï¼Œæ·»åŠ åˆ°embedä¸­
                    if message.attachments:
                        attachment_urls = [att.url for att in message.attachments]
                        forward_embed.add_field(
                            name="é™„ä»¶",
                            value="\n".join(attachment_urls),
                            inline=False
                        )

                    forward_embed.set_footer(text=f"æ¶ˆæ¯ID: {message.id}")

                    await target_channel.send(embed=forward_embed)
                    logger.info(f"è½¬å‘äº†åŒ…å«å…³é”®è¯çš„æ¶ˆæ¯: {message.content[:100]}...")
                else:
                    logger.warning(f"æ‰¾ä¸åˆ°ç›®æ ‡é¢‘é“: {config.FORWARD_TARGET_CHANNEL_ID}")

        except Exception as e:
            logger.error(f'Error handling keyword forward: {e}')

    async def handle_keyword_search(self, message):
        """å¤„ç†å…³é”®è¯å•†å“æœç´¢"""
        try:
            # åªå¤„ç†çº¯æ–‡å­—æ¶ˆæ¯ï¼ˆä¸åŒ…å«å›¾ç‰‡çš„ï¼‰
            if not message.content or message.attachments:
                return

            search_query = message.content.strip()
            if not search_query:
                return

            # è°ƒç”¨æœç´¢API
            result = await self.search_products_by_keyword(search_query)

            products = []
            if result and result.get('success') and result.get('products'):
                products = result['products'][:5]  # æœ€å¤šæ˜¾ç¤º5ä¸ªç»“æœ

            # åªåœ¨æ‰¾åˆ°å•†å“æ—¶å›å¤å’Œè®°å½•æ—¥å¿—
            if products:
                logger.info(f'å…³é”®è¯æœç´¢æˆåŠŸ: "{search_query}" -> æ‰¾åˆ° {len(products)} ä¸ªå•†å“')
                # æ ¹æ®é¢‘é“å†³å®šå‘é€å“ªä¸ªé“¾æ¥
                product = products[0]
                response = get_response_url_for_channel(product, message.channel.id)

                logger.info(f'å…³é”®è¯æœç´¢å®Œæˆï¼Œæ‰¾åˆ° {len(products)} ä¸ªå•†å“')

                # æ¨¡æ‹Ÿæ‰“å­—çŠ¶æ€å¹¶å»¶è¿Ÿå›å¤
                async with message.channel.typing():
                    # æ£€æŸ¥æ˜¯å¦è®¾ç½®äº†å…¨å±€å»¶è¿Ÿï¼ˆåªè¦æœ‰ä¸€ä¸ªå€¼ä¸ä¸ºé»˜è®¤å€¼3.0ï¼Œå°±è®¤ä¸ºå·²è®¾ç½®ï¼‰
                    if abs(config.GLOBAL_REPLY_MIN_DELAY - 3.0) > 0.01 or abs(config.GLOBAL_REPLY_MAX_DELAY - 8.0) > 0.01:
                        delay = random.uniform(config.GLOBAL_REPLY_MIN_DELAY, config.GLOBAL_REPLY_MAX_DELAY)
                        logger.info(f"æ¨¡æ‹Ÿæ‰“å­—å¹¶å»¶è¿Ÿå›å¤ {delay:.2f} ç§’...")
                        await asyncio.sleep(delay)
                    else:
                        # å¦‚æœæ²¡æœ‰è®¾ç½®å»¶è¿Ÿï¼Œè‡³å°‘æ¨¡æ‹Ÿ1-3ç§’çš„æ‰“å­—æ—¶é—´
                        delay = random.uniform(1.0, 3.0)
                        logger.info(f"æ¨¡æ‹Ÿæ‰“å­— {delay:.2f} ç§’...")
                        await asyncio.sleep(delay)

                await message.reply(response)
            else:
                # æ²¡æœ‰æ‰¾åˆ°å•†å“ï¼Œä¸å›å¤ä»»ä½•æ¶ˆæ¯
                logger.info(f'å…³é”®è¯æœç´¢æ— ç»“æœ: {search_query}')

        except Exception as e:
            logger.error(f'Error handling keyword search: {e}')
            # ä¸å‘é€é”™è¯¯æ¶ˆæ¯åˆ°Discordï¼Œåªè®°å½•æ—¥å¿—

    async def search_products_by_keyword(self, keyword):
        """æ ¹æ®å…³é”®è¯æœç´¢å•†å“"""
        try:
            # è®¾ç½®è¶…æ—¶æ—¶é—´
            timeout = aiohttp.ClientTimeout(total=10)  # 10ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # æ„å»ºæœç´¢è¯·æ±‚
                search_data = {
                    'query': keyword,
                    'limit': 10  # æœç´¢æ›´å¤šç»“æœï¼Œä½†åªæ˜¾ç¤ºå‰5ä¸ª
                }

                # è°ƒç”¨åç«¯æœç´¢API
                async with session.post('http://localhost:5001/api/search_similar_text',
                                      json=search_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'Keyword search API error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error searching products by keyword: {e}')
            return None

    async def recognize_image(self, image_data, user_shops=None):
        try:
            # è®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´ï¼Œé¿å…é˜»å¡Discordç½‘å…³
            timeout = aiohttp.ClientTimeout(total=15)  # 15ç§’è¶…æ—¶
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # å‡†å¤‡å›¾ç‰‡æ•°æ®
                form_data = aiohttp.FormData()
                form_data.add_field('image', image_data, filename='image.jpg', content_type='image/jpeg')
                # ä½¿ç”¨é…ç½®çš„é˜ˆå€¼
                # ä½¿ç”¨ç”¨æˆ·ä¸ªæ€§åŒ–é˜ˆå€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å…¨å±€é»˜è®¤å€¼
                api_threshold = config.DISCORD_SIMILARITY_THRESHOLD
                if self.user_id:
                    try:
                        try:
                            from database import db
                        except ImportError:
                            from .database import db
                        user_settings = db.get_user_settings(self.user_id)
                        if user_settings and 'discord_similarity_threshold' in user_settings:
                            api_threshold = user_settings['discord_similarity_threshold']
                    except Exception as e:
                        logger.error(f'è·å–ç”¨æˆ·ç›¸ä¼¼åº¦è®¾ç½®å¤±è´¥: {e}')

                form_data.add_field('threshold', str(api_threshold))
                form_data.add_field('limit', '1')  # Discordåªè¿”å›æœ€ç›¸ä¼¼çš„ä¸€ä¸ªç»“æœ

                # å¦‚æœæŒ‡å®šäº†ç”¨æˆ·åº—é“ºæƒé™ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
                if user_shops:
                    form_data.add_field('user_shops', json.dumps(user_shops))

                # è°ƒç”¨ DINOv2 + FAISS æœåŠ¡ï¼ˆæœ¬åœ°ï¼‰
                async with session.post('http://localhost:5001/search_similar', data=form_data) as resp:
                    if resp.status == 200:
                        result = await resp.json()
                        return result
                    else:
                        logger.error(f'PP-ShiTuV2 service error: {resp.status}')
                        return None

        except Exception as e:
            logger.error(f'Error recognizing image: {e}')
            return None

async def get_all_accounts_from_backend():
    """ä»åç«¯ API è·å–æ‰€æœ‰å¯ç”¨çš„ Discord è´¦å·"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get('http://127.0.0.1:5001/api/accounts') as resp:
                if resp.status == 200:
                    result = await resp.json()
                    accounts = result.get('accounts', [])
                    # åªè¿”å›çŠ¶æ€ä¸ºonlineçš„è´¦å·
                    return [account for account in accounts if account.get('status') == 'online']
    except Exception as e:
        logger.error(f'Failed to get accounts from backend: {e}')
    return []

async def bot_loop(client):
    """ä¸»å¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥å¹¶é‡è¿"""
    while True:
        try:
            token = await get_token_from_backend()
            if token:
                if not client.is_ready():
                    logger.info('Starting Discord bot with token from database...')
                    await client.start(token, reconnect=True)
                elif client.current_token != token:
                    logger.info('Token changed, reconnecting...')
                    await client.close()
                    await asyncio.sleep(2)
                    client.current_token = token
                    await client.start(token, reconnect=True)
            else:
                logger.warning('No active token found in database, waiting...')
                if client.is_ready():
                    await client.close()
                client.current_token = None

        except Exception as e:
            logger.error(f'Bot loop error: {e}')
            if client.is_ready():
                await client.close()

        # ç­‰å¾… 30 ç§’åå†æ¬¡æ£€æŸ¥
        await asyncio.sleep(30)

async def start_multi_bot_loop():
    """å¯åŠ¨å¤šè´¦å·æœºå™¨äººå¾ªç¯ï¼Œå®šæœŸæ£€æŸ¥è´¦å·çŠ¶æ€"""
    global bot_clients, bot_tasks

    while True:
        try:
            # è·å–å½“å‰æ‰€æœ‰è´¦å·
            accounts = await get_all_accounts_from_backend()
            current_account_ids = {account['id'] for account in accounts}

            # åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº
            to_remove = []
            for i, client in enumerate(bot_clients):
                if client.account_id not in current_account_ids:
                    logger.info(f'åœæ­¢å·²åˆ é™¤è´¦å·çš„æœºå™¨äºº: {client.account_id}')
                    try:
                        if not client.is_closed():
                            await client.close()
                    except Exception as e:
                        logger.error(f'åœæ­¢æœºå™¨äººæ—¶å‡ºé”™: {e}')

                    # å–æ¶ˆå¯¹åº”çš„ä»»åŠ¡
                    if i < len(bot_tasks) and bot_tasks[i] and not bot_tasks[i].done():
                        bot_tasks[i].cancel()

                    to_remove.append(i)

            # ä»åˆ—è¡¨ä¸­ç§»é™¤å·²åœæ­¢çš„æœºå™¨äºº
            for i in reversed(to_remove):
                bot_clients.pop(i)
                if i < len(bot_tasks):
                    bot_tasks.pop(i)

            # ä¸ºæ–°è´¦å·å¯åŠ¨æœºå™¨äºº
            existing_account_ids = {client.account_id for client in bot_clients}
            for account in accounts:
                account_id = account['id']
                if account_id not in existing_account_ids:
                    token = account['token']
                    username = account.get('username', f'account_{account_id}')

                    logger.info(f'å¯åŠ¨æ–°è´¦å·æœºå™¨äºº: {username}')

                    # åˆ›å»ºæœºå™¨äººå®ä¾‹
                    client = DiscordBotClient(account_id=account_id)

                    # å¯åŠ¨æœºå™¨äºº
                    try:
                        task = asyncio.create_task(client.start(token, reconnect=True))
                        bot_clients.append(client)
                        bot_tasks.append(task)
                        logger.info(f'æœºå™¨äººå¯åŠ¨æˆåŠŸ: {username}')
                    except Exception as e:
                        logger.error(f'å¯åŠ¨æœºå™¨äººå¤±è´¥ {username}: {e}')

            # ç­‰å¾…ä¸€æ®µæ—¶é—´åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(30)

        except Exception as e:
            logger.error(f'å¤šè´¦å·æœºå™¨äººå¾ªç¯é”™è¯¯: {e}')
            await asyncio.sleep(30)

async def main():
    client = DiscordBotClient()

    # å¯åŠ¨ä¸»å¾ªç¯
    await bot_loop(client)

if __name__ == '__main__':
    asyncio.run(main())

--- File: ./backend/feature_extractor.py ---
import os
import torch
import numpy as np
import threading
from typing import List, Optional, Union, Dict
import logging
from pathlib import Path
from PIL import Image
from transformers import AutoImageProcessor, AutoModel
from ultralytics import YOLO
try:
    from .config import config
except ImportError:
    from config import config
from functools import lru_cache
import hashlib

logger = logging.getLogger(__name__)

# === å…³é”®ä¿®æ”¹ï¼šæ›´ä¸¥æ ¼çš„å•ä¾‹æ¨¡å¼ ===
class FeatureExtractorSingleton:
    _instance = None
    _lock = threading.Lock()
    _init_done = False  # æ ‡è®°æ˜¯å¦åˆå§‹åŒ–å®Œæˆ

    @classmethod
    def get_instance(cls):
        # ç¬¬ä¸€é‡æ£€æŸ¥ï¼šå¦‚æœå·²ç»æœ‰å®ä¾‹ï¼Œç›´æ¥è¿”å›ï¼Œä¸åŠ é”ï¼Œé€Ÿåº¦å¿«
        if cls._instance is not None:
            return cls._instance
        # åŠ é”è¿›è¡Œåˆå§‹åŒ–
        with cls._lock:
            # ç¬¬äºŒé‡æ£€æŸ¥ï¼šé˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶é€šè¿‡äº†ç¬¬ä¸€é‡æ£€æŸ¥
            if cls._instance is None:
                logger.info("ğŸš€ [ç³»ç»Ÿ] æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹ (å…¨å±€å•ä¾‹)...")
                try:
                    instance = DINOv2FeatureExtractor()
                    cls._instance = instance
                    cls._init_done = True
                    logger.info("âœ… [ç³»ç»Ÿ] AI æ¨¡å‹åˆå§‹åŒ–å®Œæˆ")
                except Exception as e:
                    logger.error(f"âŒ [ç³»ç»Ÿ] AI æ¨¡å‹åˆå§‹åŒ–å¤±è´¥: {e}")
                    cls._instance = None
        return cls._instance

def get_feature_extractor():
    return FeatureExtractorSingleton.get_instance()

class DINOv2FeatureExtractor:
    """
    "çŒé¹°"æ¶æ„ç‰¹å¾æå–å™¨
    DINOv2 (å¤§è„‘) + YOLO-World (çœ¼ç›)
    ä¸“ä¸ºé‹ç±»è¯†åˆ«ä¼˜åŒ–ï¼Œè‡ªåŠ¨è£å‰ªé‹å­ä¸»ä½“åæå–é«˜ç²¾åº¦ç‰¹å¾
    """

    def __init__(self):
        self.device = torch.device(config.DEVICE)
        logger.info(f"æ­£åœ¨åˆå§‹åŒ–çŒé¹°AIå¼•æ“ï¼Œä½¿ç”¨è®¾å¤‡: {self.device}")

        # åŠ è½½YOLOv8-Nano (çœ¼ç› - ä¸»ä½“æ£€æµ‹)
        self._load_yolo_detector()

        # åŠ è½½DINOv2 (å¤§è„‘ - ç‰¹å¾æå–)
        self._load_dino_model()

        # åˆå§‹åŒ–ç¼“å­˜ç”¨äºæ£€æµ‹ç»“æœ
        self._detection_cache = {}

    def _get_image_hash(self, image_path: str) -> str:
        """è®¡ç®—å›¾ç‰‡æ–‡ä»¶çš„å“ˆå¸Œå€¼ç”¨äºç¼“å­˜"""
        try:
            with open(image_path, 'rb') as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception:
            # å¦‚æœè¯»å–å¤±è´¥ï¼Œä½¿ç”¨æ–‡ä»¶è·¯å¾„+ä¿®æ”¹æ—¶é—´ä½œä¸ºå¤‡ç”¨
            import os
            stat = os.stat(image_path)
            return hashlib.md5(f"{image_path}:{stat.st_mtime}".encode()).hexdigest()

    def _load_yolo_detector(self):
        """å¼ºåˆ¶åŠ è½½YOLO-Worldæ¨¡å‹ç”¨äºå•†å“è¯†åˆ«"""
        try:
            # å‡å°‘æ—¥å¿—çº§åˆ«
            logging.getLogger("ultralytics").setLevel(logging.WARNING)
            self.detector = YOLO(config.YOLO_MODEL_PATH)

            # [æ ¸å¿ƒé…ç½®] å®šä¹‰å…¨è‡ªåŠ¨è¯†åˆ«çš„èŒƒå›´
            # ä¼˜åŒ–åçš„å•†å“ç±»åˆ«ï¼Œè¦†ç›–å¾®åº—/ä»£è´­åœºæ™¯95%çš„å•†å“
            # YOLO-World ä¼šè‡ªåŠ¨å¿½ç•¥äººè„¸ã€æ‰‹ã€å®¶å…·ã€èƒŒæ™¯
            self.target_classes = [
                # é‹ç±» (é«˜ä¼˜å…ˆçº§)
                "shoe", "sneaker", "boot", "sandal", "slipper", "heel",
                # æœè£… (é«˜ä¼˜å…ˆçº§)
                "shirt", "t-shirt", "jacket", "coat", "pants", "jeans",
                "dress", "skirt", "shorts", "hoodie", "sweater", "suit",
                # åŒ…è¢‹é…é¥° (ä¸­ä¼˜å…ˆçº§)
                "bag", "handbag", "backpack", "wallet", "belt", "hat", "cap",
                "watch", "jewelry", "necklace", "ring", "glasses",
                # ç”µå­äº§å“ (ä¸­ä¼˜å…ˆçº§)
                "phone", "laptop", "headphone", "camera", "watch",
                # å®¶å±…ç”¨å“ (ä½ä¼˜å…ˆçº§)
                "toy", "box", "bottle", "cup", "lamp"
            ]

            # å°†è¿™äº›ç±»åˆ«æ³¨å…¥æ¨¡å‹
            self.detector.set_classes(self.target_classes)

            logger.info("ğŸ‰ YOLO-Worldæ¨¡å‹åŠ è½½æˆåŠŸï¼")
            logger.info(f"ğŸ¯ æ”¯æŒè‡ªåŠ¨è¯†åˆ« {len(self.target_classes)} ç§å•†å“ç±»åˆ«")
            logger.info(f"ğŸ“‹ YOLO-Worldç›®æ ‡ç±»åˆ«: {', '.join(self.target_classes[:10])}...")
            logger.info("âš¡ YOLO-Worldä¼˜åŒ–è¯´æ˜: ä½¿ç”¨å¤šç»´åº¦è¯„åˆ†(é¢ç§¯Ã—ç½®ä¿¡åº¦Ã—ä½ç½®Ã—ç±»åˆ«æƒé‡)ï¼Œæ˜¾è‘—æå‡è£å‰ªå‡†ç¡®ç‡")

            # éªŒè¯CLIPåº“æ˜¯å¦æ­£ç¡®å®‰è£…
            try:
                import clip
                logger.info(f"âœ… CLIPåº“ç‰ˆæœ¬éªŒè¯: {getattr(clip, '__version__', 'æœªçŸ¥')}")
                if hasattr(clip, 'load'):
                    logger.info("âœ… CLIP.loadæ–¹æ³•å¯ç”¨")
                else:
                    logger.warning("âš ï¸ CLIP.loadæ–¹æ³•ä¸å¯ç”¨ï¼Œå¯èƒ½å½±å“YOLO-Worldæ€§èƒ½")
            except ImportError as e:
                logger.warning(f"âš ï¸ æ— æ³•å¯¼å…¥CLIPåº“: {e}")

        except Exception as e:
            logger.error(f"ğŸ’¥ YOLO-Worldæ¨¡å‹åŠ è½½å¤±è´¥: {e}")

            # æ£€æŸ¥æ˜¯å¦æ˜¯CLIPç›¸å…³çš„é—®é¢˜ï¼Œå¦‚æœæ˜¯åˆ™å°è¯•å¤‡ç”¨æ–¹æ¡ˆ
            if "clip" in str(e).lower():
                logger.warning("ğŸ” æ£€æµ‹åˆ°CLIPåº“é—®é¢˜ï¼Œå°è¯•å¤‡ç”¨åŠ è½½æ–¹å¼...")

                try:
                    # å°è¯•ä¸ä¾èµ–CLIPçš„åŠ è½½æ–¹å¼
                    import ultralytics
                    logger.info(f"Ultralyticsç‰ˆæœ¬: {ultralytics.__version__}")

                    # ç›´æ¥åˆ›å»ºYOLO-Worldå®ä¾‹ï¼Œä¸è®¾ç½®ç±»åˆ«
                    self.detector = YOLO('yolov8s-world.pt')
                    self.target_classes = None  # ä¸è®¾ç½®è‡ªå®šä¹‰ç±»åˆ«

                    logger.warning("âš ï¸ YOLO-Worldä»¥åŸºç¡€æ¨¡å¼åŠ è½½ (æ— è‡ªå®šä¹‰ç±»åˆ«)")
                    logger.warning("ğŸ“Š å½±å“: å°†ä½¿ç”¨YOLO-Worldçš„å†…ç½®80ç±»è¿›è¡Œæ£€æµ‹")
                    logger.info("âœ… YOLO-WorldåŸºç¡€æ¨¡å¼åŠ è½½æˆåŠŸ")

                except Exception as backup_error:
                    logger.error(f"ğŸ’¥ å¤‡ç”¨åŠ è½½æ–¹å¼ä¹Ÿå¤±è´¥: {backup_error}")
                    logger.error("ğŸ”¥ ç”¨æˆ·è¦æ±‚å¼ºåˆ¶ä½¿ç”¨YOLO-Worldï¼Œä½†æ‰€æœ‰åŠ è½½æ–¹å¼éƒ½å¤±è´¥ï¼")
                    logger.error("ğŸ’¡ æœ€ç»ˆè§£å†³æ–¹æ¡ˆ:")
                    logger.error("   1. pip uninstall clip torch torchvision ultralytics")
                    logger.error("   2. pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu")
                    logger.error("   3. pip install ultralytics")
                    logger.error("   4. pip install git+https://github.com/openai/CLIP.git")
                    raise RuntimeError("YOLO-WorldåŠ è½½å¤±è´¥ï¼Œæ‰€æœ‰å¤‡ç”¨æ–¹æ¡ˆå‡æ— æ•ˆ") from e
            else:
                # ä¸æ˜¯CLIPé—®é¢˜ï¼Œç›´æ¥æŠ¥é”™
                logger.error("ğŸ”¥ YOLO-WorldåŠ è½½å¤±è´¥ï¼Œé”™è¯¯ä¸ç›¸å…³CLIPåº“")
                logger.error("ğŸ’¡ å»ºè®®æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œultralyticsç‰ˆæœ¬")
                raise RuntimeError("YOLO-WorldåŠ è½½å¤±è´¥") from e

    def _load_dino_model(self):
        """åŠ è½½DINOv2æ¨¡å‹ç”¨äºç‰¹å¾æå–"""
        try:
            model_name = config.DINO_MODEL_NAME
            logger.info(f"åŠ è½½DINOv2ç‰¹å¾æ¨¡å‹: {model_name}...")

            self.processor = AutoImageProcessor.from_pretrained(model_name)
            self.model = AutoModel.from_pretrained(model_name)

            # å®‰å…¨åœ°å°†æ¨¡å‹ç§»åŠ¨åˆ°è®¾å¤‡ï¼Œé¿å…meta tensoré”™è¯¯
            try:
                if hasattr(self.model, 'to'):
                    self.model = self.model.to(self.device)
                else:
                    logger.warning("æ¨¡å‹æ²¡æœ‰to()æ–¹æ³•ï¼Œä½¿ç”¨åŸæ¨¡å‹")
            except Exception as device_error:
                logger.warning(f"æ¨¡å‹ç§»åŠ¨åˆ°è®¾å¤‡å¤±è´¥: {device_error}ï¼Œå°è¯•å…¶ä»–æ–¹æ³•...")
                try:
                    # å°è¯•ä½¿ç”¨to_emptyæ–¹æ³•
                    if hasattr(self.model, 'to_empty'):
                        self.model = self.model.to_empty(device=self.device)
                    else:
                        logger.error("æ¨¡å‹ä¸æ”¯æŒto_emptyæ–¹æ³•ï¼Œä½¿ç”¨CPU")
                        self.device = torch.device('cpu')
                        self.model = self.model.to(self.device)
                except Exception as fallback_error:
                    logger.error(f"æ‰€æœ‰è®¾å¤‡ç§»åŠ¨æ–¹æ³•éƒ½å¤±è´¥: {fallback_error}")
                    raise

            self.model.eval()
            logger.info("âœ… DINOv2æ¨¡å‹åŠ è½½æˆåŠŸ")
        except Exception as e:
            logger.error(f"âŒ DINOv2æ¨¡å‹åŠ è½½å¤±è´¥: {e}")
            raise RuntimeError("DINOv2æ¨¡å‹åŠ è½½å¤±è´¥") from e

    def _crop_main_object(self, image_path: str) -> Image.Image:
        """å…¨è‡ªåŠ¨è£å‰ªå•†å“ä¸»ä½“

        å…¨è‡ªåŠ¨è£å‰ªé€»è¾‘ï¼š
        1. åœ¨é¢„è®¾çš„å•†å“ç±»åˆ«ä¸­æ£€æµ‹æ‰€æœ‰ç‰©ä½“
        2. è‡ªåŠ¨è¿‡æ»¤æ‰èƒŒæ™¯ã€äººã€æ‰‹
        3. åœ¨å‰©ä¸‹çš„å•†å“ä¸­ï¼Œé€‰å‡ºæœ€æ˜¾è‘—çš„ä¸€ä¸ªï¼ˆæœ€å¤§+æœ€ä¸­å¿ƒï¼‰
        """
        try:
            if not config.USE_YOLO_CROP:
                return Image.open(image_path).convert("RGB")

            # æ£€æŸ¥ç¼“å­˜
            image_hash = self._get_image_hash(image_path)
            if image_hash in self._detection_cache:
                logger.debug("ä½¿ç”¨ç¼“å­˜çš„æ£€æµ‹ç»“æœ")
                cached_result = self._detection_cache[image_hash]
                if cached_result is None:
                    # ç¼“å­˜ä¸­è¡¨ç¤ºæœªæ£€æµ‹åˆ°å•†å“
                    return Image.open(image_path).convert("RGB")
                # è¿”å›ç¼“å­˜çš„è£å‰ªç»“æœ
                return cached_result

            # conf=0.1: é™ä½é—¨æ§›ï¼Œå®å¯å¤šæ£€ä¸è¦æ¼æ£€ï¼Œåæ­£æˆ‘ä»¬æœ‰é€»è¾‘è¿‡æ»¤
            results = self.detector(image_path, conf=0.1, verbose=False)

            if not results or len(results[0].boxes) == 0:
                logger.info("æœªæ£€æµ‹åˆ°é€šç”¨å•†å“ï¼Œé™çº§ä½¿ç”¨åŸå›¾")
                # ç¼“å­˜æœªæ£€æµ‹åˆ°å•†å“çš„ç»“æœ
                self._detection_cache[image_hash] = None
                return Image.open(image_path).convert("RGB")

            boxes = results[0].boxes
            img = Image.open(image_path).convert("RGB")
            img_w, img_h = img.size
            center_x, center_y = img_w / 2, img_h / 2

            # --- æ™ºèƒ½è¯„åˆ†é€»è¾‘ ---
            # åœ¨æ‰€æœ‰æ£€æµ‹åˆ°çš„"å•†å“"ä¸­ï¼Œé€‰å‡ºä¸»è§’

            best_box = None
            max_score = -1

            for box in boxes:
                # 1. è·å–åæ ‡
                coords = box.xyxy[0].cpu().numpy()  # [x1, y1, x2, y2]
                x1, y1, x2, y2 = coords

                # 2. è®¡ç®—é¢ç§¯
                width = x2 - x1
                height = y2 - y1
                area = width * height

                # 3. è®¡ç®—ç¦»å›¾ç‰‡ä¸­å¿ƒçš„è·ç¦»
                box_center_x = x1 + width / 2
                box_center_y = y1 + height / 2
                dist_to_center = ((box_center_x - center_x)**2 + (box_center_y - center_y)**2) ** 0.5

                # 4. ç»¼åˆè¯„åˆ†å…¬å¼ï¼š
                # é¢ç§¯è¶Šå¤§è¶Šå¥½ (æƒé‡ 0.7)
                # è¶Šé ä¸­å¿ƒè¶Šå¥½ (æƒé‡ 0.3)
                # è¿™ä¸ªå…¬å¼èƒ½ä¿è¯ï¼šå³ä½¿è§’è½é‡Œæœ‰ä¸ªå¤§åŒ…ï¼Œä¹Ÿä¼šä¼˜å…ˆé€‰ä¸­é—´çš„å°é‹å­
                norm_area = area / (img_w * img_h)
                norm_dist = 1 - (dist_to_center / ((img_w**2 + img_h**2)**0.5))

                score = (norm_area * 0.7) + (norm_dist * 0.3) + (float(box.conf) * 0.1)

                if score > max_score:
                    max_score = score
                    best_box = coords

            if best_box is None:
                logger.info("æœªæ‰¾åˆ°åˆé€‚çš„å•†å“æ¡†ï¼Œä½¿ç”¨åŸå›¾")
                # ç¼“å­˜å¤±è´¥ç»“æœ
                self._detection_cache[image_hash] = None
                return img

            # æ‰§è¡Œè£å‰ª
            x1, y1, x2, y2 = best_box

            # æ‰©å…… 5% - 10% çš„è¾¹ç¼˜ï¼Œä¿ç•™ä¸€ç‚¹ç‚¹ä¸Šä¸‹æ–‡
            pad_x = (x2 - x1) * 0.05
            pad_y = (y2 - y1) * 0.05

            crop_box = (
                max(0, x1 - pad_x),
                max(0, y1 - pad_y),
                min(img_w, x2 + pad_x),
                min(img_h, y2 + pad_y)
            )

            cropped_img = img.crop(crop_box)
            logger.info(f"æˆåŠŸè£å‰ªå•†å“åŒºåŸŸ: {crop_box}")

            # ç¼“å­˜æˆåŠŸç»“æœ
            self._detection_cache[image_hash] = cropped_img.copy()

            return cropped_img

        except Exception as e:
            logger.warning(f"è‡ªåŠ¨è£å‰ªå‡ºé”™: {e}, ä½¿ç”¨åŸå›¾")
            # ç¼“å­˜å¤±è´¥ç»“æœ
            try:
                image_hash = self._get_image_hash(image_path)
                self._detection_cache[image_hash] = None
            except:
                pass
            return Image.open(image_path).convert("RGB")
        """ä½¿ç”¨YOLO-Worldç²¾å‡†è£å‰ªé‹ç±»ä¸»ä½“"""
        try:
            if not config.USE_YOLO_CROP:
                return Image.open(image_path).convert("RGB")

            # æ£€æŸ¥ç¼“å­˜
            image_hash = self._get_image_hash(image_path)
            if image_hash in self._detection_cache:
                logger.debug("ä½¿ç”¨ç¼“å­˜çš„æ£€æµ‹ç»“æœ")
                cached_result = self._detection_cache[image_hash]
                if cached_result is None:
                    # ç¼“å­˜ä¸­è¡¨ç¤ºæœªæ£€æµ‹åˆ°é‹å­
                    return Image.open(image_path).convert("RGB")
                # è¿”å›ç¼“å­˜çš„è£å‰ªç»“æœ
                return cached_result

            # ä¼˜åŒ–æ£€æµ‹å‚æ•°ï¼Œæé«˜å‡†ç¡®ç‡
            # ä½¿ç”¨æ›´ä½çš„ç½®ä¿¡åº¦ä½†æ›´é«˜çš„è´¨é‡é˜ˆå€¼
            results = self.detector(image_path, conf=0.05, iou=0.5, verbose=False)

            if not results or len(results[0].boxes) == 0:
                logger.info("æœªæ£€æµ‹åˆ°é€šç”¨å•†å“ï¼Œé™çº§ä½¿ç”¨åŸå›¾")
                # ç¼“å­˜æœªæ£€æµ‹åˆ°å•†å“çš„ç»“æœ
                self._detection_cache[image_hash] = None
                return Image.open(image_path).convert("RGB")

            boxes = results[0].boxes
            img = Image.open(image_path).convert("RGB")
            img_w, img_h = img.size
            center_x, center_y = img_w / 2, img_h / 2

            # --- ä¼˜åŒ–å€™é€‰é€»è¾‘ (YOLO-Worldå¢å¼ºç‰ˆ) ---
            # å¤šç»´åº¦è¯„åˆ†ï¼šé¢ç§¯ã€ç½®ä¿¡åº¦ã€ä½ç½®ã€é•¿å®½æ¯”

            candidates = []
            for box in boxes:
                coords = box.xyxy[0].cpu().numpy()
                conf = float(box.conf)
                cls = int(box.cls)

                w = coords[2] - coords[0]
                h = coords[3] - coords[1]
                area = w * h

                # è¿‡æ»¤å¤ªå°æˆ–å¤ªå¤§bbox
                if area < img_w * img_h * 0.01:  # è‡³å°‘å å›¾ç‰‡é¢ç§¯1%
                    continue
                if area > img_w * img_h * 0.9:   # æœ€å¤šå å›¾ç‰‡é¢ç§¯90%
                    continue

                # è®¡ç®—é•¿å®½æ¯” (è¿‡æ»¤æç«¯æ¯”ä¾‹)
                aspect_ratio = max(w/h, h/w)
                if aspect_ratio > 5:  # å¤ªç»†é•¿
                    continue

                # è®¡ç®—ä¸­å¿ƒè·ç¦»æƒé‡ (è¶Šé è¿‘ä¸­å¿ƒè¶Šå¥½)
                box_cx = coords[0] + w/2
                box_cy = coords[1] + h/2
                dist_from_center = ((box_cx - center_x)**2 + (box_cy - center_y)**2) ** 0.5
                max_dist = ((img_w/2)**2 + (img_h/2)**2) ** 0.5
                center_weight = 1 - (dist_from_center / max_dist)

                # è®¡ç®—ç±»åˆ«æƒé‡ (é‹ç±»å’Œæœè£…æ›´é«˜æƒé‡)
                class_name = self.target_classes[cls] if cls < len(self.target_classes) else "unknown"
                class_weight = 1.5 if any(keyword in class_name.lower() for keyword in ['shoe', 'shirt', 'pants', 'dress']) else 1.0

                # ç»¼åˆè¯„åˆ†
                score = area * conf * center_weight * class_weight

                candidates.append({
                    'coords': coords,
                    'score': score,
                    'conf': conf,
                    'area': area,
                    'class': class_name
                })

            # é€‰æ‹©æœ€ä½³å€™é€‰
            if not candidates:
                logger.info("æœªæ‰¾åˆ°åˆé€‚çš„å•†å“æ¡†ï¼Œä½¿ç”¨åŸå›¾")
                return img

            best_candidate = max(candidates, key=lambda x: x['score'])
            best_box = best_candidate['coords']

            logger.info(f"é€‰æ‹©æœ€ä½³æ£€æµ‹æ¡†: {best_candidate['class']}, ç½®ä¿¡åº¦: {best_candidate['conf']:.3f}, å¾—åˆ†: {best_candidate['score']:.1f}")

            if best_box is None:
                logger.info("æœªæ‰¾åˆ°åˆé€‚çš„é‹å­æ¡†ï¼Œä½¿ç”¨åŸå›¾")
                return img

            # è£å‰ªé€‰ä¸­çš„é‹å­
            x1, y1, x2, y2 = best_box

            # æ‰©å……5%çš„è¾¹ç¼˜ï¼Œé˜²æ­¢åˆ‡æ‰è¾¹ç¼˜ç‰¹å¾
            pad_x = (x2 - x1) * 0.05
            pad_y = (y2 - y1) * 0.05

            crop_box = (
                max(0, x1 - pad_x),
                max(0, y1 - pad_y),
                min(img_w, x2 + pad_x),
                min(img_h, y2 + pad_y)
            )

            cropped_img = img.crop(crop_box)
            logger.info(f"æˆåŠŸè£å‰ªé‹å­åŒºåŸŸ: {crop_box}")

            # ç¼“å­˜ç»“æœ
            self._detection_cache[image_hash] = cropped_img.copy()

            return cropped_img

        except Exception as e:
            logger.warning(f"é‹å­è£å‰ªå¼‚å¸¸: {e}")
            # ç¼“å­˜å¤±è´¥ç»“æœ
            self._detection_cache[image_hash] = None
            return Image.open(image_path).convert("RGB")

    def extract_feature(self, image_path: Union[str, Path]) -> Optional[np.ndarray]:
        """æå–å•å¼ å›¾ç‰‡çš„ç‰¹å¾å‘é‡ (384ç»´æˆ–768ç»´)"""
        try:
            image_path = str(image_path)

            if not os.path.exists(image_path):
                logger.error(f"æ–‡ä»¶ä¸å­˜åœ¨: {image_path}")
                return None

            # 1. YOLOè£å‰ªä¸»ä½“
            img = self._crop_main_object(image_path)

            # 2. é¢„å¤„ç†ï¼ˆDINOv2ä¼šè‡ªåŠ¨å¤„ç†ï¼‰
            inputs = self.processor(images=img, return_tensors="pt").to(self.device)

            # 3. ç‰¹å¾æå–
            with torch.no_grad():
                outputs = self.model(**inputs)

            # 4. è·å–CLS tokenç‰¹å¾ (DINOv2çš„æœ€ä½³å®è·µ)
            # outputs.last_hidden_state.shape: [1, num_patches+1, dim]
            # ç¬¬0ä¸ªæ˜¯CLS tokenï¼Œä»£è¡¨æ•´å¼ å›¾çš„è¯­ä¹‰
            embedding = outputs.last_hidden_state[0, 0, :].cpu().numpy()

            # 5. L2å½’ä¸€åŒ– (å¯¹ä½™å¼¦ç›¸ä¼¼åº¦è‡³å…³é‡è¦)
            norm = np.linalg.norm(embedding)
            if norm > 0:
                embedding = embedding / norm

            # 6. ç¡®ä¿æ•°æ®ç±»å‹ä¸ºfloat32 (FAISSè¦æ±‚)
            return embedding.astype('float32')

        except Exception as e:
            logger.error(f"DINOv2ç‰¹å¾æå–å¤±è´¥ {image_path}: {e}")
            import traceback
            traceback.print_exc()
            return None

    def extract_features_batch(self, image_paths: List[Union[str, Path]]) -> List[Optional[np.ndarray]]:
        """æ‰¹é‡æå–ç‰¹å¾å‘é‡"""
        results = []
        for image_path in image_paths:
            feature = self.extract_feature(image_path)
            results.append(feature)
        return results

    def get_status(self) -> Dict:
        """è·å–AIæ¨¡å‹çŠ¶æ€å’Œæ€§èƒ½ä¿¡æ¯"""
        status = {
            'device': str(self.device),
            'yolo_available': self.detector is not None,
            'yolo_type': 'None'
        }

        if self.detector is not None:
            if self.target_classes and len(self.target_classes) > 20:
                status['yolo_type'] = 'YOLO-World'
                status['target_classes_count'] = len(self.target_classes)
                status['target_classes'] = self.target_classes[:10]  # åªæ˜¾ç¤ºå‰10ä¸ª
            else:
                status['yolo_type'] = 'YOLOv8-Nano'
                status['target_classes_count'] = len(self.target_classes) if self.target_classes else 0

        status['detection_cache_size'] = len(self._detection_cache)
        status['confidence_threshold'] = 0.05
        status['iou_threshold'] = 0.5

        # æ€§èƒ½æç¤º
        tips = []
        if self.detector is None:
            tips.append("YOLOè£å‰ªå·²ç¦ç”¨ï¼Œå»ºè®®ä¿®å¤YOLOåŠ è½½é—®é¢˜ä»¥æå‡å‡†ç¡®æ€§")
        elif status['yolo_type'] == 'YOLOv8-Nano':
            tips.append("å½“å‰ä½¿ç”¨YOLOv8-Nanoï¼Œå»ºè®®å‡çº§ä¾èµ–ä»¥å¯ç”¨YOLO-Worldè·å¾—æ›´å¥½æ•ˆæœ")

        if status['detection_cache_size'] > 1000:
            tips.append("æ£€æµ‹ç¼“å­˜è¾ƒå¤§ï¼Œè€ƒè™‘å®šæœŸæ¸…ç†ç¼“å­˜")

        status['performance_tips'] = tips if tips else ["AIæ¨¡å‹è¿è¡Œæ­£å¸¸"]

        return status

# å‘åå…¼å®¹çš„åˆ«å
class FeatureExtractor(DINOv2FeatureExtractor):
    """å‘åå…¼å®¹çš„åˆ«å"""
    pass

# å•ä¾‹æ¨¡å¼è·å–å®ä¾‹
_feature_extractor = None

def get_feature_extractor() -> DINOv2FeatureExtractor:
    global _feature_extractor
    if _feature_extractor is None:
        _feature_extractor = DINOv2FeatureExtractor()
    return _feature_extractor

--- File: ./backend/vector_engine.py ---
import faiss
import numpy as np
import os
import pickle
import logging
from typing import List, Dict, Tuple
try:
    from .config import config
except ImportError:
    from config import config

logger = logging.getLogger(__name__)

class VectorEngine:
    """
    FAISS HNSWå‘é‡æœç´¢å¼•æ“
    çº¯æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨ï¼Œæ— éœ€Docker
    æ”¯æŒç™¾ä¸‡çº§å‘é‡æ¯«ç§’çº§æŸ¥è¯¢
    """

    def __init__(self, index_file=None, id_map_file=None):
        self.index_file = index_file or config.FAISS_INDEX_FILE
        self.id_map_file = id_map_file or config.FAISS_ID_MAP_FILE

        self.dimension = config.VECTOR_DIMENSION
        self.index = None

        # FAISSåªèƒ½å­˜æ•´æ•°IDï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ˜ å°„ï¼šFAISSå†…éƒ¨ID -> æ•°æ®åº“(product_imagesè¡¨çš„ID)
        # è¿™ä¸ªåˆ—è¡¨çš„ç´¢å¼•æ˜¯FAISS IDï¼Œå€¼æ˜¯æ•°æ®åº“ID
        self.id_map = []

        self._load_or_create_index()

    def _load_or_create_index(self):
        """åŠ è½½æˆ–åˆ›å»ºFAISS HNSWç´¢å¼•"""
        if os.path.exists(self.index_file) and os.path.exists(self.id_map_file):
            logger.info("æ­£åœ¨åŠ è½½FAISSç´¢å¼•...")
            try:
                self.index = faiss.read_index(self.index_file)
                with open(self.id_map_file, 'rb') as f:
                    self.id_map = pickle.load(f)
                logger.info(f"âœ… FAISSç´¢å¼•åŠ è½½å®Œæˆï¼Œå½“å‰åŒ…å« {self.index.ntotal} ä¸ªå‘é‡")
            except Exception as e:
                logger.error(f"åŠ è½½ç´¢å¼•å¤±è´¥ï¼Œå°†åˆ›å»ºæ–°ç´¢å¼•: {e}")
                self._create_new_index()
        else:
            logger.info("åˆ›å»ºæ–°çš„FAISS HNSWç´¢å¼•...")
            self._create_new_index()

    def _create_new_index(self):
        """åˆ›å»ºæ–°çš„FAISS HNSWç´¢å¼•ï¼Œä¼˜åŒ–å‚æ•°è®¾ç½®"""
        logger.info("åˆ›å»ºæ–°çš„FAISS HNSWç´¢å¼•...")

        # HNSW64: å›¾ç»“æ„ï¼ŒæŸ¥è¯¢æå¿«ï¼Œå‡†ç¡®ç‡é«˜
        # InnerProduct (IP) åœ¨å½’ä¸€åŒ–å‘é‡ä¸Šç­‰åŒäºä½™å¼¦ç›¸ä¼¼åº¦
        self.index = faiss.IndexHNSWFlat(
            self.dimension,
            config.FAISS_HNSW_M,
            faiss.METRIC_INNER_PRODUCT
        )

        # è®¾ç½®æ„å»ºå‚æ•° (å…¼å®¹ä¸åŒç‰ˆæœ¬çš„FAISS)
        ef_construction_set = False
        ef_search_set = False

        try:
            # å°è¯•è®¾ç½®HNSWå‚æ•° (æ–°ç‰ˆæœ¬FAISS >= 1.7.0)
            if hasattr(self.index, 'efConstruction'):
                self.index.efConstruction = config.FAISS_EF_CONSTRUCTION  # æ„å»ºæ—¶çš„æ·±åº¦ï¼Œè¶Šé«˜è¶Šå‡†ä½†æ„å»ºè¶Šæ…¢
                ef_construction_set = True
                logger.info(f"è®¾ç½®efConstruction = {config.FAISS_EF_CONSTRUCTION}")

            if hasattr(self.index, 'efSearch'):
                self.index.efSearch = config.FAISS_EF_SEARCH  # æœç´¢æ—¶çš„æ·±åº¦ï¼Œè¶Šé«˜è¶Šå‡†ä½†æœç´¢è¶Šæ…¢
                ef_search_set = True
                logger.info(f"è®¾ç½®efSearch = {config.FAISS_EF_SEARCH}")

        except AttributeError:
            logger.warning("FAISSç‰ˆæœ¬ä¸æ”¯æŒefConstruction/efSearchå‚æ•°ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼")

        # å¦‚æœæ— æ³•è®¾ç½®å‚æ•°ï¼Œæä¾›æ€§èƒ½ä¼˜åŒ–å»ºè®®
        if not ef_construction_set or not ef_search_set:
            logger.info("ğŸ’¡ FAISSæ€§èƒ½ä¼˜åŒ–å»ºè®®:")
            logger.info(f"   - å½“å‰FAISSç‰ˆæœ¬: {faiss.__version__}")
            logger.info("   - å»ºè®®å‡çº§åˆ°FAISS >= 1.7.0ä»¥è·å¾—æœ€ä½³æ€§èƒ½")
            logger.info("   - æˆ–è€…ä½¿ç”¨: pip install faiss-cpu --upgrade")

        # è®¾ç½®å…¶ä»–å…¼å®¹æ€§å‚æ•°
        try:
            # è®¾ç½®HNSWçš„Må‚æ•° (å¦‚æœæ”¯æŒ)
            if hasattr(self.index, 'hnsw'):
                logger.info(f"HNSW Må‚æ•° = {config.FAISS_HNSW_M}")
        except:
            pass

        self.id_map = []

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.index_file), exist_ok=True)

        logger.info("âœ… FAISS HNSWç´¢å¼•åˆ›å»ºå®Œæˆ")

    def save(self):
        """ä¿å­˜ç´¢å¼•åˆ°ç£ç›˜ (ç™¾ä¸‡çº§æ•°æ®ä¿å­˜å¤§çº¦éœ€è¦å‡ ç§’)"""
        try:
            faiss.write_index(self.index, self.index_file)
            with open(self.id_map_file, 'wb') as f:
                pickle.dump(self.id_map, f)
            logger.info("FAISSç´¢å¼•å·²ä¿å­˜åˆ°ç£ç›˜")
        except Exception as e:
            logger.error(f"ä¿å­˜ç´¢å¼•å¤±è´¥: {e}")

    def add_vector(self, db_id: int, vector: np.ndarray) -> bool:
        """æ·»åŠ å‘é‡åˆ°FAISSç´¢å¼•"""
        try:
            # ç¡®ä¿å‘é‡æ˜¯æ­£ç¡®çš„å½¢çŠ¶å’Œç±»å‹
            if isinstance(vector, list):
                vector = np.array(vector, dtype='float32')
            elif vector.dtype != np.float32:
                vector = vector.astype('float32')

            vector = vector.reshape(1, -1)  # ç¡®ä¿æ˜¯[1, dim]å½¢çŠ¶

            # æ·»åŠ åˆ°FAISS
            self.index.add(vector)

            # è®°å½•IDæ˜ å°„ï¼šFAISSå†…éƒ¨ID -> æ•°æ®åº“ID
            faiss_id = self.index.ntotal - 1  # æ–°æ·»åŠ çš„å‘é‡ID
            if len(self.id_map) <= faiss_id:
                self.id_map.extend([None] * (faiss_id - len(self.id_map) + 1))
            self.id_map[faiss_id] = db_id

            return True

        except Exception as e:
            logger.error(f"æ·»åŠ å‘é‡å¤±è´¥: {e}")
            return False

    def search(self, query_vector: np.ndarray, top_k: int = 1) -> List[Dict]:
        """æœç´¢æœ€ç›¸ä¼¼çš„å‘é‡"""
        if self.index.ntotal == 0:
            return []

        try:
            # ç¡®ä¿æŸ¥è¯¢å‘é‡æ ¼å¼æ­£ç¡®
            if isinstance(query_vector, list):
                query_vector = np.array(query_vector, dtype='float32')
            elif query_vector.dtype != np.float32:
                query_vector = query_vector.astype('float32')

            query_vector = query_vector.reshape(1, -1)

            # æ‰§è¡Œæœç´¢
            # distances: ç›¸ä¼¼åº¦åˆ†æ•° (å› ä¸ºæ˜¯å†…ç§¯ä¸”å½’ä¸€åŒ–äº†ï¼ŒèŒƒå›´-1åˆ°1)
            # indices: FAISSå†…éƒ¨çš„ID
            distances, indices = self.index.search(query_vector, top_k)

            results = []
            for i in range(min(top_k, len(indices[0]))):
                faiss_id = indices[0][i]
                score = distances[0][i]

                if faiss_id != -1 and faiss_id < len(self.id_map) and self.id_map[faiss_id] is not None:
                    db_id = self.id_map[faiss_id]
                    results.append({
                        'db_id': db_id,  # æ•°æ®åº“ä¸­çš„ID
                        'score': float(score)  # ç›¸ä¼¼åº¦åˆ†æ•°
                    })

            return results

        except Exception as e:
            logger.error(f"æœç´¢å¤±è´¥: {e}")
            return []

    def remove_vector_by_db_id(self, db_id: int) -> bool:
        """
        ä»FAISSç´¢å¼•ä¸­åˆ é™¤å‘é‡ã€‚ç”±äºFAISSä¸æ”¯æŒç›´æ¥åˆ é™¤å•ä¸ªå‘é‡ï¼Œ
        æˆ‘ä»¬æ ‡è®°åˆ é™¤å¹¶å®šæœŸé‡å»ºç´¢å¼•ï¼ˆæ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬ï¼‰ã€‚
        """
        try:
            # æ ‡è®°è¦åˆ é™¤çš„å‘é‡
            vector_removed = False
            for i, mapped_id in enumerate(self.id_map):
                if mapped_id == db_id:
                    self.id_map[i] = None
                    vector_removed = True
                    logger.info(f"æ ‡è®°å‘é‡åˆ é™¤: db_id={db_id}, faiss_id={i}")
                    break

            # æ€§èƒ½ä¼˜åŒ–ï¼šä¸ç«‹å³é‡å»ºç´¢å¼•ï¼Œåªä¿å­˜çŠ¶æ€
            # åªæœ‰å½“åˆ é™¤çš„å‘é‡æ¯”ä¾‹è¶…è¿‡é˜ˆå€¼æ—¶æ‰é‡å»º
            if vector_removed:
                deleted_count = sum(1 for id_val in self.id_map if id_val is None)
                total_count = len(self.id_map)
                deletion_ratio = deleted_count / total_count if total_count > 0 else 0

                # å¦‚æœåˆ é™¤æ¯”ä¾‹è¶…è¿‡30%ï¼Œåˆ™é‡å»ºç´¢å¼•æ¸…ç†ç¢ç‰‡
                if deletion_ratio > 0.3:
                    logger.info(f"åˆ é™¤æ¯”ä¾‹({deletion_ratio:.1%})è¿‡é«˜ï¼Œé‡å»ºç´¢å¼•æ¸…ç†ç¢ç‰‡")
                    self._rebuild_index_after_removal()
                else:
                    # åªä¿å­˜ç´¢å¼•çŠ¶æ€ï¼Œä¸é‡å»º
                    self.save()

            return True
        except Exception as e:
            logger.error(f"åˆ é™¤å‘é‡å¤±è´¥: {e}")
            return False

    def _rebuild_index_after_removal(self):
        """åˆ é™¤å‘é‡åé‡å»ºç´¢å¼•"""
        try:
            # è·å–æ‰€æœ‰æœªåˆ é™¤çš„å‘é‡æ•°æ®
            try:
                from database import db
            except ImportError:
                from .database import db
            valid_vectors = []

            with db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT id, image_path FROM product_images WHERE id IS NOT NULL")
                for row in cursor.fetchall():
                    img_id = row['id']
                    # æ£€æŸ¥è¿™ä¸ªå‘é‡æ˜¯å¦åœ¨æˆ‘ä»¬çš„id_mapä¸­ä¸”æœªè¢«æ ‡è®°åˆ é™¤
                    if img_id in self.id_map and self.id_map[self.id_map.index(img_id)] is not None:
                        # é‡æ–°æå–ç‰¹å¾ï¼ˆæˆ–è€…ä»ç¼“å­˜ä¸­è·å–ï¼‰
                        # è¿™é‡Œä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬å‡è®¾ç‰¹å¾éœ€è¦é‡æ–°æå–
                        # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”è¯¥ç¼“å­˜ç‰¹å¾æˆ–å®šæœŸé‡å»º
                        try:
                            # è¿™é‡Œéœ€è¦å¯¼å…¥ç‰¹å¾æå–å™¨
                            try:
                                from feature_extractor import get_feature_extractor
                            except ImportError:
                                from .feature_extractor import get_feature_extractor
                            extractor = get_feature_extractor()
                            features = extractor.extract_feature(row['image_path'])
                            if features is not None:
                                valid_vectors.append((img_id, features))
                        except Exception as e:
                            logger.warning(f"é‡æ–°æå–ç‰¹å¾å¤±è´¥ {row['image_path']}: {e}")

            # é‡å»ºç´¢å¼•
            self._create_new_index()
            for img_id, features in valid_vectors:
                self.add_vector(img_id, features)

            self.save()
            logger.info(f"ç´¢å¼•é‡å»ºå®Œæˆï¼ŒåŒ…å« {len(valid_vectors)} ä¸ªå‘é‡")

        except Exception as e:
            logger.error(f"é‡å»ºç´¢å¼•å¤±è´¥: {e}")

    def rebuild_index(self, vectors_data: List[Tuple[int, np.ndarray]]) -> bool:
        """
        é‡å»ºæ•´ä¸ªç´¢å¼• (ç”¨äºæ¸…ç†å·²åˆ é™¤çš„å‘é‡æˆ–æ‰¹é‡æ›´æ–°)

        vectors_data: [(db_id, vector), ...]
        """
        try:
            logger.info("å¼€å§‹é‡å»ºFAISSç´¢å¼•...")

            # åˆ é™¤æ—§çš„ç´¢å¼•æ–‡ä»¶
            try:
                if os.path.exists(self.index_file):
                    os.remove(self.index_file)
                if os.path.exists(self.id_map_file):
                    os.remove(self.id_map_file)
            except Exception as e:
                logger.warning(f"åˆ é™¤æ—§ç´¢å¼•æ–‡ä»¶å¤±è´¥: {e}")

            # åˆ›å»ºæ–°ç´¢å¼•
            self._create_new_index()

            # é‡æ–°æ·»åŠ æ‰€æœ‰å‘é‡
            for db_id, vector in vectors_data:
                self.add_vector(db_id, vector)

            # ç«‹å³ä¿å­˜æ–°ç´¢å¼•
            self.save()

            logger.info(f"ç´¢å¼•é‡å»ºå®Œæˆï¼ŒåŒ…å« {self.index.ntotal} ä¸ªå‘é‡")
            return True

        except Exception as e:
            logger.error(f"é‡å»ºç´¢å¼•å¤±è´¥: {e}")
            # å°è¯•é‡æ–°åŠ è½½æ—§ç´¢å¼•
            try:
                self._load_or_create_index()
            except:
                pass
            return False

    def count(self) -> int:
        """è¿”å›å½“å‰ç´¢å¼•ä¸­çš„å‘é‡æ•°é‡"""
        return self.index.ntotal

    def get_stats(self) -> Dict:
        """è·å–ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯"""
        ef_construction = getattr(self.index, 'efConstruction', 'ä¸æ”¯æŒ')
        ef_search = getattr(self.index, 'efSearch', 'ä¸æ”¯æŒ')

        return {
            'total_vectors': self.index.ntotal,
            'dimension': self.dimension,
            'index_type': 'HNSW',
            'metric_type': 'InnerProduct (Cosine)',
            'ef_construction': ef_construction,
            'ef_search': ef_search,
            'memory_usage_mb': self._estimate_memory_usage(),
            'faiss_version': faiss.__version__,
            'performance_tips': self._get_performance_tips()
        }

    def _get_performance_tips(self) -> List[str]:
        """è·å–æ€§èƒ½ä¼˜åŒ–å»ºè®®"""
        tips = []

        # æ£€æŸ¥FAISSç‰ˆæœ¬
        try:
            version_parts = faiss.__version__.split('.')
            major = int(version_parts[0])
            minor = int(version_parts[1])

            if major < 1 or (major == 1 and minor < 7):
                tips.append("å»ºè®®å‡çº§FAISSåˆ°1.7.0+ç‰ˆæœ¬ä»¥è·å¾—efConstruction/efSearchå‚æ•°æ”¯æŒ")
        except:
            tips.append("æ— æ³•æ£€æµ‹FAISSç‰ˆæœ¬ï¼Œå»ºè®®å‡çº§åˆ°æœ€æ–°ç‰ˆæœ¬")

        # æ£€æŸ¥efå‚æ•°
        if not hasattr(self.index, 'efConstruction'):
            tips.append("å½“å‰FAISSç‰ˆæœ¬ä¸æ”¯æŒefConstructionå‚æ•°ï¼Œæœç´¢æ€§èƒ½å¯èƒ½å—é™")

        if not hasattr(self.index, 'efSearch'):
            tips.append("å½“å‰FAISSç‰ˆæœ¬ä¸æ”¯æŒefSearchå‚æ•°ï¼Œå»ºè®®æ‰‹åŠ¨è®¾ç½®æœç´¢å‚æ•°")

        # æ£€æŸ¥å‘é‡æ•°é‡
        if self.index.ntotal < 1000:
            tips.append("å‘é‡æ•°é‡è¾ƒå°‘ï¼Œè€ƒè™‘å¢åŠ æ›´å¤šå•†å“æ•°æ®ä»¥æé«˜æœç´¢å‡†ç¡®æ€§")

        # æ£€æŸ¥å†…å­˜ä½¿ç”¨
        memory_mb = self._estimate_memory_usage()
        if memory_mb > 1000:  # è¶…è¿‡1GB
            tips.append(f"å†…å­˜ä½¿ç”¨é‡è¾ƒå¤§ ({memory_mb:.1f}MB)ï¼Œå»ºè®®ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ")

        return tips if tips else ["ç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œæ— æ€§èƒ½ä¼˜åŒ–å»ºè®®"]

    def _estimate_memory_usage(self) -> float:
        """ä¼°ç®—å†…å­˜ä½¿ç”¨é‡ (MB)"""
        # HNSWç´¢å¼•å†…å­˜ä¼°ç®—ï¼šå‘é‡æ•°æ® + å›¾ç»“æ„
        vector_memory = self.index.ntotal * self.dimension * 4  # float32 = 4 bytes
        graph_memory = self.index.ntotal * config.FAISS_HNSW_M * 4  # é‚»å±…æŒ‡é’ˆ
        total_bytes = vector_memory + graph_memory
        return total_bytes / (1024 * 1024)

# å…¨å±€å•ä¾‹
_engine = None

def get_vector_engine() -> VectorEngine:
    global _engine
    if _engine is None:
        _engine = VectorEngine()
    return _engine

--- File: ./backend/scripts/clear_database.py ---
#!/usr/bin/env python3
"""
æ•°æ®åº“æ¸…ç†è„šæœ¬
æ¸…ç©ºæ‰€æœ‰æ•°æ®åº“æ•°æ®ã€å›¾ç‰‡æ–‡ä»¶å’Œå‘é‡ç´¢å¼•

ä½¿ç”¨æ–¹æ³•:
cd backend
python3 clear_database.py

æˆ–è€…ç›´æ¥è¿è¡Œ:
python3 clear_database.py --confirm
"""

import os
import sys
import sqlite3
import shutil
from pathlib import Path

def clear_all_data(confirm=False):
    """æ¸…ç©ºæ‰€æœ‰æ•°æ®"""
    if not confirm:
        print("âš ï¸ è­¦å‘Š: æ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼")
        print("åŒ…æ‹¬: ç”¨æˆ·è´¦æˆ·ã€å•†å“æ•°æ®ã€å›¾ç‰‡æ–‡ä»¶ã€å‘é‡ç´¢å¼•ç­‰")
        print("")
        response = input("ç¡®è®¤è¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿè¾“å…¥ 'YES' ç¡®è®¤: ")
        if response != 'YES':
            print("æ“ä½œå·²å–æ¶ˆ")
            return

    # æ•°æ®ç›®å½•
    DATA_DIR = Path('data')

    # æ‰€æœ‰æ•°æ®åº“æ–‡ä»¶
    DB_FILES = [
        'data/app.db',
        'data/metadata.db',
        'data/milvus.db',
        'data/discord_bot.db'  # ä¸‡ä¸€å­˜åœ¨
    ]

    print('ğŸ—‘ï¸ å¼€å§‹å…¨é¢æ¸…ç©ºæ‰€æœ‰æ•°æ®åº“å’Œç›¸å…³æ•°æ®...')

    # 1. æ¸…ç©ºæ‰€æœ‰SQLiteæ•°æ®åº“
    for db_path in DB_FILES:
        if os.path.exists(db_path):
            print(f'ğŸ“„ æ¸…ç©ºSQLiteæ•°æ®åº“: {db_path}')
            try:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()

                # è·å–æ‰€æœ‰è¡¨å
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = cursor.fetchall()

                # æ¸…ç©ºæ‰€æœ‰è¡¨
                for table in tables:
                    table_name = table[0]
                    if table_name != 'sqlite_sequence':  # è·³è¿‡SQLiteå†…éƒ¨è¡¨
                        print(f'  åˆ é™¤è¡¨ {table_name} çš„æ‰€æœ‰æ•°æ®')
                        cursor.execute(f'DELETE FROM {table_name}')

                        # é‡ç½®è‡ªå¢ID
                        cursor.execute(f'DELETE FROM sqlite_sequence WHERE name="{table_name}"')

                conn.commit()
                conn.close()
                print(f'âœ… {db_path} å·²æ¸…ç©º')

            except Exception as e:
                print(f'âŒ æ¸…ç©º {db_path} å¤±è´¥: {e}')
        else:
            print(f'âš ï¸ æ•°æ®åº“æ–‡ä»¶ä¸å­˜åœ¨: {db_path}')

    # 2. åˆ é™¤å›¾ç‰‡æ–‡ä»¶
    IMAGES_DIR = DATA_DIR / 'scraped_images'
    if IMAGES_DIR.exists():
        print(f'ğŸ–¼ï¸ åˆ é™¤å›¾ç‰‡ç›®å½•: {IMAGES_DIR}')
        try:
            shutil.rmtree(IMAGES_DIR)
            print('âœ… å›¾ç‰‡ç›®å½•å·²åˆ é™¤')
        except Exception as e:
            print(f'âŒ åˆ é™¤å›¾ç‰‡ç›®å½•å¤±è´¥: {e}')
    else:
        print('âš ï¸ å›¾ç‰‡ç›®å½•ä¸å­˜åœ¨')

    # 3. åˆ é™¤å‘é‡æ•°æ®ç›®å½•
    VECTOR_DIR = DATA_DIR / 'vectors'
    if VECTOR_DIR.exists():
        print(f'ğŸ” åˆ é™¤å‘é‡æ•°æ®ç›®å½•: {VECTOR_DIR}')
        try:
            shutil.rmtree(VECTOR_DIR)
            print('âœ… å‘é‡æ•°æ®ç›®å½•å·²åˆ é™¤')
        except Exception as e:
            print(f'âŒ åˆ é™¤å‘é‡æ•°æ®ç›®å½•å¤±è´¥: {e}')
    else:
        print('âš ï¸ å‘é‡æ•°æ®ç›®å½•ä¸å­˜åœ¨')

    # 4. åˆ é™¤å‘é‡ç´¢å¼•æ–‡ä»¶
    vector_extensions = ['*.faiss', '*.index', '*.pkl', '*.npy', '*.bin']
    vector_files = []
    for ext in vector_extensions:
        vector_files.extend(list(DATA_DIR.glob(ext)))

    if vector_files:
        print('ğŸ” åˆ é™¤å‘é‡ç´¢å¼•æ–‡ä»¶:')
        for vf in vector_files:
            try:
                vf.unlink()
                print(f'  âœ… åˆ é™¤: {vf}')
            except Exception as e:
                print(f'  âŒ åˆ é™¤å¤±è´¥ {vf}: {e}')

    # 5. åˆ é™¤ä¸´æ—¶æ–‡ä»¶
    temp_files = list(DATA_DIR.glob('temp_*')) + list(DATA_DIR.glob('*.tmp'))
    if temp_files:
        print('ğŸ—‚ï¸ åˆ é™¤ä¸´æ—¶æ–‡ä»¶:')
        for tf in temp_files:
            try:
                tf.unlink()
                print(f'  âœ… åˆ é™¤: {tf}')
            except Exception as e:
                print(f'  âŒ åˆ é™¤å¤±è´¥ {tf}: {e}')

    print('\nğŸ‰ å…¨é¢æ•°æ®åº“æ¸…ç†å®Œæˆï¼')
    print('\nğŸ“‹ æ¸…ç†å†…å®¹æ€»ç»“:')
    print('  - æ‰€æœ‰SQLiteæ•°æ®åº“ (app.db, metadata.db, milvus.db) å·²æ¸…ç©º')
    print('  - è‡ªå¢IDè®¡æ•°å™¨å·²é‡ç½®')
    print('  - å›¾ç‰‡æ–‡ä»¶ç›®å½•å·²åˆ é™¤')
    print('  - å‘é‡æ•°æ®ç›®å½•å·²åˆ é™¤')
    print('  - å‘é‡ç´¢å¼•æ–‡ä»¶ (*.faiss, *.index, *.pkl, *.npy, *.bin) å·²åˆ é™¤')
    print('  - ä¸´æ—¶æ–‡ä»¶å·²åˆ é™¤')
    print('\nâš ï¸ æ³¨æ„: æ‰€æœ‰ç”¨æˆ·è´¦æˆ·ã€å•†å“æ•°æ®ã€ç³»ç»Ÿé…ç½®ã€å‘é‡ç´¢å¼•éƒ½å·²è¢«æ¸…ç©º')
    print('   è¿™æ˜¯ä¸€ä¸ªä¸å¯é€†çš„æ“ä½œï¼Œå¦‚éœ€æ¢å¤è¯·ä»å¤‡ä»½æ¢å¤')

if __name__ == '__main__':
    confirm = '--confirm' in sys.argv
    clear_all_data(confirm)

--- File: ./backend/scripts/create_admin.py ---
#!/usr/bin/env python3
"""
åˆ›å»ºç®¡ç†å‘˜è´¦å·è„šæœ¬

ä½¿ç”¨æ–¹æ³•:
# æ¨èï¼šåœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œ
cd /path/to/project
python3 create_admin.py

# æˆ–è€…åœ¨backendç›®å½•ä¸‹è¿è¡Œ
cd backend
python3 scripts/create_admin.py

# æŒ‡å®šç”¨æˆ·åå’Œå¯†ç 
python3 create_admin.py --username admin --password admin123
"""

import sys
import getpass
import argparse
import os

# ç¡®ä¿åœ¨æ­£ç¡®çš„ç›®å½•ä¸‹è¿è¡Œ
if not os.path.exists('database.py'):
    print("âŒ è¯·åœ¨ backend ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬")
    print("æ­£ç¡®ç”¨æ³•:")
    print("  cd backend")
    print("  python3 scripts/create_admin.py")
    sys.exit(1)

try:
    from database import Database
except ImportError as e:
    print(f"âŒ å¯¼å…¥æ•°æ®åº“æ¨¡å—å¤±è´¥: {e}")
    print("è¯·ç¡®ä¿åœ¨ backend ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬")
    sys.exit(1)

from werkzeug.security import generate_password_hash

def create_admin_user(username=None, password=None):
    """åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·"""
    db = Database()

    # å¦‚æœæ²¡æœ‰æä¾›å‚æ•°ï¼Œäº¤äº’å¼è¾“å…¥
    if not username:
        username = input("è¯·è¾“å…¥ç®¡ç†å‘˜ç”¨æˆ·å: ").strip()
        if not username:
            print("âŒ ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
            return

    if not password:
        password = getpass.getpass("è¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç : ").strip()
        if not password:
            print("âŒ å¯†ç ä¸èƒ½ä¸ºç©º")
            return

        # ç¡®è®¤å¯†ç 
        confirm_password = getpass.getpass("è¯·å†æ¬¡è¾“å…¥å¯†ç ç¡®è®¤: ").strip()
        if password != confirm_password:
            print("âŒ ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´")
            return

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = cursor.fetchone()

            if existing_user:
                print(f"âŒ ç”¨æˆ·å '{username}' å·²å­˜åœ¨")
                return

            # åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·
            hashed_password = generate_password_hash(password)
            cursor.execute("""
                INSERT INTO users (username, password_hash, role, created_at, updated_at)
                VALUES (?, ?, 'admin', datetime('now'), datetime('now'))
            """, (username, hashed_password))

            user_id = cursor.lastrowid
            conn.commit()

            print("âœ… ç®¡ç†å‘˜è´¦å·åˆ›å»ºæˆåŠŸï¼")
            print(f"   ç”¨æˆ·å: {username}")
            print(f"   è§’è‰²: ç®¡ç†å‘˜")
            print(f"   ç”¨æˆ·ID: {user_id}")
            print("\nğŸ” è¯·å¦¥å–„ä¿ç®¡è´¦å·ä¿¡æ¯")

    except Exception as e:
        print(f"âŒ åˆ›å»ºç®¡ç†å‘˜è´¦å·å¤±è´¥: {e}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='åˆ›å»ºç®¡ç†å‘˜è´¦å·')
    parser.add_argument('--username', help='ç®¡ç†å‘˜ç”¨æˆ·å')
    parser.add_argument('--password', help='ç®¡ç†å‘˜å¯†ç ')

    args = parser.parse_args()

    if args.username and args.password:
        create_admin_user(args.username, args.password)
    else:
        create_admin_user()

--- File: ./backend/app.py ---
from flask import Flask, request, jsonify, Response, session
import numpy as np
import os
import logging
import sys
from datetime import datetime

# è‡ªåŠ¨åŠ è½½.envæ–‡ä»¶
try:
    from dotenv import load_dotenv
    # ä»é¡¹ç›®æ ¹ç›®å½•åŠ è½½.envæ–‡ä»¶
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    env_path = os.path.join(project_root, '.env')
    if os.path.exists(env_path):
        load_dotenv(env_path)
        print(f"âœ… å·²åŠ è½½ç¯å¢ƒå˜é‡æ–‡ä»¶: {env_path}")
    else:
        print("â„¹ï¸  æœªæ‰¾åˆ°.envæ–‡ä»¶ï¼Œä½¿ç”¨ç³»ç»Ÿç¯å¢ƒå˜é‡")
except ImportError:
    print("â„¹ï¸  python-dotenvæœªå®‰è£…ï¼Œä½¿ç”¨ç³»ç»Ÿç¯å¢ƒå˜é‡")

try:
    from feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
except ImportError:
    from .feature_extractor import get_feature_extractor, DINOv2FeatureExtractor
try:
    from database import db
    from config import config
except ImportError:
    from .database import db
    from .config import config
import requests
import json
from flask_cors import CORS
import queue
import threading
import time
from urllib.parse import quote
import hashlib

# åœ¨åº”ç”¨å¯åŠ¨æ—¶ä»æ•°æ®åº“åŠ è½½ç³»ç»Ÿé…ç½®
def load_system_config():
    """ä»æ•°æ®åº“åŠ è½½ç³»ç»Ÿé…ç½®åˆ°å†…å­˜"""
    # åœ¨å‡½æ•°å†…éƒ¨å®šä¹‰loggerï¼Œå› ä¸ºæ­¤æ—¶å…¨å±€loggerå¯èƒ½è¿˜æ²¡æœ‰åˆå§‹åŒ–
    import logging
    func_logger = logging.getLogger(__name__)

    try:
        sys_config = db.get_system_config()
        config.DISCORD_SIMILARITY_THRESHOLD = sys_config['discord_similarity_threshold']
        config.DISCORD_CHANNEL_ID = sys_config['discord_channel_id']
        config.CNFANS_CHANNEL_ID = sys_config['cnfans_channel_id']
        config.ACBUY_CHANNEL_ID = sys_config['acbuy_channel_id']

        # åŠ è½½å…¨å±€å›å¤å»¶è¿Ÿé…ç½®
        reply_config = db.get_global_reply_config()
        config.GLOBAL_REPLY_MIN_DELAY = reply_config['min_delay']
        config.GLOBAL_REPLY_MAX_DELAY = reply_config['max_delay']

        # è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆä¾›æœºå™¨äººä½¿ç”¨ï¼‰
        discord_channel_id = sys_config['discord_channel_id']
        if discord_channel_id:
            os.environ['DISCORD_CHANNEL_ID'] = discord_channel_id

        func_logger.info("ç³»ç»Ÿé…ç½®å·²ä»æ•°æ®åº“åŠ è½½")
        func_logger.info(f"ä¸‹è½½çº¿ç¨‹: {DOWNLOAD_THREADS}")
        func_logger.info(f"ç‰¹å¾æå–çº¿ç¨‹: {FEATURE_EXTRACT_THREADS}")
        func_logger.info(f"Discordç›¸ä¼¼åº¦é˜ˆå€¼: {config.DISCORD_SIMILARITY_THRESHOLD} ({config.DISCORD_SIMILARITY_THRESHOLD*100:.0f}%)")
        func_logger.info(f"å…¨å±€å›å¤å»¶è¿Ÿè®¾ç½®ä¸º: {config.GLOBAL_REPLY_MIN_DELAY}-{config.GLOBAL_REPLY_MAX_DELAY}ç§’")
        func_logger.info(f"Discordé¢‘é“ID: {discord_channel_id or 'æœªè®¾ç½®(ç›‘å¬æ‰€æœ‰é¢‘é“)'}")
    except Exception as e:
        func_logger.warning(f"åŠ è½½ç³»ç»Ÿé…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: {e}")

def check_duplicate_image(new_features, existing_features_list, threshold=0.99):
    """
    æ£€æŸ¥æ–°å›¾ç‰‡çš„ç‰¹å¾å‘é‡æ˜¯å¦ä¸ç°æœ‰åˆ—è¡¨ä¸­çš„å›¾ç‰‡é‡å¤

    :param new_features: æ–°å›¾ç‰‡çš„ç‰¹å¾å‘é‡ (numpy array)
    :param existing_features_list: ç°æœ‰å›¾ç‰‡çš„ç‰¹å¾å‘é‡åˆ—è¡¨ (å¯ä»¥æ˜¯jsonå­—ç¬¦ä¸²åˆ—è¡¨æˆ–numpyåˆ—è¡¨)
    :param threshold: ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œé»˜è®¤99%
    :return: (is_duplicate, similarity_score)
    """
    if not existing_features_list:
        return False, 0.0

    try:
        # é¢„è®¡ç®—æ–°å‘é‡çš„èŒƒæ•°
        norm_new = np.linalg.norm(new_features)
        if norm_new == 0:
            return False, 0.0

        for feat_item in existing_features_list:
            try:
                # å¤„ç†è¾“å…¥å¯èƒ½æ˜¯ JSON å­—ç¬¦ä¸²æˆ–å·²ç»æ˜¯ numpy æ•°ç»„çš„æƒ…å†µ
                if isinstance(feat_item, str):
                    feat_vec = np.array(json.loads(feat_item), dtype='float32')
                else:
                    feat_vec = np.array(feat_item, dtype='float32')

                norm_existing = np.linalg.norm(feat_vec)
                if norm_existing == 0:
                    continue

                # è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
                dot_product = np.dot(new_features, feat_vec)
                similarity = dot_product / (norm_new * norm_existing)

                if similarity > threshold:
                    return True, similarity

            except Exception:
                continue

    except Exception as e:
        logger.error(f"å‘é‡æ¯”å¯¹å‡ºé”™: {e}")

    return False, 0.0

def process_and_save_image_core(product_id, image_url_or_file, index, existing_features=None, save_faiss_immediately=True):
    """
    æ ¸å¿ƒå›¾ç‰‡å¤„ç†å•å…ƒï¼šä¿å­˜ -> ç‰¹å¾æå– -> æŸ¥é‡ -> æ•°æ®åº“ -> FAISS

    :param product_id: å•†å“ID
    :param image_url_or_file: æˆ–è€…æ˜¯ URL å­—ç¬¦ä¸²ï¼Œæˆ–è€…æ˜¯ Flask çš„ FileStorage å¯¹è±¡
    :param index: å›¾ç‰‡ç´¢å¼•
    :param existing_features: ç°æœ‰ç‰¹å¾å‘é‡åˆ—è¡¨ï¼Œç”¨äºæŸ¥é‡
    :param save_faiss_immediately: æ˜¯å¦ç«‹å³ä¿å­˜FAISSç´¢å¼•ï¼ˆå•å¼ ä¸Šä¼ æ—¶ä¸ºTrueï¼Œæ‰¹é‡å¤„ç†æ—¶ä¸ºFalseï¼‰
    :return: å¤„ç†ç»“æœå­—å…¸
    """
    import os
    import time

    # 1. ç¡®å®šä¿å­˜è·¯å¾„ï¼ˆä½¿ç”¨é…ç½®çš„ç›®å½•ï¼‰
    timestamp = int(time.time() * 1000000)
    filename = f"{product_id}_{index}_{timestamp}.jpg"
    save_path = os.path.join(config.IMAGE_SAVE_DIR, str(product_id), filename)
    os.makedirs(os.path.dirname(save_path), exist_ok=True)

    img_db_id = None  # åˆå§‹åŒ–æ•°æ®åº“ ID

    try:
        # 2. ä¿å­˜æ–‡ä»¶
        if hasattr(image_url_or_file, 'save'):
            # æ˜¯ä¸Šä¼ çš„æ–‡ä»¶å¯¹è±¡ (FileStorage)
            image_url_or_file.save(save_path)
        else:
            # æ˜¯ URL å­—ç¬¦ä¸²
            import requests
            resp = requests.get(image_url_or_file, timeout=config.REQUEST_TIMEOUT, proxies={'http': None, 'https': None})
            if resp.status_code != 200:
                return {'success': False, 'error': f'Download failed: {resp.status_code}'}
            with open(save_path, 'wb') as f:
                f.write(resp.content)

        # éªŒè¯æ–‡ä»¶å¤§å°
        if os.path.getsize(save_path) == 0:
            os.remove(save_path)
            return {'success': False, 'error': 'Empty file'}

        # 3. ç‰¹å¾æå– (DINOv2 + YOLO)
        extractor = get_global_feature_extractor()
        if extractor is None:
            os.remove(save_path)
            return {'success': False, 'error': 'Feature extractor not initialized'}

        features = extractor.extract_feature(save_path)
        if features is None:
            os.remove(save_path)
            return {'success': False, 'error': 'Feature extraction failed'}

        # 4. æŸ¥é‡é€»è¾‘
        if existing_features:
            is_dup, score = check_duplicate_image(features, existing_features)
            if is_dup:
                os.remove(save_path)
                logger.info(f"å›¾ç‰‡é‡å¤ (ç›¸ä¼¼åº¦: {score:.2f})ï¼Œå·²åˆ é™¤: {filename}")
                return {'success': False, 'error': 'Duplicate image'}

        # 5. å…¥åº“ (SQLite)
        img_db_id = db.insert_image_record(product_id, save_path, index, features)

        # 6. å…¥åº“ (FAISS)
        try:
            from vector_engine import get_vector_engine
            engine = get_vector_engine()
            engine.add_vector(img_db_id, features)
            # æ€§èƒ½ä¼˜åŒ–ï¼šå•å¼ ä¸Šä¼ æ—¶ç«‹å³ä¿å­˜ï¼Œæ‰¹é‡å¤„ç†æ—¶å»¶è¿Ÿä¿å­˜
            if save_faiss_immediately:
                engine.save()
        except Exception as faiss_err:
            logger.error(f"FAISS å…¥åº“å¤±è´¥: {faiss_err}")
            # FAISSå¤±è´¥æ—¶åˆ é™¤æ•°æ®åº“è®°å½•å’Œæ–‡ä»¶ï¼Œå›æ»šæ“ä½œ
            try:
                db.delete_image_record(img_db_id)
            except:
                pass
            if os.path.exists(save_path):
                os.remove(save_path)
            return {'success': False, 'error': f'FAISS error: {faiss_err}'}

        # 7. å®Œæˆ
        return {
            'success': True,
            'image_path': save_path,
            'features': features,
            'index': index,
            'filename': filename,
            'db_id': img_db_id
        }

    except Exception as e:
        logger.error(f'å›¾ç‰‡å¤„ç†æ€»å‡ºé”™ï¼Œå°è¯•æ¸…ç†: {e}')
        if os.path.exists(save_path):
            os.remove(save_path)
        # å¦‚æœå·²ç»æ’å…¥æ•°æ®åº“ä½†åç»­å¤±è´¥ï¼Œéœ€è¦å›æ»š
        if img_db_id:
            try:
                db.delete_image_record(img_db_id)
            except:
                pass
        return {'success': False, 'error': str(e)}

# çº¿ç¨‹é…ç½®ç°åœ¨ç»Ÿä¸€åœ¨ config.py ä¸­ç®¡ç†

# åŠ è½½ç³»ç»Ÿé…ç½®
load_system_config()

# === é‡æ„ï¼šåº—é“ºæŠ“å–çŠ¶æ€æ§åˆ¶ ===
# ç§»é™¤å…¨å±€çŠ¶æ€å˜é‡ï¼Œæ”¹ä¸ºæ•°æ®åº“æŒä¹…åŒ–å­˜å‚¨
# scrape_statusç°åœ¨é€šè¿‡db.get_scrape_status()å’Œdb.update_scrape_status()ç®¡ç†

# çº¿ç¨‹ç®¡ç†ï¼šè·Ÿè¸ªå½“å‰è¿è¡Œçš„æŠ“å–çº¿ç¨‹
current_scrape_thread = None
scrape_thread_lock = threading.Lock()

# å…¨å±€å…³é—­äº‹ä»¶ï¼Œç”¨äºä¼˜é›…å…³é—­
shutdown_event = None

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)

# åˆ›å»ºæ—¥å¿—é˜Ÿåˆ—ç”¨äºå®æ—¶æµå¼ä¼ è¾“
log_queue = queue.Queue()
log_clients = []

# å­˜å‚¨æ‰€æœ‰æ—¥å¿—çš„åˆ—è¡¨ï¼Œç”¨äºAPIæŸ¥è¯¢
all_logs = []

class QueueHandler(logging.Handler):
    """è‡ªå®šä¹‰æ—¥å¿—å¤„ç†å™¨ï¼Œå°†æ—¥å¿—å‘é€åˆ°é˜Ÿåˆ—"""
    def emit(self, record):
        try:
            # è¿‡æ»¤æ‰HTTPè¯·æ±‚æ—¥å¿—å’Œä¸é‡è¦çš„ç³»ç»Ÿæ—¥å¿—
            if self._should_filter_log(record):
                return

            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'level': record.levelname,
                'message': self.format(record),
                'module': record.module,
                'func': record.funcName
            }

            # æ·»åŠ åˆ°æ—¥å¿—åˆ—è¡¨ï¼ˆé™åˆ¶å¤§å°ï¼‰
            all_logs.append(log_entry)
            if len(all_logs) > 200:  # æœ€å¤šä¿å­˜200æ¡æ—¥å¿—
                all_logs.pop(0)

            log_queue.put(log_entry)

            # é€šçŸ¥æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯
            for client_queue in log_clients[:]:  # å¤åˆ¶åˆ—è¡¨ä»¥é¿å…ä¿®æ”¹æ—¶çš„é—®é¢˜
                try:
                    client_queue.put(log_entry)
                except:
                    # å¦‚æœå®¢æˆ·ç«¯é˜Ÿåˆ—å·²æ»¡æˆ–æ–­å¼€ï¼Œç§»é™¤å®ƒ
                    if client_queue in log_clients:
                        log_clients.remove(client_queue)
        except Exception as e:
            print(f"æ—¥å¿—é˜Ÿåˆ—é”™è¯¯: {e}")

    def _should_filter_log(self, record):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥è¿‡æ»¤æ‰è¿™æ¡æ—¥å¿—"""
        # è¿‡æ»¤Werkzeugçš„HTTPè¯·æ±‚æ—¥å¿—
        if record.module == '_internal':
            return True

        # è¿‡æ»¤åŒ…å«HTTPè¯·æ±‚æ¨¡å¼çš„æ—¥å¿—
        message = self.format(record)
        if any(pattern in message for pattern in [
            '"GET ', '"POST ', '"PUT ', '"DELETE ',
            'HTTP/1.1"', 'HTTP/1.0"',
            'werkzeug',
            '127.0.0.1 - -',  # è¿‡æ»¤è®¿é—®æ—¥å¿—
        ]):
            return True

        # è¿‡æ»¤ä¸€äº›ä¸é‡è¦çš„ç³»ç»Ÿæ—¥å¿—
        if record.module in ['urllib3', 'requests', 'aiohttp']:
            return True

        # 2. å…³é”®ä¿®å¤ï¼šå…è®¸ weidian_scraper å’Œ app çš„ INFO æ—¥å¿—é€šè¿‡
        # åªè¦æ˜¯è¿™äº›æ¨¡å—ï¼Œå³ä½¿æ˜¯ INFO çº§åˆ«ä¹Ÿå…è®¸é€šè¿‡
        whitelist_modules = [
            '__main__', 'app', 'database', 'bot',
            'weidian_scraper', 'feature_extractor',
            'vector_engine', 'migrate_data'
        ]

        if record.module in whitelist_modules:
            return False

        # å¯¹äºå…¶ä»–æœªçŸ¥æ¨¡å—ï¼Œåªæ˜¾ç¤ºWARNINGçº§åˆ«ä»¥ä¸Š
        if record.levelno < logging.WARNING:
            return True

        return False

# åˆ›å»ºé˜Ÿåˆ—å¤„ç†å™¨å¹¶æ·»åŠ åˆ°æ ¹æ—¥å¿—å™¨
queue_handler = QueueHandler()
queue_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(queue_handler)

# ç¡®ä¿æ§åˆ¶å°è¾“å‡ºä¸å—QueueHandlerè¿‡æ»¤å½±å“
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
logging.getLogger().addHandler(console_handler)

# 1. è®¾ç½® werkzeug æ—¥å¿—çº§åˆ«ä¸º WARNINGï¼Œå±è”½ HTTP è¯·æ±‚åˆ·å±
logging.getLogger('werkzeug').setLevel(logging.WARNING)
# 2. è®¾ç½®å…¶ä»–åº“çš„æ—¥å¿—çº§åˆ«
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('requests').setLevel(logging.WARNING)
logging.getLogger('aiohttp').setLevel(logging.WARNING)
logging.getLogger('ultralytics').setLevel(logging.WARNING)  # å±è”½ YOLO æ—¥å¿—

logger = logging.getLogger(__name__)

# æœºå™¨äººç›¸å…³å˜é‡
bot_clients = []
bot_tasks = []
bot_running = False  # æ ‡è®°æœºå™¨äººæ˜¯å¦æ­£åœ¨è¿è¡Œ

# å…¨å±€ç‰¹å¾æå–å™¨å®ä¾‹ï¼ˆåœ¨åº”ç”¨å¯åŠ¨æ—¶åˆ›å»ºï¼‰
feature_extractor_instance = None

def initialize_feature_extractor():
    """åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–ç‰¹å¾æå–å™¨ï¼Œç¡®ä¿å•ä¾‹æ¨¡å¼"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        print("ğŸš€ åˆå§‹åŒ–å…¨å±€ç‰¹å¾æå–å™¨å®ä¾‹...")
        try:
            from feature_extractor import DINOv2FeatureExtractor
            feature_extractor_instance = DINOv2FeatureExtractor()
            print("âœ… å…¨å±€ç‰¹å¾æå–å™¨å®ä¾‹åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            print(f"âŒ ç‰¹å¾æå–å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            feature_extractor_instance = None
    return feature_extractor_instance

def get_global_feature_extractor():
    """è·å–å…¨å±€ç‰¹å¾æå–å™¨å®ä¾‹"""
    global feature_extractor_instance
    if feature_extractor_instance is None:
        return initialize_feature_extractor()
    return feature_extractor_instance

# åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–
initialize_feature_extractor()

# Flaské…ç½®åˆå§‹åŒ–ï¼ˆç®€åŒ–ç‰ˆ - è§£å†³HTTP IPè®¿é—®é—®é¢˜ï¼‰
app = Flask(__name__)
app.secret_key = config.SECRET_KEY

# CORS é…ç½®ï¼ˆå…è®¸æ‰€æœ‰æ¥æºï¼‰
CORS(app, origins=config.CORS_ORIGINS, supports_credentials=True)

# å¼ºåˆ¶æ›´æ–°é…ç½®ï¼Œè¦†ç›–é»˜è®¤çš„å®‰å…¨è®¾ç½®
app.config.update(
    SECRET_KEY=config.SECRET_KEY,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE=config.SESSION_COOKIE_SAMESITE,
    SESSION_COOKIE_SECURE=config.SESSION_COOKIE_SECURE,  # ç¡®ä¿æ˜¯False
    SESSION_COOKIE_DOMAIN=None,
    PERMANENT_SESSION_LIFETIME=config.SESSION_LIFETIME,  # 30å¤©ä¸è¿‡æœŸ
)

def extract_features(image_path):
    """ä½¿ç”¨æ·±åº¦å­¦ä¹ æ¨¡å‹æå–å›¾åƒç‰¹å¾"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            logger.error("ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–")
            return None
        features = extractor.extract_feature(image_path)
        # å¦‚æœç‰¹å¾æå–å¤±è´¥ï¼Œè¿”å› Noneï¼ˆä¸Šå±‚å°†å¤„ç†å¹¶è¿”å›é”™è¯¯ï¼‰
        if features is None:
            logger.warning(f"ç‰¹å¾æå–å¤±è´¥: {image_path}")
            return None

        return features

    except Exception as e:
        logger.error(f"ç‰¹å¾æå–å¼‚å¸¸: {e}")
        return None

@app.route('/search_similar', methods=['POST'])
def search_similar():
    """æœç´¢ç›¸ä¼¼å›¾åƒ - ä½¿ç”¨ FAISS HNSW"""
    try:
        image_url = request.form.get('image_url')
        threshold = float(request.form.get('threshold', 0.6))  # DINOv2éœ€è¦æ›´é«˜çš„é˜ˆå€¼
        limit = int(request.form.get('limit', 5))  # è¿”å›ç»“æœæ•°é‡ï¼Œé»˜è®¤5ä¸ª

        # è·å–ç”¨æˆ·åº—é“ºæƒé™è¿‡æ»¤ï¼ˆç”¨äºDiscordæœºå™¨äººï¼‰
        user_shops = None
        user_shops_json = request.form.get('user_shops')
        if user_shops_json:
            try:
                user_shops = json.loads(user_shops_json)
            except:
                user_shops = None

        # è°ƒè¯•ä¿¡æ¯
        print(f"DEBUG: Received threshold: {threshold}")
        print(f"DEBUG: User shops filter: {user_shops}")
        print(f"DEBUG: Form data: {list(request.form.keys())}")
        print(f"DEBUG: Files: {list(request.files.keys()) if request.files else 'No files'}")
        print(f"DEBUG: Content-Type: {request.content_type}")
        print(f"DEBUG: Method: {request.method}")
        print(f"DEBUG: image_url parameter: '{image_url}'")

        # å¤„ç†å›¾ç‰‡æ¥æº
        import uuid
        import os
        if image_url:
            print(f"DEBUG: Processing image URL: {image_url}")
            # éªŒè¯URLæ ¼å¼
            if not image_url.startswith(('http://', 'https://')):
                return jsonify({'error': 'Invalid URL format, must start with http:// or https://'}), 400

            # ä»URLä¸‹è½½å›¾ç‰‡
            import requests
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                response = requests.get(image_url, timeout=15, headers=headers, stream=True)
                print(f"DEBUG: URL response status: {response.status_code}")
                print(f"DEBUG: Content-Type: {response.headers.get('content-type', 'unknown')}")

                if response.status_code != 200:
                    return jsonify({'error': f'Failed to download image from URL, status: {response.status_code}'}), 400

                # æ£€æŸ¥å†…å®¹ç±»å‹
                content_type = response.headers.get('content-type', '').lower()
                if not any(img_type in content_type for img_type in ['image/', 'application/octet-stream']):
                    print(f"DEBUG: Warning - Content-Type '{content_type}' may not be an image")

                temp_filename = f"{uuid.uuid4()}.jpg"
                image_path = f"/tmp/{temp_filename}"

                with open(image_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)

                # æ£€æŸ¥æ–‡ä»¶å¤§å°
                file_size = os.path.getsize(image_path)
                print(f"DEBUG: Image downloaded to: {image_path}, size: {file_size} bytes")

                if file_size == 0:
                    os.remove(image_path)
                    return jsonify({'error': 'Downloaded file is empty'}), 400

                if file_size > 10 * 1024 * 1024:  # 10MB limit
                    os.remove(image_path)
                    return jsonify({'error': 'Image file too large (max 10MB)'}), 400

            except requests.exceptions.RequestException as e:
                print(f"DEBUG: Network error downloading image: {str(e)}")
                return jsonify({'error': f'Network error downloading image: {str(e)}'}), 400
            except Exception as e:
                print(f"DEBUG: Failed to download image: {str(e)}")
                return jsonify({'error': f'Failed to download image: {str(e)}'}), 400
        else:
            print("DEBUG: No image_url provided, checking for uploaded file")
            # ä»ä¸Šä¼ çš„æ–‡ä»¶è·å–å›¾ç‰‡
            if 'image' not in request.files:
                print("DEBUG: No 'image' file found in request.files")
                return jsonify({'error': 'No image provided'}), 400

            image_file = request.files['image']
            print(f"DEBUG: Found uploaded file: {image_file.filename if image_file else 'None'}")
        temp_filename = f"{uuid.uuid4()}.jpg"
        image_path = f"/tmp/{temp_filename}"
        image_file.save(image_path)

        try:
            # æå–ç‰¹å¾ (ä½¿ç”¨ DINOv2 + YOLOv8)
            query_features = extract_features(image_path)

            if query_features is None:
                return jsonify({'error': 'Feature extraction failed'}), 500

            # ä½¿ç”¨ FAISS HNSW å‘é‡æœç´¢
            print(f"DEBUG: Searching with threshold: {threshold}, vector length: {len(query_features)}")
            # ç”¨è¾ƒä½çš„é˜ˆå€¼æœç´¢æ‰¾åˆ°å€™é€‰ç»“æœï¼Œç„¶åä»ä¸­ç­›é€‰æ»¡è¶³ç”¨æˆ·é˜ˆå€¼çš„ç»“æœ
            low_threshold_results = db.search_similar_images(query_features, limit=10, threshold=0.1)
            print(f"DEBUG: Low threshold (0.1) search results: {len(low_threshold_results) if low_threshold_results else 0}")

            # ä»ä½é˜ˆå€¼ç»“æœä¸­ç­›é€‰å‡ºæ»¡è¶³ç”¨æˆ·é˜ˆå€¼çš„ç»“æœ
            results = []
            if low_threshold_results:
                for result in low_threshold_results:
                    similarity = result.get('similarity', 0)
                    # åº”ç”¨ç”¨æˆ·ç›¸ä¼¼åº¦é˜ˆå€¼å’Œåº—é“ºè¿‡æ»¤
                    if similarity >= threshold:
                        # æ£€æŸ¥åº—é“ºæƒé™
                        if user_shops and result.get('shop_name') not in user_shops:
                            print(f"DEBUG: Skipping result from shop {result.get('shop_name')} - not in user shops {user_shops}")
                            continue
                        results.append(result)
                        if len(results) >= limit:
                            break

            print(f"DEBUG: Filtered results count (threshold {threshold}): {len(results)}")
            if results:
                print(f"DEBUG: Best match similarity: {results[0]['similarity']}")
            elif low_threshold_results:
                print(f"DEBUG: Best low-threshold match similarity: {low_threshold_results[0]['similarity']}")
            print(f"DEBUG: Total indexed images: {db.get_total_indexed_images()}")

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³é˜ˆå€¼çš„ç»“æœï¼Œä½†æœ‰é«˜è´¨é‡çš„ä½é˜ˆå€¼åŒ¹é…ï¼ˆç›¸ä¼¼åº¦>0.8ï¼‰ï¼Œä¹Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨
            if not results and low_threshold_results and len(low_threshold_results) > 0:
                best_low_match = low_threshold_results[0]
                if best_low_match.get('similarity', 0) > 0.8:  # é«˜è´¨é‡åŒ¹é…
                    print(f"DEBUG: Using high-quality low-threshold result (similarity: {best_low_match['similarity']:.4f})")
                    results = [best_low_match]

            response_data = {
                'success': True,
                'results': [],
                'totalResults': 0,
                'message': f'æœªæ‰¾åˆ°ç›¸ä¼¼åº¦è¶…è¿‡{threshold*100:.0f}%çš„å•†å“',
                'searchTime': datetime.now().isoformat(),
                'debugInfo': {
                    'totalIndexedImages': db.get_total_indexed_images(),
                    'threshold': threshold,
                    'searchedVectors': len(results) if results else 0
                }
            }

            if results:
                # å¤„ç†å¤šä¸ªæœç´¢ç»“æœ
                processed_results = []
                for i, result in enumerate(results):
                    # è·å–å®Œæ•´äº§å“ä¿¡æ¯
                    product_info = db._get_product_info_by_id(result['id'])

                    # è·å–å®é™…çš„å›¾ç‰‡URLåˆ—è¡¨
                    actual_images = []
                    if product_info:
                        with db.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (result['id'],))
                            actual_images = [f"/api/image/{result['id']}/{row[0]}" for row in cursor.fetchall()]

                    result_data = {
                        'rank': i + 1,
                        'similarity': float(result['similarity']),
                        'imageIndex': result['image_index'],
                        'matchedImage': f"/api/image/{result['id']}/{result['image_index']}",
                        'product': {
                            'id': result['id'],
                            'title': product_info['title'] if product_info else result.get('title', ''),
                            'englishTitle': product_info.get('english_title', ''),
                            'weidianUrl': product_info['product_url'] if product_info else result.get('product_url', ''),
                            'cnfansUrl': product_info.get('cnfans_url', ''),
                            'acbuyUrl': product_info.get('acbuy_url', ''),
                            'ruleEnabled': product_info.get('ruleEnabled', True) if product_info else True,
                            'images': actual_images if actual_images else [f"/api/image/{result['id']}/{result['image_index']}"]  # ä½¿ç”¨å®é™…å›¾ç‰‡åˆ—è¡¨
                        }
                    }
                    processed_results.append(result_data)

                # ä¿å­˜æœ€ä½³åŒ¹é…çš„æœç´¢å†å²
                if processed_results:
                    best_match = processed_results[0]
                    db.add_search_history(
                        query_image_path=image_path,
                        matched_product_id=best_match['product']['id'],
                        matched_image_index=best_match['imageIndex'],
                        similarity=best_match['similarity'],
                        threshold=threshold
                    )

                response_data = {
                    'success': True,
                    'results': processed_results,
                    'totalResults': len(processed_results),
                    'searchTime': datetime.now().isoformat(),
                    'debugInfo': {
                        'totalIndexedImages': db.get_total_indexed_images(),
                        'threshold': threshold,
                        'limit': limit,
                        'searchedVectors': len(results) if results else 0
                    }
                }

            return jsonify(response_data)

        finally:
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            if os.path.exists(image_path):
                os.unlink(image_path)

    except Exception as e:
        logger.error(f"æœç´¢å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/scrape', methods=['POST'])
def scrape_product():
    """æŠ“å–å•†å“å¹¶å»ºç«‹ç´¢å¼•"""
    try:
        logger.info("æ”¶åˆ°å•†å“æŠ“å–è¯·æ±‚")
        data = request.get_json()
        if data is None:
            logger.error("è¯·æ±‚ä½“ä¸ºç©º")
            return jsonify({'error': 'Invalid request body'}), 400

        logger.info(f"è¯·æ±‚æ•°æ®: {data}")

        # æ”¯æŒä¸¤ç§è¾“å…¥æ–¹å¼ï¼šå®Œæ•´URLæˆ–å•†å“ID
        url = data.get('url')
        weidian_id = data.get('weidianId')

        if not url and not weidian_id:
            logger.error("ç¼ºå°‘URLæˆ–weidianId")
            return jsonify({'error': 'URL or weidianId is required'}), 400

        # å¦‚æœæä¾›äº†weidianIdï¼Œæ„é€ URL
        if weidian_id and not url:
            url = f"https://weidian.com/item.html?itemID={weidian_id}"
            logger.info(f"æ„é€ URL: {url}")

        # éªŒè¯URLæ ¼å¼
        if 'weidian.com' not in url:
            logger.error(f"ä¸æ”¯æŒçš„URLæ ¼å¼: {url}")
            return jsonify({'error': 'åªæ”¯æŒå¾®åº—å•†å“é“¾æ¥'}), 400

        logger.info(f"å¼€å§‹æŠ“å–å•†å“: {url}")

        # æ£€æŸ¥å•†å“æ˜¯å¦å·²å­˜åœ¨
        existing = db.get_product_by_url(url)
        if existing:
            return jsonify({'error': 'å•†å“å·²å­˜åœ¨', 'existing': True}), 409

        # ä½¿ç”¨çœŸæ­£çš„çˆ¬è™«
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        # æŠ“å–å•†å“ä¿¡æ¯
        product_info = scraper.scrape_product_info(url)

        if not product_info:
            return jsonify({'error': 'å•†å“ä¿¡æ¯æŠ“å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®'}), 500

        # ç”Ÿæˆacbuyé“¾æ¥
        acbuy_url = ''
        if product_info['weidian_url']:
            # ä»weidian_urlä¸­æå–itemID
            import re
            item_id_match = re.search(r'itemID=(\d+)', product_info['weidian_url'])
            if item_id_match:
                item_id = item_id_match.group(1)
                # æ„å»ºacbuyé“¾æ¥
                encoded_url = product_info['weidian_url'].replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
                acbuy_url = f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'

        # ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆä½¿ç”¨å…¨å±€å»¶è¿Ÿé…ç½®ï¼‰
        product_id = db.insert_product({
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'description': product_info['description'],
            'english_title': product_info.get('english_title') or '',
            'cnfans_url': product_info.get('cnfans_url') or '',
            'acbuy_url': acbuy_url,
            'shop_name': product_info.get('shop_name', ''),  # ä»product_infoè·å–åº—é“ºåç§°
            'ruleEnabled': True  # é»˜è®¤å¯ç”¨è‡ªåŠ¨å›å¤è§„åˆ™
        })

        # ä¸‹è½½å›¾ç‰‡å¹¶å»ºç«‹å‘é‡ç´¢å¼•
        if product_info['images']:
            logger.info(f"ä¸‹è½½ {len(product_info['images'])} å¼ å›¾ç‰‡å¹¶å»ºç«‹ç´¢å¼•")

            # åˆ›å»ºå›¾ç‰‡ä¿å­˜ç›®å½•
            import os
            images_dir = os.path.join(os.path.dirname(__file__), 'data', 'scraped_images', product_info['id'])
            os.makedirs(images_dir, exist_ok=True)

            # ä¸‹è½½å›¾ç‰‡
            saved_image_paths = scraper.download_images(
                product_info['images'],
                images_dir,
                product_info['id']
            )
            # ä¸ºæ¯å¼ å›¾ç‰‡å»ºç«‹å‘é‡ç´¢å¼•
            # æ³¨æ„ï¼šYOLOè£å‰ªå·²é›†æˆåœ¨DINOv2ç‰¹å¾æå–è¿‡ç¨‹ä¸­ï¼Œæ— éœ€é¢å¤–æ­¥éª¤
            # ä½¿ç”¨å…¨å±€ç‰¹å¾æå–å™¨
            extractor = get_global_feature_extractor()
            if extractor is None:
                logger.error("ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–")
                return

            # ä¸²è¡Œå»ºç«‹å‘é‡ç´¢å¼• (SQLiteä¸æ”¯æŒå¤šçº¿ç¨‹å†™å…¥)
            # ä½†å…ˆä½¿ç”¨å¤šçº¿ç¨‹è¿›è¡Œç‰¹å¾æå–ï¼Œç„¶åä¸²è¡Œæ’å…¥æ•°æ®åº“
            import concurrent.futures
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()

            def extract_features_only(img_path):
                """åªæå–ç‰¹å¾ï¼Œä¸æ’å…¥æ•°æ®åº“"""
                try:
                    features = extractor.extract_feature(img_path)
                    return features
                except Exception as e:
                    logger.error(f"ç‰¹å¾æå–å¤±è´¥ {img_path}: {e}")
                    return None

            # ç¬¬ä¸€æ­¥ï¼šå¤šçº¿ç¨‹ç‰¹å¾æå–
            logger.info("å¼€å§‹å¤šçº¿ç¨‹ç‰¹å¾æå–...")
            features_list = []
            max_workers = min(FEATURE_EXTRACT_THREADS, len(saved_image_paths))

            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # æäº¤ç‰¹å¾æå–ä»»åŠ¡
                future_to_image = {
                    executor.submit(extract_features_only, img_path): (i, img_path)
                    for i, img_path in enumerate(saved_image_paths)
                }

                # æ”¶é›†ç‰¹å¾æå–ç»“æœ
                for future in concurrent.futures.as_completed(future_to_image):
                    i, img_path = future_to_image[future]
                    try:
                        features = future.result()
                        features_list.append((i, img_path, features))
                    except Exception as e:
                        logger.error(f"ç‰¹å¾æå–å¼‚å¸¸ {img_path}: {e}")
                        features_list.append((i, img_path, None))

            # æŒ‰ç´¢å¼•æ’åºç»“æœ
            features_list.sort(key=lambda x: x[0])

            # ç¬¬äºŒæ­¥ï¼šä¸²è¡Œæ’å…¥æ•°æ®åº“å’ŒFAISSç´¢å¼•
            logger.info("å¼€å§‹ä¸²è¡Œæ•°æ®åº“æ’å…¥å’Œç´¢å¼•å»ºç«‹...")
            indexed_images = []

            for i, img_path, features in features_list:
                try:
                    if features is None:
                        logger.error(f"è·³è¿‡å›¾ç‰‡ {i}: ç‰¹å¾æå–å¤±è´¥")
                        continue

                    # æ’å…¥æ•°æ®åº“è®°å½•
                    image_db_id = db.insert_image_record(product_id, img_path, i)
                    if not image_db_id:
                        logger.error(f"å›¾ç‰‡ {i} å…ƒæ•°æ®æ’å…¥å¤±è´¥")
                        continue

                    # æ’å…¥FAISSå‘é‡ç´¢å¼•
                    success = engine.add_vector(image_db_id, features)
                    if success:
                        indexed_images.append(f"{i}.jpg")
                        logger.info(f"å›¾ç‰‡ {i} ç´¢å¼•å»ºç«‹æˆåŠŸ")
                    else:
                        logger.error(f"å›¾ç‰‡ {i} ç´¢å¼•å»ºç«‹å¤±è´¥")

                except Exception as e:
                    logger.error(f"å¤„ç†å›¾ç‰‡ {i} æ—¶å‡ºé”™: {e}")
                    continue

            # æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡å¤„ç†å¤±è´¥
            if len(indexed_images) != len(saved_image_paths):
                failed_count = len(saved_image_paths) - len(indexed_images)
                logger.warning(f"æœ‰ {failed_count} å¼ å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œä½†ç»§ç»­æ‰§è¡Œ")

            # å¦‚æœä¸€å¼ å›¾ç‰‡éƒ½æ²¡æˆåŠŸï¼Œè®¤ä¸ºæ˜¯é”™è¯¯
            if not indexed_images:
                logger.error("æ‰€æœ‰å›¾ç‰‡å¤„ç†éƒ½å¤±è´¥äº†")
                try:
                    db.delete_product_images(product_id)
                except Exception as del_e:
                    logger.error(f"å›æ»šåˆ é™¤å¤±è´¥: {del_e}")
                return jsonify({'error': 'All image processing failed'}), 500

            # å®æ—¶ä¿å­˜FAISSç´¢å¼•
            engine.save()

            logger.info(f"å…±å»ºç«‹ {len(indexed_images)} å¼ å›¾ç‰‡çš„ç´¢å¼•")
        else:
            logger.warning("æœªæ‰¾åˆ°å•†å“å›¾ç‰‡")

        # è¿”å›å®Œæ•´çš„å•†å“ä¿¡æ¯
        result = {
            'id': product_id,
            'weidianId': product_info['id'],  # æ·»åŠ å¾®åº—å•†å“ID
            'product_url': product_info['weidian_url'],
            'title': product_info['title'],
            'englishTitle': product_info['english_title'],
            'weidianUrl': product_info['weidian_url'],
            'cnfansUrl': product_info['cnfans_url'],
            'description': product_info['description'],
            'ruleEnabled': True,  # é»˜è®¤å¯ç”¨è§„åˆ™
            'createdAt': datetime.now().isoformat(),
            'images': product_info['images']  # è¿”å›å›¾ç‰‡URLåˆ—è¡¨
        }

        logger.info(f"å•†å“æŠ“å–å®Œæˆ: {product_info['title']}")
        return jsonify(result)

    except Exception as e:
        logger.error(f"æŠ“å–å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# Discord è´¦å·ç®¡ç† API
# ===== ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†API =====

def get_current_user():
    """è·å–å½“å‰ç™»å½•ç”¨æˆ·"""
    user_id = session.get('user_id')
    if user_id:
        return db.get_user_by_id(user_id)
    return None

def require_admin():
    """æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜"""
    user = get_current_user()
    return user and user.get('role') == 'admin'

def can_manage_shops():
    """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ç®¡ç†åº—é“ºçš„æƒé™ï¼ˆç®¡ç†å‘˜æˆ–æœ‰åˆ†é…çš„åº—é“ºï¼‰"""
    user = get_current_user()
    if not user:
        return False
    # ç®¡ç†å‘˜å¯ä»¥ç®¡ç†æ‰€æœ‰åº—é“º
    if user.get('role') == 'admin':
        return True
    # æ™®é€šç”¨æˆ·å¦‚æœæœ‰åˆ†é…çš„åº—é“ºï¼Œä¹Ÿå¯ä»¥ç®¡ç†
    user_shops = user.get('shops', [])
    return len(user_shops) > 0

def require_login():
    """æ£€æŸ¥æ˜¯å¦å·²ç™»å½•"""
    # å¼€å‘æ¨¡å¼ä¸‹è·³è¿‡è®¤è¯
    if config.DEBUG:
        # å¼€å‘æ¨¡å¼ä¸‹è‡ªåŠ¨è®¾ç½®ä¸ºadminç”¨æˆ·
        if 'user_id' not in session:
            session['user_id'] = 1  # é»˜è®¤adminç”¨æˆ·ID
        return True
    return get_current_user() is not None

@app.route('/api/auth/login', methods=['POST'])
def login():
    """ç”¨æˆ·ç™»å½•"""
    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º'}), 400

        username = data['username']
        password = data['password']

        user = db.authenticate_user(username, password)
        if user:
            session['user_id'] = user['id']
            # ä¸è¿”å›å¯†ç å“ˆå¸Œ
            user_info = {k: v for k, v in user.items() if k != 'password_hash'}
            return jsonify({'user': user_info, 'message': 'ç™»å½•æˆåŠŸ'})
        else:
            return jsonify({'error': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
    except Exception as e:
        logger.error(f"ç™»å½•å¤±è´¥: {e}")
        return jsonify({'error': 'ç™»å½•å¤±è´¥'}), 500

@app.route('/api/auth/logout', methods=['POST'])
def logout():
    """ç”¨æˆ·ç™»å‡º"""
    session.pop('user_id', None)
    return jsonify({'message': 'å·²ç™»å‡º'})

@app.route('/api/auth/me', methods=['GET'])
def get_current_user_info():
    """è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯"""
    user = get_current_user()
    if user:
        # ä¸è¿”å›å¯†ç å“ˆå¸Œ
        user_info = {k: v for k, v in user.items() if k != 'password_hash'}
        return jsonify({'user': user_info})
    return jsonify({'error': 'æœªç™»å½•'}), 401

@app.route('/api/users', methods=['GET'])
def get_users():
    """è·å–æ‰€æœ‰ç”¨æˆ·ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        users = db.get_all_users()
        # ä¸è¿”å›å¯†ç å“ˆå¸Œ
        for user in users:
            user.pop('password_hash', None)
        return jsonify({'users': users})
    except Exception as e:
        logger.error(f"è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users', methods=['POST'])
def create_user():
    """åˆ›å»ºæ–°ç”¨æˆ·ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º'}), 400

        username = data['username']
        password = data['password']
        role = data.get('role', 'user')
        shop_ids = data.get('shops', [])

        # åˆ›å»ºç”¨æˆ·
        password_hash = f"hashed_{password}"
        if db.create_user(username, password_hash, role):
            # è·å–æ–°åˆ›å»ºçš„ç”¨æˆ·ID
            user = db.authenticate_user(username, password_hash)
            if user:
                # è®¾ç½®åº—é“ºæƒé™
                if shop_ids:
                    db.update_user_shops(user['id'], shop_ids)

                user_info = {k: v for k, v in user.items() if k != 'password_hash'}
                return jsonify({'user': user_info, 'message': 'ç”¨æˆ·åˆ›å»ºæˆåŠŸ'})
            else:
                return jsonify({'error': 'ç”¨æˆ·åˆ›å»ºå¤±è´¥'}), 500
        else:
            return jsonify({'error': 'ç”¨æˆ·åå·²å­˜åœ¨æˆ–åˆ›å»ºå¤±è´¥'}), 400
    except Exception as e:
        logger.error(f"åˆ›å»ºç”¨æˆ·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """åˆ é™¤ç”¨æˆ·ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        current_user = get_current_user()
        if current_user['id'] == user_id:
            return jsonify({'error': 'ä¸èƒ½åˆ é™¤è‡ªå·±çš„è´¦å·'}), 400

        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        user = db.get_user_by_id(user_id)
        if not user:
            return jsonify({'error': 'ç”¨æˆ·ä¸å­˜åœ¨'}), 404

        # åˆ é™¤ç”¨æˆ·
        if db.delete_user(user_id):
            logger.info(f"ç®¡ç†å‘˜ {current_user['username']} åˆ é™¤äº†ç”¨æˆ· {user['username']}")
            return jsonify({'message': 'ç”¨æˆ·åˆ é™¤æˆåŠŸ'})
        else:
            return jsonify({'error': 'ç”¨æˆ·åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤ç”¨æˆ·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šç®¡ç†å‘˜ä¿®æ”¹ç”¨æˆ·å¯†ç  ===
@app.route('/api/users/<int:user_id>/password', methods=['PUT'])
def reset_user_password(user_id):
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        new_password = data.get('password')
        if not new_password:
            return jsonify({'error': 'å¯†ç ä¸èƒ½ä¸ºç©º'}), 400

        # ç®€å•å“ˆå¸Œ (ç”Ÿäº§ç¯å¢ƒè¯·ç”¨ bcrypt)
        password_hash = f"hashed_{new_password}"

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (password_hash, user_id))
            conn.commit()

        return jsonify({'success': True, 'message': 'å¯†ç å·²é‡ç½®'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šç½‘ç«™é…ç½®ç®¡ç†API ===
@app.route('/api/websites', methods=['GET'])
def get_website_configs():
    """è·å–æ‰€æœ‰ç½‘ç«™é…ç½®åŠå…¶é¢‘é“ç»‘å®šï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œé¿å…N+1æŸ¥è¯¢ï¼‰"""
    try:
        configs = db.get_website_configs()
        return jsonify({'websites': configs})
    except Exception as e:
        logger.error(f"è·å–ç½‘ç«™é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites', methods=['POST'])
def add_website_config():
    """æ·»åŠ ç½‘ç«™é…ç½®"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': 'æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.add_website_config(name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': 'ç½‘ç«™é…ç½®å·²æ·»åŠ '})
        else:
            return jsonify({'error': 'æ·»åŠ å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ·»åŠ ç½‘ç«™é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['PUT'])
def update_website_config(config_id):
    """æ›´æ–°ç½‘ç«™é…ç½®"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        name = data.get('name')
        display_name = data.get('display_name')
        url_template = data.get('url_template')
        id_pattern = data.get('id_pattern')
        badge_color = data.get('badge_color', 'blue')

        if not all([name, display_name, url_template, id_pattern]):
            return jsonify({'error': 'æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.update_website_config(config_id, name, display_name, url_template, id_pattern, badge_color):
            return jsonify({'success': True, 'message': 'ç½‘ç«™é…ç½®å·²æ›´æ–°'})
        else:
            return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°ç½‘ç«™é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>', methods=['DELETE'])
def delete_website_config(config_id):
    """åˆ é™¤ç½‘ç«™é…ç½®"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        if db.delete_website_config(config_id):
            return jsonify({'success': True, 'message': 'ç½‘ç«™é…ç½®å·²åˆ é™¤'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤ç½‘ç«™é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['GET'])
def get_website_channels(config_id):
    """è·å–ç½‘ç«™ç»‘å®šçš„é¢‘é“"""
    try:
        channels = db.get_website_channel_bindings(config_id)
        return jsonify({'channels': channels})
    except Exception as e:
        logger.error(f"è·å–ç½‘ç«™é¢‘é“å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels', methods=['POST'])
def add_website_channel(config_id):
    """æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®š"""
    try:
        data = request.get_json()
        channel_id = data.get('channel_id')

        if not channel_id:
            return jsonify({'error': 'é¢‘é“IDä¸èƒ½ä¸ºç©º'}), 400

        if db.add_website_channel_binding(config_id, channel_id):
            return jsonify({'success': True, 'message': 'é¢‘é“ç»‘å®šå·²æ·»åŠ '})
        else:
            return jsonify({'error': 'æ·»åŠ å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ·»åŠ ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/websites/<int:config_id>/channels/<channel_id>', methods=['DELETE'])
def remove_website_channel(config_id, channel_id):
    """ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®š"""
    try:
        if db.remove_website_channel_binding(config_id, channel_id):
            return jsonify({'success': True, 'message': 'é¢‘é“ç»‘å®šå·²ç§»é™¤'})
        else:
            return jsonify({'error': 'ç§»é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"ç§»é™¤ç½‘ç«™é¢‘é“ç»‘å®šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>/urls', methods=['GET'])
def get_product_urls(product_id):
    """è·å–å•†å“çš„æ‰€æœ‰ç½‘ç«™URL"""
    try:
        # è·å–å•†å“ä¿¡æ¯
        product = db._get_product_info_by_id(product_id)
        if not product:
            return jsonify({'error': 'å•†å“ä¸å­˜åœ¨'}), 404

        # ä»å•†å“URLä¸­æå–å¾®åº—ID
        weidian_url = product.get('product_url', '')
        weidian_id = None

        if 'itemID=' in weidian_url:
            # æå–itemIDå‚æ•°
            import re
            match = re.search(r'itemID=([^&]+)', weidian_url)
            if match:
                weidian_id = match.group(1)

        if not weidian_id:
            return jsonify({'urls': []})

        # ç”Ÿæˆæ‰€æœ‰ç½‘ç«™çš„URL
        urls = db.generate_website_urls(weidian_id)
        return jsonify({'urls': urls})
    except Exception as e:
        logger.error(f"è·å–å•†å“URLå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯API ===
@app.route('/api/system/stats', methods=['GET'])
def get_system_stats():
    """è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯"""
    try:
        stats = db.get_system_stats()
        return jsonify(stats)
    except Exception as e:
        logger.error(f"è·å–ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šå…¬å‘Šç®¡ç†API ===
@app.route('/api/announcements', methods=['GET'])
def get_announcements():
    """è·å–æ‰€æœ‰å…¬å‘Š"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        announcements = db.get_active_announcements()
        return jsonify({'announcements': announcements})
    except Exception as e:
        logger.error(f"è·å–å…¬å‘Šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements', methods=['POST'])
def create_announcement():
    """åˆ›å»ºå…¬å‘Š"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')

        if not title or not content:
            return jsonify({'error': 'æ ‡é¢˜å’Œå†…å®¹éƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.create_announcement(title, content):
            return jsonify({'success': True, 'message': 'å…¬å‘Šåˆ›å»ºæˆåŠŸ'})
        else:
            return jsonify({'error': 'åˆ›å»ºå¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ›å»ºå…¬å‘Šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['PUT'])
def update_announcement(announcement_id):
    """æ›´æ–°å…¬å‘Š"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        title = data.get('title')
        content = data.get('content')
        is_active = data.get('is_active', True)

        if not title or not content:
            return jsonify({'error': 'æ ‡é¢˜å’Œå†…å®¹éƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.update_announcement(announcement_id, title, content, is_active):
            return jsonify({'success': True, 'message': 'å…¬å‘Šæ›´æ–°æˆåŠŸ'})
        else:
            return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°å…¬å‘Šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/announcements/<int:announcement_id>', methods=['DELETE'])
def delete_announcement(announcement_id):
    """åˆ é™¤å…¬å‘Š"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        if db.delete_announcement(announcement_id):
            return jsonify({'success': True, 'message': 'å…¬å‘Šåˆ é™¤æˆåŠŸ'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤å…¬å‘Šå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šæ¶ˆæ¯è¿‡æ»¤è§„åˆ™API ===
@app.route('/api/message-filters', methods=['GET'])
def get_message_filters():
    """è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
    try:
        filters = db.get_message_filters()
        return jsonify({'filters': filters})
    except Exception as e:
        logger.error(f"è·å–æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters', methods=['POST'])
def add_message_filter():
    """æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')

        if not filter_type or not filter_value:
            return jsonify({'error': 'è¿‡æ»¤ç±»å‹å’Œå€¼éƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.add_message_filter(filter_type, filter_value):
            return jsonify({'success': True, 'message': 'è¿‡æ»¤è§„åˆ™æ·»åŠ æˆåŠŸ'})
        else:
            return jsonify({'error': 'æ·»åŠ å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ·»åŠ æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['PUT'])
def update_message_filter(filter_id):
    """æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        filter_type = data.get('filter_type')
        filter_value = data.get('filter_value')
        is_active = data.get('is_active', True)

        if not filter_type or not filter_value:
            return jsonify({'error': 'è¿‡æ»¤ç±»å‹å’Œå€¼éƒ½æ˜¯å¿…å¡«çš„'}), 400

        if db.update_message_filter(filter_id, filter_type, filter_value, is_active):
            return jsonify({'success': True, 'message': 'è¿‡æ»¤è§„åˆ™æ›´æ–°æˆåŠŸ'})
        else:
            return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/message-filters/<int:filter_id>', methods=['DELETE'])
def delete_message_filter(filter_id):
    """åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        if db.delete_message_filter(filter_id):
            return jsonify({'success': True, 'message': 'è¿‡æ»¤è§„åˆ™åˆ é™¤æˆåŠŸ'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤æ¶ˆæ¯è¿‡æ»¤è§„åˆ™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === æ–°å¢ï¼šè‡ªå®šä¹‰å›å¤å†…å®¹API ===
@app.route('/api/custom-replies', methods=['GET'])
def get_custom_replies():
    """è·å–è‡ªå®šä¹‰å›å¤å†…å®¹"""
    try:
        replies = db.get_custom_replies()
        return jsonify({'replies': replies})
    except Exception as e:
        logger.error(f"è·å–è‡ªå®šä¹‰å›å¤å†…å®¹å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies', methods=['POST'])
def add_custom_reply():
    """æ·»åŠ è‡ªå®šä¹‰å›å¤å†…å®¹"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)

        if not reply_type:
            return jsonify({'error': 'å›å¤ç±»å‹æ˜¯å¿…å¡«çš„'}), 400

        if db.add_custom_reply(reply_type, content, image_url, priority):
            return jsonify({'success': True, 'message': 'è‡ªå®šä¹‰å›å¤æ·»åŠ æˆåŠŸ'})
        else:
            return jsonify({'error': 'æ·»åŠ å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ·»åŠ è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['PUT'])
def update_custom_reply(reply_id):
    """æ›´æ–°è‡ªå®šä¹‰å›å¤å†…å®¹"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        reply_type = data.get('reply_type')
        content = data.get('content')
        image_url = data.get('image_url')
        priority = data.get('priority', 0)
        is_active = data.get('is_active', True)

        if not reply_type:
            return jsonify({'error': 'å›å¤ç±»å‹æ˜¯å¿…å¡«çš„'}), 400

        if db.update_custom_reply(reply_id, reply_type, content, image_url, priority, is_active):
            return jsonify({'success': True, 'message': 'è‡ªå®šä¹‰å›å¤æ›´æ–°æˆåŠŸ'})
        else:
            return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/custom-replies/<int:reply_id>', methods=['DELETE'])
def delete_custom_reply(reply_id):
    """åˆ é™¤è‡ªå®šä¹‰å›å¤å†…å®¹"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        if db.delete_custom_reply(reply_id):
            return jsonify({'success': True, 'message': 'è‡ªå®šä¹‰å›å¤åˆ é™¤æˆåŠŸ'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤è‡ªå®šä¹‰å›å¤å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/<int:user_id>/shops', methods=['PUT'])
def update_user_shops(user_id):
    """æ›´æ–°ç”¨æˆ·åº—é“ºæƒé™ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        shop_ids = data.get('shops', [])

        if db.update_user_shops(user_id, shop_ids):
            return jsonify({'message': 'æƒé™æ›´æ–°æˆåŠŸ'})
        else:
            return jsonify({'error': 'æƒé™æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°ç”¨æˆ·æƒé™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """è·å–æ‰€æœ‰ Discord è´¦å·"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    current_user = get_current_user()
    try:
        # æ ¹æ®ç”¨æˆ·æƒé™è¿‡æ»¤è´¦å·
        if current_user['role'] == 'admin':
            # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°æ‰€æœ‰è´¦å·
            accounts = db.get_discord_accounts_by_user(None)
        else:
            # æ™®é€šç”¨æˆ·åªèƒ½çœ‹åˆ°è‡ªå·±å…³è”çš„è´¦å·
            accounts = db.get_discord_accounts_by_user(current_user['id'])

        return jsonify({'accounts': accounts})
    except Exception as e:
        logger.error(f"è·å–è´¦å·åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['GET'])
def list_products():
    """åˆ—å‡ºç”¨æˆ·æœ‰æƒé™çš„å•†å“åŠå…¶å›¾ç‰‡"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    current_user = get_current_user()
    try:
        # è·å–åˆ†é¡µå‚æ•°
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 50))  # é»˜è®¤æ¯é¡µ50æ¡
        offset = (page - 1) * limit

        # æ ¹æ®ç”¨æˆ·æƒé™è·å–å•†å“ï¼ˆæ”¯æŒåˆ†é¡µï¼‰
        if current_user['role'] == 'admin':
            # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°æ‰€æœ‰å•†å“
            logger.info(f"ç®¡ç†å‘˜ç”¨æˆ· {current_user['username']} è·å–å•†å“åˆ—è¡¨ (é¡µ{page}, æ¯é¡µ{limit}æ¡)")
            result = db.get_products_by_user_shops(None, limit=limit, offset=offset)
        else:
            # æ™®é€šç”¨æˆ·åªèƒ½çœ‹åˆ°è‡ªå·±ç®¡ç†çš„åº—é“ºçš„å•†å“
            user_shops = current_user.get('shops', [])
            logger.info(f"æ™®é€šç”¨æˆ· {current_user['username']} è·å–åº—é“ºå•†å“ (é¡µ{page}, æ¯é¡µ{limit}æ¡)ï¼Œåˆ†é…çš„åº—é“º: {user_shops}")
            result = db.get_products_by_user_shops(user_shops, limit=limit, offset=offset)

            # è°ƒè¯•ï¼šæ£€æŸ¥æ•°æ®åº“ä¸­çš„å•†å“å’Œåº—é“ºåŒ¹é…æƒ…å†µ
            if user_shops:
                with db.get_connection() as conn:
                    cursor = conn.cursor()
                    placeholders = ','.join('?' * len(user_shops))
                    cursor.execute(f"SELECT COUNT(*) FROM products WHERE shop_name IN ({placeholders})", user_shops)
                    matching_products = cursor.fetchone()[0]
                    logger.info(f"æ•°æ®åº“ä¸­åŒ¹é…çš„å•†å“æ•°é‡: {matching_products}")

                    # åˆ—å‡ºæ‰€æœ‰åº—é“ºåç§°
                    cursor.execute("SELECT DISTINCT shop_name FROM products")
                    all_shop_names = [row[0] for row in cursor.fetchall()]
                    logger.info(f"æ•°æ®åº“ä¸­çš„æ‰€æœ‰åº—é“ºåç§°: {all_shop_names}")

        logger.info(f"è¿”å›å•†å“æ•°é‡: {len(result['products'])}")

        # æ·»åŠ è°ƒè¯•ä¿¡æ¯åˆ°å“åº”ä¸­
        response_data = {
            'products': result['products'],
            'total': result['total'],
            'debug': {
                'user_role': current_user['role'],
                'user_shops': current_user.get('shops', []),
                'is_admin': current_user['role'] == 'admin'
            }
        }

        # æ·»åŠ ç¼“å­˜å¤´ä»¥ä¼˜åŒ–æ€§èƒ½ï¼ˆ5åˆ†é’Ÿç¼“å­˜ï¼‰
        response = jsonify(response_data)
        response.headers['Cache-Control'] = 'private, max-age=300'
        return response
    except Exception as e:
        logger.error(f"åˆ—å‡ºå•†å“å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/products', methods=['PUT'])
def update_product():
    """æ›´æ–°å•†å“ä¿¡æ¯"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    current_user = get_current_user()

    # æ£€æŸ¥æ˜¯å¦æ˜¯multipart/form-dataï¼ˆåŒ…å«æ–‡ä»¶ä¸Šä¼ ï¼‰
    if request.content_type and 'multipart/form-data' in request.content_type:
        # å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        product_id = request.form.get('id')
        if not product_id:
            return jsonify({'error': 'å•†å“IDä¸èƒ½ä¸ºç©º'}), 400

        try:
            # æ£€æŸ¥æƒé™
            if current_user['role'] == 'admin':
                pass
            else:
                user_shops = current_user.get('shops', [])
                product = db.get_product_by_id(int(product_id))
                if not product or product.get('shop_name') not in user_shops:
                    return jsonify({'error': 'æ— æƒé™æ›´æ–°æ­¤å•†å“'}), 403

            # å¤„ç†ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶
            uploaded_files = []
            if 'uploadedImages' in request.files:
                files = request.files.getlist('uploadedImages')
                for file in files:
                    if file and file.filename:
                        # ä¿å­˜æ–‡ä»¶åˆ°å•†å“å›¾ç‰‡ç›®å½•
                        import uuid
                        import os
                        filename = f"{uuid.uuid4()}_{file.filename}"
                        image_path = os.path.join('data', 'images', str(product_id), filename)

                        # ç¡®ä¿ç›®å½•å­˜åœ¨
                        os.makedirs(os.path.dirname(image_path), exist_ok=True)

                        # ä¿å­˜æ–‡ä»¶
                        file.save(image_path)

                        # æ·»åŠ åˆ°æ•°æ®åº“
                        db.add_product_image(int(product_id), filename)
                        uploaded_files.append(filename)

            # æ„å»ºæ›´æ–°æ•°æ®
            updates = {}
            for key in ['title', 'englishTitle', 'ruleEnabled', 'customReplyText', 'imageSource']:
                value = request.form.get(key)
                if value is not None:
                    if key == 'englishTitle':
                        updates['english_title'] = value
                    elif key == 'ruleEnabled':
                        updates['ruleEnabled'] = value.lower() == 'true'
                    elif key == 'customReplyText':
                        updates['custom_reply_text'] = value
                    elif key == 'imageSource':
                        updates['image_source'] = value
                    else:
                        updates[key] = value

            # å¤„ç†æ•°ç»„æ•°æ®
            if 'selectedImageIndexes' in request.form:
                import json
                try:
                    updates['custom_reply_images'] = json.loads(request.form.get('selectedImageIndexes'))
                except:
                    pass

            if 'customImageUrls' in request.form:
                try:
                    updates['custom_image_urls'] = json.loads(request.form.get('customImageUrls'))
                except:
                    pass

            # æ‰§è¡Œæ›´æ–°
            if updates:
                success = db.update_product(int(product_id), updates)
                if success:
                    updated_product = db.get_product_by_id(int(product_id))
                    return jsonify({'message': 'å•†å“æ›´æ–°æˆåŠŸ', 'product': updated_product})
                else:
                    return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
            else:
                return jsonify({'error': 'æ²¡æœ‰è¦æ›´æ–°çš„å­—æ®µ'}), 400

        except Exception as e:
            logger.error(f"æ›´æ–°å•†å“å¤±è´¥: {e}")
            return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
    else:
        # å¤„ç†JSONæ•°æ®ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
        data = request.get_json()

    if not data or not data.get('id'):
        return jsonify({'error': 'å•†å“IDä¸èƒ½ä¸ºç©º'}), 400

    product_id = data['id']

    try:
            # æ£€æŸ¥æƒé™
        if current_user['role'] == 'admin':
            pass
        else:
            user_shops = current_user.get('shops', [])
            product = db.get_product_by_id(product_id)
            if not product or product.get('shop_name') not in user_shops:
                return jsonify({'error': 'æ— æƒé™æ›´æ–°æ­¤å•†å“'}), 403

            # æ„å»ºæ›´æ–°æ•°æ®
            updates = {}
            if 'title' in data:
                updates['title'] = data['title']
            if 'englishTitle' in data:
                updates['english_title'] = data['englishTitle']
            if 'ruleEnabled' in data:
                updates['ruleEnabled'] = data['ruleEnabled']
            if 'customReplyText' in data:
                updates['custom_reply_text'] = data['customReplyText']
            if 'selectedImageIndexes' in data:
                updates['custom_reply_images'] = data['selectedImageIndexes']
            if 'customImageUrls' in data:
                updates['custom_image_urls'] = data['customImageUrls']
            if 'imageSource' in data:
                updates['image_source'] = data['imageSource']

            # æ‰§è¡Œæ›´æ–°
            if updates:
                success = db.update_product(product_id, updates)
                if success:
                    updated_product = db.get_product_by_id(product_id)
                    return jsonify({'message': 'å•†å“æ›´æ–°æˆåŠŸ', 'product': updated_product})
                else:
                    return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500
            else:
                return jsonify({'error': 'æ²¡æœ‰è¦æ›´æ–°çš„å­—æ®µ'}), 400

    except Exception as e:
        logger.error(f"æ›´æ–°å•†å“å¤±è´¥: {e}")
        return jsonify({'error': 'æ›´æ–°å¤±è´¥'}), 500


@app.route('/api/backfill_products', methods=['POST'])
def backfill_products():
    """ä¸ºå·²å­˜åœ¨ä½†ç¼ºå°‘è‹±åæˆ– cnfans é“¾æ¥çš„å•†å“å›å¡«æ•°æ®"""
    try:
        from weidian_scraper import get_weidian_scraper
        scraper = get_weidian_scraper()

        updated = []
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, product_url, english_title, cnfans_url FROM products")
            rows = cursor.fetchall()

            for row in rows:
                pid = row['id']
                url = row['product_url']
                need_english = not row['english_title']
                need_cnfans = not row['cnfans_url']
                if not (need_english or need_cnfans):
                    continue

                product_info = scraper.scrape_product_info(url)
                if not product_info:
                    logger.warning(f"å›å¡«å¤±è´¥ï¼Œæ— æ³•æŠ“å–: {url}")
                    continue

                english = product_info.get('english_title') or ''
                cnfans = product_info.get('cnfans_url') or ''

                cursor.execute("""
                    UPDATE products
                    SET english_title = ?, cnfans_url = ?
                    WHERE id = ?
                """, (english, cnfans, pid))
                conn.commit()
                updated.append(pid)

        return jsonify({'updated': updated, 'count': len(updated)})
    except Exception as e:
        logger.error(f"å›å¡«å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/rebuild_index', methods=['POST'])
def rebuild_index():
    """é‡å»ºFAISSç´¢å¼•ï¼Œæ¸…ç†è¢«åˆ é™¤çš„å‘é‡"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        from feature_extractor import get_feature_extractor

        logger.info("å¼€å§‹é‡å»ºFAISSç´¢å¼•...")

        # è·å–æ‰€æœ‰æœ‰æ•ˆçš„å›¾ç‰‡è®°å½•ï¼ˆç¡®ä¿å›¾ç‰‡æ–‡ä»¶å­˜åœ¨ï¼‰
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT pi.id, pi.product_id, pi.image_path, pi.image_index
                FROM product_images pi
                JOIN products p ON pi.product_id = p.id
                ORDER BY pi.id
            """)
            all_records = cursor.fetchall()

        # è¿‡æ»¤å‡ºæ–‡ä»¶å­˜åœ¨çš„è®°å½•
        image_records = []
        for record in all_records:
            if os.path.exists(record['image_path']):
                image_records.append(record)
            else:
                logger.warning(f"å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡: {record['image_path']}")

        if not image_records:
            return jsonify({'error': 'æ²¡æœ‰æ‰¾åˆ°å›¾ç‰‡è®°å½•'}), 400

        logger.info(f"æ‰¾åˆ° {len(image_records)} å¼ å›¾ç‰‡è®°å½•")

        # é‡æ–°æå–ç‰¹å¾å¹¶é‡å»ºç´¢å¼•
        extractor = get_feature_extractor()
        engine = get_vector_engine()

        # åˆ›å»ºæ–°ç´¢å¼•
        vectors_data = []
        for record in image_records:
            try:
                image_path = record['image_path']
                if not os.path.exists(image_path):
                    logger.warning(f"å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨: {image_path}")
                    continue

                # æå–ç‰¹å¾
                features = extractor.extract_feature(image_path)
                if features is not None:
                    vectors_data.append((record['id'], features))
                    logger.info(f"é‡æ–°æå–ç‰¹å¾: {record['id']}")
                else:
                    logger.warning(f"ç‰¹å¾æå–å¤±è´¥: {image_path}")

            except Exception as e:
                logger.error(f"å¤„ç†å›¾ç‰‡ {record['id']} å¤±è´¥: {e}")
                continue

        # é‡å»ºç´¢å¼•
        success = engine.rebuild_index(vectors_data)
        if success:
            logger.info(f"ç´¢å¼•é‡å»ºå®Œæˆï¼ŒåŒ…å« {len(vectors_data)} ä¸ªå‘é‡")
            return jsonify({
                'success': True,
                'message': f'ç´¢å¼•é‡å»ºå®Œæˆï¼ŒåŒ…å« {len(vectors_data)} ä¸ªæœ‰æ•ˆå‘é‡',
                'total_vectors': len(vectors_data)
            })
        else:
            return jsonify({'error': 'ç´¢å¼•é‡å»ºå¤±è´¥'}), 500

    except Exception as e:
        logger.error(f"é‡å»ºç´¢å¼•å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/rebuild_vectors', methods=['POST'])
def rebuild_vectors():
    """ä¸ºå·²æœ‰å•†å“ï¼ˆæˆ–ç¼ºå¤±å‘é‡çš„å›¾ç‰‡ï¼‰é‡å»ºç‰¹å¾å¹¶æ’å…¥ FAISS"""
    try:
        extractor = get_feature_extractor()
        rebuilt = []
        failed = []

        with db.get_connection() as conn:
            cursor = conn.cursor()
            # æŸ¥æ‰¾æ‰€æœ‰ product_images ä¸­ milvus_id ä¸ºç©ºæˆ– NULL çš„è®°å½•
            cursor.execute("SELECT id, product_id, image_path, image_index FROM product_images WHERE milvus_id IS NULL OR milvus_id = ''")
            rows = cursor.fetchall()

        for row in rows:
            pid = row['product_id']
            img_path = row['image_path']
            idx = row['image_index']
            try:
                features = extractor.extract_feature(img_path)
                if features is None:
                    logger.error(f"é‡å»ºç‰¹å¾å¤±è´¥: {img_path}")
                    failed.append({'product_id': pid, 'image_index': idx})
                    continue

                success = db.insert_image_vector(product_id=pid, image_path=img_path, image_index=idx, vector=features)
                if success:
                    rebuilt.append({'product_id': pid, 'image_index': idx})
                else:
                    failed.append({'product_id': pid, 'image_index': idx})
            except Exception as e:
                logger.error(f"é‡å»ºå‘é‡å‡ºé”™: {e}")
                failed.append({'product_id': pid, 'image_index': idx})

        return jsonify({'rebuilt': rebuilt, 'failed': failed, 'count': len(rebuilt)})
    except Exception as e:
        logger.error(f"é‡å»ºå‘é‡å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500



@app.route('/api/image/<int:product_id>/<int:image_index>', methods=['GET'])
def serve_product_image(product_id: int, image_index: int):
    """è¿”å›æŒ‡å®šå•†å“æŒ‡å®šåºå·çš„å›¾ç‰‡æ–‡ä»¶ï¼ˆç”¨äºå‰ç«¯ç¼©ç•¥å›¾/æŸ¥çœ‹ï¼‰"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_path FROM product_images WHERE product_id = ? AND image_index = ?", (product_id, image_index))
            row = cursor.fetchone()
            if not row:
                return jsonify({'error': 'Image not found'}), 404
            image_path = row[0]

        # å®‰å…¨æ£€æŸ¥å¹¶è¿”å›æ–‡ä»¶
        from flask import send_file
        if not os.path.exists(image_path):
            return jsonify({'error': 'Image file missing'}), 404
        return send_file(image_path, mimetype='image/jpeg')
    except Exception as e:
        logger.error(f"serve_product_image å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

def verify_discord_token(token):
    """éªŒè¯Discord tokenå¹¶è·å–ç”¨æˆ·ä¿¡æ¯"""
    try:
        headers = {
            'Authorization': f'Bot {token}' if token.startswith('Bot ') else token,
            'User-Agent': 'DiscordBot/1.0'
        }

        # é¦–å…ˆå°è¯•ä½œä¸ºBot tokenéªŒè¯
        response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 401:
            # å¦‚æœBot tokenå¤±è´¥ï¼Œå°è¯•ä½œä¸ºUser token
            if not token.startswith('Bot '):
                headers['Authorization'] = f'Bot {token}'
                response = requests.get('https://discord.com/api/v10/users/@me', headers=headers, timeout=10)

        if response.status_code == 200:
            user_data = response.json()
            return {
                'valid': True,
                'username': f"{user_data.get('username', 'Unknown')}#{user_data.get('discriminator', '0000')}",
                'user_id': user_data.get('id'),
                'avatar': user_data.get('avatar'),
                'bot': user_data.get('bot', False)
            }
        else:
            return {
                'valid': False,
                'error': f'HTTP {response.status_code}: {response.text}'
            }
    except requests.exceptions.RequestException as e:
        return {
            'valid': False,
            'error': f'ç½‘ç»œé”™è¯¯: {str(e)}'
        }
    except Exception as e:
        return {
            'valid': False,
            'error': f'éªŒè¯å¤±è´¥: {str(e)}'
        }

@app.route('/api/accounts', methods=['POST'])
def add_account():
    """æ·»åŠ æ–°çš„ Discord è´¦å·"""
    try:
        # è·å–å½“å‰ç™»å½•ç”¨æˆ·
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        token = data.get('token')
        username = data.get('username', '')

        if not token:
            return jsonify({'error': 'Token is required'}), 400

        # éªŒè¯tokenå¹¶è·å–çœŸå®ç”¨æˆ·å
        logger.info("æ­£åœ¨éªŒè¯Discord token...")
        token_info = verify_discord_token(token)

        if not token_info['valid']:
            return jsonify({'error': f'TokenéªŒè¯å¤±è´¥: {token_info["error"]} è¯·æ£€æŸ¥tokenæ˜¯å¦æ­£ç¡®'}), 400

        # å¦‚æœæ²¡æœ‰æä¾›ç”¨æˆ·åï¼Œä½¿ç”¨ä»tokenè·å–çš„ç”¨æˆ·å
        if not username:
            username = token_info['username']
            logger.info(f"è‡ªåŠ¨è·å–ç”¨æˆ·å: {username}")

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO discord_accounts (username, token, status, user_id)
                VALUES (?, ?, 'offline', ?)
            """, (username, token, current_user['id']))
            account_id = cursor.lastrowid

            cursor.execute("SELECT id, username, token, status, last_active, user_id FROM discord_accounts WHERE id = ?", (account_id,))
            account = cursor.fetchone()
            conn.commit()

        logger.info(f"è´¦å·æ·»åŠ æˆåŠŸ: {username} (ç”¨æˆ·ID: {current_user['id']})")
        return jsonify({
            'id': account[0],
            'username': account[1],
            'token': account[2],
            'status': account[3],
            'lastActive': account[4],
            'user_id': account[5],
            'verified': True
        })
    except Exception as e:
        logger.error(f"æ·»åŠ è´¦å·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/user', methods=['PUT'])
def assign_account_to_user(account_id):
    """å°†Discordè´¦å·åˆ†é…ç»™ç”¨æˆ·ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        data = request.get_json()
        user_id = data.get('user_id')

        if db.update_discord_account_user(account_id, user_id):
            return jsonify({'message': 'è´¦å·åˆ†é…æˆåŠŸ'})
        else:
            return jsonify({'error': 'è´¦å·åˆ†é…å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ†é…è´¦å·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>', methods=['DELETE'])
def delete_account(account_id):
    """åˆ é™¤ Discord è´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM discord_accounts WHERE id = ?", (account_id,))
            conn.commit()

        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"åˆ é™¤è´¦å·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/<int:account_id>/status', methods=['PUT'])
def update_account_status(account_id):
    """æ›´æ–°è´¦å·çŠ¶æ€"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        status = data.get('status')

        if status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status'}), 400

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE discord_accounts
                SET status = ?, updated_at = datetime('now')
                WHERE id = ?
            """, (status, account_id))
            conn.commit()

        return jsonify({'success': True, 'status': status})
    except Exception as e:
        logger.error(f"æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/current', methods=['GET'])
def get_current_account():
    """è·å–å½“å‰å¯ç”¨çš„ Discord è´¦å· (çŠ¶æ€ä¸ºonlineçš„ç¬¬ä¸€ä¸ª)"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, username, token, status, last_active
                FROM discord_accounts
                WHERE status = 'online'
                ORDER BY last_active DESC NULLS LAST, created_at ASC
                LIMIT 1
            """)
            account = cursor.fetchone()

            if account:
                return jsonify({
                    'id': account[0],
                    'username': account[1],
                    'token': account[2],
                    'status': account[3],
                    'lastActive': account[4]
                })
            else:
                return jsonify({'error': 'No active account found'}), 404
    except Exception as e:
        logger.error(f"è·å–å½“å‰è´¦å·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/verify-all', methods=['POST'])
def verify_all_accounts():
    """é‡æ–°éªŒè¯æ‰€æœ‰è´¦å·"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            # è·å–æ‰€æœ‰è´¦å·
            cursor.execute("SELECT id, username, token FROM discord_accounts")
            accounts = cursor.fetchall()

            verified_count = 0
            invalid_count = 0
            results = []

            for account in accounts:
                account_id, username, token = account
                logger.info(f"æ­£åœ¨éªŒè¯è´¦å·: {username}")

                token_info = verify_discord_token(token)

                if token_info['valid']:
                    # æ›´æ–°ç”¨æˆ·åï¼ˆå¦‚æœæœ‰å˜åŒ–ï¼‰
                    new_username = token_info['username']
                    if new_username != username:
                        cursor.execute("""
                            UPDATE discord_accounts
                            SET username = ?
                            WHERE id = ?
                        """, (new_username, account_id))
                        logger.info(f"ç”¨æˆ·åå·²æ›´æ–°: {username} -> {new_username}")

                    verified_count += 1
                    results.append({
                        'id': account_id,
                        'username': new_username,
                        'valid': True
                    })
                else:
                    invalid_count += 1
                    results.append({
                        'id': account_id,
                        'username': username,
                        'valid': False,
                        'error': token_info['error']
                    })

            conn.commit()

        return jsonify({
            'success': True,
            'total': len(accounts),
            'verified': verified_count,
            'invalid': invalid_count,
            'results': results
        })
    except Exception as e:
        logger.error(f"æ‰¹é‡éªŒè¯è´¦å·å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/bulk-status', methods=['POST'])
def bulk_update_status():
    """æ‰¹é‡å¼€å¯æˆ–åœæ­¢æ‰€æœ‰è´¦å·"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        new_status = data.get('status')
        if new_status not in ['online', 'offline']:
            return jsonify({'error': 'Invalid status. Must be "online" or "offline"'}), 400

        with db.get_connection() as conn:
            cursor = conn.cursor()

            if new_status == 'online':
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'online', last_active = ?
                """, (datetime.now(),))
            else:
                cursor.execute("""
                    UPDATE discord_accounts
                    SET status = 'offline'
                """)

            updated_count = cursor.rowcount
            conn.commit()

        logger.info(f"æ‰¹é‡æ›´æ–°è´¦å·çŠ¶æ€: {updated_count} ä¸ªè´¦å·è®¾ç½®ä¸º {new_status}")

        return jsonify({
            'success': True,
            'updated_count': updated_count,
            'new_status': new_status
        })
    except Exception as e:
        logger.error(f"æ‰¹é‡æ›´æ–°è´¦å·çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/rotation', methods=['GET'])
def get_rotation_config():
    """è·å–è´¦å·è½®æ¢é…ç½®"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT enabled, rotation_interval, current_account_id
                FROM account_rotation_config
                LIMIT 1
            """)
            row = cursor.fetchone()

        if row:
            return jsonify({
                'enabled': row[0],
                'rotationInterval': row[1],
                'currentAccountId': row[2]
            })
        return jsonify({'enabled': False, 'rotationInterval': 10})
    except Exception as e:
        logger.error(f"è·å–è½®æ¢é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/user/settings', methods=['GET'])
def get_user_settings():
    """è·å–å½“å‰ç”¨æˆ·çš„ä¸ªæ€§åŒ–è®¾ç½®"""
    user = get_current_user()
    if not user:
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        settings = db.get_user_settings(user['id'])
        return jsonify(settings)
    except Exception as e:
        logger.error(f"è·å–ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
        return jsonify({'error': 'è·å–è®¾ç½®å¤±è´¥'}), 500

@app.route('/api/user/settings', methods=['PUT'])
def update_user_settings():
    """æ›´æ–°å½“å‰ç”¨æˆ·çš„ä¸ªæ€§åŒ–è®¾ç½®"""
    user = get_current_user()
    if not user:
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        success = db.update_user_settings(
            user_id=user['id'],
            download_threads=data.get('download_threads'),
            feature_extract_threads=data.get('feature_extract_threads'),
            discord_similarity_threshold=data.get('discord_similarity_threshold'),
            global_reply_min_delay=data.get('global_reply_min_delay'),
            global_reply_max_delay=data.get('global_reply_max_delay'),
            user_blacklist=data.get('user_blacklist'),
            keyword_filters=data.get('keyword_filters')
        )

        if success:
            return jsonify({'message': 'è®¾ç½®æ›´æ–°æˆåŠŸ'})
        else:
            return jsonify({'error': 'è®¾ç½®æ›´æ–°å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°ç”¨æˆ·è®¾ç½®å¤±è´¥: {e}")
        return jsonify({'error': 'æ›´æ–°è®¾ç½®å¤±è´¥'}), 500

@app.route('/api/accounts/rotation', methods=['POST'])
def update_rotation_config():
    """æ›´æ–°è´¦å·è½®æ¢é…ç½®"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        enabled = data.get('enabled', False)
        rotation_interval = data.get('rotationInterval', 10)

        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE account_rotation_config
                SET enabled = ?, rotation_interval = ?, updated_at = datetime('now')
                WHERE id = 1
            """, (enabled, rotation_interval))
            conn.commit()

        return jsonify({'success': True, 'enabled': enabled, 'rotationInterval': rotation_interval})
    except Exception as e:
        logger.error(f"æ›´æ–°è½®æ¢é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/get_indexed_ids', methods=['GET'])
def get_indexed_ids():
    """è·å–å·²å»ºç«‹ç´¢å¼•çš„å•†å“URLåˆ—è¡¨"""
    try:
        indexed_urls = db.get_indexed_product_urls()
        return jsonify({'indexedIds': indexed_urls})
    except Exception as e:
        logger.error(f"è·å–å·²ç´¢å¼•IDå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === ä¿®å¤ï¼šæ‰¹é‡åˆ é™¤ API ===
@app.route('/api/products/batch', methods=['DELETE'])
def batch_delete_products():
    """æ‰¹é‡åˆ é™¤å•†å“ï¼ˆå¤šçº¿ç¨‹é«˜æ€§èƒ½ç‰ˆï¼‰"""
    try:
        data = request.get_json()
        ids = data.get('ids', [])
        if not ids:
            return jsonify({'error': 'No IDs provided'}), 400

        logger.info(f"å¼€å§‹æ‰¹é‡åˆ é™¤ {len(ids)} ä¸ªå•†å“")

        # ä½¿ç”¨å¤šçº¿ç¨‹åˆ é™¤
        import concurrent.futures
        max_threads = min(5, len(ids))  # åˆ é™¤ç”¨è¾ƒå°‘çš„çº¿ç¨‹ï¼Œé¿å…IOå†²çª

        deleted_count = 0
        failed_ids = []

        def delete_single_product(product_id):
            """åˆ é™¤å•ä¸ªå•†å“"""
            try:
                # åˆ›å»ºæ–°çš„æ•°æ®åº“å®ä¾‹é¿å…å¤šçº¿ç¨‹å†²çª
                from database import Database
                temp_db = Database()
                if temp_db.delete_product_images(product_id):
                    return {'success': True, 'id': product_id}
                else:
                    return {'success': False, 'id': product_id}
            except Exception as e:
                logger.error(f"åˆ é™¤å•†å“ {product_id} å¤±è´¥: {e}")
                return {'success': False, 'id': product_id}

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(delete_single_product, pid) for pid in ids]

            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result['success']:
                    deleted_count += 1
                else:
                    failed_ids.append(result['id'])

        logger.info(f"æ‰¹é‡åˆ é™¤å®Œæˆ: {deleted_count}/{len(ids)} ä¸ªå•†å“æˆåŠŸåˆ é™¤")

        response = {'success': True, 'count': deleted_count, 'total': len(ids)}
        if failed_ids:
            response['failed_ids'] = failed_ids
            response['warning'] = f'{len(failed_ids)} ä¸ªå•†å“åˆ é™¤å¤±è´¥'

        return jsonify(response)
    except Exception as e:
        logger.error(f"æ‰¹é‡åˆ é™¤å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/batch-delete-all', methods=['DELETE'])
def batch_delete_all_products():
    """åˆ é™¤æ‰€æœ‰å•†å“ï¼ˆå…¨é€‰åˆ é™¤ï¼‰"""
    try:
        # è·å–æ‰€æœ‰å•†å“ID
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM products")
            all_ids = [row['id'] for row in cursor.fetchall()]

        if not all_ids:
            return jsonify({'success': True, 'count': 0, 'message': 'æ²¡æœ‰å•†å“éœ€è¦åˆ é™¤'})

        logger.info(f"å¼€å§‹åˆ é™¤æ‰€æœ‰ {len(all_ids)} ä¸ªå•†å“")

        # ä½¿ç”¨å¤šçº¿ç¨‹åˆ é™¤æ‰€æœ‰å•†å“
        import concurrent.futures
        max_threads = min(5, len(all_ids))

        deleted_count = 0
        failed_ids = []

        def delete_single_product(product_id):
            try:
                # åˆ›å»ºæ–°çš„æ•°æ®åº“å®ä¾‹é¿å…å¤šçº¿ç¨‹å†²çª
                from database import Database
                temp_db = Database()
                if temp_db.delete_product_images(product_id):
                    return {'success': True, 'id': product_id}
                else:
                    return {'success': False, 'id': product_id}
            except Exception as e:
                logger.error(f"åˆ é™¤å•†å“ {product_id} å¤±è´¥: {e}")
                return {'success': False, 'id': product_id}

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(delete_single_product, pid) for pid in all_ids]

            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result['success']:
                    deleted_count += 1
                else:
                    failed_ids.append(result['id'])

        logger.info(f"å…¨é€‰åˆ é™¤å®Œæˆ: {deleted_count}/{len(all_ids)} ä¸ªå•†å“æˆåŠŸåˆ é™¤")

        response = {
            'success': True,
            'count': deleted_count,
            'total': len(all_ids),
            'message': f'æˆåŠŸåˆ é™¤ {deleted_count} ä¸ªå•†å“'
        }

        if failed_ids:
            response['failed_ids'] = failed_ids
            response['warning'] = f'{len(failed_ids)} ä¸ªå•†å“åˆ é™¤å¤±è´¥'

        return jsonify(response)
    except Exception as e:
        logger.error(f"å…¨é€‰åˆ é™¤å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/products/<int:product_id>', methods=['DELETE'])
def delete_product(product_id):
    """åˆ é™¤å•†å“åŠå…¶æ‰€æœ‰ç›¸å…³æ•°æ®"""
    try:
        # åˆ é™¤å•†å“åŠå…¶å‘é‡æ•°æ®
        if db.delete_product_images(product_id):
            return jsonify({'success': True, 'message': f'å•†å“ {product_id} å·²åˆ é™¤'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"åˆ é™¤å•†å“å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === ä¿®å¤ï¼šå•†å“å›¾ç‰‡ä¸Šä¼  API ===
@app.route('/api/products/<int:product_id>/images', methods=['POST'])
def upload_product_image(product_id):
    """ä¸Šä¼ æ–°å›¾ç‰‡åˆ°å•†å“ï¼ˆè°ƒç”¨å®Œæ•´çš„æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼‰"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    file = request.files.get('image')
    if not file:
        return jsonify({'error': 'æ— æ–‡ä»¶'}), 400

    try:
        # è·å–ç°æœ‰ç‰¹å¾ç”¨äºæŸ¥é‡
        existing_images = db.get_product_images(product_id)
        existing_feats = [img['features'] for img in existing_images if img['features']]

        # è·å–ä¸‹ä¸€ä¸ª index
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT MAX(image_index) FROM product_images WHERE product_id = ?", (product_id,))
            row = cursor.fetchone()
            next_index = (row[0] + 1) if row and row[0] is not None else 0

            # æ£€æŸ¥å›¾ç‰‡æ•°é‡é™åˆ¶ï¼ˆæ¯ä¸ªå•†å“æœ€å¤š20å¼ å›¾ç‰‡ï¼‰
            cursor.execute("SELECT COUNT(*) FROM product_images WHERE product_id = ?", (product_id,))
            count_row = cursor.fetchone()
            if count_row and count_row[0] >= 20:
                return jsonify({'error': 'æ¯ä¸ªå•†å“æœ€å¤šåªèƒ½ä¸Šä¼ 20å¼ å›¾ç‰‡'}), 400

        # è°ƒç”¨æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼ˆç°åœ¨åŒ…å«å®Œæ•´çš„æ•°æ®åº“å’ŒFAISSæ“ä½œï¼‰
        result = process_and_save_image_core(product_id, file, next_index, existing_feats)

        if not result['success']:
            return jsonify({'error': result['error']}), 400

        # è¿”å›æ›´æ–°åçš„å•†å“ä¿¡æ¯
        product = db._get_product_info_by_id(product_id)

        # è·å–æ‰€æœ‰å›¾ç‰‡
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            images = [f"/api/image/{product_id}/{row[0]}" for row in cursor.fetchall()]

        product['images'] = images

        # æ ¼å¼åŒ–ä»¥åŒ¹é…å‰ç«¯
        product['weidianId'] = product.get('product_url', '').split('itemID=')[1] if 'itemID=' in product.get('product_url', '') else ''
        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['ruleEnabled'] = product.get('ruleEnabled')
        product['matchType'] = 'fuzzy'

        return jsonify({'success': True, 'product': product})

    except Exception as e:
        logger.error(f"ä¸Šä¼ å›¾ç‰‡å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

# === ä¿®å¤ï¼šåˆ é™¤å›¾ç‰‡åè¿”å›æœ€æ–° Product å¯¹è±¡ ===
@app.route('/api/products/<int:product_id>/images/<int:image_index>', methods=['DELETE'])
def delete_product_image(product_id, image_index):
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        logger.info(f"å¼€å§‹åˆ é™¤å›¾ç‰‡: product_id={product_id}, image_index={image_index}")


        # éªŒè¯å‚æ•°
        try:
            product_id = int(product_id)
            image_index = int(image_index)
        except ValueError:
            return jsonify({'error': 'å‚æ•°æ ¼å¼é”™è¯¯'}), 400

        # è°ƒç”¨æ•°æ®åº“åˆ é™¤é€»è¾‘
        success = db.delete_image_vector(product_id, image_index)

        if not success:
            logger.warning(f"åˆ é™¤å›¾ç‰‡å¤±è´¥: product_id={product_id}, image_index={image_index}")
            return jsonify({'error': 'åˆ é™¤å¤±è´¥ï¼Œå›¾ç‰‡å¯èƒ½ä¸å­˜åœ¨'}), 404

        # è·å–æœ€æ–°å•†å“ä¿¡æ¯
        product = db._get_product_info_by_id(product_id)

        if not product:
            logger.error(f"åˆ é™¤åå•†å“ä¸å­˜åœ¨: product_id={product_id}")
            return jsonify({'error': 'å•†å“ä¸å­˜åœ¨'}), 404

        # è·å–å‰©ä½™æ‰€æœ‰å›¾ç‰‡
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT image_index FROM product_images WHERE product_id = ? ORDER BY image_index", (product_id,))
            image_indices = [row[0] for row in cursor.fetchall()]
            images = [f"/api/image/{product_id}/{idx}" for idx in image_indices]

        product['images'] = images

        # æ ¼å¼åŒ–å•†å“ä¿¡æ¯
        try:
            if 'itemID=' in product.get('product_url', ''):
                product['weidianId'] = product.get('product_url', '').split('itemID=')[1]
            else:
                product['weidianId'] = ''
        except:
            product['weidianId'] = ''

        product['weidianUrl'] = product.get('product_url')
        product['englishTitle'] = product.get('english_title')
        product['cnfansUrl'] = product.get('cnfans_url')
        product['acbuyUrl'] = product.get('acbuy_url')
        product['ruleEnabled'] = product.get('ruleEnabled')

        logger.info(f"åˆ é™¤å›¾ç‰‡æˆåŠŸ: product_id={product_id}, image_index={image_index}, å‰©ä½™å›¾ç‰‡æ•°é‡={len(images)}")

        return jsonify({'success': True, 'product': product})

    except Exception as e:
        logger.error(f"åˆ é™¤å›¾ç‰‡å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/cleanup/images', methods=['POST'])
def cleanup_images():
    """æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': 'åªæœ‰ç®¡ç†å‘˜å¯ä»¥æ‰§è¡Œæ¸…ç†æ“ä½œ'}), 403

        # è·å–æ¸…ç†å‚æ•°
        data = request.get_json() or {}
        days_old = data.get('days_old', 30)

        # æ‰§è¡Œæ¸…ç†
        deleted_count = db.cleanup_unused_images(days_old)

        return jsonify({
            'success': True,
            'message': f'æ¸…ç†å®Œæˆï¼Œå…±åˆ é™¤ {deleted_count} ä¸ªæœªä½¿ç”¨çš„å›¾ç‰‡æ–‡ä»¶',
            'deleted_count': deleted_count
        })

    except Exception as e:
        logger.error(f"å›¾ç‰‡æ¸…ç†å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/ai-status', methods=['GET'])
def get_ai_status():
    """è·å–AIç³»ç»Ÿå®Œæ•´çŠ¶æ€å’Œè¯Šæ–­ä¿¡æ¯"""
    try:
        extractor = get_global_feature_extractor()
        if extractor is None:
            return {'error': 'ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–'}
        ai_status = extractor.get_status()

        # è·å–FAISSçŠ¶æ€
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        faiss_engine = get_vector_engine()
        faiss_status = faiss_engine.get_stats()

        # ç»¼åˆçŠ¶æ€
        overall_status = {
            'ai_model_status': ai_status,
            'vector_engine_status': faiss_status,
            'system_health': 'è‰¯å¥½' if ai_status['yolo_available'] and faiss_status['total_vectors'] >= 0 else 'éœ€è¦ä¼˜åŒ–',
            'recommendations': []
        }

        # ç”Ÿæˆå»ºè®®
        recommendations = []
        recommendations.extend(ai_status.get('performance_tips', []))
        recommendations.extend(faiss_status.get('performance_tips', []))

        # é¢å¤–çš„ç³»ç»Ÿçº§å»ºè®®
        if not ai_status['yolo_available']:
            recommendations.append("YOLOè£å‰ªåŠŸèƒ½å·²ç¦ç”¨ï¼Œå›¾åƒè¯†åˆ«å‡†ç¡®ç‡ä¼šé™ä½")
        if faiss_status['total_vectors'] == 0:
            recommendations.append("å‘é‡æ•°æ®åº“ä¸ºç©ºï¼Œå»ºè®®æ·»åŠ å•†å“æ•°æ®")
        if faiss_status['ef_construction'] == 'ä¸æ”¯æŒ' or faiss_status['ef_search'] == 'ä¸æ”¯æŒ':
            recommendations.append("FAISSç‰ˆæœ¬è¾ƒæ—§ï¼Œå»ºè®®å‡çº§ä»¥è·å¾—æœ€ä½³æœç´¢æ€§èƒ½")

        overall_status['recommendations'] = recommendations[:5]  # æœ€å¤šæ˜¾ç¤º5æ¡å»ºè®®

        return jsonify(overall_status)
    except Exception as e:
        logger.error(f"è·å–AIçŠ¶æ€å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/rebuild-index', methods=['POST'])
def rebuild_faiss_index():
    """é‡å»ºFAISSç´¢å¼•ï¼Œæ¸…ç†å·²åˆ é™¤çš„å‘é‡"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        current_user = get_current_user()
        if current_user['role'] != 'admin':
            return jsonify({'error': 'åªæœ‰ç®¡ç†å‘˜å¯ä»¥é‡å»ºç´¢å¼•'}), 403

        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()

        # è·å–æ‰€æœ‰æœ‰æ•ˆçš„å›¾ç‰‡æ•°æ®
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, image_path FROM product_images WHERE id IS NOT NULL")
            all_images = cursor.fetchall()

        # é‡æ–°æå–æ‰€æœ‰ç‰¹å¾
        valid_vectors = []
        for row in all_images:
            try:
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–")
                    continue
                features = extractor.extract_feature(row['image_path'])
                if features is not None:
                    valid_vectors.append((row['id'], features))
            except Exception as e:
                logger.warning(f"é‡æ–°æå–ç‰¹å¾å¤±è´¥ {row['image_path']}: {e}")

        # é‡å»ºç´¢å¼•
        engine.rebuild_index(valid_vectors)

        return jsonify({
            'success': True,
            'message': f'ç´¢å¼•é‡å»ºå®Œæˆï¼ŒåŒ…å« {len(valid_vectors)} ä¸ªå‘é‡',
            'total_vectors': len(valid_vectors)
        })

    except Exception as e:
        logger.error(f"é‡å»ºç´¢å¼•å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config', methods=['GET'])
def get_config():
    """è·å–ç³»ç»Ÿé…ç½®ä¿¡æ¯"""
    try:
        from config import config
        return jsonify({
            'version': '1.0.0',
            'features': {
                'multithread_scraping': True,
                'ai_image_processing': True,
                'discord_bot': True,
                'real_time_monitoring': True
            },
            'limits': {
                'max_scrape_threads': config.SCRAPE_THREADS,
                'max_download_threads': config.DOWNLOAD_THREADS,
                'max_feature_threads': config.FEATURE_EXTRACT_THREADS
            }
        })
    except Exception as e:
        logger.error(f"è·å–é…ç½®ä¿¡æ¯å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['GET'])
def get_discord_threshold():
    """è·å–Discordç›¸ä¼¼åº¦é˜ˆå€¼"""
    try:
        sys_config = db.get_system_config()
        threshold = sys_config['discord_similarity_threshold']
        return jsonify({
            'threshold': threshold,
            'threshold_percentage': threshold * 100
        })
    except Exception as e:
        logger.error(f"è·å–Discordé˜ˆå€¼å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-threshold', methods=['POST'])
def update_discord_threshold():
    """æ›´æ–°Discordç›¸ä¼¼åº¦é˜ˆå€¼"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        threshold = float(data.get('threshold', 0.4))

        # éªŒè¯èŒƒå›´
        if not (0.0 <= threshold <= 1.0):
            return jsonify({'error': 'é˜ˆå€¼å¿…é¡»åœ¨0.0-1.0ä¹‹é—´'}), 400

        # ä¿å­˜åˆ°æ•°æ®åº“
        if db.update_system_config(discord_similarity_threshold=threshold):
            # åŒæ—¶æ›´æ–°å†…å­˜ä¸­çš„é…ç½®

            return jsonify({
                'message': f'Discordç›¸ä¼¼åº¦é˜ˆå€¼å·²æ›´æ–°ä¸º {threshold}',
                'threshold': threshold
            })

        return jsonify({'error': 'æ›´æ–°é…ç½®å¤±è´¥'}), 500
    except ValueError as e:
        return jsonify({'error': 'é˜ˆå€¼å¿…é¡»æ˜¯æ•°å­—'}), 400
    except Exception as e:
        logger.error(f"æ›´æ–°Discordé˜ˆå€¼å¤±è´¥: {e}")
        return jsonify({'error': 'æ›´æ–°é…ç½®å¤±è´¥'}), 500

@app.route('/api/config/scrape-threads', methods=['GET', 'POST'])
def config_scrape_threads():
    """é…ç½®æŠ“å–å¤šçº¿ç¨‹æ•°é‡"""
    if request.method == 'GET':
        config = db.get_system_config()
        return jsonify({
            'scrape_threads': config.get('scrape_threads', 2)
        })

    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        scrape_threads = int(data.get('scrape_threads', 2))

        # ç¡®ä¿çº¿ç¨‹æ•°åœ¨åˆç†èŒƒå›´å†…
        if scrape_threads < 1 or scrape_threads > 10:
            return jsonify({'error': 'æŠ“å–çº¿ç¨‹æ•°å¿…é¡»æ˜¯1-10ä¹‹é—´çš„æ•´æ•°'}), 400

        # ä¿å­˜åˆ°æ•°æ®åº“
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('UPDATE system_config SET scrape_threads = ?, updated_at = CURRENT_TIMESTAMP WHERE id = 1',
                          (scrape_threads,))
            conn.commit()

        return jsonify({
            'message': f'æŠ“å–çº¿ç¨‹æ•°å·²è®¾ç½®ä¸º {scrape_threads}',
            'scrape_threads': scrape_threads
        })

    except ValueError as e:
        return jsonify({'error': 'çº¿ç¨‹æ•°å¿…é¡»æ˜¯æ•´æ•°'}), 400
    except Exception as e:
        logger.error(f"æ›´æ–°æŠ“å–çº¿ç¨‹é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': 'æ›´æ–°é…ç½®å¤±è´¥'}), 500

@app.route('/api/config/global-reply-delay', methods=['GET'])
def get_global_reply_delay():
    """è·å–å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
    try:
        delay_config = db.get_global_reply_config()
        return jsonify({
            'min_delay': delay_config['min_delay'],
            'max_delay': delay_config['max_delay'],
            'description': f'{delay_config["min_delay"]}-{delay_config["max_delay"]}ç§’éšæœºå»¶è¿Ÿ'
        })
    except Exception as e:
        logger.error(f"è·å–å…¨å±€å›å¤å»¶è¿Ÿå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/debug/faiss_status', methods=['GET'])
def get_faiss_status():
    """è·å–FAISSå‘é‡æ•°æ®åº“çŠ¶æ€"""
    try:
        try:
            from vector_engine import get_vector_engine
        except ImportError:
            from .vector_engine import get_vector_engine
        engine = get_vector_engine()
        stats = engine.get_stats()

        # å°è¯•æœç´¢ä¸€ä¸ªæµ‹è¯•å‘é‡
        test_vector = np.zeros(config.VECTOR_DIMENSION, dtype='float32')
        test_results = engine.search(test_vector, top_k=1)

        return jsonify({
            'index_exists': True,
            'entity_count': stats['total_vectors'],
            'test_search_works': len(test_results) > 0,
            'vector_dimension': config.VECTOR_DIMENSION,
            'index_type': stats['index_type'],
            'metric_type': stats['metric_type'],
            'memory_usage_mb': stats['memory_usage_mb'],
            'ef_construction': stats['ef_construction'],
            'ef_search': stats['ef_search']
        })
    except Exception as e:
        logger.error(f"è·å–FAISSçŠ¶æ€å¤±è´¥: {e}")
        return jsonify({
            'error': str(e),
            'index_exists': False,
            'entity_count': 0
        }), 500


@app.route('/api/config/global-reply-delay', methods=['POST'])
def update_global_reply_delay():
    """æ›´æ–°å…¨å±€å›å¤å»¶è¿Ÿé…ç½®"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400
        min_delay = float(data.get('min_delay', 3))
        max_delay = float(data.get('max_delay', 8))

        # éªŒè¯èŒƒå›´
        if min_delay < 0 or max_delay < 0:
            return jsonify({'error': 'å»¶è¿Ÿæ—¶é—´ä¸èƒ½ä¸ºè´Ÿæ•°'}), 400
        if min_delay > max_delay:
            return jsonify({'error': 'æœ€å°å»¶è¿Ÿä¸èƒ½å¤§äºæœ€å¤§å»¶è¿Ÿ'}), 400
        if max_delay > 300:
            return jsonify({'error': 'æœ€å¤§å»¶è¿Ÿä¸èƒ½è¶…è¿‡300ç§’'}), 400

        # ä¿å­˜åˆ°æ•°æ®åº“
        if db.update_global_reply_config(min_delay, max_delay):
            # åŒæ—¶æ›´æ–°å†…å­˜ä¸­çš„é…ç½®
            config.GLOBAL_REPLY_MIN_DELAY = min_delay
            config.GLOBAL_REPLY_MAX_DELAY = max_delay

            logger.info(f"å…¨å±€å›å¤å»¶è¿Ÿè®¾ç½®ä¸º: {min_delay}-{max_delay}ç§’")

            return jsonify({
                'success': True,
                'min_delay': min_delay,
                'max_delay': max_delay,
                'description': f'{min_delay}-{max_delay}ç§’éšæœºå»¶è¿Ÿ',
                'message': 'å…¨å±€å›å¤å»¶è¿Ÿè®¾ç½®å·²æ›´æ–°ï¼Œæ‰€æœ‰è‡ªåŠ¨å›å¤å°†ä½¿ç”¨æ­¤è®¾ç½®'
            })
        else:
            return jsonify({'error': 'ä¿å­˜å¤±è´¥'}), 500

    except Exception as e:
        logger.error(f"æ›´æ–°å…¨å±€å›å¤å»¶è¿Ÿå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['GET'])
def get_discord_channel():
    """è·å–Discordé¢‘é“é…ç½®"""
    try:
        sys_config = db.get_system_config()
        return jsonify({
            'channel_id': sys_config['discord_channel_id'],
            'cnfans_channel_id': sys_config['cnfans_channel_id'],
            'acbuy_channel_id': sys_config['acbuy_channel_id']
        })
    except Exception as e:
        logger.error(f"è·å–Discordé¢‘é“é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/discord-channel', methods=['POST'])
def update_discord_channel():
    """æ›´æ–°Discordé¢‘é“é…ç½®"""
    try:
        data = request.get_json()
        if data is None:
            return jsonify({'error': 'Invalid request body'}), 400

        channel_id = data.get('channel_id', '').strip()
        cnfans_channel_id = data.get('cnfans_channel_id', '').strip()
        acbuy_channel_id = data.get('acbuy_channel_id', '').strip()

        # éªŒè¯é¢‘é“IDæ ¼å¼ï¼ˆåº”è¯¥æ˜¯æ•°å­—ï¼‰
        for cid_name, cid_value in [('channel_id', channel_id), ('cnfans_channel_id', cnfans_channel_id), ('acbuy_channel_id', acbuy_channel_id)]:
            if cid_value and not cid_value.isdigit():
                return jsonify({'error': f'{cid_name} å¿…é¡»æ˜¯æ•°å­—'}), 400

        # ä¿å­˜åˆ°æ•°æ®åº“
        if db.update_system_config(
            discord_channel_id=channel_id,
            cnfans_channel_id=cnfans_channel_id,
            acbuy_channel_id=acbuy_channel_id
        ):
            # åŒæ—¶æ›´æ–°ç¯å¢ƒå˜é‡å’Œbot_config
            if channel_id:
                os.environ['DISCORD_CHANNEL_ID'] = channel_id
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = int(channel_id)
                logger.info(f"Discordé¢‘é“IDè®¾ç½®ä¸º: {channel_id}")
            else:
                os.environ.pop('DISCORD_CHANNEL_ID', None)
                import bot_config
                bot_config.config.DISCORD_CHANNEL_ID = 0
                logger.info("Discordé¢‘é“IDå·²æ¸…é™¤")

            return jsonify({
                'success': True,
                'channel_id': channel_id,
                'message': f'Discordé¢‘é“IDå·²è®¾ç½®ä¸º: {channel_id or "æ— (ç›‘å¬æ‰€æœ‰é¢‘é“)"}'
            })
        else:
            return jsonify({'error': 'ä¿å­˜å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ›´æ–°Discordé¢‘é“é…ç½®å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['GET'])
def get_search_history():
    """è·å–æœç´¢å†å²è®°å½•ï¼ˆæ”¯æŒåˆ†é¡µï¼‰"""
    try:
        limit = min(int(request.args.get('limit', 20)), 100)  # æœ€å¤š100æ¡
        offset = max(int(request.args.get('offset', 0)), 0)
        page = max(int(request.args.get('page', 1)), 1)

        # å¦‚æœæä¾›äº†pageå‚æ•°ï¼Œè®¡ç®—offset
        if 'page' in request.args and 'offset' not in request.args:
            offset = (page - 1) * limit

        result = db.get_search_history(limit, offset)
        return jsonify(result)
    except Exception as e:
        logger.error(f"è·å–æœç´¢å†å²å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_similar_text', methods=['POST'])
def search_similar_text():
    """æ ¹æ®æ–‡å­—å…³é”®è¯æœç´¢ç›¸ä¼¼å•†å“"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid request body'}), 400

        query = data.get('query', '').strip()
        limit = min(int(data.get('limit', 5)), 20)  # æœ€å¤š20ä¸ªç»“æœ

        if not query:
            return jsonify({'error': 'Query is required'}), 400

        logger.info(f'æ–‡å­—æœç´¢è¯·æ±‚: "{query}", é™åˆ¶: {limit}')

        # åœ¨æ•°æ®åº“ä¸­æœç´¢åŒ…å«å…³é”®è¯çš„å•†å“
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # ä½¿ç”¨LIKEæŸ¥è¯¢åœ¨æ ‡é¢˜å’Œè‹±æ–‡æ ‡é¢˜ä¸­æœç´¢
            cursor.execute("""
                SELECT id, product_url, title, english_title, description,
                       ruleEnabled, min_delay, max_delay, created_at,
                       cnfans_url
                FROM products
                WHERE (title LIKE ? OR english_title LIKE ? OR description LIKE ?)
                  AND ruleEnabled = 1
                ORDER BY created_at DESC
                LIMIT ?
            """, (f'%{query}%', f'%{query}%', f'%{query}%', limit))

            rows = cursor.fetchall()

            products = []
            for row in rows:
                prod = dict(row)
                # è·å–å›¾ç‰‡
                cursor.execute("SELECT image_path FROM product_images WHERE product_id = ? ORDER BY image_index LIMIT 1", (prod['id'],))
                img_row = cursor.fetchone()
                if img_row:
                    prod['image'] = f"/api/image/{prod['id']}/0"
                else:
                    prod['image'] = None

                # æ ¼å¼åŒ–å­—æ®µ
                prod['weidianUrl'] = prod.get('product_url')
                prod['englishTitle'] = prod.get('english_title') or ''
                prod['cnfansUrl'] = prod.get('cnfans_url') or ''
                prod['autoReplyEnabled'] = prod.get('ruleEnabled', True)
                # ä»URLä¸­æå–weidian ID
                try:
                    import re
                    m = re.search(r'itemID=(\d+)', prod.get('product_url') or '')
                    prod['weidianId'] = m.group(1) if m else ''
                except:
                    prod['weidianId'] = ''

                products.append(prod)

        logger.info(f'æ–‡å­—æœç´¢å®Œæˆï¼Œæ‰¾åˆ° {len(products)} ä¸ªå•†å“')

        return jsonify({
            'success': True,
            'query': query,
            'products': products,
            'total': len(products)
        })

    except Exception as e:
        logger.error(f"æ–‡å­—æœç´¢å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history/<int:history_id>', methods=['DELETE'])
def delete_search_history(history_id):
    """åˆ é™¤æœç´¢å†å²è®°å½•"""
    try:
        if db.delete_search_history(history_id):
            return jsonify({'success': True})
        else:
            return jsonify({'error': 'è®°å½•ä¸å­˜åœ¨'}), 404
    except Exception as e:
        logger.error(f"åˆ é™¤æœç´¢å†å²å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/search_history', methods=['DELETE'])
def clear_search_history():
    """æ¸…ç©ºæ‰€æœ‰æœç´¢å†å²"""
    try:
        if db.clear_search_history():
            return jsonify({'success': True})
        else:
            return jsonify({'error': 'æ¸…ç©ºå¤±è´¥'}), 500
    except Exception as e:
        logger.error(f"æ¸…ç©ºæœç´¢å†å²å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/stream')
def log_stream():
    """Server-Sent Events æ—¥å¿—æµ"""
    import json

    def generate():
        # ä¸ºè¿™ä¸ªå®¢æˆ·ç«¯åˆ›å»ºé˜Ÿåˆ—
        client_queue = queue.Queue(maxsize=100)  # é™åˆ¶é˜Ÿåˆ—å¤§å°
        log_clients.append(client_queue)

        try:
            # å‘é€æœ€è¿‘çš„æ—¥å¿—å†å²
            for log_entry in all_logs[-20:]:  # å‘é€æœ€è¿‘20æ¡å†å²æ—¥å¿—
                yield f"data: {json.dumps(log_entry)}\n\n"

            # æŒç»­ç›‘å¬æ–°æ—¥å¿—
            while True:
                try:
                    # ç­‰å¾…æ–°æ—¥å¿—ï¼Œè¶…æ—¶æ—¶é—´è®¾ä¸º30ç§’
                    log_entry = client_queue.get(timeout=30)
                    yield f"data: {json.dumps(log_entry)}\n\n"
                except queue.Empty:
                    # å‘é€å¿ƒè·³åŒ…ä¿æŒè¿æ¥
                    yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': datetime.now().isoformat()})}\n\n"

        except GeneratorExit:
            # å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
            pass
        finally:
            # æ¸…ç†å®¢æˆ·ç«¯é˜Ÿåˆ—
            if client_queue in log_clients:
                log_clients.remove(client_queue)

    return Response(generate(), mimetype='text/event-stream',
                   headers={'Cache-Control': 'no-cache',
                           'Access-Control-Allow-Origin': '*',
                           'Access-Control-Allow-Headers': 'Cache-Control'})

@app.route('/api/logs/recent')
def get_recent_logs():
    """è·å–æœ€è¿‘çš„æ—¥å¿—è®°å½•"""
    try:
        # ä»æ—¥å¿—åˆ—è¡¨ä¸­è¿”å›æœ€è¿‘50æ¡æ—¥å¿—
        return jsonify({
            'logs': all_logs[-50:],
            'total': len(all_logs)
        })
    except Exception as e:
        logger.error(f"è·å–æœ€è¿‘æ—¥å¿—å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/logs/add', methods=['POST'])
def add_external_log():
    """æ¥æ”¶å¤–éƒ¨è¿›ç¨‹å‘é€çš„æ—¥å¿—"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Invalid log data'}), 400

        # åˆ›å»ºæ—¥å¿—æ¡ç›®
        log_entry = {
            'timestamp': data.get('timestamp', datetime.now().isoformat()),
            'level': data.get('level', 'INFO'),
            'message': data.get('message', ''),
            'module': data.get('module', 'external'),
            'func': data.get('func', '')
        }

        # æ·»åŠ åˆ°æ—¥å¿—åˆ—è¡¨
        all_logs.append(log_entry)
        if len(all_logs) > 200:
            all_logs.pop(0)

        # æ·»åŠ åˆ°é˜Ÿåˆ—
        log_queue.put(log_entry)

        return jsonify({'success': True})
    except Exception as e:
        print(f"æ·»åŠ å¤–éƒ¨æ—¥å¿—å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

def start_discord_bot(user_id=None):
    """å¯åŠ¨Discordæœºå™¨äºº - æ”¯æŒå¤šè´¦å·"""
    global bot_clients, bot_tasks, bot_running

    if bot_running:
        logger.warning("æœºå™¨äººå·²ç»åœ¨è¿è¡Œä¸­")
        return

    try:
        import asyncio
        from bot import DiscordBotClient

        logger.info(f"æ­£åœ¨å¯åŠ¨Discordæœºå™¨äºº... (ç”¨æˆ·ID: {user_id})")

        # è·å–è´¦å· - å¦‚æœæŒ‡å®šäº†ç”¨æˆ·IDï¼Œåªè·å–è¯¥ç”¨æˆ·çš„è´¦å·
        if user_id:
            accounts = db.get_discord_accounts_by_user(user_id)
        else:
            # è·å–æ‰€æœ‰è´¦å·
            accounts = db.get_discord_accounts_by_user(None)

        if not accounts:
            logger.warning("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„Discordè´¦å·")
            return

        logger.info(f"æ‰¾åˆ° {len(accounts)} ä¸ªDiscordè´¦å·ï¼Œå¼€å§‹å¯åŠ¨...")

        # åœ¨æ–°çš„äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œæœºå™¨äºº
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        # ä¸ºæ¯ä¸ªè´¦å·åˆ›å»ºæœºå™¨äººå®ä¾‹
        for account in accounts:
            account_id = account['id']
            token = account['token']
            username = account.get('username', f'account_{account_id}')
            user_id = account.get('user_id')

            # è·å–ç”¨æˆ·ç®¡ç†çš„åº—é“º
            user_shops = None
            if user_id:
                user = db.get_user_by_id(user_id)
                if user:
                    user_shops = user.get('shops', [])

            logger.info(f"æ­£åœ¨å¯åŠ¨æœºå™¨äººè´¦å·: {username} (ç”¨æˆ·ID: {user_id}, ç®¡ç†åº—é“º: {user_shops})")

            # åˆ›å»ºæœºå™¨äººå®ä¾‹
            client = DiscordBotClient(account_id=account_id, user_id=user_id, user_shops=user_shops)

            # å¯åŠ¨æœºå™¨äºº
            try:
                task = loop.create_task(client.start(token, reconnect=True))
                bot_clients.append(client)
                bot_tasks.append(task)
                logger.info(f"Discordæœºå™¨äººå¯åŠ¨æˆåŠŸ: {username}")
            except Exception as e:
                logger.error(f"å¯åŠ¨æœºå™¨äººå¤±è´¥ {username}: {e}")

        # åœ¨åå°çº¿ç¨‹ä¸­è¿è¡Œäº‹ä»¶å¾ªç¯
        import threading
        bot_thread = threading.Thread(target=loop.run_forever, daemon=True)
        bot_thread.start()

        if bot_clients:
            bot_running = True
            logger.info(f"å…±å¯åŠ¨äº† {len(bot_clients)} ä¸ªDiscordæœºå™¨äºº")
        else:
            logger.warning("æ²¡æœ‰æˆåŠŸå¯åŠ¨ä»»ä½•æœºå™¨äºº")

    except ImportError as e:
        logger.warning(f"Discordæœºå™¨äººæ¨¡å—ä¸å¯ç”¨: {e}")
        logger.info("Flaskåº”ç”¨å°†ç»§ç»­è¿è¡Œï¼Œä½†æœºå™¨äººåŠŸèƒ½ä¸å¯ç”¨")
    except Exception as e:
        logger.error(f"Discordæœºå™¨äººå¯åŠ¨å¤±è´¥: {e}")
        logger.info("Flaskåº”ç”¨å°†ç»§ç»­è¿è¡Œï¼Œä½†æœºå™¨äººåŠŸèƒ½ä¸å¯ç”¨")

def stop_discord_bot():
    """åœæ­¢Discordæœºå™¨äºº"""
    global bot_clients, bot_tasks, bot_running

    if not bot_running:
        logger.info("æœºå™¨äººæœªåœ¨è¿è¡Œ")
        return

    if bot_clients:
        logger.info(f"æ­£åœ¨åœæ­¢ {len(bot_clients)} ä¸ªDiscordæœºå™¨äºº...")
        try:
            import asyncio
            # åˆ›å»ºä»»åŠ¡æ¥åœæ­¢æ‰€æœ‰æœºå™¨äºº
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            for i, client in enumerate(bot_clients):
                try:
                    if client and not client.is_closed():
                        # æ›´æ–°è´¦å·çŠ¶æ€ä¸ºoffline
                        if hasattr(client, 'account_id') and client.account_id:
                            db.update_account_status(client.account_id, 'offline')
                            logger.info(f"è´¦å· {client.account_id} çŠ¶æ€å·²æ›´æ–°ä¸ºç¦»çº¿")
                        loop.run_until_complete(client.close())
                        logger.info(f"Discordæœºå™¨äºº {i+1} å·²åœæ­¢")
                except Exception as e:
                    logger.error(f"åœæ­¢æœºå™¨äºº {i+1} æ—¶å‡ºé”™: {e}")

            logger.info("æ‰€æœ‰Discordæœºå™¨äººå·²åœæ­¢")
        except Exception as e:
            logger.error(f"åœæ­¢æœºå™¨äººæ—¶å‡ºé”™: {e}")

    # å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
    for task in bot_tasks:
        if task and not task.done():
            task.cancel()

    # æ¸…ç©ºæœºå™¨äººåˆ—è¡¨
    bot_clients.clear()
    bot_tasks.clear()
    bot_running = False

# ===== æœºå™¨äººæ§åˆ¶API =====

@app.route('/api/bot/start', methods=['POST'])
def start_bot():
    """å¯åŠ¨Discordæœºå™¨äºº"""
    if not require_login():
        return jsonify({'error': 'éœ€è¦ç™»å½•'}), 401

    try:
        data = request.get_json()
        user_id = data.get('userId')

        if not user_id:
            return jsonify({'error': 'éœ€è¦ç”¨æˆ·ID'}), 400

        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™çš„è´¦å·
        user_accounts = db.get_discord_accounts_by_user(user_id)

        if not user_accounts:
            return jsonify({'error': 'ç”¨æˆ·æ²¡æœ‰Discordè´¦å·ï¼Œè¯·å…ˆæ·»åŠ è´¦å·'}), 400

        # å¯åŠ¨æœºå™¨äººï¼ˆå¯åŠ¨æ‰€æœ‰è´¦å·ï¼Œä¸ç®¡æ˜¯å¦åœ¨çº¿ï¼‰
        start_discord_bot(user_id)

        logger.info(f"ç”¨æˆ· {user_id} å¯åŠ¨æœºå™¨äººæˆåŠŸï¼Œå…±æœ‰ {len(user_accounts)} ä¸ªè´¦å·")
        return jsonify({
            'message': 'è´¦å·å¯åŠ¨æˆåŠŸ',
            'totalAccounts': len(user_accounts)
        })

    except Exception as e:
        logger.error(f"å¯åŠ¨æœºå™¨äººå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/bot/stop', methods=['POST'])
def stop_bot():
    """åœæ­¢Discordæœºå™¨äºº"""
    try:
        stop_discord_bot()
        logger.info("æœºå™¨äººåœæ­¢æˆåŠŸ")
        return jsonify({'message': 'æœºå™¨äººåœæ­¢æˆåŠŸ'})

    except Exception as e:
        logger.error(f"åœæ­¢æœºå™¨äººå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/shop-info', methods=['GET'])
def get_shop_info():
    """è·å–åº—é“ºä¿¡æ¯"""
    try:
        shop_id = request.args.get('shopId')
        if not shop_id:
            return jsonify({'error': 'ç¼ºå°‘shopIdå‚æ•°'}), 400

        shop_id = shop_id.strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopIdå¿…é¡»æ˜¯æ•°å­—'}), 400

        logger.info(f'è·å–åº—é“ºä¿¡æ¯: {shop_id}')

        # è°ƒç”¨å¾®åº—APIè·å–åº—é“ºä¿¡æ¯
        try:
            param = json.dumps({"shop_id": shop_id, "page_id": 0})
            encoded_param = quote(param)

            api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

            response = requests.get(api_url, headers={
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                'Origin': 'https://weidian.com',
                'Referer': 'https://weidian.com/',
                'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"macOS"',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-site',
            }, cookies={
                'wdtoken': '8ea9315c',
                '__spider__visitorid': '0dcf6a5b878847ec',
                'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
                'v-components/cpn-coupon-dialog@nologinshop': '10',
                '__spider__sessionid': 'e55c6458ac1fdba4'
            }, timeout=10)

            if response.status_code == 200:
                data = response.json()
                if data.get('status', {}).get('code') == 0:
                    shop_name = data.get('result', {}).get('shareTitle', f'åº—é“º {shop_id}')
                    return jsonify({'shopName': shop_name})
                else:
                    logger.warning(f'APIè¿”å›é”™è¯¯çŠ¶æ€: {data}')
            else:
                logger.warning(f'APIè¯·æ±‚å¤±è´¥: {response.status_code}')

        except Exception as e:
            logger.error(f'è·å–åº—é“ºä¿¡æ¯å¤±è´¥: {e}')

        # å¦‚æœAPIå¤±è´¥ï¼Œè¿”å›é»˜è®¤åç§°
        return jsonify({'shopName': f'åº—é“º {shop_id}'})

    except Exception as e:
        logger.error(f'è·å–åº—é“ºä¿¡æ¯å‡ºé”™: {e}')
        return jsonify({'error': 'è·å–åº—é“ºä¿¡æ¯å¤±è´¥'}), 500

# ===== åº—é“ºç®¡ç†API =====

@app.route('/api/shops', methods=['GET'])
def get_shops():
    """è·å–æ‰€æœ‰åº—é“ºåˆ—è¡¨"""
    try:
        shops = db.get_all_shops()
        return jsonify({'shops': shops})
    except Exception as e:
        logger.error(f'è·å–åº—é“ºåˆ—è¡¨å¤±è´¥: {e}')
        return jsonify({'error': 'è·å–åº—é“ºåˆ—è¡¨å¤±è´¥'}), 500

@app.route('/api/shops', methods=['POST'])
def add_shop():
    """æ·»åŠ æ–°åº—é“º"""
    if not can_manage_shops():
        return jsonify({'error': 'éœ€è¦ç®¡ç†åº—é“ºçš„æƒé™'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId') or not data.get('name'):
            return jsonify({'error': 'ç¼ºå°‘shopIdæˆ–nameå‚æ•°'}), 400

        shop_id = data['shopId'].strip()
        name = data['name'].strip()

        if not shop_id.isdigit():
            return jsonify({'error': 'shopIdå¿…é¡»æ˜¯æ•°å­—'}), 400

        # è·å–çœŸå®çš„åº—é“ºåç§°
        shop_info = get_shop_info_from_api(shop_id)
        if shop_info and shop_info.get('shopName'):
            name = shop_info['shopName']

        if db.add_shop(shop_id, name):
            return jsonify({'success': True, 'message': 'åº—é“ºæ·»åŠ æˆåŠŸ'})
        else:
            return jsonify({'error': 'åº—é“ºå·²å­˜åœ¨æˆ–æ·»åŠ å¤±è´¥'}), 400
    except Exception as e:
        logger.error(f'æ·»åŠ åº—é“ºå¤±è´¥: {e}')
        return jsonify({'error': 'æ·»åŠ åº—é“ºå¤±è´¥'}), 500

@app.route('/api/shops/<shop_id>', methods=['DELETE'])
def delete_shop(shop_id):
    """åˆ é™¤åº—é“º"""
    if not can_manage_shops():
        return jsonify({'error': 'éœ€è¦ç®¡ç†åº—é“ºçš„æƒé™'}), 403

    try:
        # è·å–åº—é“ºä¿¡æ¯ï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™åˆ é™¤
        shop_info = db.get_shop_by_id(shop_id)
        if not shop_info:
            return jsonify({'error': 'åº—é“ºä¸å­˜åœ¨'}), 404

        current_user = get_current_user()
        # ç®¡ç†å‘˜å¯ä»¥åˆ é™¤ä»»ä½•åº—é“ºï¼Œæ™®é€šç”¨æˆ·åªèƒ½åˆ é™¤åˆ†é…ç»™ä»–ä»¬çš„åº—é“º
        if current_user['role'] != 'admin' and shop_info['shop_id'] not in current_user.get('shops', []):
            return jsonify({'error': 'æ— æƒé™åˆ é™¤æ­¤åº—é“º'}), 403

        if db.delete_shop(shop_id):
            return jsonify({'success': True, 'message': 'åº—é“ºåˆ é™¤æˆåŠŸ'})
        else:
            return jsonify({'error': 'åˆ é™¤å¤±è´¥'}), 500
    except Exception as e:
        logger.error(f'åˆ é™¤åº—é“ºå¤±è´¥: {e}')
        return jsonify({'error': 'åˆ é™¤åº—é“ºå¤±è´¥'}), 500

def get_shop_info_from_api(shop_id):
    """ä»APIè·å–åº—é“ºä¿¡æ¯"""
    try:
        import json
        from urllib.parse import quote
        import time

        param = json.dumps({"shop_id": shop_id, "page_id": 0})
        encoded_param = quote(param)

        api_url = f"https://thor.weidian.com/decorate/customSharePage.getPageInfo/1.0?param={encoded_param}&wdtoken=8ea9315c&_={int(time.time() * 1000)}"

        response = requests.get(api_url, headers={
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
            'Origin': 'https://weidian.com',
            'Referer': 'https://weidian.com/',
            'Sec-Ch-Ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'Sec-Ch-Ua-Mobile': '?0',
            'Sec-Ch-Ua-Platform': '"macOS"',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site',
        }, cookies={
            'wdtoken': '8ea9315c',
            '__spider__visitorid': '0dcf6a5b878847ec',
            'visitor_id': '4d36e980-4128-451c-8178-a976b6303114',
            'v-components/cpn-coupon-dialog@nologinshop': '2',
            '__spider__sessionid': 'c7da7d6e06b1f1ac'
        }, timeout=10, proxies={'http': None, 'https': None})

        if response.status_code == 200:
            data = response.json()
            if data.get('status', {}).get('code') == 0:
                result = data.get('result', {})
                shop_name = result.get('shareTitle', '')
                if shop_name:
                    return {'shopName': shop_name}

    except Exception as e:
        logger.warning(f'è·å–åº—é“ºä¿¡æ¯å¤±è´¥: {e}')

    return None

@app.route('/api/scrape/shop', methods=['POST'])
def scrape_shop():
    """æŠ“å–æ•´ä¸ªåº—é“ºçš„æ‰€æœ‰å•†å“"""
    if not can_manage_shops():
        return jsonify({'error': 'éœ€è¦ç®¡ç†åº—é“ºçš„æƒé™'}), 403

    try:
        data = request.get_json()
        if not data or not data.get('shopId'):
            return jsonify({'error': 'ç¼ºå°‘shopIdå‚æ•°'}), 400

        shop_id = data['shopId'].strip()
        if not shop_id.isdigit():
            return jsonify({'error': 'shopIdå¿…é¡»æ˜¯æ•°å­—'}), 400

        # æ£€æŸ¥æ˜¯å¦å·²æœ‰æŠ“å–ä»»åŠ¡åœ¨è¿è¡Œ
        current_status = db.get_scrape_status()
        if current_status.get('is_scraping', False):
            return jsonify({'error': 'å·²æœ‰æŠ“å–ä»»åŠ¡åœ¨è¿è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆåå†è¯•'}), 409

        logger.info(f'å¼€å§‹æŠ“å–åº—é“º: {shop_id}')

        # åœ¨åå°çº¿ç¨‹ä¸­è¿è¡ŒæŠ“å–ä»»åŠ¡ï¼Œé¿å…é˜»å¡å…¶ä»–æ“ä½œ
        import threading

        def run_scrape_task():
            """åå°æŠ“å–ä»»åŠ¡"""
            try:
                scrape_shop_products(shop_id)
            except Exception as e:
                logger.error(f'æŠ“å–ä»»åŠ¡å¼‚å¸¸: {e}')
            finally:
                # ç¡®ä¿çŠ¶æ€æ­£ç¡®é‡ç½®
                error_msg = f'æŠ“å–å¼‚å¸¸ç»“æŸ: {str(e)}' if 'e' in locals() else 'æŠ“å–å·²å®Œæˆ'
                db.update_scrape_status(is_scraping=False, message=error_msg)

        # åˆ›å»ºå®ˆæŠ¤çº¿ç¨‹ï¼Œç¡®ä¿ä¸ä¼šé˜»å¡åº”ç”¨é€€å‡º
        scrape_thread = threading.Thread(target=run_scrape_task, daemon=True, name=f'scrape-{shop_id}')
        scrape_thread.start()

        logger.info(f'å·²å¯åŠ¨åå°æŠ“å–çº¿ç¨‹å¤„ç†åº—é“º {shop_id}')

        return jsonify({
            'success': True,
            'message': 'æŠ“å–ä»»åŠ¡å·²å¯åŠ¨ï¼Œè¯·æŸ¥çœ‹è¿›åº¦'
        })

    except Exception as e:
        logger.error(f'åº—é“ºæŠ“å–å¤±è´¥: {e}')
        return jsonify({'error': str(e)        }), 500


@app.route('/api/scrape/shop/control', methods=['POST'])
def control_shop_scrape():
    """æ§åˆ¶æŠ“å–ä»»åŠ¡: start, stop"""
    action = request.json.get('action')
    shop_id = request.json.get('shopId')  # å¯é€‰å‚æ•°

    global current_scrape_thread, scrape_thread_lock

    # è·å–å½“å‰çŠ¶æ€
    current_status = db.get_scrape_status()
    logger.info(f"æ”¶åˆ°æŠ“å–æ§åˆ¶è¯·æ±‚: action={action}, shop_id={shop_id}, å½“å‰çŠ¶æ€: is_scraping={current_status.get('is_scraping')}, stop_signal={current_status.get('stop_signal')}")

    if action == 'stop':
        # ç«‹å³åœæ­¢ - ä¸ç­‰å¾…å½“å‰å•†å“å®Œæˆï¼Œç›´æ¥è®¾ç½®çŠ¶æ€ä¸ºåœæ­¢
        success = db.update_scrape_status(
            is_scraping=False,
            stop_signal=True,
            completed=True,
            message='æŠ“å–å·²åœæ­¢',
            progress=100
        )

        if success:
            logger.info("âœ… æŠ“å–ä»»åŠ¡å·²å¼ºåˆ¶åœæ­¢")

            # ç»ˆæ­¢å½“å‰çº¿ç¨‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            with scrape_thread_lock:
                if current_scrape_thread and current_scrape_thread.is_alive():
                    logger.info("ç»ˆæ­¢æŠ“å–çº¿ç¨‹")
                    # è®¾ç½®çº¿ç¨‹åœæ­¢ä¿¡å·ï¼Œä½†ä¸å¼ºåˆ¶ç»ˆæ­¢
                    current_scrape_thread = None

            updated_status = db.get_scrape_status()
            return jsonify(updated_status)
        else:
            return jsonify({'error': 'åœæ­¢æŠ“å–å¤±è´¥'}), 500

    if action == 'start':
        if current_status.get('is_scraping', False):
            return jsonify({'error': 'å·²æœ‰ä»»åŠ¡åœ¨è¿è¡Œ'}), 400

        # æ£€æŸ¥æ˜¯å¦æœ‰çº¿ç¨‹åœ¨è¿è¡Œ
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                return jsonify({'error': 'å·²æœ‰çº¿ç¨‹åœ¨è¿è¡Œ'}), 400

        # é‡ç½®çŠ¶æ€
        success = db.update_scrape_status(
            is_scraping=True,
            stop_signal=False,
            current_shop_id=shop_id,
            total=0,
            processed=0,
            success=0,
            progress=0,
            message='åˆå§‹åŒ–æŠ“å–...',
            completed=False,
            thread_id=None
        )

        if not success:
            return jsonify({'error': 'é‡ç½®çŠ¶æ€å¤±è´¥'}), 500

        # å¼‚æ­¥å¯åŠ¨
        with scrape_thread_lock:
            current_scrape_thread = threading.Thread(
                target=run_shop_scrape_task,
                args=(shop_id,),
                daemon=True,
                name=f'scrape-{shop_id}'
            )
            current_scrape_thread.start()

            # æ›´æ–°çº¿ç¨‹IDåˆ°æ•°æ®åº“
            db.update_scrape_status(thread_id=current_scrape_thread.ident)

        updated_status = db.get_scrape_status()
        return jsonify(updated_status)

    return jsonify({'error': 'Invalid action'}), 400

@app.route('/api/scrape/batch', methods=['POST'])
def batch_scrape_products():
    """æ‰¹é‡æŠ“å–å¤šä¸ªå•†å“ï¼ˆé«˜æ€§èƒ½å¤šçº¿ç¨‹ç‰ˆæœ¬ï¼‰"""
    try:
        data = request.get_json()
        if not data or not data.get('productIds'):
            return jsonify({'error': 'ç¼ºå°‘productIdså‚æ•°'}), 400

        product_ids = data.get('productIds', [])
        if not isinstance(product_ids, list) or len(product_ids) == 0:
            return jsonify({'error': 'productIdså¿…é¡»æ˜¯éç©ºæ•°ç»„'}), 400

        # ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®çš„çº¿ç¨‹æ•°
        try:
            from config import config
            max_threads = config.SCRAPE_THREADS
        except:
            max_threads = 2

        # åˆ›å»ºåœæ­¢äº‹ä»¶ç”¨äºä¼˜é›…å…³é—­
        shutdown_event = threading.Event()

        logger.info(f"å¼€å§‹æ‰¹é‡æŠ“å– {len(product_ids)} ä¸ªå•†å“ï¼Œä½¿ç”¨ {max_threads} ä¸ªçº¿ç¨‹")

        # åˆ›å»ºæ‰¹é‡å¤„ç†ä»»åŠ¡
        import concurrent.futures
        import time
        import threading

        results = {
            'total': len(product_ids),
            'processed': 0,
            'success': 0,
            'skipped': 0,
            'cancelled': 0,
            'partial': 0,
            'errors': 0,
            'start_time': time.time()
        }

        def process_single_product_batch(product_id):
            """å¤„ç†å•ä¸ªå•†å“ï¼ˆç”¨äºçº¿ç¨‹æ± ï¼‰"""
            try:
                # === æ£€æŸ¥åœæ­¢ä¿¡å· ===
                current_status = db.get_scrape_status()
                if current_status.get('stop_signal', False):
                    logger.info(f"ğŸ”´ å¤„ç†å•†å“å‰æ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œå–æ¶ˆå¤„ç†å•†å“ {product_id}")
                    return {'status': 'cancelled', 'product_id': product_id, 'message': 'ä»»åŠ¡å·²å–æ¶ˆ'}

                # è°ƒç”¨ç°æœ‰çš„å•ä¸ªå•†å“å¤„ç†é€»è¾‘
                from app import process_single_product

                # æ„å»ºå•†å“ä¿¡æ¯
                product_info = {
                    'item_id': str(product_id),
                    'item_url': f'https://weidian.com/item.html?itemID={product_id}',
                    'shop_name': 'æ‰¹é‡ä¸Šä¼ '
                }

                # å¤„ç†å•†å“
                product_data = process_single_product(product_info)

                if product_data:
                    # === å†æ¬¡æ£€æŸ¥åœæ­¢ä¿¡å· ===
                    current_status = db.get_scrape_status()
                    if current_status.get('stop_signal', False):
                        logger.info(f"ğŸ”´ è·å–å•†å“æ•°æ®åæ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œè·³è¿‡å•†å“ {product_id}")
                        return {'status': 'cancelled', 'product_id': product_id, 'message': 'ä»»åŠ¡å·²å–æ¶ˆ'}

                    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    if db.get_product_by_url(product_data['product_url']):
                        return {'status': 'skipped', 'product_id': product_id, 'message': 'å•†å“å·²å­˜åœ¨'}

                    # å…¥åº“
                    product_id_db = db.insert_product(product_data)

                    # === å†æ¬¡æ£€æŸ¥åœæ­¢ä¿¡å· ===
                    current_status = db.get_scrape_status()
                    if current_status.get('stop_signal', False):
                        logger.info(f"ğŸ”´ å…¥åº“åæ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œå•†å“ {product_id} å·²å…¥åº“ä½†è·³è¿‡å›¾ç‰‡å¤„ç†")
                        return {'status': 'partial', 'product_id': product_id, 'message': 'å•†å“å·²å…¥åº“ï¼Œå›¾ç‰‡å¤„ç†è¢«å–æ¶ˆ'}

                    # å¤„ç†å›¾ç‰‡ï¼ˆä½¿ç”¨ä¼˜åŒ–åçš„å¤šçº¿ç¨‹å›¾ç‰‡å¤„ç†ï¼‰
                    if product_data.get('images'):
                        save_product_images_unified(product_id_db, product_data['images'], shutdown_event=shutdown_event)

                    return {'status': 'success', 'product_id': product_id, 'message': 'å¤„ç†æˆåŠŸ'}
                else:
                    return {'status': 'error', 'product_id': product_id, 'message': 'è·å–å•†å“æ•°æ®å¤±è´¥'}

            except Exception as e:
                logger.error(f"å¤„ç†å•†å“ {product_id} å¤±è´¥: {e}")
                return {'status': 'error', 'product_id': product_id, 'message': str(e)}

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘å¤„ç†å•†å“
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            # æäº¤æ‰€æœ‰ä»»åŠ¡
            future_to_product = {
                executor.submit(process_single_product_batch, pid): pid
                for pid in product_ids
            }

            # æ”¶é›†ç»“æœ - æ”¯æŒä¼˜é›…åœæ­¢
            pending_futures = set(future_to_product.keys())
            stop_detected = False

            try:
                while pending_futures:
                    # æ£€æŸ¥æ˜¯å¦æœ‰åœæ­¢ä¿¡å·æˆ–å…³é—­äº‹ä»¶
                    current_status = db.get_scrape_status()
                    should_stop = (current_status.get('stop_signal', False) or
                                 (shutdown_event and shutdown_event.is_set()))

                    if should_stop and not stop_detected:
                        logger.info("ğŸ”´ æ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨ç­‰å¾…å·²æäº¤çš„ä»»åŠ¡å®Œæˆ...")
                        db.update_scrape_status(message='æ­£åœ¨ç­‰å¾…å½“å‰å•†å“å®Œæˆ...')
                        stop_detected = True
                        # ä¸å…³é—­çº¿ç¨‹æ± ï¼Œè®©å·²æäº¤çš„ä»»åŠ¡ç»§ç»­å®Œæˆ

                    # ç­‰å¾…ä»»æ„ä¸€ä¸ªä»»åŠ¡å®Œæˆ
                    done, pending_futures = concurrent.futures.wait(
                        pending_futures,
                        timeout=1.0,
                        return_when=concurrent.futures.FIRST_COMPLETED
                    )

                    # å¤„ç†å·²å®Œæˆçš„ä»»åŠ¡
                    for future in done:
                        product_id = future_to_product[future]
                        try:
                            result = future.result()
                            results['processed'] += 1

                            if result['status'] == 'success':
                                results['success'] += 1
                                logger.info(f"å•†å“ {product_id} å¤„ç†æˆåŠŸ")
                            elif result['status'] == 'skipped':
                                results['skipped'] += 1
                                logger.info(f"å•†å“ {product_id} å·²å­˜åœ¨ï¼Œè·³è¿‡")
                            elif result['status'] == 'cancelled':
                                results['cancelled'] += 1
                                logger.info(f"å•†å“ {product_id} å¤„ç†è¢«å–æ¶ˆ")
                            elif result['status'] == 'partial':
                                results['partial'] += 1
                                logger.info(f"å•†å“ {product_id} éƒ¨åˆ†å®Œæˆï¼ˆå·²å…¥åº“ï¼Œå›¾ç‰‡å¤„ç†è¢«å–æ¶ˆï¼‰")
                            else:
                                results['errors'] += 1
                                logger.error(f"å•†å“ {product_id} å¤„ç†å¤±è´¥: {result.get('message', 'æœªçŸ¥é”™è¯¯')}")

                        except Exception as e:
                            results['processed'] += 1
                            results['errors'] += 1
                            logger.error(f"å¤„ç†å•†å“ {product_id} æ—¶å‘ç”Ÿå¼‚å¸¸: {e}")

                    # å¦‚æœæ£€æµ‹åˆ°åœæ­¢ä¿¡å·ä¸”æ²¡æœ‰å¾…å¤„ç†çš„ä»»åŠ¡ï¼Œé€€å‡ºå¾ªç¯
                    if stop_detected and len(pending_futures) == 0:
                        logger.info("âœ… æ‰€æœ‰å·²æäº¤çš„ä»»åŠ¡å·²å®Œæˆï¼Œé€€å‡ºæ‰¹é‡å¤„ç†")
                        break

            except KeyboardInterrupt:
                logger.warning("æ”¶åˆ°é”®ç›˜ä¸­æ–­ï¼Œæ­£åœ¨ä¼˜é›…å…³é—­...")
                executor.shutdown(wait=True, timeout=10.0)
                raise
            finally:
                # ç¡®ä¿çº¿ç¨‹æ± è¢«æ­£ç¡®å…³é—­
                if not executor._shutdown:
                    executor.shutdown(wait=False)

        # è®¡ç®—å¤„ç†æ—¶é—´
        results['end_time'] = time.time()
        results['duration'] = results['end_time'] - results['start_time']

        logger.info(f"æ‰¹é‡å¤„ç†å®Œæˆ: {results}")

        # æ³¨æ„ï¼šæ‰¹é‡æŠ“å–ä¸åº”è¯¥é‡ç½®åº—é“ºæŠ“å–çš„çŠ¶æ€
        # æ‰¹é‡æŠ“å–æœ‰è‡ªå·±çš„çŠ¶æ€ç®¡ç†ï¼Œä¸å½±å“åº—é“ºæŠ“å–çš„çŠ¶æ€æ˜¾ç¤º

        return jsonify({
            'message': f'æ‰¹é‡å¤„ç†å®Œæˆï¼Œå…±å¤„ç† {results["total"]} ä¸ªå•†å“ï¼ŒæˆåŠŸ {results["success"]} ä¸ªï¼Œè·³è¿‡ {results["skipped"]} ä¸ªï¼Œå–æ¶ˆ {results["cancelled"]} ä¸ªï¼Œéƒ¨åˆ†å®Œæˆ {results["partial"]} ä¸ªï¼Œå¤±è´¥ {results["errors"]} ä¸ª',
            'results': results
        })

    except Exception as e:
        logger.error(f"æ‰¹é‡æŠ“å–å¤±è´¥: {e}")
        import traceback
        logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
        return jsonify({'error': f'æ‰¹é‡æŠ“å–å¤±è´¥: {str(e)}'}), 500

@app.route('/api/scrape/shop/status', methods=['GET'])
def get_scrape_status():
    """è·å–æŠ“å–çŠ¶æ€"""
    try:
        status = db.get_scrape_status()

        # ç¡®ä¿è¿”å›å¿…è¦çš„å­—æ®µï¼ˆå…¼å®¹å‰ç«¯æœŸæœ›çš„å­—æ®µåï¼‰
        result = {
            'is_scraping': status.get('is_scraping', False),
            'progress': status.get('progress', 0),
            'total': status.get('total', 0),
            'current': status.get('processed', 0),  # å‰ç«¯æœŸæœ›currentå­—æ®µ
            'processed': status.get('processed', 0),
            'success': status.get('success', 0),
            'message': status.get('message', ''),
            'completed': status.get('completed', False),
            'current_shop_id': status.get('current_shop_id'),
            'thread_id': status.get('thread_id')
        }

        # è°ƒè¯•æ—¥å¿—
        logger.debug(f"DEBUG: Scrape status - is_scraping: {result.get('is_scraping')}, message: {result.get('message')}")

        return jsonify(result)
    except Exception as e:
        logger.error(f'è·å–æŠ“å–çŠ¶æ€å¤±è´¥: {e}')
        return jsonify({
            'is_scraping': False,
            'progress': 0,
            'total': 0,
            'current': 0,
            'processed': 0,
            'success': 0,
            'message': 'è·å–çŠ¶æ€å¤±è´¥',
            'completed': False,
            'current_shop_id': None,
            'thread_id': None
        })

@app.route('/api/products/count', methods=['GET'])
def get_products_count():
    """è·å–å•†å“æ€»æ•°"""
    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM products")
            count = cursor.fetchone()[0]
            return jsonify({'count': count})
    except Exception as e:
        logger.error(f"è·å–å•†å“æ•°é‡å¤±è´¥: {e}")
        return jsonify({'count': 0}), 500

@app.route('/api/debug/user_permissions', methods=['GET'])
def debug_user_permissions():
    """è°ƒè¯•ç”¨æˆ·æƒé™å’Œå•†å“åˆ†é…ï¼ˆç®¡ç†å‘˜æƒé™ï¼‰"""
    if not require_admin():
        return jsonify({'error': 'éœ€è¦ç®¡ç†å‘˜æƒé™'}), 403

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # è·å–æ‰€æœ‰ç”¨æˆ·
            cursor.execute('SELECT id, username, role FROM users')
            users = []
            for row in cursor.fetchall():
                user_dict = dict(row)
                user_dict['shops'] = db.get_user_shops(user_dict['id'])
                users.append(user_dict)

            # è·å–æ‰€æœ‰åº—é“º
            cursor.execute('SELECT id, name FROM shops')
            shops = [dict(row) for row in cursor.fetchall()]

            # è·å–å•†å“ç»Ÿè®¡
            cursor.execute('SELECT shop_name, COUNT(*) as count FROM products GROUP BY shop_name')
            product_stats = [dict(row) for row in cursor.fetchall()]

            # è·å–ç”¨æˆ·åº—é“ºæƒé™ç»Ÿè®¡
            cursor.execute('SELECT user_id, COUNT(*) as shop_count FROM user_shop_permissions GROUP BY user_id')
            permission_stats = []
            for row in cursor.fetchall():
                user_id, shop_count = row
                user = next((u for u in users if u['id'] == user_id), None)
                if user:
                    permission_stats.append({
                        'username': user['username'],
                        'shop_count': shop_count,
                        'shops': user['shops']
                    })

            return jsonify({
                'users': users,
                'shops': shops,
                'product_stats': product_stats,
                'permission_stats': permission_stats
            })
    except Exception as e:
        logger.error(f"è°ƒè¯•ç”¨æˆ·æƒé™å¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

def run_shop_scrape_task(shop_id):
    """åå°ä»»åŠ¡åŒ…è£…å™¨ - è°ƒç”¨çœŸæ­£çš„æŠ“å–é€»è¾‘"""
    try:
        logger.info(f"ğŸ§µ åå°æŠ“å–çº¿ç¨‹å¯åŠ¨: {shop_id}")
        scrape_shop_products(shop_id)
    except Exception as e:
        logger.error(f"âŒ åå°æŠ“å–çº¿ç¨‹å´©æºƒ: {e}")
        db.update_scrape_status(message=f"ç³»ç»Ÿé”™è¯¯: {str(e)}")
    finally:
        # ç¡®ä¿çŠ¶æ€æ­£ç¡®é‡ç½®
        final_status = db.get_scrape_status()
        db.update_scrape_status(
            is_scraping=False,
            completed=True
        )
        if not final_status.get('stop_signal', False):
            db.update_scrape_status(message='ä»»åŠ¡ç»“æŸ')
        logger.info("ğŸ§µ åå°æŠ“å–çº¿ç¨‹ç»“æŸ")

def scrape_shop_products(shop_id):
    """æŠ“å–åº—é“ºæ‰€æœ‰å•†å“çš„å®ç° (å…¨å±€çº¿ç¨‹æ± é«˜æ€§èƒ½ç‰ˆ - æ¯ä¸ªå•†å“ä¸€ä¸ªçº¿ç¨‹)"""
    import requests
    import time
    from weidian_scraper import get_weidian_scraper
    import concurrent.futures

    # è·å–é…ç½®çš„çº¿ç¨‹æ•°
    try:
        from config import config
        max_threads = config.SCRAPE_THREADS
    except:
        max_threads = 2

    scraper = get_weidian_scraper()
    all_product_tasks = []  # æ”¶é›†æ‰€æœ‰å•†å“ä»»åŠ¡
    offset = 0
    limit = 20
    page_count = 0

    # åˆå§‹åŒ–çŠ¶æ€
    db.update_scrape_status(
        is_scraping=True,
        paused=False,
        stop_signal=False,
        progress=0,
        total=0,
        processed=0,
        success=0,
        message='æ­£åœ¨åˆå§‹åŒ–...'
    )

    # è·å–åº—é“ºåç§°
    shop_info = get_shop_info_from_api(shop_id)
    shop_name = shop_info.get('shopName', f'åº—é“º {shop_id}') if shop_info else f'åº—é“º {shop_id}'

    db.update_scrape_status(message=f'æ­£åœ¨æŠ“å–åº—é“º: {shop_name}')
    logger.info(f"å¼€å§‹æ”¶é›†å•†å“åˆ—è¡¨ï¼Œåº—é“º: {shop_name}")

    # ç¬¬ä¸€é˜¶æ®µï¼šæ”¶é›†æ‰€æœ‰å•†å“ä¿¡æ¯ï¼ˆå•çº¿ç¨‹ï¼Œé¿å…APIå‹åŠ›ï¼‰
    while True:
        # æ£€æŸ¥åœæ­¢ä¿¡å·
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info("ğŸ”´ åœæ­¢ä¿¡å·è§¦å‘ï¼Œé€€å‡ºæ”¶é›†")
            break

        try:
            # API è¯·æ±‚å•†å“åˆ—è¡¨
            url = f"https://thor.weidian.com/decorate/shopDetail.tab.getItemList/1.0"
            param_encoded = quote(f'{{"shopId":"{shop_id}","tabId":0,"sortOrder":"desc","offset":{offset},"limit":{limit},"from":"h5","showItemTag":true}}')
            full_url = f"{url}?param={param_encoded}&wdtoken=8ea9315c&_={int(time.time()*1000)}"

            response = scraper.session.get(full_url, timeout=10)
            if response.status_code != 200:
                logger.warning(f'APIè¯·æ±‚å¤±è´¥: {response.status_code}')
                break

            data = response.json()
            if data.get('status', {}).get('code') != 0:
                logger.warning('APIå“åº”çŠ¶æ€ç ä¸ä¸º0')
                break

            result = data.get('result', {})
            if not result.get('hasData', False):
                logger.info('æ²¡æœ‰æ›´å¤šæ•°æ®ï¼Œæ”¶é›†å®Œæˆ')
                break

            items = result.get('itemList', [])
            if not items:
                logger.info('å•†å“åˆ—è¡¨ä¸ºç©ºï¼Œæ”¶é›†å®Œæˆ')
                break

            # æ”¶é›†å½“å‰é¡µçš„å•†å“ä»»åŠ¡
            page_tasks = []
            for item in items:
                item_id = item.get('itemId', '')
                if item_id:
                    product_info = {
                        'item_id': item_id,
                        'item_url': item.get('itemUrl', ''),
                        'shop_name': shop_name
                    }
                    page_tasks.append(product_info)

            all_product_tasks.extend(page_tasks)
            logger.info(f'ç¬¬ {page_count + 1} é¡µæ”¶é›†äº† {len(page_tasks)} ä¸ªå•†å“ï¼Œæ€»è®¡ {len(all_product_tasks)} ä¸ª')

            page_count += 1
            offset += limit
            time.sleep(0.5)  # ç¨å¾®æ­‡ä¸€ä¸‹é˜²æ­¢å°IP

        except Exception as e:
            logger.error(f'æ”¶é›†å•†å“åˆ—è¡¨å‡ºé”™: {e}')
            break

    total_products = len(all_product_tasks)
    logger.info(f"âœ… å•†å“æ”¶é›†å®Œæˆï¼Œæ€»è®¡ {total_products} ä¸ªå•†å“ï¼Œå‡†å¤‡ä½¿ç”¨ {max_threads} ä¸ªçº¿ç¨‹å¹¶å‘å¤„ç†")

    # æ›´æ–°çŠ¶æ€ï¼šå¼€å§‹å¤„ç†
    db.update_scrape_status(
        total=total_products,
        message=f'å¼€å§‹å¤„ç† {total_products} ä¸ªå•†å“...'
    )

    # ç¬¬äºŒé˜¶æ®µï¼šä½¿ç”¨å…¨å±€çº¿ç¨‹æ± å¹¶å‘å¤„ç†æ‰€æœ‰å•†å“
    processed_count = 0
    success_count = 0

    if all_product_tasks:
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            # æäº¤æ‰€æœ‰å•†å“ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
            future_to_product = {
                executor.submit(process_and_save_single_product_sync, product_info): product_info
                for product_info in all_product_tasks
            }

            # å¤„ç†å®Œæˆçš„ä»»åŠ¡
            for future in concurrent.futures.as_completed(future_to_product):
                # æ£€æŸ¥åœæ­¢ä¿¡å·
                if db.get_scrape_status().get('stop_signal', False):
                    logger.info("ğŸ”´ æ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨å–æ¶ˆå‰©ä½™ä»»åŠ¡...")
                    # å–æ¶ˆæ‰€æœ‰å¾…å¤„ç†çš„ä»»åŠ¡
                    for f in future_to_product:
                        if not f.done():
                            f.cancel()
                    break

                try:
                    product_info = future_to_product[future]
                    success = future.result()
                    processed_count += 1

                    if success:
                        success_count += 1

                    # æ¯å¤„ç†10ä¸ªå•†å“æˆ–æœ€åä¸€æ‰¹æ›´æ–°ä¸€æ¬¡çŠ¶æ€
                    if processed_count % 10 == 0 or processed_count == total_products:
                        progress = int((processed_count / total_products) * 100)
                        db.update_scrape_status(
                            processed=processed_count,
                            success=success_count,
                            progress=progress,
                            message=f'æ­£åœ¨å¤„ç†å•†å“... ({processed_count}/{total_products})'
                        )
                        logger.info(f'å·²å¤„ç† {processed_count}/{total_products} ä¸ªå•†å“ï¼ŒæˆåŠŸ {success_count} ä¸ª')

                except Exception as e:
                    logger.error(f"å•†å“å¤„ç†å¼‚å¸¸: {e}")
                    processed_count += 1

    # ç»“æŸ
    db.update_scrape_status(
        is_scraping=False,
        completed=True,
        progress=100,
        message=f'æŠ“å–å®Œæˆï¼Œå…±å¤„ç† {processed_count} ä¸ªå•†å“ï¼ŒæˆåŠŸ {success_count} ä¸ª'
    )
    logger.info(f"âœ… åº—é“º {shop_id} æŠ“å–ä»»åŠ¡å®Œæˆ: {success_count}/{processed_count} å•†å“æˆåŠŸå¤„ç†")

    return {
        "total_products": processed_count,
        "success_count": success_count,
        "pages_processed": page_count
    }

def process_and_save_single_product_sync(product_info):
    """åŒæ­¥å¤„ç†å•ä¸ªå•†å“ï¼Œé¿å…é‡å¤å¤„ç†"""
    try:
        item_id = product_info.get('item_id', '')

        # === æ£€æŸ¥åœæ­¢ä¿¡å· ===
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"ğŸ”´ å¤„ç†å•†å“å‰æ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œå–æ¶ˆå¤„ç†å•†å“ {item_id}")
            return False

        # === 0. åŸºäºitem_idçš„å¼ºåŠ›å»é‡ ===
        if db.get_product_by_item_id(item_id):
            logger.info(f"â­ï¸ å•†å“ {item_id} å·²å­˜åœ¨ï¼Œè·³è¿‡é‡å¤å¤„ç†")
            return True  # å·²å­˜åœ¨ç®—å¤„ç†æˆåŠŸ

        # 1. æŠ“å–è¯¦æƒ…
        from app import process_single_product  # å¼•ç”¨ app.py ä¸­çš„é€»è¾‘
        product_data = process_single_product(product_info)

        if not product_data:
            return False

        # === å†æ¬¡æ£€æŸ¥åœæ­¢çŠ¶æ€ ===
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"ğŸ”´ æŠ“å–è¯¦æƒ…åæ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œå–æ¶ˆå¤„ç†å•†å“ {item_id}")
            return False

        # 2. å†æ¬¡æŸ¥é‡ (åŒé‡ä¿é™©)
        if db.get_product_by_url(product_data['product_url']):
            logger.info(f"â­ï¸ å•†å“URLå·²å­˜åœ¨: {product_data['product_url']}")
            return True  # å·²å­˜åœ¨ç®—å¤„ç†æˆåŠŸ

        # 3. å…¥åº“ (æ·»åŠ item_idå­—æ®µ)
        product_data['item_id'] = item_id  # ç¡®ä¿item_idè¢«ä¿å­˜
        product_id = db.insert_product(product_data)

        logger.info(f"âœ… å•†å“ {item_id} æˆåŠŸå…¥åº“ï¼Œæ•°æ®åº“ID: {product_id}")

        # === å†æ¬¡æ£€æŸ¥åœæ­¢çŠ¶æ€ ===
        current_status = db.get_scrape_status()
        if current_status.get('stop_signal', False):
            logger.info(f"ğŸ”´ å…¥åº“åæ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œå•†å“ {item_id} å·²å…¥åº“ä½†è·³è¿‡å›¾ç‰‡å¤„ç†")
            return True  # å•†å“å·²å…¥åº“ï¼Œç®—æˆåŠŸ

        # 4. å›¾ç‰‡å¤„ç† (ä½¿ç”¨å¤šçº¿ç¨‹ç‰ˆæœ¬)
        if product_data.get('images'):
            from app import save_product_images_unified
            processed_count = save_product_images_unified(product_id, product_data['images'])
            logger.info(f"ğŸ–¼ï¸ å•†å“ {item_id} å›¾ç‰‡å¤„ç†å®Œæˆï¼Œå…±å¤„ç† {processed_count} å¼ å›¾ç‰‡")

        return True
    except Exception as e:
        logger.error(f"âŒ å¤„ç†å•†å“å‡ºé”™ {product_info.get('item_id')}: {e}")
        return False

def scrape_product_info(product_url):
    """æ ¹æ®å•†å“URLè·å–å•†å“è¯¦ç»†ä¿¡æ¯"""
    try:
        from weidian_scraper import get_weidian_scraper

        scraper = get_weidian_scraper()
        product_info = scraper.scrape_product_info(product_url)

        if product_info:
            # é‡æ–°æ ¼å¼åŒ–è¿”å›æ•°æ®
            return {
                'title': product_info.get('title', ''),
                'description': product_info.get('description', ''),
                # ä¿®å¤ï¼šç§»é™¤ [:5] é™åˆ¶ï¼Œè¿”å›æ‰€æœ‰æŠ“å–åˆ°çš„å›¾ç‰‡
                'images': product_info.get('images', []),
                'shop_name': product_info.get('shop_name', '')
            }

        return None

    except Exception as e:
        logger.error(f'è·å–å•†å“è¯¦ç»†ä¿¡æ¯å¤±è´¥: {e}')
        return None

def generate_acbuy_url(weidian_url):
    """ç”ŸæˆAcBuyé“¾æ¥"""
    if not weidian_url:
        return ''

    try:
        import re
        item_id_match = re.search(r'itemID=(\d+)', weidian_url)
        if item_id_match:
            item_id = item_id_match.group(1)
            # æ„å»ºacbuyé“¾æ¥
            encoded_url = weidian_url.replace(':', '%3A').replace('/', '%2F').replace('?', '%3F').replace('=', '%3D').replace('&', '%26')
            return f'https://www.acbuy.com/product?url={encoded_url}&id={item_id}&source=WD'
    except Exception as e:
        logger.error(f'ç”ŸæˆAcBuyé“¾æ¥å¤±è´¥: {e}')

    return ''

def generate_cnfans_url(item_id):
    """ç”ŸæˆCNFansé“¾æ¥"""
    if not item_id:
        return ''
    return f"https://cnfans.com/product?id={item_id}&platform=WEIDIAN"

def generate_english_title(chinese_title):
    """å°†ä¸­æ–‡æ ‡é¢˜ç¿»è¯‘ä¸ºè‹±æ–‡æ ‡é¢˜"""
    if not chinese_title:
        return ''

    try:
        import re
        import requests

        # é¦–å…ˆå°è¯•æå–å·²æœ‰çš„è‹±æ–‡éƒ¨åˆ†
        english_parts = re.findall(r'[a-zA-Z\s]+', chinese_title)
        if english_parts and len(' '.join(english_parts).strip()) > 5:
            # å¦‚æœè‹±æ–‡éƒ¨åˆ†è¶³å¤Ÿé•¿ï¼Œç›´æ¥è¿”å›
            return ' '.join(english_parts).strip()

        # å“ç‰Œåç§°æ˜ å°„ï¼ˆæ‰©å±•ç‰ˆï¼‰
        brand_mappings = {
            'Nike': 'Nike', 'é˜¿è¿ª': 'Adidas', 'Adidas': 'Adidas', 'æå®': 'LiNing',
            'å®‰è¸': 'Anta', 'åŒ¹å…‹': 'Peak', 'ä¹”ä¸¹': 'Jordan', 'New Balance': 'New Balance',
            'Converse': 'Converse', 'Vans': 'Vans', 'Supreme': 'Supreme', 'BAPE': 'BAPE',
            'Palace': 'Palace', 'Stone Island': 'Stone Island', 'Off-White': 'Off-White',
            'Balenciaga': 'Balenciaga', 'Gucci': 'Gucci', 'Louis Vuitton': 'Louis Vuitton',
            'Chanel': 'Chanel', 'Dior': 'Dior', 'Yeezy': 'Yeezy', 'Puma': 'Puma',
            'Reebok': 'Reebok', 'Under Armour': 'Under Armour', 'Fila': 'Fila',
            'The North Face': 'The North Face', 'Columbia': 'Columbia', 'Patagonia': 'Patagonia',
            'Arc\'teryx': 'Arc\'teryx', 'Canada Goose': 'Canada Goose', 'Moncler': 'Moncler',
            'Burberry': 'Burberry', 'Prada': 'Prada', 'Versace': 'Versace', 'Fendi': 'Fendi',
            'Hermes': 'Hermes', 'Rolex': 'Rolex', 'Cartier': 'Cartier', 'Omega': 'Omega',
            'IWC': 'IWC', 'Jaeger-LeCoultre': 'Jaeger-LeCoultre', 'Patek Philippe': 'Patek Philippe'
        }

        # åº”ç”¨å“ç‰Œæ˜ å°„
        title = chinese_title
        for zh, en in brand_mappings.items():
            title = title.replace(zh, en)

        # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸­æ–‡å­—ç¬¦
        has_chinese = any('\u4e00' <= char <= '\u9fff' for char in title)

        if has_chinese:
            # ä½¿ç”¨ç™¾åº¦ç¿»è¯‘APIæˆ–å…¶ä»–å…è´¹ç¿»è¯‘æœåŠ¡
            try:
                # è¿™é‡Œä½¿ç”¨ä¸€ä¸ªç®€å•çš„ç¿»è¯‘APIç¤ºä¾‹
                # å®é™…éƒ¨ç½²æ—¶éœ€è¦æ›¿æ¢ä¸ºç¨³å®šçš„ç¿»è¯‘æœåŠ¡
                api_url = "https://api.mymemory.translated.net/get"
                params = {
                    'q': chinese_title,
                    'langpair': 'zh-CN|en-US',
                    'de': 'your-email@example.com'  # MyMemoryè¦æ±‚æä¾›é‚®ç®±
                }

                response = requests.get(api_url, params=params, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code == 200:
                    data = response.json()
                    translated = data.get('responseData', {}).get('translatedText', '')
                    if translated and translated != chinese_title:
                        # æ¸…ç†ç¿»è¯‘ç»“æœ
                        translated = re.sub(r'[^\w\s\-]', '', translated)
                        return translated.strip()

            except Exception as e:
                logger.warning(f'åœ¨çº¿ç¿»è¯‘å¤±è´¥: {e}')

            # å¦‚æœç¿»è¯‘å¤±è´¥ï¼Œè¿”å›æå–çš„è‹±æ–‡éƒ¨åˆ†æˆ–åŸæ ‡é¢˜
            english_parts = re.findall(r'[a-zA-Z\s\-]+', title)
            if english_parts:
                result = ' '.join(english_parts).strip()
                if len(result) > 3:
                    return result

        # å¦‚æœæ²¡æœ‰ä¸­æ–‡æˆ–ç¿»è¯‘å¤±è´¥ï¼Œè¿”å›å¤„ç†åçš„æ ‡é¢˜
        return re.sub(r'[^\w\s\-]', '', title).strip()

    except Exception as e:
        logger.error(f'ç”Ÿæˆè‹±æ–‡æ ‡é¢˜å¤±è´¥: {e}')
        return chinese_title

def process_single_product(product_info):
    """å¤„ç†å•ä¸ªå•†å“çš„è¯¦æƒ…æŠ“å–"""
    try:
        item_id = product_info['item_id']
        item_url = product_info['item_url']
        shop_name = product_info['shop_name']

        # è·å–å•†å“è¯¦ç»†ä¿¡æ¯
        product_details = scrape_product_info(item_url)

        if product_details:
            # ç”Ÿæˆè‹±æ–‡æ ‡é¢˜
            english_title = generate_english_title(product_details.get('title', ''))

            return {
                'product_url': item_url,
                'title': product_details.get('title', ''),
                'description': product_details.get('description', ''),
                'english_title': english_title,
                'cnfans_url': generate_cnfans_url(item_id),
                'acbuy_url': generate_acbuy_url(item_url),
                'shop_name': shop_name,
                'images': product_details.get('images', []),
                'ruleEnabled': True
            }
        return None

    except Exception as e:
        logger.error(f'å¤„ç†å•†å“å¤±è´¥: {e}')
        return None

def process_products_multithreaded(products_list):
    """å¤šçº¿ç¨‹å¤„ç†å•†å“è¯¦æƒ…æŠ“å–"""
    import concurrent.futures

    processed_products = []

    # è·å–é…ç½®çš„çº¿ç¨‹æ•°
    max_workers = DOWNLOAD_THREADS

    logger.info(f'å¼€å§‹å¤šçº¿ç¨‹å¤„ç† {len(products_list)} ä¸ªå•†å“ï¼Œä½¿ç”¨ {max_workers} ä¸ªçº¿ç¨‹')

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_product = {
            executor.submit(process_single_product, product): product
            for product in products_list
        }

        # æ”¶é›†ç»“æœ
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                if result:
                    processed_products.append(result)
            except Exception as e:
                logger.error(f'å•†å“å¤„ç†ä»»åŠ¡å¤±è´¥: {e}')

    logger.info(f'å¤šçº¿ç¨‹å¤„ç†å®Œæˆï¼Œå…±å¤„ç† {len(processed_products)} ä¸ªå•†å“')
    return processed_products

def process_page_multithreaded(products_list, page_num):
    """
    å¤šçº¿ç¨‹å¤„ç†æ•´ä¸ªé¡µé¢ï¼šè·å–è¯¦æƒ… + æ’å…¥æ•°æ®åº“ + ä¸‹è½½å›¾ç‰‡
    æ¯ä¸ªçº¿ç¨‹è´Ÿè´£ä¸€ä¸ªå•†å“çš„å®Œæ•´å¤„ç†æµç¨‹
    """
    import concurrent.futures

    processed_count = 0

    # è·å–é…ç½®çš„çº¿ç¨‹æ•°
    max_workers = DOWNLOAD_THREADS

    logger.info(f'ç¬¬ {page_num} é¡µå¼€å§‹å¤šçº¿ç¨‹å¤„ç† {len(products_list)} ä¸ªå•†å“')

    def process_and_save_product(product):
        """å¤„ç†å•ä¸ªå•†å“çš„å®Œæ•´æµç¨‹ï¼šè·å–è¯¦æƒ… -> æ’å…¥æ•°æ®åº“ -> ä¸‹è½½å›¾ç‰‡"""
        try:
            # 1. è·å–å•†å“è¯¦æƒ…
            product_data = process_single_product(product)
            if not product_data:
                logger.warning(f'å•†å“è¯¦æƒ…è·å–å¤±è´¥: {product}')
                return 0

            # 2. æ£€æŸ¥å•†å“æ˜¯å¦å·²å­˜åœ¨
            existing = db.get_product_by_url(product_data['product_url'])
            if existing:
                logger.info(f'å•†å“å·²å­˜åœ¨ï¼Œè·³è¿‡: {product_data["title"]} (URL: {product_data["product_url"]})')
                return 0

            # 3. æ’å…¥å•†å“åˆ°æ•°æ®åº“
            product_id = db.insert_product(product_data)
            logger.info(f'âœ… æˆåŠŸæ’å…¥æ–°å•†å“: {product_data["title"]} (ID: {product_id})')

            # 4. ä¸‹è½½å¹¶ä¿å­˜å›¾ç‰‡
            if product_data.get('images'):
                save_product_images(product_id, product_data['images'])
                logger.info(f'ğŸ“¸ å•†å“å›¾ç‰‡ä¸‹è½½å®Œæˆ: {product_data["title"]} ({len(product_data["images"])}å¼ )')

            return 1  # æˆåŠŸå¤„ç†ä¸€ä¸ªå•†å“

        except Exception as e:
            logger.error(f'å¤„ç†å•†å“å¤±è´¥: {e}')
            return 0

    # é™ä½å¹¶å‘æ•°é¿å…å†…å­˜çˆ†ç‚¸ï¼ŒYOLOæ¨¡å‹ç°åœ¨æ˜¯å•ä¾‹æ¨¡å¼
    max_workers_page = min(2, len(products_list))  # æœ€å¤š2ä¸ªå¹¶å‘
    logger.info(f"é¡µé¢å¤„ç†ä½¿ç”¨ {max_workers_page} ä¸ªçº¿ç¨‹")

    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers_page) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡ï¼Œæ¯ä¸ªå•†å“ä¸€ä¸ªä»»åŠ¡
        future_to_product = {
            executor.submit(process_and_save_product, product): product
            for product in products_list
        }

        # æ”¶é›†ç»“æœ
        for future in concurrent.futures.as_completed(future_to_product):
            try:
                result = future.result()
                processed_count += result
            except Exception as e:
                logger.error(f'é¡µé¢å¤„ç†ä»»åŠ¡å¤±è´¥: {e}')

    logger.info(f'ç¬¬ {page_num} é¡µå¤„ç†å®Œæˆï¼ŒæˆåŠŸæ–°å¢ {processed_count} ä¸ªå•†å“')
    return processed_count

def save_product_images(product_id, image_urls):
    """ä¿å­˜å•†å“å›¾ç‰‡å¹¶æå–ç‰¹å¾å‘é‡ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ - å‡å°‘å¹¶å‘é¿å…å†…å­˜çˆ†ç‚¸ï¼‰"""
    try:
        # ä½¿ç”¨çº¿ç¨‹æ± è€Œä¸æ˜¯è¿›ç¨‹æ± ï¼Œé¿å…YOLOæ¨¡å‹é‡å¤åŠ è½½
        # é™ä½å¹¶å‘æ•°ï¼Œä»4ä¸ªå‡å°‘åˆ°2ä¸ªï¼Œé¿å…å†…å­˜çˆ†ç‚¸
        import concurrent.futures

        max_workers = min(2, len(image_urls))  # æœ€å¤š2ä¸ªå¹¶å‘çº¿ç¨‹
        logger.info(f"å¼€å§‹å¤„ç† {len(image_urls)} å¼ å›¾ç‰‡ï¼Œä½¿ç”¨ {max_workers} ä¸ªçº¿ç¨‹")

        def process_single_image(args):
            """å¤„ç†å•å¼ å›¾ç‰‡ï¼šä¸‹è½½ -> ä¿å­˜ -> æå–ç‰¹å¾ -> ç´¢å¼•"""
            index, image_url = args
            try:
                # ä¸‹è½½å›¾ç‰‡ï¼ˆä½¿ç”¨æ›´çŸ­çš„è¶…æ—¶æ—¶é—´ï¼‰
                response = requests.get(image_url, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code != 200:
                    return None

                # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼Œé¿å…å¹¶å‘å†²çª
                timestamp = int(time.time() * 1000000)  # å¾®ç§’çº§æ—¶é—´æˆ³
                image_filename = f"{product_id}_{index}_{timestamp}.jpg"
                image_path = os.path.join('data', 'images', image_filename)

                # ç¡®ä¿ç›®å½•å­˜åœ¨
                os.makedirs(os.path.dirname(image_path), exist_ok=True)

                # ç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œé¿å…å†…å­˜å ç”¨è¿‡å¤š
                with open(image_path, 'wb') as f:
                    f.write(response.content)

                # éªŒè¯å›¾ç‰‡å®Œæ•´æ€§
                if os.path.getsize(image_path) == 0:
                    os.remove(image_path)
                    return None

                # æå–ç‰¹å¾ï¼ˆè¿™é‡Œä¼šè°ƒç”¨YOLOè£å‰ªå’ŒDINOv2ç‰¹å¾æå–ï¼‰
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–")
                    return None
                features = extractor.extract_feature(image_path)

                if features is None:
                    # ç‰¹å¾æå–å¤±è´¥ï¼Œåˆ é™¤æ–‡ä»¶
                    os.remove(image_path)
                    return None

                # === æ–°å¢ï¼šå‘é‡å»é‡æ£€æŸ¥ ===
                # æ£€æŸ¥ä¸è¯¥å•†å“ç°æœ‰å›¾ç‰‡çš„ç›¸ä¼¼åº¦
                if existing_features:
                    import numpy as np
                    for existing_feature_json in existing_features:
                        try:
                            # ååºåˆ—åŒ–ç°æœ‰å‘é‡
                            existing_features_array = json.loads(existing_feature_json)
                            existing_features_array = np.array(existing_features_array, dtype='float32')

                            # è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
                            dot_product = np.dot(features, existing_features_array)
                            norm_new = np.linalg.norm(features)
                            norm_existing = np.linalg.norm(existing_features_array)

                            if norm_new > 0 and norm_existing > 0:
                                similarity = dot_product / (norm_new * norm_existing)
                                if similarity > 0.95:  # ç›¸ä¼¼åº¦é˜ˆå€¼95%
                                    logger.info(f'æ£€æµ‹åˆ°é‡å¤å›¾ç‰‡ (ç›¸ä¼¼åº¦: {similarity:.3f})ï¼Œè·³è¿‡: {os.path.basename(image_path)}')
                                    os.remove(image_path)
                                    return None
                        except (json.JSONDecodeError, ValueError, TypeError) as e:
                            logger.warning(f"è§£æç°æœ‰å‘é‡å¤±è´¥: {e}")
                            continue

                # è¿”å›å¤„ç†ç»“æœï¼Œè®©ä¸»è¿›ç¨‹ç»Ÿä¸€å¤„ç†æ•°æ®åº“æ“ä½œ
                return {
                    'image_path': image_path,
                    'features': features,
                    'index': index
                }

            except Exception as e:
                logger.error(f'å¤„ç†å›¾ç‰‡å¤±è´¥ {image_url}: {e}')
                return None

        # è·å–è¯¥å•†å“å·²æœ‰çš„å›¾ç‰‡å‘é‡ï¼Œç”¨äºå»é‡
        existing_features = []
        try:
            existing_images = db.get_product_images(product_id)
            for img_record in existing_images:
                if img_record.get('features'):
                    existing_features.append(img_record['features'])
            logger.info(f'å•†å“ {product_id} å·²å­˜åœ¨ {len(existing_features)} å¼ å›¾ç‰‡çš„å‘é‡æ•°æ®')
        except Exception as e:
            logger.warning(f'è·å–å•†å“ç°æœ‰å‘é‡å¤±è´¥: {e}')

        # ä½¿ç”¨çº¿ç¨‹æ± å¤„ç†å›¾ç‰‡ä¸‹è½½å’Œç‰¹å¾æå–ï¼ˆå•ä¾‹YOLOé¿å…é‡å¤åŠ è½½ï¼‰
        # é™ä½å¹¶å‘æ•°é¿å…å†…å­˜çˆ†ç‚¸
        max_workers = min(2, len(image_urls))  # æœ€å¤š2ä¸ªå¹¶å‘çº¿ç¨‹

        logger.info(f'å•†å“ {product_id} å¼€å§‹å¤šçº¿ç¨‹å¤„ç† {len(image_urls)} å¼ å›¾ç‰‡ï¼Œä½¿ç”¨ {max_workers} ä¸ªçº¿ç¨‹')

        def process_single_image_with_deduplication(args):
            """å¤„ç†å•å¼ å›¾ç‰‡ï¼šä¸‹è½½ -> ä¿å­˜ -> æå–ç‰¹å¾ -> å‘é‡å»é‡"""
            index, image_url = args
            try:
                # ä¸‹è½½å›¾ç‰‡ï¼ˆä½¿ç”¨æ›´çŸ­çš„è¶…æ—¶æ—¶é—´ï¼‰
                response = requests.get(image_url, timeout=5, proxies={'http': None, 'https': None})
                if response.status_code != 200:
                    return None

                # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼Œé¿å…å¹¶å‘å†²çª
                timestamp = int(time.time() * 1000000)  # å¾®ç§’çº§æ—¶é—´æˆ³
                image_filename = f"{product_id}_{index}_{timestamp}.jpg"
                image_path = os.path.join('data', 'images', image_filename)

                # ç¡®ä¿ç›®å½•å­˜åœ¨
                os.makedirs(os.path.dirname(image_path), exist_ok=True)

                # ç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œé¿å…å†…å­˜å ç”¨è¿‡å¤š
                with open(image_path, 'wb') as f:
                    f.write(response.content)

                # éªŒè¯å›¾ç‰‡å®Œæ•´æ€§
                if os.path.getsize(image_path) == 0:
                    os.remove(image_path)
                    return None

                # æå–ç‰¹å¾ï¼ˆè¿™é‡Œä¼šè°ƒç”¨YOLOè£å‰ªå’ŒDINOv2ç‰¹å¾æå–ï¼‰
                extractor = get_global_feature_extractor()
                if extractor is None:
                    logger.error("ç‰¹å¾æå–å™¨æœªåˆå§‹åŒ–")
                    return None
                features = extractor.extract_feature(image_path)

                if features is None:
                    # ç‰¹å¾æå–å¤±è´¥ï¼Œåˆ é™¤æ–‡ä»¶
                    os.remove(image_path)
                    return None

                # å‘é‡å»é‡ï¼šæ£€æŸ¥ä¸è¯¥å•†å“ç°æœ‰å›¾ç‰‡çš„ç›¸ä¼¼åº¦
                if existing_features:
                    import numpy as np
                    for existing_feature in existing_features:
                        # è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
                        similarity = np.dot(features, existing_feature) / (np.linalg.norm(features) * np.linalg.norm(existing_feature))
                        if similarity > 0.95:  # ç›¸ä¼¼åº¦é˜ˆå€¼95%
                            logger.info(f'æ£€æµ‹åˆ°é‡å¤å›¾ç‰‡ (ç›¸ä¼¼åº¦: {similarity:.3f})ï¼Œè·³è¿‡: {os.path.basename(image_path)}')
                            os.remove(image_path)
                            return None

                # è¿”å›å¤„ç†ç»“æœï¼Œè®©ä¸»è¿›ç¨‹ç»Ÿä¸€å¤„ç†æ•°æ®åº“æ“ä½œ
                return {
                    'image_path': image_path,
                    'features': features,
                    'index': index
                }

            except Exception as e:
                logger.error(f'å¤„ç†å›¾ç‰‡å¤±è´¥ {image_url}: {e}')
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æäº¤ä»»åŠ¡ - ç§»é™¤å›¾ç‰‡æ•°é‡é™åˆ¶
            image_tasks = [(index, url) for index, url in enumerate(image_urls) if url]
            futures = [executor.submit(process_single_image_with_deduplication, task) for task in image_tasks]

            # æ”¶é›†ç»“æœï¼Œæ”¯æŒä¼˜é›…å…³é—­
            processed_results = []
        try:
            for future in concurrent.futures.as_completed(futures, timeout=30):  # 30ç§’è¶…æ—¶
                # æ£€æŸ¥æ˜¯å¦æ”¶åˆ°å…³é—­ä¿¡å·
                if shutdown_event and shutdown_event.is_set():
                    logger.info("æ£€æµ‹åˆ°å…³é—­ä¿¡å·ï¼Œåœæ­¢å›¾ç‰‡å¤„ç†...")
                    executor.shutdown(wait=False)
                    break

                result = future.result()
                if result is not None:
                    processed_results.append(result)
        except concurrent.futures.TimeoutError:
            logger.warning("å›¾ç‰‡å¤„ç†è¶…æ—¶ï¼Œå¼ºåˆ¶å…³é—­çº¿ç¨‹æ± ")
            executor.shutdown(wait=False)
        except Exception as e:
            logger.error(f"å›¾ç‰‡å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™: {e}")
            executor.shutdown(wait=False)

        # åœ¨ä¸»è¿›ç¨‹ä¸­ç»Ÿä¸€å¤„ç†æ•°æ®åº“æ“ä½œï¼Œé¿å…è¿›ç¨‹é—´æ•°æ®åº“è¿æ¥é—®é¢˜
        processed_images = 0
        for result in processed_results:
            try:
                # æ’å…¥å›¾ç‰‡è®°å½•åˆ°æ•°æ®åº“ï¼ˆåŒ…å«ç‰¹å¾å‘é‡ï¼‰
                img_db_id = db.insert_image_record(product_id, result['image_path'], result['index'], result['features'])

                # æ·»åŠ åˆ°FAISSç´¢å¼•
                try:
                    from vector_engine import get_vector_engine
                except ImportError:
                    from .vector_engine import get_vector_engine
                engine = get_vector_engine()
                engine.add_vector(img_db_id, result['features'])

                processed_images += 1
                logger.debug(f'å›¾ç‰‡å…¥åº“å®Œæˆ: {os.path.basename(result["image_path"])} (ID: {img_db_id})')

            except Exception as e:
                logger.error(f'å›¾ç‰‡å…¥åº“å¤±è´¥ {result["image_path"]}: {e}')
                # æ¸…ç†å¤±è´¥çš„æ–‡ä»¶
                try:
                    os.remove(result['image_path'])
                except:
                    pass

        # ä¿å­˜FAISSç´¢å¼•ï¼ˆæ‰¹é‡ä¿å­˜æ›´é«˜æ•ˆï¼‰
        if processed_images > 0:
            try:
                from vector_engine import get_vector_engine
            except ImportError:
                from .vector_engine import get_vector_engine
            engine = get_vector_engine()
            engine.save()

        logger.info(f'å•†å“ {product_id} å›¾ç‰‡å¤„ç†å®Œæˆï¼Œå…±å¤„ç† {processed_images}/{len(image_urls)} å¼ å›¾ç‰‡')

    except Exception as e:
        logger.error(f'ä¿å­˜å•†å“å›¾ç‰‡å¤±è´¥: {e}')

def save_product_images_unified(product_id, image_urls, max_workers=None, shutdown_event=None):
    """ç»Ÿä¸€çš„æ‰¹é‡å›¾ç‰‡å¤„ç†å‡½æ•°ï¼ˆä¼˜åŒ–ç‰ˆï¼šå»¶è¿ŸFAISSä¿å­˜ï¼Œæé«˜æ€§èƒ½ï¼‰"""
    if not image_urls:
        return 0

    try:
        import concurrent.futures

        # åŠ¨æ€å†³å®šçº¿ç¨‹æ•°
        if max_workers is None:
            max_workers = min(config.DOWNLOAD_THREADS, len(image_urls))

        # è·å–ç°æœ‰ç‰¹å¾å‘é‡ç”¨äºæŸ¥é‡
        existing_images = db.get_product_images(product_id)
        existing_feats = [img['features'] for img in existing_images if img['features']]
        logger.info(f'å•†å“ {product_id} å·²å­˜åœ¨ {len(existing_feats)} å¼ å›¾ç‰‡çš„å‘é‡æ•°æ®')

        # å¤„ç†ç»“æœè®¡æ•°
        processed_images = 0

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æäº¤ä»»åŠ¡ï¼ˆæ‰¹é‡å¤„ç†æ—¶ä¸ç«‹å³ä¿å­˜FAISSï¼Œå»¶è¿Ÿåˆ°æœ€åï¼‰
            futures = [executor.submit(process_and_save_image_core, product_id, url, idx, existing_feats, save_faiss_immediately=False)
                       for idx, url in enumerate(image_urls)]

            # ç­‰å¾…å®Œæˆ (æ”¯æŒä¼˜é›…å…³é—­)
            for future in concurrent.futures.as_completed(futures):
                try:
                    # æ£€æŸ¥åœæ­¢ä¿¡å·
                    if shutdown_event and shutdown_event.is_set():
                        logger.info("æ£€æµ‹åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨ç­‰å¾…å›¾ç‰‡å¤„ç†å®Œæˆ...")
                        executor.shutdown(wait=True, timeout=15.0)
                        break

                    result = future.result()
                    if result and result['success']:
                        processed_images += 1  # è®¡æ•°æˆåŠŸå¤„ç†çš„å›¾ç‰‡

                except Exception as e:
                    logger.error(f'ä¸€ä¸ªå›¾ç‰‡å¤„ç†å¤±è´¥: {e}')

        # æ‰¹é‡æ“ä½œç»“æŸåç»Ÿä¸€ä¿å­˜ FAISSï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
        try:
            from vector_engine import get_vector_engine
            get_vector_engine().save()
            logger.info(f"FAISSç´¢å¼•å·²ä¿å­˜ï¼Œå…±å¤„ç† {processed_images} å¼ å›¾ç‰‡")
        except Exception as faiss_err:
            logger.error(f"FAISSä¿å­˜å¤±è´¥: {faiss_err}")

        logger.info(f"å•†å“ {product_id} æˆåŠŸå¤„ç† {processed_images}/{len(image_urls)} å¼ å›¾ç‰‡")
        return processed_images

    except Exception as e:
        logger.error(f"æ‰¹é‡ä¿å­˜å•†å“ {product_id} å›¾ç‰‡å¤±è´¥: {e}")
        return 0

# å‘åå…¼å®¹çš„åˆ«å
def save_product_images(product_id, image_urls):
    """å‘åå…¼å®¹çš„å‡½æ•°å"""
    return save_product_images_unified(product_id, image_urls)

def save_product_images_multithreaded(product_id, image_urls):
    """å¤šçº¿ç¨‹ç‰ˆæœ¬çš„å›¾ç‰‡ä¿å­˜å‡½æ•°ï¼ˆå‘åå…¼å®¹ï¼‰"""
    return save_product_images_unified(product_id, image_urls)

if __name__ == '__main__':
    import atexit
    import threading
    import signal
    import time

    # å…¨å±€å˜é‡ç”¨äºæ§åˆ¶ä¼˜é›…å…³é—­
    shutdown_event = threading.Event()

    def signal_handler(signum, frame):
        """å¤„ç†ä¸­æ–­ä¿¡å·ï¼Œä¼˜é›…å…³é—­"""
        print(f"\nğŸ›‘ Received signal {signum}, initiating graceful shutdown...")
        shutdown_event.set()

        # è®¾ç½®æŠ“å–çŠ¶æ€ä¸ºåœæ­¢
        current_status = db.get_scrape_status()
        if current_status.get('is_scraping', False):
            db.update_scrape_status(
                stop_signal=True,
                message='ç³»ç»Ÿæ­£åœ¨å…³é—­ï¼Œå·²åœæ­¢æŠ“å–ä»»åŠ¡'
            )
            print("â¹ï¸  å·²åœæ­¢æ‰€æœ‰æŠ“å–ä»»åŠ¡")

        # ç­‰å¾…æŠ“å–çº¿ç¨‹ç»“æŸï¼ˆæœ€å¤šç­‰å¾…10ç§’ï¼‰
        global current_scrape_thread, scrape_thread_lock
        with scrape_thread_lock:
            if current_scrape_thread and current_scrape_thread.is_alive():
                print("â³ ç­‰å¾…æŠ“å–çº¿ç¨‹ç»“æŸ...")
                current_scrape_thread.join(timeout=10.0)
                if current_scrape_thread.is_alive():
                    print("âš ï¸ æŠ“å–çº¿ç¨‹æœªèƒ½åœ¨10ç§’å†…ç»“æŸ")
                else:
                    print("âœ… æŠ“å–çº¿ç¨‹å·²ç»“æŸ")

        # ç«‹å³åœæ­¢Discordæœºå™¨äºº
        stop_discord_bot()

        # çŸ­æš‚ç­‰å¾…è®©å…¶ä»–çº¿ç¨‹æœ‰æœºä¼šæ¸…ç†
        time.sleep(0.2)
        print("ğŸ’¥ Force exiting...")
        import os
        os._exit(0)

    # æ³¨å†Œä¿¡å·å¤„ç†å™¨
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # æ³¨å†Œé€€å‡ºæ—¶åœæ­¢æœºå™¨äººçš„å‡½æ•°
    atexit.register(stop_discord_bot)

    # ====================================================
    # æ–°å¢ä¿®å¤ï¼šå¯åŠ¨æ—¶å¼ºåˆ¶é‡ç½®æ•°æ®åº“æŠ“å–çŠ¶æ€
    # ====================================================
    print("ğŸ§¹ [ç³»ç»Ÿ] æ­£åœ¨é‡ç½®æŠ“å–ä»»åŠ¡çŠ¶æ€...")
    try:
        # å¼ºåˆ¶å°†æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„çŠ¶æ€é‡ç½®ä¸ºåœæ­¢
        db.update_scrape_status(
            is_scraping=False,
            stop_signal=False,
            message='ç³»ç»Ÿé‡å¯ï¼Œä»»åŠ¡çŠ¶æ€å·²é‡ç½®'
        )
        print("âœ… [ç³»ç»Ÿ] æŠ“å–çŠ¶æ€å·²é‡ç½®ï¼Œéšæ—¶å¯ä»¥å¼€å§‹æ–°ä»»åŠ¡")
    except Exception as e:
        print(f"âš ï¸ [ç³»ç»Ÿ] çŠ¶æ€é‡ç½®å¤±è´¥ (å¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œæ•°æ®åº“æœªåˆå§‹åŒ–): {e}")

    # 3. åœ¨ä¸»çº¿ç¨‹é¢„åŠ è½½æ¨¡å‹ (å…³é”®)
    print("ğŸ¤– [ç³»ç»Ÿ] æ­£åœ¨é¢„çƒ­ AI å¼•æ“ï¼Œè¯·ç¨å€™...")
    try:
        from feature_extractor import get_feature_extractor
        # å¼ºåˆ¶è·å–ä¸€æ¬¡å®ä¾‹ï¼Œè§¦å‘åˆå§‹åŒ–
        get_feature_extractor()
        print("âœ… [ç³»ç»Ÿ] AI å¼•æ“é¢„çƒ­å®Œæˆï¼Œå¤šçº¿ç¨‹ä»»åŠ¡å°†å…±äº«æ­¤å®ä¾‹")
    except Exception as e:
        print(f"âš ï¸ [ç³»ç»Ÿ] AI é¢„çƒ­å¤±è´¥: {e}")

    # 4. å¯åŠ¨ Flask
    print("ğŸš€ æœåŠ¡å¯åŠ¨ä¸­...")
    try:
        # å…³é—­ debug æ¨¡å¼ï¼Œé¿å… Flask é‡è½½å™¨å¯¼è‡´åŒé‡åˆå§‹åŒ–
        app.run(host='0.0.0.0', port=5001, debug=False, threaded=True)
    except KeyboardInterrupt:
        print("\nğŸ›‘ Received KeyboardInterrupt, shutting down...")
        signal_handler(signal.SIGINT, None)
    except Exception as e:
        print(f"\nğŸ’¥ Unexpected error: {e}")
        signal_handler(signal.SIGINT, None)
    finally:
        print("ğŸ‘‹ Flask API shutdown complete")

--- File: ./create_admin.py ---
#!/usr/bin/env python3
"""
åˆ›å»ºç®¡ç†å‘˜è´¦å·è„šæœ¬ - é¡¹ç›®æ ¹ç›®å½•ç‰ˆæœ¬

ä½¿ç”¨æ–¹æ³•:
python3 create_admin.py

æˆ–è€…æŒ‡å®šç”¨æˆ·åå’Œå¯†ç :
python3 create_admin.py --username admin --password admin123
"""

import sys
import os
import getpass
import argparse

# ç¡®ä¿åœ¨æ­£ç¡®çš„ç›®å½•ä¸‹è¿è¡Œ
script_dir = os.path.dirname(os.path.abspath(__file__))
backend_dir = os.path.join(script_dir, 'backend')

if not os.path.exists(backend_dir):
    print("âŒ æœªæ‰¾åˆ° backend ç›®å½•ï¼Œè¯·ç¡®ä¿åœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œæ­¤è„šæœ¬")
    sys.exit(1)

# æ·»åŠ  backend ç›®å½•åˆ° Python è·¯å¾„
sys.path.insert(0, backend_dir)

try:
    from database import Database
except ImportError as e:
    print(f"âŒ å¯¼å…¥æ•°æ®åº“æ¨¡å—å¤±è´¥: {e}")
    print("è¯·ç¡®ä¿é¡¹ç›®ç»“æ„å®Œæ•´")
    sys.exit(1)

from werkzeug.security import generate_password_hash

def create_admin_user(username=None, password=None):
    """åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·"""
    db = Database()

    # å¦‚æœæ²¡æœ‰æä¾›å‚æ•°ï¼Œäº¤äº’å¼è¾“å…¥
    if not username:
        username = input("è¯·è¾“å…¥ç®¡ç†å‘˜ç”¨æˆ·å: ").strip()
        if not username:
            print("âŒ ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
            return

    if not password:
        password = getpass.getpass("è¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç : ").strip()
        if not password:
            print("âŒ å¯†ç ä¸èƒ½ä¸ºç©º")
            return

        # ç¡®è®¤å¯†ç 
        confirm_password = getpass.getpass("è¯·å†æ¬¡è¾“å…¥å¯†ç ç¡®è®¤: ").strip()
        if password != confirm_password:
            print("âŒ ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´")
            return

    try:
        with db.get_connection() as conn:
            cursor = conn.cursor()

            # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = cursor.fetchone()

            if existing_user:
                print(f"âŒ ç”¨æˆ·å '{username}' å·²å­˜åœ¨")
                return

            # åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·
            hashed_password = generate_password_hash(password)
            cursor.execute("""
                INSERT INTO users (username, password_hash, role, created_at, updated_at)
                VALUES (?, ?, 'admin', datetime('now'), datetime('now'))
            """, (username, hashed_password))

            user_id = cursor.lastrowid
            conn.commit()

            print("âœ… ç®¡ç†å‘˜è´¦å·åˆ›å»ºæˆåŠŸï¼")
            print(f"   ç”¨æˆ·å: {username}")
            print(f"   è§’è‰²: ç®¡ç†å‘˜")
            print(f"   ç”¨æˆ·ID: {user_id}")
            print("\nğŸ” è¯·å¦¥å–„ä¿ç®¡è´¦å·ä¿¡æ¯")
            print("\nğŸš€ ç°åœ¨å¯ä»¥ä½¿ç”¨æ­¤è´¦å·ç™»å½•ç³»ç»Ÿäº†")

    except Exception as e:
        print(f"âŒ åˆ›å»ºç®¡ç†å‘˜è´¦å·å¤±è´¥: {e}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='åˆ›å»ºç®¡ç†å‘˜è´¦å·')
    parser.add_argument('--username', help='ç®¡ç†å‘˜ç”¨æˆ·å')
    parser.add_argument('--password', help='ç®¡ç†å‘˜å¯†ç ')

    args = parser.parse_args()

    print("ğŸ”§ Discord å•†å“è¥é”€ç³»ç»Ÿ - ç®¡ç†å‘˜è´¦å·åˆ›å»ºå·¥å…·")
    print("=" * 50)

    if args.username and args.password:
        create_admin_user(args.username, args.password)
    else:
        create_admin_user()

